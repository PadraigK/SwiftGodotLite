// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A modal window used to display a list of options.
/// 
/// ``PopupMenu`` is a modal window used to display a list of options. Useful for toolbars and context menus.
/// 
/// The size of a ``PopupMenu`` can be limited by using ``Window/maxSize``. If the height of the list of items is larger than the maximum height of the ``PopupMenu``, a ``ScrollContainer`` within the popup will allow the user to scroll the contents. If no maximum size is set, or if it is set to `0`, the ``PopupMenu`` height will be limited by its parent rect.
/// 
/// All `set_*` methods allow negative item indices, i.e. `-1` to access the last item, `-2` to select the second-to-last item, and so on.
/// 
/// **Incremental search:** Like ``ItemList`` and ``Tree``, ``PopupMenu`` supports searching within the list while the control is focused. Press a key that matches the first letter of an item's name to select the first item starting with the given letter. After that point, there are two ways to perform incremental search: 1) Press the same key again before the timeout duration to select the next item starting with the same letter. 2) Press letter keys that match the rest of the word before the timeout duration to match to select the item in question directly. Both of these actions will be reset to the beginning of the list if the timeout duration has passed since the last keystroke was registered. You can adjust the timeout duration by changing ``ProjectSettings/gui/timers/incrementalSearchMaxIntervalMsec``.
/// 
/// > Note: The ID values used for items are limited to 32 bits, not full 64 bits of integer. This has a range of `-2^32` to `2^32 - 1`, i.e. `-2147483648` to `2147483647`.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``idPressed``
/// - ``idFocused``
/// - ``indexPressed``
/// - ``menuChanged``
open class PopupMenu: Popup {
    override open class var godotClassName: StringName { "PopupMenu" }
    
    /* Properties */
    
    /// If `true`, hides the ``PopupMenu`` when an item is selected.
    final public var hideOnItemSelection: Bool {
        get {
            return is_hide_on_item_selection ()
        }
        
        set {
            set_hide_on_item_selection (newValue)
        }
        
    }
    
    /// If `true`, hides the ``PopupMenu`` when a checkbox or radio button is selected.
    final public var hideOnCheckableItemSelection: Bool {
        get {
            return is_hide_on_checkable_item_selection ()
        }
        
        set {
            set_hide_on_checkable_item_selection (newValue)
        }
        
    }
    
    /// If `true`, hides the ``PopupMenu`` when a state item is selected.
    final public var hideOnStateItemSelection: Bool {
        get {
            return is_hide_on_state_item_selection ()
        }
        
        set {
            set_hide_on_state_item_selection (newValue)
        }
        
    }
    
    /// Sets the delay time in seconds for the submenu item to popup on mouse hovering. If the popup menu is added as a child of another (acting as a submenu), it will inherit the delay time of the parent menu item.
    final public var submenuPopupDelay: Double {
        get {
            return get_submenu_popup_delay ()
        }
        
        set {
            set_submenu_popup_delay (newValue)
        }
        
    }
    
    /// If `true`, allows navigating ``PopupMenu`` with letter keys.
    final public var allowSearch: Bool {
        get {
            return get_allow_search ()
        }
        
        set {
            set_allow_search (newValue)
        }
        
    }
    
    /// The number of items currently in the list.
    final public var itemCount: Int32 {
        get {
            return get_item_count ()
        }
        
        set {
            set_item_count (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_activate_item_by_event: GDExtensionMethodBindPtr = {
        let methodName = StringName ("activate_item_by_event")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3716412023)!
            }
            
        }
        
    }()
    
    /// Checks the provided `event` against the ``PopupMenu``'s shortcuts and accelerators, and activates the first item with matching events. If `forGlobalOnly` is `true`, only shortcuts and accelerators with `global` set to `true` will be called.
    /// 
    /// Returns `true` if an item was successfully activated.
    /// 
    /// > Note: Certain ``Control``s, such as ``MenuButton``, will call this method automatically.
    /// 
    public final func activateItemByEvent (_ event: InputEvent?, forGlobalOnly: Bool = false)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_for_global_only = forGlobalOnly
        var copy_event_handle = event?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_activate_item_by_event, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_event_handle, &copy_for_global_only)
        return _result
        #else
        
        var copy_for_global_only = forGlobalOnly
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: event?.handle) { p0 in
        _args.append (event == nil ? nil : p0)
            return withUnsafePointer (to: &copy_for_global_only) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_activate_item_by_event, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3674230041)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: The provided `id` is used only in [signal id_pressed] and [signal id_focused] signals. It's not related to the `index` arguments in e.g. ``setItemChecked(index:checked:)``.
    /// 
    public final func addItem (label: String, id: Int32 = -1, accel: Key = .none) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_item, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_label.content, &copy_id, &copy_accel)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_label.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_accel) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (PopupMenu.method_add_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_icon_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_icon_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1086190128)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label` and icon `texture`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    public final func addIconItem (texture: Texture2D?, label: String, id: Int32 = -1, accel: Key = .none) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_icon_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &gstr_label.content, &copy_id, &copy_accel)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_id) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_accel) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (PopupMenu.method_add_icon_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_check_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3674230041)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item with text `label`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addCheckItem (label: String, id: Int32 = -1, accel: Key = .none) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_check_item, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_label.content, &copy_id, &copy_accel)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_label.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_accel) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (PopupMenu.method_add_check_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_icon_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_icon_check_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1086190128)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item with text `label` and icon `texture`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addIconCheckItem (texture: Texture2D?, label: String, id: Int32 = -1, accel: Key = .none) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_icon_check_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &gstr_label.content, &copy_id, &copy_accel)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_id) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_accel) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (PopupMenu.method_add_icon_check_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_radio_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_radio_check_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3674230041)!
            }
            
        }
        
    }()
    
    /// Adds a new radio check button with text `label`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addRadioCheckItem (label: String, id: Int32 = -1, accel: Key = .none) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_radio_check_item, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_label.content, &copy_id, &copy_accel)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_label.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_accel) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (PopupMenu.method_add_radio_check_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_icon_radio_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_icon_radio_check_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1086190128)!
            }
            
        }
        
    }()
    
    /// Same as ``addIconCheckItem(texture:label:id:accel:)``, but uses a radio check button.
    public final func addIconRadioCheckItem (texture: Texture2D?, label: String, id: Int32 = -1, accel: Key = .none) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_icon_radio_check_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &gstr_label.content, &copy_id, &copy_accel)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_id) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_accel) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (PopupMenu.method_add_icon_radio_check_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_multistate_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_multistate_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 150780458)!
            }
            
        }
        
    }()
    
    /// Adds a new multistate item with text `label`.
    /// 
    /// Contrarily to normal binary items, multistate items can have more than two states, as defined by `maxStates`. Each press or activate of the item will increase the state by one. The default value is defined by `defaultState`.
    /// 
    /// An `id` can optionally be provided, as well as an accelerator (`accel`). If no `id` is provided, one will be created from the index. If no `accel` is provided, then the default value of 0 (corresponding to ``@GlobalScope.KEY_NONE``) will be assigned to the item (which means it won't have any accelerator). See ``getItemAccelerator(index:)`` for more info on accelerators.
    /// 
    public final func addMultistateItem (label: String, maxStates: Int32, defaultState: Int32 = 0, id: Int32 = -1, accel: Key = .none) {
        #if true
        
        let gstr_label = GString (label)
        var copy_max_states: Int = Int (maxStates)
        var copy_default_state: Int = Int (defaultState)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_multistate_item, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_label.content, &copy_max_states, &copy_default_state, &copy_id, &copy_accel)
        
        #else
        
        let gstr_label = GString (label)
        var copy_max_states: Int = Int (maxStates)
        var copy_default_state: Int = Int (defaultState)
        var copy_id: Int = Int (id)
        var copy_accel = Int64 (accel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_label.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_max_states) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_default_state) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_id) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_accel) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (PopupMenu.method_add_multistate_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_shortcut")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3451850107)!
            }
            
        }
        
    }()
    
    /// Adds a ``Shortcut``.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// If `allowEcho` is `true`, the shortcut can be activated with echo events.
    /// 
    public final func addShortcut (_ shortcut: Shortcut?, id: Int32 = -1, global: Bool = false, allowEcho: Bool = false) {
        #if true
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var copy_allow_echo = allowEcho
        var copy_shortcut_handle = shortcut?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_shortcut, UnsafeMutableRawPointer (mutating: handle), nil, &copy_shortcut_handle, &copy_id, &copy_global, &copy_allow_echo)
        
        #else
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var copy_allow_echo = allowEcho
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: shortcut?.handle) { p0 in
        _args.append (shortcut == nil ? nil : p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_global) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_allow_echo) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (PopupMenu.method_add_shortcut, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_icon_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_icon_shortcut")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2997871092)!
            }
            
        }
        
    }()
    
    /// Adds a new item and assigns the specified ``Shortcut`` and icon `texture` to it. Sets the label of the checkbox to the ``Shortcut``'s name.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// If `allowEcho` is `true`, the shortcut can be activated with echo events.
    /// 
    public final func addIconShortcut (texture: Texture2D?, shortcut: Shortcut?, id: Int32 = -1, global: Bool = false, allowEcho: Bool = false) {
        #if true
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var copy_allow_echo = allowEcho
        var copy_texture_handle = texture?.handle
        var copy_shortcut_handle = shortcut?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_icon_shortcut, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &copy_shortcut_handle, &copy_id, &copy_global, &copy_allow_echo)
        
        #else
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var copy_allow_echo = allowEcho
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: shortcut?.handle) { p1 in
            _args.append (shortcut == nil ? nil : p1)
                withUnsafePointer (to: &copy_id) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_global) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_allow_echo) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (PopupMenu.method_add_icon_shortcut, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_check_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_check_shortcut")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1642193386)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item and assigns the specified ``Shortcut`` to it. Sets the label of the checkbox to the ``Shortcut``'s name.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addCheckShortcut (_ shortcut: Shortcut?, id: Int32 = -1, global: Bool = false) {
        #if true
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var copy_shortcut_handle = shortcut?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_check_shortcut, UnsafeMutableRawPointer (mutating: handle), nil, &copy_shortcut_handle, &copy_id, &copy_global)
        
        #else
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: shortcut?.handle) { p0 in
        _args.append (shortcut == nil ? nil : p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_global) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (PopupMenu.method_add_check_shortcut, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_icon_check_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_icon_check_shortcut")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3856247530)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item and assigns the specified ``Shortcut`` and icon `texture` to it. Sets the label of the checkbox to the ``Shortcut``'s name.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addIconCheckShortcut (texture: Texture2D?, shortcut: Shortcut?, id: Int32 = -1, global: Bool = false) {
        #if true
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var copy_texture_handle = texture?.handle
        var copy_shortcut_handle = shortcut?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_icon_check_shortcut, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &copy_shortcut_handle, &copy_id, &copy_global)
        
        #else
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: shortcut?.handle) { p1 in
            _args.append (shortcut == nil ? nil : p1)
                withUnsafePointer (to: &copy_id) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_global) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (PopupMenu.method_add_icon_check_shortcut, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_radio_check_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_radio_check_shortcut")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1642193386)!
            }
            
        }
        
    }()
    
    /// Adds a new radio check button and assigns a ``Shortcut`` to it. Sets the label of the checkbox to the ``Shortcut``'s name.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``setItemChecked(index:checked:)`` for more info on how to control it.
    /// 
    public final func addRadioCheckShortcut (_ shortcut: Shortcut?, id: Int32 = -1, global: Bool = false) {
        #if true
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var copy_shortcut_handle = shortcut?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_radio_check_shortcut, UnsafeMutableRawPointer (mutating: handle), nil, &copy_shortcut_handle, &copy_id, &copy_global)
        
        #else
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: shortcut?.handle) { p0 in
        _args.append (shortcut == nil ? nil : p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_global) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (PopupMenu.method_add_radio_check_shortcut, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_icon_radio_check_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_icon_radio_check_shortcut")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3856247530)!
            }
            
        }
        
    }()
    
    /// Same as ``addIconCheckShortcut(texture:shortcut:id:global:)``, but uses a radio check button.
    public final func addIconRadioCheckShortcut (texture: Texture2D?, shortcut: Shortcut?, id: Int32 = -1, global: Bool = false) {
        #if true
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var copy_texture_handle = texture?.handle
        var copy_shortcut_handle = shortcut?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_icon_radio_check_shortcut, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &copy_shortcut_handle, &copy_id, &copy_global)
        
        #else
        
        var copy_id: Int = Int (id)
        var copy_global = global
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: shortcut?.handle) { p1 in
            _args.append (shortcut == nil ? nil : p1)
                withUnsafePointer (to: &copy_id) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_global) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (PopupMenu.method_add_icon_radio_check_shortcut, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_submenu_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_submenu_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2979222410)!
            }
            
        }
        
    }()
    
    /// Adds an item that will act as a submenu of the parent ``PopupMenu`` node when clicked. The `submenu` argument must be the name of an existing ``PopupMenu`` that has been added as a child to this node. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the `ui_select` or `ui_right` input actions.
    /// 
    /// An `id` can optionally be provided. If no `id` is provided, one will be created from the index.
    /// 
    public final func addSubmenuItem (label: String, submenu: String, id: Int32 = -1) {
        #if true
        
        let gstr_label = GString (label)
        let gstr_submenu = GString (submenu)
        var copy_id: Int = Int (id)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_submenu_item, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_label.content, &gstr_submenu.content, &copy_id)
        
        #else
        
        let gstr_label = GString (label)
        let gstr_submenu = GString (submenu)
        var copy_id: Int = Int (id)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_label.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_submenu.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_id) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (PopupMenu.method_add_submenu_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_text")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the text of the item at the given `index`.
    public final func setItemText (index: Int32, text: String) {
        #if true
        
        var copy_index: Int = Int (index)
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_text, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &gstr_text.content)
        
        #else
        
        var copy_index: Int = Int (index)
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_text.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_text_direction")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1707680378)!
            }
            
        }
        
    }()
    
    /// Sets item's text base writing direction.
    public final func setItemTextDirection (index: Int32, direction: Control.TextDirection) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_direction = Int64 (direction.rawValue)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_text_direction, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_direction)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_direction = Int64 (direction.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_direction) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_text_direction, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_language")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets language code of item's text used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    public final func setItemLanguage (index: Int32, language: String) {
        #if true
        
        var copy_index: Int = Int (index)
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_language, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &gstr_language.content)
        
        #else
        
        var copy_index: Int = Int (index)
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_language, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_icon")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 666127730)!
            }
            
        }
        
    }()
    
    /// Replaces the ``Texture2D`` icon of the item at the given `index`.
    public final func setItemIcon (index: Int32, icon: Texture2D?) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_icon, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_icon_handle)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_icon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_icon_max_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_icon_max_width")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the maximum allowed width of the icon for the item at the given `index`. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
    public final func setItemIconMaxWidth (index: Int32, width: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_width: Int = Int (width)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_icon_max_width, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_width)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_width: Int = Int (width)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_icon_max_width, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_icon_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_icon_modulate")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2878471219)!
            }
            
        }
        
    }()
    
    /// Sets a modulating ``Color`` of the item's icon at the given `index`.
    public final func setItemIconModulate (index: Int32, modulate: Color) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_modulate = modulate
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_icon_modulate, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_modulate)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_modulate) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_icon_modulate, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_checked")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the checkstate status of the item at the given `index`.
    public final func setItemChecked (index: Int32, checked: Bool) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_checked = checked
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_checked, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_checked)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_checked = checked
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_checked) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_checked, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_id")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the `id` of the item at the given `index`.
    /// 
    /// The `id` is used in [signal id_pressed] and [signal id_focused] signals.
    /// 
    public final func setItemId (index: Int32, id: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_id: Int = Int (id)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_id, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_id)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_id: Int = Int (id)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_id, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_accelerator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_accelerator")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2992817551)!
            }
            
        }
        
    }()
    
    /// Sets the accelerator of the item at the given `index`. An accelerator is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. `accel` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    public final func setItemAccelerator (index: Int32, accel: Key) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_accel = Int64 (accel.rawValue)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_accelerator, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_accel)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_accel = Int64 (accel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_accel) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_accelerator, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_metadata")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2152698145)!
            }
            
        }
        
    }()
    
    /// Sets the metadata of an item, which may be of any type. You can later get it with ``getItemMetadata(index:)``, which provides a simple way of assigning context data to items.
    public final func setItemMetadata (index: Int32, metadata: Variant) {
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_metadata, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &metadata.content)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &metadata.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_disabled")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Enables/disables the item at the given `index`. When it is disabled, it can't be selected and its action can't be invoked.
    public final func setItemDisabled (index: Int32, disabled: Bool) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_disabled = disabled
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_disabled)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_disabled = disabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_disabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_submenu")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the submenu of the item at the given `index`. The submenu is the name of a child ``PopupMenu`` node that would be shown when the item is clicked.
    public final func setItemSubmenu (index: Int32, submenu: String) {
        #if true
        
        var copy_index: Int = Int (index)
        let gstr_submenu = GString (submenu)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_submenu, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &gstr_submenu.content)
        
        #else
        
        var copy_index: Int = Int (index)
        let gstr_submenu = GString (submenu)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_submenu.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_submenu, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_as_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_as_separator")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Mark the item at the given `index` as a separator, which means that it would be displayed as a line. If `false`, sets the type of the item to plain text.
    public final func setItemAsSeparator (index: Int32, enable: Bool) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_as_separator, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_enable)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_as_separator, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_as_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_as_checkable")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets whether the item at the given `index` has a checkbox. If `false`, sets the type of the item to plain text.
    /// 
    /// > Note: Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
    /// 
    public final func setItemAsCheckable (index: Int32, enable: Bool) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_as_checkable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_enable)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_as_checkable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_as_radio_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_as_radio_checkable")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the type of the item at the given `index` to radio button. If `false`, sets the type of the item to plain text.
    public final func setItemAsRadioCheckable (index: Int32, enable: Bool) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_as_radio_checkable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_enable)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_as_radio_checkable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_tooltip")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the ``String`` tooltip of the item at the given `index`.
    public final func setItemTooltip (index: Int32, tooltip: String) {
        #if true
        
        var copy_index: Int = Int (index)
        let gstr_tooltip = GString (tooltip)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_tooltip, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &gstr_tooltip.content)
        
        #else
        
        var copy_index: Int = Int (index)
        let gstr_tooltip = GString (tooltip)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_tooltip.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_tooltip, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_shortcut")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 825127832)!
            }
            
        }
        
    }()
    
    /// Sets a ``Shortcut`` for the item at the given `index`.
    public final func setItemShortcut (index: Int32, shortcut: Shortcut?, global: Bool = false) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_global = global
        var copy_shortcut_handle = shortcut?.handle
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_shortcut, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_shortcut_handle, &copy_global)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_global = global
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: shortcut?.handle) { p1 in
            _args.append (shortcut == nil ? nil : p1)
                withUnsafePointer (to: &copy_global) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (PopupMenu.method_set_item_shortcut, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_indent")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the horizontal offset of the item at the given `index`.
    public final func setItemIndent (index: Int32, indent: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_indent: Int = Int (indent)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_indent, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_indent)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_indent: Int = Int (indent)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_indent) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_indent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_multistate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_multistate")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the state of a multistate item. See ``addMultistateItem(label:maxStates:defaultState:id:accel:)`` for details.
    public final func setItemMultistate (index: Int32, state: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_state: Int = Int (state)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_multistate, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_state)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_state: Int = Int (state)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_state) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_multistate, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_shortcut_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_shortcut_disabled")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Disables the ``Shortcut`` of the item at the given `index`.
    public final func setItemShortcutDisabled (index: Int32, disabled: Bool) {
        #if true
        
        var copy_index: Int = Int (index)
        var copy_disabled = disabled
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_shortcut_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index, &copy_disabled)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_disabled = disabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_disabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_set_item_shortcut_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_toggle_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("toggle_item_checked")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Toggles the check state of the item at the given `index`.
    public final func toggleItemChecked (index: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_toggle_item_checked, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_toggle_item_checked, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_toggle_item_multistate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("toggle_item_multistate")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Cycle to the next state of a multistate item. See ``addMultistateItem(label:maxStates:defaultState:id:accel:)`` for details.
    public final func toggleItemMultistate (index: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_toggle_item_multistate, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_toggle_item_multistate, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_text")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the text of the item at the given `index`.
    public final func getItemText (index: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_text, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_index)
        return _result.description
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_text, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_text_direction")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4235602388)!
            }
            
        }
        
    }()
    
    /// Returns item's text base writing direction.
    public final func getItemTextDirection (index: Int32)-> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_text_direction, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return Control.TextDirection (rawValue: _result)!
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_text_direction, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return Control.TextDirection (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_language")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns item's text language code.
    public final func getItemLanguage (index: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_language, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_index)
        return _result.description
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_language, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_icon")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3536238170)!
            }
            
        }
        
    }()
    
    /// Returns the icon of the item at the given `index`.
    public final func getItemIcon (index: Int32)-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_icon_max_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_icon_max_width")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the maximum allowed width of the icon for the item at the given `index`.
    public final func getItemIconMaxWidth (index: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_icon_max_width, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_icon_max_width, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_icon_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_icon_modulate")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3457211756)!
            }
            
        }
        
    }()
    
    /// Returns a ``Color`` modulating the item's icon at the given `index`.
    public final func getItemIconModulate (index: Int32)-> Color {
        var _result: Color = Color ()
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_icon_modulate, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_icon_modulate, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_item_checked")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at the given `index` is checked.
    public final func isItemChecked (index: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_is_item_checked, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_is_item_checked, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_id")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the ID of the item at the given `index`. `id` can be manually assigned, while index can not.
    public final func getItemId (index: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_id, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_id, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_index")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the index of the item containing the specified `id`. Index is automatically assigned to each item by the engine and can not be set manually.
    public final func getItemIndex (id: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_id: Int = Int (id)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_index, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_id)
        return _result
        #else
        
        var copy_id: Int = Int (id)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_index, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_accelerator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_accelerator")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 253789942)!
            }
            
        }
        
    }()
    
    /// Returns the accelerator of the item at the given `index`. An accelerator is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The return value is an integer which is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]). If no accelerator is defined for the specified `index`, ``getItemAccelerator(index:)`` returns `0` (corresponding to ``@GlobalScope.KEY_NONE``).
    public final func getItemAccelerator (index: Int32)-> Key {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_accelerator, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return Key (rawValue: _result)!
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_accelerator, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return Key (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_metadata")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4227898402)!
            }
            
        }
        
    }()
    
    /// Returns the metadata of the specified item, which might be of any type. You can set it with ``setItemMetadata(index:metadata:)``, which provides a simple way of assigning context data to items.
    public final func getItemMetadata (index: Int32)-> Variant {
        let _result: Variant = Variant ()
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_metadata, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_item_disabled")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at the given `index` is disabled. When it is disabled it can't be selected, or its action invoked.
    /// 
    /// See ``setItemDisabled(index:disabled:)`` for more info on how to disable an item.
    /// 
    public final func isItemDisabled (index: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_is_item_disabled, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_is_item_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_submenu")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the submenu name of the item at the given `index`. See ``addSubmenuItem(label:submenu:id:)`` for more info on how to add a submenu.
    public final func getItemSubmenu (index: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_submenu, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_index)
        return _result.description
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_submenu, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_is_item_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_item_separator")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item is a separator. If it is, it will be displayed as a line. See ``addSeparator(label:id:)`` for more info on how to add a separator.
    public final func isItemSeparator (index: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_is_item_separator, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_is_item_separator, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_item_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_item_checkable")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at the given `index` is checkable in some way, i.e. if it has a checkbox or radio button.
    /// 
    /// > Note: Checkable items just display a checkmark or radio button, but don't have any built-in checking behavior and must be checked/unchecked manually.
    /// 
    public final func isItemCheckable (index: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_is_item_checkable, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_is_item_checkable, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_item_radio_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_item_radio_checkable")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at the given `index` has radio button-style checkability.
    /// 
    /// > Note: This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
    /// 
    public final func isItemRadioCheckable (index: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_is_item_radio_checkable, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_is_item_radio_checkable, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_item_shortcut_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_item_shortcut_disabled")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the specified item's shortcut is disabled.
    public final func isItemShortcutDisabled (index: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_is_item_shortcut_disabled, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_is_item_shortcut_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_tooltip")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the tooltip associated with the item at the given `index`.
    public final func getItemTooltip (index: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_tooltip, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_index)
        return _result.description
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_tooltip, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_shortcut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_shortcut")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1449483325)!
            }
            
        }
        
    }()
    
    /// Returns the ``Shortcut`` associated with the item at the given `index`.
    public final func getItemShortcut (index: Int32)-> Shortcut? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_shortcut, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_shortcut, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_indent")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the horizontal offset of the item at the given `index`.
    public final func getItemIndent (index: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_get_item_indent, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_get_item_indent, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_focused_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_focused_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the currently focused item as the given `index`.
    /// 
    /// Passing `-1` as the index makes so that no item is focused.
    /// 
    public final func setFocusedItem (index: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_focused_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_set_focused_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_focused_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_focused_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the index of the currently focused item. Returns `-1` if no item is focused.
    public final func getFocusedItem ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (PopupMenu.method_get_focused_item, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_item_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_count")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_item_count (_ count: Int32) {
        #if true
        
        var copy_count: Int = Int (count)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_item_count, UnsafeMutableRawPointer (mutating: handle), nil, &copy_count)
        
        #else
        
        var copy_count: Int = Int (count)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_count) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_set_item_count, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_count")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_item_count ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (PopupMenu.method_get_item_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_scroll_to_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scroll_to_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Moves the scroll view to make the item at the given `index` visible.
    public final func scrollToItem (index: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_scroll_to_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_scroll_to_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_item")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the item at the given `index` from the menu.
    /// 
    /// > Note: The indices of items after the removed item will be shifted by one.
    /// 
    public final func removeItem (index: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_remove_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_remove_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_separator")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2266703459)!
            }
            
        }
        
    }()
    
    /// Adds a separator between items. Separators also occupy an index, which you can set by using the `id` parameter.
    /// 
    /// A `label` can optionally be provided, which will appear at the center of the separator.
    /// 
    public final func addSeparator (label: String = "", id: Int32 = -1) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_add_separator, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_label.content, &copy_id)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_label.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (PopupMenu.method_add_separator, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 107499316)!
            }
            
        }
        
    }()
    
    /// Removes all items from the ``PopupMenu``. If `freeSubmenus` is `true`, the submenu nodes are automatically freed.
    public final func clear (freeSubmenus: Bool = false) {
        #if true
        
        var copy_free_submenus = freeSubmenus
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_clear, UnsafeMutableRawPointer (mutating: handle), nil, &copy_free_submenus)
        
        #else
        
        var copy_free_submenus = freeSubmenus
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_free_submenus) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_clear, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_hide_on_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hide_on_item_selection")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_on_item_selection (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_hide_on_item_selection, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_set_hide_on_item_selection, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_hide_on_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_hide_on_item_selection")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hide_on_item_selection ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (PopupMenu.method_is_hide_on_item_selection, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hide_on_checkable_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hide_on_checkable_item_selection")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_on_checkable_item_selection (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_hide_on_checkable_item_selection, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_set_hide_on_checkable_item_selection, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_hide_on_checkable_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_hide_on_checkable_item_selection")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hide_on_checkable_item_selection ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (PopupMenu.method_is_hide_on_checkable_item_selection, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hide_on_state_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hide_on_state_item_selection")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_on_state_item_selection (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_hide_on_state_item_selection, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_set_hide_on_state_item_selection, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_hide_on_state_item_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_hide_on_state_item_selection")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hide_on_state_item_selection ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (PopupMenu.method_is_hide_on_state_item_selection, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_submenu_popup_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_submenu_popup_delay")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_submenu_popup_delay (_ seconds: Double) {
        #if true
        
        var copy_seconds = seconds
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_submenu_popup_delay, UnsafeMutableRawPointer (mutating: handle), nil, &copy_seconds)
        
        #else
        
        var copy_seconds = seconds
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_seconds) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_set_submenu_popup_delay, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_submenu_popup_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_submenu_popup_delay")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_submenu_popup_delay ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (PopupMenu.method_get_submenu_popup_delay, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_search: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_allow_search")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_search (_ allow: Bool) {
        #if true
        
        var copy_allow = allow
        
        gi.object_method_bind_ptrcall_v (PopupMenu.method_set_allow_search, UnsafeMutableRawPointer (mutating: handle), nil, &copy_allow)
        
        #else
        
        var copy_allow = allow
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_allow) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (PopupMenu.method_set_allow_search, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_allow_search: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_allow_search")
        return withUnsafePointer (to: &PopupMenu.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_search ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (PopupMenu.method_get_allow_search, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ id: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item of some `id` is pressed or its accelerator is activated.
    /// 
    /// > Note: If `id` is negative (either explicitly or due to overflow), this will return the corresponding index instead.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.idPressed.connect { id in
    ///    print ("caught signal")
    /// }
    /// ```
    public var idPressed: Signal1 { Signal1 (target: self, signalName: "id_pressed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ id: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user navigated to an item of some `id` using the ``ProjectSettings/input/uiUp`` or ``ProjectSettings/input/uiDown`` input action.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.idFocused.connect { id in
    ///    print ("caught signal")
    /// }
    /// ```
    public var idFocused: Signal2 { Signal2 (target: self, signalName: "id_focused") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ index: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item of some `index` is pressed or its accelerator is activated.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.indexPressed.connect { index in
    ///    print ("caught signal")
    /// }
    /// ```
    public var indexPressed: Signal3 { Signal3 (target: self, signalName: "index_pressed") }
    
    /// Emitted when any item is added, modified or removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.menuChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var menuChanged: SimpleSignal { SimpleSignal (target: self, signalName: "menu_changed") }
    
}

