// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Class for importing and exporting glTF files in and out of Godot.
/// 
/// GLTFDocument supports reading data from a glTF file, buffer, or Godot scene. This data can then be written to the filesystem, buffer, or used to create a Godot scene.
/// 
/// All of the data in a GLTF scene is stored in the ``GLTFState`` class. GLTFDocument processes state objects, but does not contain any scene data itself. GLTFDocument has member variables to store export configuration settings such as the image format, but is otherwise stateless. Multiple scenes can be processed with the same settings using the same GLTFDocument object and different ``GLTFState`` objects.
/// 
/// GLTFDocument can be extended with arbitrary functionality by extending the ``GLTFDocumentExtension`` class and registering it with GLTFDocument via ``registerGltfDocumentExtension(_:firstPriority:)``. This allows for custom data to be imported and exported.
/// 
open class GLTFDocument: Resource {
    override open class var godotClassName: StringName { "GLTFDocument" }
    public enum RootNodeMode: Int64 {
        /// Treat the Godot scene's root node as the root node of the glTF file, and mark it as the single root node via the `GODOT_single_root` glTF extension. This will be parsed the same as .keepRoot if the implementation does not support `GODOT_single_root`.
        case singleRoot = 0 // ROOT_NODE_MODE_SINGLE_ROOT
        /// Treat the Godot scene's root node as the root node of the glTF file, but do not mark it as anything special. An extra root node will be generated when importing into Godot. This uses only vanilla glTF features. This is equivalent to the behavior in Godot 4.1 and earlier.
        case keepRoot = 1 // ROOT_NODE_MODE_KEEP_ROOT
        /// Treat the Godot scene's root node as the name of the glTF scene, and add all of its children as root nodes of the glTF file. This uses only vanilla glTF features. This avoids an extra root node, but only the name of the Godot scene's root node will be preserved, as it will not be saved as a node.
        case multiRoot = 2 // ROOT_NODE_MODE_MULTI_ROOT
    }
    
    
    /* Properties */
    
    /// The user-friendly name of the export image format. This is used when exporting the GLTF file, including writing to a file and writing to a byte array.
    /// 
    /// By default, Godot allows the following options: "None", "PNG", "JPEG", "Lossless WebP", and "Lossy WebP". Support for more image formats can be added in ``GLTFDocumentExtension`` classes.
    /// 
    final public var imageFormat: String {
        get {
            return get_image_format ()
        }
        
        set {
            set_image_format (newValue)
        }
        
    }
    
    /// If ``imageFormat`` is a lossy image format, this determines the lossy quality of the image. On a range of `0.0` to `1.0`, where `0.0` is the lowest quality and `1.0` is the highest quality. A lossy quality of `1.0` is not the same as lossless.
    final public var lossyQuality: Double {
        get {
            return get_lossy_quality ()
        }
        
        set {
            set_lossy_quality (newValue)
        }
        
    }
    
    /// How to process the root node during export. See ``GLTFDocument/RootNodeMode`` for details. The default and recommended value is .singleRoot.
    /// 
    /// > Note: Regardless of how the glTF file is exported, when importing, the root node type and name can be overridden in the scene import settings tab.
    /// 
    final public var rootNodeMode: GLTFDocument.RootNodeMode {
        get {
            return get_root_node_mode ()
        }
        
        set {
            set_root_node_mode (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_append_from_file: GDExtensionMethodBindPtr = {
        let methodName = StringName ("append_from_file")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866380864)!
            }
            
        }
        
    }()
    
    /// Takes a path to a GLTF file and imports the data at that file path to the given ``GLTFState`` object through the `state` parameter.
    /// 
    /// > Note: The `basePath` tells ``appendFromFile(path:state:flags:basePath:)`` where to find dependencies and can be empty.
    /// 
    public final func appendFromFile (path: String, state: GLTFState?, flags: UInt32 = 0, basePath: String = "")-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        let gstr_path = GString (path)
        var copy_flags: Int = Int (flags)
        let gstr_base_path = GString (basePath)
        var copy_state_handle = state?.handle
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_append_from_file, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_path.content, &copy_state_handle, &copy_flags, &gstr_base_path.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_path = GString (path)
        var copy_flags: Int = Int (flags)
        let gstr_base_path = GString (basePath)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_path.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: state?.handle) { p1 in
            _args.append (state == nil ? nil : p1)
                return withUnsafePointer (to: &copy_flags) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &gstr_base_path.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (GLTFDocument.method_append_from_file, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return GodotError (rawValue: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_append_from_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("append_from_buffer")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1616081266)!
            }
            
        }
        
    }()
    
    /// Takes a ``PackedByteArray`` defining a GLTF and imports the data to the given ``GLTFState`` object through the `state` parameter.
    /// 
    /// > Note: The `basePath` tells ``appendFromBuffer(bytes:basePath:state:flags:)`` where to find dependencies and can be empty.
    /// 
    public final func appendFromBuffer (bytes: PackedByteArray, basePath: String, state: GLTFState?, flags: UInt32 = 0)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        let gstr_base_path = GString (basePath)
        var copy_flags: Int = Int (flags)
        var copy_state_handle = state?.handle
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_append_from_buffer, UnsafeMutableRawPointer (mutating: handle), &_result, &bytes.content, &gstr_base_path.content, &copy_state_handle, &copy_flags)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_base_path = GString (basePath)
        var copy_flags: Int = Int (flags)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &bytes.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_base_path.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: state?.handle) { p2 in
                _args.append (state == nil ? nil : p2)
                    return withUnsafePointer (to: &copy_flags) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (GLTFDocument.method_append_from_buffer, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return GodotError (rawValue: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_append_from_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName ("append_from_scene")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1622574258)!
            }
            
        }
        
    }()
    
    /// Takes a Godot Engine scene node and exports it and its descendants to the given ``GLTFState`` object through the `state` parameter.
    public final func appendFromScene (node: Node?, state: GLTFState?, flags: UInt32 = 0)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_flags: Int = Int (flags)
        var copy_node_handle = node?.handle
        var copy_state_handle = state?.handle
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_append_from_scene, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_node_handle, &copy_state_handle, &copy_flags)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_flags: Int = Int (flags)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
            return withUnsafePointer (to: state?.handle) { p1 in
            _args.append (state == nil ? nil : p1)
                return withUnsafePointer (to: &copy_flags) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (GLTFDocument.method_append_from_scene, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return GodotError (rawValue: _result)!
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_generate_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_scene")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 596118388)!
            }
            
        }
        
    }()
    
    /// Takes a ``GLTFState`` object through the `state` parameter and returns a Godot Engine scene node.
    public final func generateScene (state: GLTFState?, bakeFps: Double = 30, trimming: Bool = false, removeImmutableTracks: Bool = true)-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_bake_fps = bakeFps
        var copy_trimming = trimming
        var copy_remove_immutable_tracks = removeImmutableTracks
        var copy_state_handle = state?.handle
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_generate_scene, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_state_handle, &copy_bake_fps, &copy_trimming, &copy_remove_immutable_tracks)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_bake_fps = bakeFps
        var copy_trimming = trimming
        var copy_remove_immutable_tracks = removeImmutableTracks
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: state?.handle) { p0 in
        _args.append (state == nil ? nil : p0)
            return withUnsafePointer (to: &copy_bake_fps) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_trimming) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_remove_immutable_tracks) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (GLTFDocument.method_generate_scene, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_generate_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_buffer")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 741783455)!
            }
            
        }
        
    }()
    
    /// Takes a ``GLTFState`` object through the `state` parameter and returns a GLTF ``PackedByteArray``.
    public final func generateBuffer (state: GLTFState?)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if true
        
        var copy_state_handle = state?.handle
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_generate_buffer, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_state_handle)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: state?.handle) { p0 in
        _args.append (state == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (GLTFDocument.method_generate_buffer, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_write_to_filesystem: GDExtensionMethodBindPtr = {
        let methodName = StringName ("write_to_filesystem")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1784551478)!
            }
            
        }
        
    }()
    
    /// Takes a ``GLTFState`` object through the `state` parameter and writes a glTF file to the filesystem.
    /// 
    /// > Note: The extension of the glTF file determines if it is a .glb binary file or a .gltf file.
    /// 
    public final func writeToFilesystem (state: GLTFState?, path: String)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        let gstr_path = GString (path)
        var copy_state_handle = state?.handle
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_write_to_filesystem, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_state_handle, &gstr_path.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_path = GString (path)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: state?.handle) { p0 in
        _args.append (state == nil ? nil : p0)
            return withUnsafePointer (to: &gstr_path.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (GLTFDocument.method_write_to_filesystem, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_image_format: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_image_format")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_image_format (_ imageFormat: String) {
        #if true
        
        let gstr_image_format = GString (imageFormat)
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_set_image_format, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_image_format.content)
        
        #else
        
        let gstr_image_format = GString (imageFormat)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_image_format.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GLTFDocument.method_set_image_format, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_image_format: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_image_format")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_image_format ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (GLTFDocument.method_get_image_format, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_lossy_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_lossy_quality")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_lossy_quality (_ lossyQuality: Double) {
        #if true
        
        var copy_lossy_quality = lossyQuality
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_set_lossy_quality, UnsafeMutableRawPointer (mutating: handle), nil, &copy_lossy_quality)
        
        #else
        
        var copy_lossy_quality = lossyQuality
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_lossy_quality) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GLTFDocument.method_set_lossy_quality, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_lossy_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_lossy_quality")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_lossy_quality ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (GLTFDocument.method_get_lossy_quality, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_root_node_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_root_node_mode")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 463633402)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_root_node_mode (_ rootNodeMode: GLTFDocument.RootNodeMode) {
        #if true
        
        var copy_root_node_mode = Int64 (rootNodeMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_set_root_node_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_root_node_mode)
        
        #else
        
        var copy_root_node_mode = Int64 (rootNodeMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_root_node_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GLTFDocument.method_set_root_node_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_root_node_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_node_mode")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 948057992)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_root_node_mode ()-> GLTFDocument.RootNodeMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (GLTFDocument.method_get_root_node_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return GLTFDocument.RootNodeMode (rawValue: _result)!
    }
    
    fileprivate static var method_register_gltf_document_extension: GDExtensionMethodBindPtr = {
        let methodName = StringName ("register_gltf_document_extension")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3752678331)!
            }
            
        }
        
    }()
    
    /// Registers the given ``GLTFDocumentExtension`` instance with GLTFDocument. If `firstPriority` is true, this extension will be run first. Otherwise, it will be run last.
    /// 
    /// > Note: Like GLTFDocument itself, all GLTFDocumentExtension classes must be stateless in order to function properly. If you need to store data, use the `set_additional_data` and `get_additional_data` methods in ``GLTFState`` or ``GLTFNode``.
    /// 
    public static func registerGltfDocumentExtension (_ `extension`: GLTFDocumentExtension?, firstPriority: Bool = false) {
        #if true
        
        var copy_first_priority = firstPriority
        var copy_extension_handle = `extension`?.handle
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_register_gltf_document_extension, nil, nil, &copy_extension_handle, &copy_first_priority)
        
        #else
        
        var copy_first_priority = firstPriority
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: `extension`?.handle) { p0 in
        _args.append (`extension` == nil ? nil : p0)
            withUnsafePointer (to: &copy_first_priority) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (GLTFDocument.method_register_gltf_document_extension, nil, &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_unregister_gltf_document_extension: GDExtensionMethodBindPtr = {
        let methodName = StringName ("unregister_gltf_document_extension")
        return withUnsafePointer (to: &GLTFDocument.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2684415758)!
            }
            
        }
        
    }()
    
    /// Unregisters the given ``GLTFDocumentExtension`` instance.
    public static func unregisterGltfDocumentExtension (_ `extension`: GLTFDocumentExtension?) {
        #if true
        
        var copy_extension_handle = `extension`?.handle
        
        gi.object_method_bind_ptrcall_v (GLTFDocument.method_unregister_gltf_document_extension, nil, nil, &copy_extension_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: `extension`?.handle) { p0 in
        _args.append (`extension` == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (GLTFDocument.method_unregister_gltf_document_extension, nil, &_args, nil)
        }
        
        #endif
    }
    
}

