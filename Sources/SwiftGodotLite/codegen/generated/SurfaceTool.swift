// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Helper tool to create geometry.
/// 
/// The ``SurfaceTool`` is used to construct a ``Mesh`` by specifying vertex attributes individually. It can be used to construct a ``Mesh`` from a script. All properties except indices need to be added before calling ``addVertex(_:)``. For example, to add vertex colors and UVs:
/// 
/// The above ``SurfaceTool`` now contains one vertex of a triangle which has a UV coordinate and a specified ``Color``. If another vertex were added without calling ``setUv(_:)`` or ``setColor(_:)``, then the last values would be used.
/// 
/// Vertex attributes must be passed **before** calling ``addVertex(_:)``. Failure to do so will result in an error when committing the vertex information to a mesh.
/// 
/// Additionally, the attributes used before the first vertex is added determine the format of the mesh. For example, if you only add UVs to the first vertex, you cannot add color to any of the subsequent vertices.
/// 
/// See also ``ArrayMesh``, ``ImmediateMesh`` and ``MeshDataTool`` for procedural geometry generation.
/// 
/// > Note: Godot uses clockwise [url=https://learnopengl.com/Advanced-OpenGL/Face-culling]winding order[/url] for front faces of triangle primitive modes.
/// 
open class SurfaceTool: RefCounted {
    override open class var godotClassName: StringName { "SurfaceTool" }
    public enum CustomFormat: Int64 {
        /// Limits range of data passed to ``setCustom(channelIndex:customColor:)`` to unsigned normalized 0 to 1 stored in 8 bits per channel. See ``Mesh/ArrayCustomFormat/arrayCustomRgba8Unorm``.
        case rgba8Unorm = 0 // CUSTOM_RGBA8_UNORM
        /// Limits range of data passed to ``setCustom(channelIndex:customColor:)`` to signed normalized -1 to 1 stored in 8 bits per channel. See ``Mesh/ArrayCustomFormat/arrayCustomRgba8Snorm``.
        case rgba8Snorm = 1 // CUSTOM_RGBA8_SNORM
        /// Stores data passed to ``setCustom(channelIndex:customColor:)`` as half precision floats, and uses only red and green color channels. See ``Mesh/ArrayCustomFormat/arrayCustomRgHalf``.
        case rgHalf = 2 // CUSTOM_RG_HALF
        /// Stores data passed to ``setCustom(channelIndex:customColor:)`` as half precision floats and uses all color channels. See ``Mesh/ArrayCustomFormat/arrayCustomRgbaHalf``.
        case rgbaHalf = 3 // CUSTOM_RGBA_HALF
        /// Stores data passed to ``setCustom(channelIndex:customColor:)`` as full precision floats, and uses only red color channel. See ``Mesh/ArrayCustomFormat/arrayCustomRFloat``.
        case rFloat = 4 // CUSTOM_R_FLOAT
        /// Stores data passed to ``setCustom(channelIndex:customColor:)`` as full precision floats, and uses only red and green color channels. See ``Mesh/ArrayCustomFormat/arrayCustomRgFloat``.
        case rgFloat = 5 // CUSTOM_RG_FLOAT
        /// Stores data passed to ``setCustom(channelIndex:customColor:)`` as full precision floats, and uses only red, green and blue color channels. See ``Mesh/ArrayCustomFormat/arrayCustomRgbFloat``.
        case rgbFloat = 6 // CUSTOM_RGB_FLOAT
        /// Stores data passed to ``setCustom(channelIndex:customColor:)`` as full precision floats, and uses all color channels. See ``Mesh/ArrayCustomFormat/arrayCustomRgbaFloat``.
        case rgbaFloat = 7 // CUSTOM_RGBA_FLOAT
        /// Used to indicate a disabled custom channel.
        case max = 8 // CUSTOM_MAX
    }
    
    public enum SkinWeightCount: Int64 {
        /// Each individual vertex can be influenced by only 4 bone weights.
        case skin4Weights = 0 // SKIN_4_WEIGHTS
        /// Each individual vertex can be influenced by up to 8 bone weights.
        case skin8Weights = 1 // SKIN_8_WEIGHTS
    }
    
    /* Methods */
    fileprivate static var method_set_skin_weight_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_skin_weight_count")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 618679515)!
            }
            
        }
        
    }()
    
    /// Set to .skin8Weights to indicate that up to 8 bone influences per vertex may be used.
    /// 
    /// By default, only 4 bone influences are used (.skin4Weights)
    /// 
    /// > Note: This function takes an enum, not the exact number of weights.
    /// 
    public final func setSkinWeightCount (_ count: SurfaceTool.SkinWeightCount) {
        #if false
        
        var copy_count = Int64 (count.rawValue)
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_skin_weight_count, UnsafeMutableRawPointer (mutating: handle), nil, &copy_count)
        
        #else
        
        var copy_count = Int64 (count.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_count) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_skin_weight_count, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_skin_weight_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_skin_weight_count")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1072401130)!
            }
            
        }
        
    }()
    
    /// By default, returns .skin4Weights to indicate only 4 bone influences per vertex are used.
    /// 
    /// Returns .skin8Weights if up to 8 influences are used.
    /// 
    /// > Note: This function returns an enum, not the exact number of weights.
    /// 
    public final func getSkinWeightCount ()-> SurfaceTool.SkinWeightCount {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (SurfaceTool.method_get_skin_weight_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return SurfaceTool.SkinWeightCount (rawValue: _result)!
    }
    
    fileprivate static var method_set_custom_format: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_custom_format")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4087759856)!
            }
            
        }
        
    }()
    
    /// Sets the color format for this custom `channelIndex`. Use .customMax to disable.
    /// 
    /// Must be invoked after ``begin(primitive:)`` and should be set before ``commit(existing:flags:)`` or ``commitToArrays()``.
    /// 
    public final func setCustomFormat (channelIndex: Int32, format: SurfaceTool.CustomFormat) {
        #if false
        
        var copy_channel_index: Int = Int (channelIndex)
        var copy_format = Int64 (format.rawValue)
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_custom_format, UnsafeMutableRawPointer (mutating: handle), nil, &copy_channel_index, &copy_format)
        
        #else
        
        var copy_channel_index: Int = Int (channelIndex)
        var copy_format = Int64 (format.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_channel_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_format) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (SurfaceTool.method_set_custom_format, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_custom_format: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_custom_format")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 839863283)!
            }
            
        }
        
    }()
    
    /// Returns the format for custom `channelIndex` (currently up to 4). Returns .customMax if this custom channel is unused.
    public final func getCustomFormat (channelIndex: Int32)-> SurfaceTool.CustomFormat {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_channel_index: Int = Int (channelIndex)
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_get_custom_format, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_channel_index)
        return SurfaceTool.CustomFormat (rawValue: _result)!
        #else
        
        var copy_channel_index: Int = Int (channelIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_channel_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_get_custom_format, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return SurfaceTool.CustomFormat (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_begin: GDExtensionMethodBindPtr = {
        let methodName = StringName ("begin")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2230304113)!
            }
            
        }
        
    }()
    
    /// Called before adding any vertices. Takes the primitive type as an argument (e.g. ``Mesh/PrimitiveType/primitiveTriangles``).
    public final func begin (primitive: Mesh.PrimitiveType) {
        #if false
        
        var copy_primitive = Int64 (primitive.rawValue)
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_begin, UnsafeMutableRawPointer (mutating: handle), nil, &copy_primitive)
        
        #else
        
        var copy_primitive = Int64 (primitive.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_primitive) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_begin, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_vertex: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_vertex")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3460891852)!
            }
            
        }
        
    }()
    
    /// Specifies the position of current vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
    public final func addVertex (_ vertex: Vector3) {
        #if false
        
        var copy_vertex = vertex
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_add_vertex, UnsafeMutableRawPointer (mutating: handle), nil, &copy_vertex)
        
        #else
        
        var copy_vertex = vertex
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_vertex) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_add_vertex, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_color")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Specifies a ``Color`` to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
    /// 
    /// > Note: The material must have ``BaseMaterial3D/vertexColorUseAsAlbedo`` enabled for the vertex color to be visible.
    /// 
    public final func setColor (_ color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_normal: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_normal")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3460891852)!
            }
            
        }
        
    }()
    
    /// Specifies a normal to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
    public final func setNormal (_ normal: Vector3) {
        #if false
        
        var copy_normal = normal
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_normal, UnsafeMutableRawPointer (mutating: handle), nil, &copy_normal)
        
        #else
        
        var copy_normal = normal
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_normal) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_normal, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_tangent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tangent")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3505987427)!
            }
            
        }
        
    }()
    
    /// Specifies a tangent to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
    public final func setTangent (_ tangent: Plane) {
        #if false
        
        var copy_tangent = tangent
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_tangent, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tangent)
        
        #else
        
        var copy_tangent = tangent
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tangent) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_tangent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_uv: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_uv")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    /// Specifies a set of UV coordinates to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
    public final func setUv (_ uv: Vector2) {
        #if false
        
        var copy_uv = uv
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_uv, UnsafeMutableRawPointer (mutating: handle), nil, &copy_uv)
        
        #else
        
        var copy_uv = uv
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_uv) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_uv, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_uv2: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_uv2")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    /// Specifies an optional second set of UV coordinates to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
    public final func setUv2 (_ uv2: Vector2) {
        #if false
        
        var copy_uv2 = uv2
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_uv2, UnsafeMutableRawPointer (mutating: handle), nil, &copy_uv2)
        
        #else
        
        var copy_uv2 = uv2
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_uv2) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_uv2, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_bones: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_bones")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3614634198)!
            }
            
        }
        
    }()
    
    /// Specifies an array of bones to use for the _next_ vertex. `bones` must contain 4 integers.
    public final func setBones (_ bones: PackedInt32Array) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_bones, UnsafeMutableRawPointer (mutating: handle), nil, &bones.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &bones.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_bones, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_weights: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_weights")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2899603908)!
            }
            
        }
        
    }()
    
    /// Specifies weight values to use for the _next_ vertex. `weights` must contain 4 values. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
    public final func setWeights (_ weights: PackedFloat32Array) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_weights, UnsafeMutableRawPointer (mutating: handle), nil, &weights.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &weights.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_weights, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_custom: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_custom")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2878471219)!
            }
            
        }
        
    }()
    
    /// Sets the custom value on this vertex for `channelIndex`.
    /// 
    /// ``setCustomFormat(channelIndex:format:)`` must be called first for this `channelIndex`. Formats which are not RGBA will ignore other color channels.
    /// 
    public final func setCustom (channelIndex: Int32, customColor: Color) {
        #if false
        
        var copy_channel_index: Int = Int (channelIndex)
        var copy_custom_color = customColor
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_custom, UnsafeMutableRawPointer (mutating: handle), nil, &copy_channel_index, &copy_custom_color)
        
        #else
        
        var copy_channel_index: Int = Int (channelIndex)
        var copy_custom_color = customColor
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_channel_index) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_custom_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (SurfaceTool.method_set_custom, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_smooth_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_smooth_group")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Specifies the smooth group to use for the _next_ vertex. If this is never called, all vertices will have the default smooth group of `0` and will be smoothed with adjacent vertices of the same group. To produce a mesh with flat normals, set the smooth group to `-1`.
    /// 
    /// > Note: This function actually takes a `uint32_t`, so C# users should use `uint32.MaxValue` instead of `-1` to produce a mesh with flat normals.
    /// 
    public final func setSmoothGroup (index: UInt32) {
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_smooth_group, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_smooth_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_triangle_fan: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_triangle_fan")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2235017613)!
            }
            
        }
        
    }()
    
    /// Inserts a triangle fan made of array data into ``Mesh`` being constructed.
    /// 
    /// Requires the primitive type be set to ``Mesh/PrimitiveType/primitiveTriangles``.
    /// 
    public final func addTriangleFan (vertices: PackedVector3Array, uvs: PackedVector2Array = PackedVector2Array(), colors: PackedColorArray = PackedColorArray(), uv2s: PackedVector2Array = PackedVector2Array(), normals: PackedVector3Array = PackedVector3Array(), tangents: VariantCollection<Plane> = VariantCollection<Plane> ()) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_add_triangle_fan, UnsafeMutableRawPointer (mutating: handle), nil, &vertices.content, &uvs.content, &colors.content, &uv2s.content, &normals.content, &tangents.array.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &vertices.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &uvs.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &colors.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &uv2s.content) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &normals.content) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &tangents.array.content) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (SurfaceTool.method_add_triangle_fan, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_index")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Adds a vertex to index array if you are using indexed vertices. Does not need to be called before adding vertices.
    public final func addIndex (_ index: Int32) {
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_add_index, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_add_index, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("index")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Shrinks the vertex array by creating an index array. This can improve performance by avoiding vertex reuse.
    public final func index () {
        gi.object_method_bind_ptrcall (SurfaceTool.method_index, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_deindex: GDExtensionMethodBindPtr = {
        let methodName = StringName ("deindex")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes the index array by expanding the vertex array.
    public final func deindex () {
        gi.object_method_bind_ptrcall (SurfaceTool.method_deindex, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_generate_normals: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_normals")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 107499316)!
            }
            
        }
        
    }()
    
    /// Generates normals from vertices so you do not have to do it manually. If `flip` is `true`, the resulting normals will be inverted. ``generateNormals(flip:)`` should be called _after_ generating geometry and _before_ committing the mesh using ``commit(existing:flags:)`` or ``commitToArrays()``. For correct display of normal-mapped surfaces, you will also have to generate tangents using ``generateTangents()``.
    /// 
    /// > Note: ``generateNormals(flip:)`` only works if the primitive type to be set to ``Mesh/PrimitiveType/primitiveTriangles``.
    /// 
    /// > Note: ``generateNormals(flip:)`` takes smooth groups into account. To generate smooth normals, set the smooth group to a value greater than or equal to `0` using ``setSmoothGroup(index:)`` or leave the smooth group at the default of `0`. To generate flat normals, set the smooth group to `-1` using ``setSmoothGroup(index:)`` prior to adding vertices.
    /// 
    public final func generateNormals (flip: Bool = false) {
        #if false
        
        var copy_flip = flip
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_generate_normals, UnsafeMutableRawPointer (mutating: handle), nil, &copy_flip)
        
        #else
        
        var copy_flip = flip
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_flip) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_generate_normals, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_generate_tangents: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_tangents")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Generates a tangent vector for each vertex. Requires that each vertex have UVs and normals set already (see ``generateNormals(flip:)``).
    public final func generateTangents () {
        gi.object_method_bind_ptrcall (SurfaceTool.method_generate_tangents, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_optimize_indices_for_cache: GDExtensionMethodBindPtr = {
        let methodName = StringName ("optimize_indices_for_cache")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Optimizes triangle sorting for performance. Requires that ``getPrimitiveType()`` is ``Mesh/PrimitiveType/primitiveTriangles``.
    public final func optimizeIndicesForCache () {
        gi.object_method_bind_ptrcall (SurfaceTool.method_optimize_indices_for_cache, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_aabb")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1068685055)!
            }
            
        }
        
    }()
    
    /// Returns the axis-aligned bounding box of the vertex positions.
    public final func getAabb ()-> AABB {
        var _result: AABB = AABB ()
        gi.object_method_bind_ptrcall (SurfaceTool.method_get_aabb, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_generate_lod: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_lod")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1938056459)!
            }
            
        }
        
    }()
    
    /// Generates a LOD for a given `ndThreshold` in linear units (square root of quadric error metric), using at most `targetIndexCount` indices.
    /// 
    /// _Deprecated._ Unused internally and neglects to preserve normals or UVs. Consider using ``ImporterMesh/generateLods(normalMergeAngle:normalSplitAngle:boneTransformArray:)`` instead.
    /// 
    public final func generateLod (ndThreshold: Double, targetIndexCount: Int32 = 3)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        var copy_nd_threshold = ndThreshold
        var copy_target_index_count: Int = Int (targetIndexCount)
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_generate_lod, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_nd_threshold, &copy_target_index_count)
        return _result
        #else
        
        var copy_nd_threshold = ndThreshold
        var copy_target_index_count: Int = Int (targetIndexCount)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_nd_threshold) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_target_index_count) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (SurfaceTool.method_generate_lod, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_material")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2757459619)!
            }
            
        }
        
    }()
    
    /// Sets ``Material`` to be used by the ``Mesh`` you are constructing.
    public final func setMaterial (_ material: Material?) {
        #if false
        
        var copy_material_handle = material?.handle
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_set_material, UnsafeMutableRawPointer (mutating: handle), nil, &copy_material_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: material?.handle) { p0 in
        _args.append (material == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (SurfaceTool.method_set_material, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_primitive_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_primitive_type")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 768822145)!
            }
            
        }
        
    }()
    
    /// Returns the type of mesh geometry, such as ``Mesh/PrimitiveType/primitiveTriangles``.
    public final func getPrimitiveType ()-> Mesh.PrimitiveType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (SurfaceTool.method_get_primitive_type, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Mesh.PrimitiveType (rawValue: _result)!
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clear all information passed into the surface tool so far.
    public final func clear () {
        gi.object_method_bind_ptrcall (SurfaceTool.method_clear, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_create_from: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_from")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1767024570)!
            }
            
        }
        
    }()
    
    /// Creates a vertex array from an existing ``Mesh``.
    public final func createFrom (existing: Mesh?, surface: Int32) {
        #if false
        
        var copy_surface: Int = Int (surface)
        var copy_existing_handle = existing?.handle
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_create_from, UnsafeMutableRawPointer (mutating: handle), nil, &copy_existing_handle, &copy_surface)
        
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: existing?.handle) { p0 in
        _args.append (existing == nil ? nil : p0)
            withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (SurfaceTool.method_create_from, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_create_from_blend_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_from_blend_shape")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1306185582)!
            }
            
        }
        
    }()
    
    /// Creates a vertex array from the specified blend shape of an existing ``Mesh``. This can be used to extract a specific pose from a blend shape.
    public final func createFromBlendShape (existing: Mesh?, surface: Int32, blendShape: String) {
        #if false
        
        var copy_surface: Int = Int (surface)
        let gstr_blend_shape = GString (blendShape)
        var copy_existing_handle = existing?.handle
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_create_from_blend_shape, UnsafeMutableRawPointer (mutating: handle), nil, &copy_existing_handle, &copy_surface, &gstr_blend_shape.content)
        
        #else
        
        var copy_surface: Int = Int (surface)
        let gstr_blend_shape = GString (blendShape)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: existing?.handle) { p0 in
        _args.append (existing == nil ? nil : p0)
            withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_blend_shape.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (SurfaceTool.method_create_from_blend_shape, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_append_from: GDExtensionMethodBindPtr = {
        let methodName = StringName ("append_from")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2217967155)!
            }
            
        }
        
    }()
    
    /// Append vertices from a given ``Mesh`` surface onto the current vertex array with specified ``Transform3D``.
    public final func appendFrom (existing: Mesh?, surface: Int32, transform: Transform3D) {
        #if false
        
        var copy_surface: Int = Int (surface)
        var copy_transform = transform
        var copy_existing_handle = existing?.handle
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_append_from, UnsafeMutableRawPointer (mutating: handle), nil, &copy_existing_handle, &copy_surface, &copy_transform)
        
        #else
        
        var copy_surface: Int = Int (surface)
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: existing?.handle) { p0 in
        _args.append (existing == nil ? nil : p0)
            withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_transform) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (SurfaceTool.method_append_from, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_commit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("commit")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4107864055)!
            }
            
        }
        
    }()
    
    /// Returns a constructed ``ArrayMesh`` from current information passed in. If an existing ``ArrayMesh`` is passed in as an argument, will add an extra surface to the existing ``ArrayMesh``.
    /// 
    /// **FIXME:** Document possible values for `flags`, it changed in 4.0. Likely some combinations of ``Mesh.ArrayFormat``.
    /// 
    public final func commit (existing: ArrayMesh? = nil, flags: UInt = 0)-> ArrayMesh? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_flags = flags
        var copy_existing_handle = existing?.handle
        
        gi.object_method_bind_ptrcall_v (SurfaceTool.method_commit, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_existing_handle, &copy_flags)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_flags = flags
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: existing?.handle) { p0 in
        _args.append (existing == nil ? nil : p0)
            return withUnsafePointer (to: &copy_flags) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (SurfaceTool.method_commit, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_commit_to_arrays: GDExtensionMethodBindPtr = {
        let methodName = StringName ("commit_to_arrays")
        return withUnsafePointer (to: &SurfaceTool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2915620761)!
            }
            
        }
        
    }()
    
    /// Commits the data to the same format used by ``ArrayMesh/addSurfaceFromArrays(primitive:arrays:blendShapes:lods:flags:)``. This way you can further process the mesh data using the ``ArrayMesh`` API.
    public final func commitToArrays ()-> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall (SurfaceTool.method_commit_to_arrays, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
}

