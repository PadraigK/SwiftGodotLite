// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for all scene objects.
/// 
/// Nodes are Godot's building blocks. They can be assigned as the child of another node, resulting in a tree arrangement. A given node can contain any number of nodes as children with the requirement that all siblings (direct children of a node) should have unique names.
/// 
/// A tree of nodes is called a _scene_. Scenes can be saved to the disk and then instantiated into other scenes. This allows for very high flexibility in the architecture and data model of Godot projects.
/// 
/// **Scene tree:** The ``SceneTree`` contains the active tree of nodes. When a node is added to the scene tree, it receives the ``notificationEnterTree`` notification and its ``_enterTree()`` callback is triggered. Child nodes are always added _after_ their parent node, i.e. the ``_enterTree()`` callback of a parent node will be triggered before its child's.
/// 
/// Once all nodes have been added in the scene tree, they receive the ``notificationReady`` notification and their respective ``_ready()`` callbacks are triggered. For groups of nodes, the ``_ready()`` callback is called in reverse order, starting with the children and moving up to the parent nodes.
/// 
/// This means that when adding a node to the scene tree, the following order will be used for the callbacks: ``_enterTree()`` of the parent, ``_enterTree()`` of the children, ``_ready()`` of the children and finally ``_ready()`` of the parent (recursively for the entire scene tree).
/// 
/// **Processing:** Nodes can override the "process" state, so that they receive a callback on each frame requesting them to process (do something). Normal processing (callback ``_process(delta:)``, toggled with ``setProcess(enable:)``) happens as fast as possible and is dependent on the frame rate, so the processing time _delta_ (in seconds) is passed as an argument. Physics processing (callback ``_physicsProcess(delta:)``, toggled with ``setPhysicsProcess(enable:)``) happens a fixed number of times per second (60 by default) and is useful for code related to the physics engine.
/// 
/// Nodes can also process input events. When present, the ``_input(event:)`` function will be called for each input that the program receives. In many cases, this can be overkill (unless used for simple projects), and the ``_unhandledInput(event:)`` function might be preferred; it is called when the input event was not handled by anyone else (typically, GUI ``Control`` nodes), ensuring that the node only receives the events that were meant for it.
/// 
/// To keep track of the scene hierarchy (especially when instancing scenes into other scenes), an "owner" can be set for the node with the ``owner`` property. This keeps track of who instantiated what. This is mostly useful when writing editors and tools, though.
/// 
/// Finally, when a node is freed with ``Object/free()`` or ``queueFree()``, it will also free all its children.
/// 
/// **Groups:** Nodes can be added to as many groups as you want to be easy to manage, you could create groups like "enemies" or "collectables" for example, depending on your game. See ``addToGroup(_:persistent:)``, ``isInGroup(_:)`` and ``removeFromGroup(_:)``. You can then retrieve all nodes in these groups, iterate them and even call methods on groups via the methods on ``SceneTree``.
/// 
/// **Networking with nodes:** After connecting to a server (or making one, see ``ENetMultiplayerPeer``), it is possible to use the built-in RPC (remote procedure call) system to communicate over the network. By calling ``rpc(method:)`` with a method name, it will be called locally and in all connected peers (peers = clients and the server that accepts connections). To identify which node receives the RPC call, Godot will use its ``NodePath`` (make sure node names are the same on all peers). Also, take a look at the high-level networking tutorial and corresponding demos.
/// 
/// > Note: The `script` property is part of the ``Object`` class, not ``Node``. It isn't exposed like most properties but does have a setter and getter (`set_script()` and `get_script()`).
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``ready``
/// - ``renamed``
/// - ``treeEntered``
/// - ``treeExiting``
/// - ``treeExited``
/// - ``childEnteredTree``
/// - ``childExitingTree``
/// - ``childOrderChanged``
/// - ``replacingBy``
open class Node: Object {
    override open class var godotClassName: StringName { "Node" }
    public enum ProcessMode: Int64 {
        /// Inherits process mode from the node's parent. For the root node, it is equivalent to .pausable. Default.
        case inherit = 0 // PROCESS_MODE_INHERIT
        /// Stops processing when the ``SceneTree`` is paused (process when unpaused). This is the inverse of .whenPaused.
        case pausable = 1 // PROCESS_MODE_PAUSABLE
        /// Only process when the ``SceneTree`` is paused (don't process when unpaused). This is the inverse of .pausable.
        case whenPaused = 2 // PROCESS_MODE_WHEN_PAUSED
        /// Always process. Continue processing always, ignoring the ``SceneTree``'s paused property. This is the inverse of .disabled.
        case always = 3 // PROCESS_MODE_ALWAYS
        /// Never process. Completely disables processing, ignoring the ``SceneTree``'s paused property. This is the inverse of .always.
        case disabled = 4 // PROCESS_MODE_DISABLED
    }
    
    public enum ProcessThreadGroup: Int64 {
        /// If the ``processThreadGroup`` property is sent to this, the node will belong to any parent (or grandparent) node that has a thread group mode that is not inherit. See ``processThreadGroup`` for more information.
        case inherit = 0 // PROCESS_THREAD_GROUP_INHERIT
        /// Process this node (and children nodes set to inherit) on the main thread. See ``processThreadGroup`` for more information.
        case mainThread = 1 // PROCESS_THREAD_GROUP_MAIN_THREAD
        /// Process this node (and children nodes set to inherit) on a sub-thread. See ``processThreadGroup`` for more information.
        case subThread = 2 // PROCESS_THREAD_GROUP_SUB_THREAD
    }
    
    public struct ProcessThreadMessages: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// 
        public static let messages = ProcessThreadMessages (rawValue: 1)
        /// 
        public static let messagesPhysics = ProcessThreadMessages (rawValue: 2)
        /// 
        public static let messagesAll = ProcessThreadMessages (rawValue: 3)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.messages) { result += "messages, " }
            if self.contains (.messagesPhysics) { result += "messagesPhysics, " }
            if self.contains (.messagesAll) { result += "messagesAll, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum DuplicateFlags: Int64 {
        /// Duplicate the node's signals.
        case signals = 1 // DUPLICATE_SIGNALS
        /// Duplicate the node's groups.
        case groups = 2 // DUPLICATE_GROUPS
        /// Duplicate the node's scripts.
        case scripts = 4 // DUPLICATE_SCRIPTS
        /// Duplicate using instancing.
        /// 
        /// An instance stays linked to the original so when the original changes, the instance changes too.
        /// 
        case useInstantiation = 8 // DUPLICATE_USE_INSTANTIATION
    }
    
    public enum InternalMode: Int64 {
        /// Node will not be internal.
        case disabled = 0 // INTERNAL_MODE_DISABLED
        /// Node will be placed at the front of parent's node list, before any non-internal sibling.
        case front = 1 // INTERNAL_MODE_FRONT
        /// Node will be placed at the back of parent's node list, after any non-internal sibling.
        case back = 2 // INTERNAL_MODE_BACK
    }
    
    /* Constants */
    /// Notification received when the node enters a ``SceneTree``.
    /// 
    /// This notification is emitted _before_ the related [signal tree_entered].
    /// 
    public static let notificationEnterTree = 10
    /// Notification received when the node is about to exit a ``SceneTree``.
    /// 
    /// This notification is emitted _after_ the related [signal tree_exiting].
    /// 
    public static let notificationExitTree = 11
    /// _Deprecated._ This notification is no longer emitted. Use ``notificationChildOrderChanged`` instead.
    public static let notificationMovedInParent = 12
    /// Notification received when the node is ready. See ``_ready()``.
    public static let notificationReady = 13
    /// Notification received when the node is paused.
    public static let notificationPaused = 14
    /// Notification received when the node is unpaused.
    public static let notificationUnpaused = 15
    /// Notification received every frame when the physics process flag is set (see ``setPhysicsProcess(enable:)``).
    public static let notificationPhysicsProcess = 16
    /// Notification received every frame when the process flag is set (see ``setProcess(enable:)``).
    public static let notificationProcess = 17
    /// Notification received when a node is set as a child of another node.
    /// 
    /// > Note: This doesn't mean that a node entered the ``SceneTree``.
    /// 
    public static let notificationParented = 18
    /// Notification received when a node is unparented (parent removed it from the list of children).
    public static let notificationUnparented = 19
    /// Notification received by scene owner when its scene is instantiated.
    public static let notificationSceneInstantiated = 20
    /// Notification received when a drag operation begins. All nodes receive this notification, not only the dragged one.
    /// 
    /// Can be triggered either by dragging a ``Control`` that provides drag data (see ``Control/_getDragData(atPosition:)``) or using ``Control/forceDrag(data:preview:)``.
    /// 
    /// Use ``Viewport/guiGetDragData()`` to get the dragged data.
    /// 
    public static let notificationDragBegin = 21
    /// Notification received when a drag operation ends.
    /// 
    /// Use ``Viewport/guiIsDragSuccessful()`` to check if the drag succeeded.
    /// 
    public static let notificationDragEnd = 22
    /// Notification received when the node's name or one of its parents' name is changed. This notification is _not_ received when the node is removed from the scene tree to be added to another parent later on.
    public static let notificationPathRenamed = 23
    /// Notification received when the list of children is changed. This happens when child nodes are added, moved or removed.
    public static let notificationChildOrderChanged = 24
    /// Notification received every frame when the internal process flag is set (see ``setProcessInternal(enable:)``).
    public static let notificationInternalProcess = 25
    /// Notification received every frame when the internal physics process flag is set (see ``setPhysicsProcessInternal(enable:)``).
    public static let notificationInternalPhysicsProcess = 26
    /// Notification received when the node is ready, just before ``notificationReady`` is received. Unlike the latter, it's sent every time the node enters the tree, instead of only once.
    public static let notificationPostEnterTree = 27
    /// Notification received when the node is disabled. See .disabled.
    public static let notificationDisabled = 28
    /// Notification received when the node is enabled again after being disabled. See .disabled.
    public static let notificationEnabled = 29
    /// Notification received right before the scene with the node is saved in the editor. This notification is only sent in the Godot editor and will not occur in exported projects.
    public static let notificationEditorPreSave = 9001
    /// Notification received right after the scene with the node is saved in the editor. This notification is only sent in the Godot editor and will not occur in exported projects.
    public static let notificationEditorPostSave = 9002
    /// Notification received when the mouse enters the window.
    /// 
    /// Implemented for embedded windows and on desktop and web platforms.
    /// 
    public static let notificationWmMouseEnter = 1002
    /// Notification received when the mouse leaves the window.
    /// 
    /// Implemented for embedded windows and on desktop and web platforms.
    /// 
    public static let notificationWmMouseExit = 1003
    /// Notification received when the node's parent ``Window`` is focused. This may be a change of focus between two windows of the same engine instance, or from the OS desktop or a third-party application to a window of the game (in which case ``notificationApplicationFocusIn`` is also emitted).
    /// 
    /// A ``Window`` node receives this notification when it is focused.
    /// 
    public static let notificationWmWindowFocusIn = 1004
    /// Notification received when the node's parent ``Window`` is defocused. This may be a change of focus between two windows of the same engine instance, or from a window of the game to the OS desktop or a third-party application (in which case ``notificationApplicationFocusOut`` is also emitted).
    /// 
    /// A ``Window`` node receives this notification when it is defocused.
    /// 
    public static let notificationWmWindowFocusOut = 1005
    /// Notification received from the OS when a close request is sent (e.g. closing the window with a "Close" button or [kbd]Alt + F4[/kbd]).
    /// 
    /// Implemented on desktop platforms.
    /// 
    public static let notificationWmCloseRequest = 1006
    /// Notification received from the OS when a go back request is sent (e.g. pressing the "Back" button on Android).
    /// 
    /// Specific to the Android platform.
    /// 
    public static let notificationWmGoBackRequest = 1007
    /// Notification received from the OS when the window is resized.
    public static let notificationWmSizeChanged = 1008
    /// Notification received from the OS when the screen's DPI has been changed. Only implemented on macOS.
    public static let notificationWmDpiChange = 1009
    /// Notification received when the mouse cursor enters the ``Viewport``'s visible area, that is not occluded behind other ``Control``s or ``Window``s, provided its ``Viewport/guiDisableInput`` is `false` and regardless if it's currently focused or not.
    public static let notificationVpMouseEnter = 1010
    /// Notification received when the mouse cursor leaves the ``Viewport``'s visible area, that is not occluded behind other ``Control``s or ``Window``s, provided its ``Viewport/guiDisableInput`` is `false` and regardless if it's currently focused or not.
    public static let notificationVpMouseExit = 1011
    /// Notification received from the OS when the application is exceeding its allocated memory.
    /// 
    /// Specific to the iOS platform.
    /// 
    public static let notificationOsMemoryWarning = 2009
    /// Notification received when translations may have changed. Can be triggered by the user changing the locale. Can be used to respond to language changes, for example to change the UI strings on the fly. Useful when working with the built-in translation support, like ``Object/tr(message:context:)``.
    public static let notificationTranslationChanged = 2010
    /// Notification received from the OS when a request for "About" information is sent.
    /// 
    /// Specific to the macOS platform.
    /// 
    public static let notificationWmAbout = 2011
    /// Notification received from Godot's crash handler when the engine is about to crash.
    /// 
    /// Implemented on desktop platforms if the crash handler is enabled.
    /// 
    public static let notificationCrash = 2012
    /// Notification received from the OS when an update of the Input Method Engine occurs (e.g. change of IME cursor position or composition string).
    /// 
    /// Specific to the macOS platform.
    /// 
    public static let notificationOsImeUpdate = 2013
    /// Notification received from the OS when the application is resumed.
    /// 
    /// Specific to the Android platform.
    /// 
    public static let notificationApplicationResumed = 2014
    /// Notification received from the OS when the application is paused.
    /// 
    /// Specific to the Android platform.
    /// 
    public static let notificationApplicationPaused = 2015
    /// Notification received from the OS when the application is focused, i.e. when changing the focus from the OS desktop or a thirdparty application to any open window of the Godot instance.
    /// 
    /// Implemented on desktop platforms.
    /// 
    public static let notificationApplicationFocusIn = 2016
    /// Notification received from the OS when the application is defocused, i.e. when changing the focus from any open window of the Godot instance to the OS desktop or a thirdparty application.
    /// 
    /// Implemented on desktop platforms.
    /// 
    public static let notificationApplicationFocusOut = 2017
    /// Notification received when text server is changed.
    public static let notificationTextServerChanged = 2018
    
    /* Properties */
    
    /// The name of the node. This name is unique among the siblings (other child nodes from the same parent). When set to an existing name, the node will be automatically renamed.
    /// 
    /// > Note: Auto-generated names might include the `@` character, which is reserved for unique names when using ``addChild(node:forceReadableName:`internal`:)``. When setting the name manually, any `@` will be removed.
    /// 
    final public var name: StringName {
        get {
            return get_name ()
        }
        
        set {
            set_name (String (newValue))
        }
        
    }
    
    /// Sets this node's name as a unique name in its ``owner``. This allows the node to be accessed as `%Name` instead of the full path, from any node within that scene.
    /// 
    /// If another node with the same owner already had that name declared as unique, that other node's name will no longer be set as having a unique name.
    /// 
    final public var uniqueNameInOwner: Bool {
        get {
            return is_unique_name_in_owner ()
        }
        
        set {
            set_unique_name_in_owner (newValue)
        }
        
    }
    
    /// If a scene is instantiated from a file, its topmost node contains the absolute file path from which it was loaded in ``sceneFilePath`` (e.g. `res://levels/1.tscn`). Otherwise, ``sceneFilePath`` is set to an empty string.
    final public var sceneFilePath: String {
        get {
            return get_scene_file_path ()
        }
        
        set {
            set_scene_file_path (newValue)
        }
        
    }
    
    /// The node owner. A node can have any ancestor node as owner (i.e. a parent, grandparent, etc. node ascending in the tree). This implies that ``addChild(node:forceReadableName:`internal`:)`` should be called before setting the owner, so that this relationship of parenting exists. When saving a node (using ``PackedScene``), all the nodes it owns will be saved with it. This allows for the creation of complex scene trees, with instancing and subinstancing.
    /// 
    /// > Note: If you want a child to be persisted to a ``PackedScene``, you must set ``owner`` in addition to calling ``addChild(node:forceReadableName:`internal`:)``. This is typically relevant for [url=$DOCS_URL/tutorials/plugins/running_code_in_the_editor.html]tool scripts[/url] and [url=$DOCS_URL/tutorials/plugins/editor/index.html]editor plugins[/url]. If a new node is added to the tree without setting its owner as an ancestor in that tree, it will be visible in the 2D/3D view, but not in the scene tree (and not persisted when packing or saving).
    /// 
    final public var owner: Node? {
        get {
            return get_owner ()
        }
        
        set {
            set_owner (newValue)
        }
        
    }
    
    /// The ``MultiplayerAPI`` instance associated with this node. See ``SceneTree/getMultiplayer(forPath:)``.
    /// 
    /// > Note: Renaming the node, or moving it in the tree, will not move the ``MultiplayerAPI`` to the new path, you will have to update this manually.
    /// 
    final public var multiplayer: MultiplayerAPI? {
        get {
            return get_multiplayer ()
        }
        
    }
    
    /// Can be used to pause or unpause the node, or make the node paused based on the ``SceneTree``, or make it inherit the process mode from its parent (default).
    final public var processMode: Node.ProcessMode {
        get {
            return get_process_mode ()
        }
        
        set {
            set_process_mode (newValue)
        }
        
    }
    
    /// The node's priority in the execution order of the enabled processing callbacks (i.e. ``notificationProcess``, ``notificationPhysicsProcess`` and their internal counterparts). Nodes whose process priority value is _lower_ will have their processing callbacks executed first.
    final public var processPriority: Int32 {
        get {
            return get_process_priority ()
        }
        
        set {
            set_process_priority (newValue)
        }
        
    }
    
    /// Similar to ``processPriority`` but for ``notificationPhysicsProcess``, ``_physicsProcess(delta:)`` or the internal version.
    final public var processPhysicsPriority: Int32 {
        get {
            return get_physics_process_priority ()
        }
        
        set {
            set_physics_process_priority (newValue)
        }
        
    }
    
    /// Set the process thread group for this node (basically, whether it receives ``notificationProcess``, ``notificationPhysicsProcess``, ``_process(delta:)`` or ``_physicsProcess(delta:)`` (and the internal versions) on the main thread or in a sub-thread.
    /// 
    /// By default, the thread group is .inherit, which means that this node belongs to the same thread group as the parent node. The thread groups means that nodes in a specific thread group will process together, separate to other thread groups (depending on ``processThreadGroupOrder``). If the value is set is .subThread, this thread group will occur on a sub thread (not the main thread), otherwise if set to .mainThread it will process on the main thread. If there is not a parent or grandparent node set to something other than inherit, the node will belong to the _default thread group_. This default group will process on the main thread and its group order is 0.
    /// 
    /// During processing in a sub-thread, accessing most functions in nodes outside the thread group is forbidden (and it will result in an error in debug mode). Use ``Object/callDeferred(method:)``, ``callThreadSafe(method:)``, ``callDeferredThreadGroup(method:)`` and the likes in order to communicate from the thread groups to the main thread (or to other thread groups).
    /// 
    /// To better understand process thread groups, the idea is that any node set to any other value than .inherit will include any children (and grandchildren) nodes set to inherit into its process thread group. this means that the processing of all the nodes in the group will happen together, at the same time as the node including them.
    /// 
    final public var processThreadGroup: Node.ProcessThreadGroup {
        get {
            return get_process_thread_group ()
        }
        
        set {
            set_process_thread_group (newValue)
        }
        
    }
    
    /// Change the process thread group order. Groups with a lesser order will process before groups with a greater order. This is useful when a large amount of nodes process in sub thread and, afterwards, another group wants to collect their result in the main thread, as an example.
    final public var processThreadGroupOrder: Int32 {
        get {
            return get_process_thread_group_order ()
        }
        
        set {
            set_process_thread_group_order (newValue)
        }
        
    }
    
    /// Set whether the current thread group will process messages (calls to ``callDeferredThreadGroup(method:)`` on threads, and whether it wants to receive them during regular process or physics process callbacks.
    final public var processThreadMessages: Node.ProcessThreadMessages {
        get {
            return get_process_thread_messages ()
        }
        
        set {
            set_process_thread_messages (newValue)
        }
        
    }
    
    /// Add a custom description to a node. It will be displayed in a tooltip when hovered in editor's scene tree.
    final public var editorDescription: String {
        get {
            return get_editor_description ()
        }
        
        set {
            set_editor_description (newValue)
        }
        
    }
    
    /* Methods */
    /// Called during the processing step of the main loop. Processing happens at every frame and as fast as possible, so the `delta` time since the previous frame is not constant. `delta` is in seconds.
    /// 
    /// It is only called if processing is enabled, which is done automatically if this method is overridden, and can be toggled with ``setProcess(enable:)``.
    /// 
    /// Corresponds to the ``notificationProcess`` notification in ``Object/_notification()``.
    /// 
    /// > Note: This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).
    /// 
    @_documentation(visibility: public)
    open func _process (delta: Double) {
    }
    
    /// Called during the physics processing step of the main loop. Physics processing means that the frame rate is synced to the physics, i.e. the `delta` variable should be constant. `delta` is in seconds.
    /// 
    /// It is only called if physics processing is enabled, which is done automatically if this method is overridden, and can be toggled with ``setPhysicsProcess(enable:)``.
    /// 
    /// Corresponds to the ``notificationPhysicsProcess`` notification in ``Object/_notification()``.
    /// 
    /// > Note: This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).
    /// 
    @_documentation(visibility: public)
    open func _physicsProcess (delta: Double) {
    }
    
    /// Called when the node enters the ``SceneTree`` (e.g. upon instancing, scene changing, or after calling ``addChild(node:forceReadableName:`internal`:)`` in a script). If the node has children, its ``_enterTree()`` callback will be called first, and then that of the children.
    /// 
    /// Corresponds to the ``notificationEnterTree`` notification in ``Object/_notification()``.
    /// 
    @_documentation(visibility: public)
    open func _enterTree () {
    }
    
    /// Called when the node is about to leave the ``SceneTree`` (e.g. upon freeing, scene changing, or after calling ``removeChild(node:)`` in a script). If the node has children, its ``_exitTree()`` callback will be called last, after all its children have left the tree.
    /// 
    /// Corresponds to the ``notificationExitTree`` notification in ``Object/_notification()`` and signal [signal tree_exiting]. To get notified when the node has already left the active tree, connect to the [signal tree_exited].
    /// 
    @_documentation(visibility: public)
    open func _exitTree () {
    }
    
    /// Called when the node is "ready", i.e. when both the node and its children have entered the scene tree. If the node has children, their ``_ready()`` callbacks get triggered first, and the parent node will receive the ready notification afterwards.
    /// 
    /// Corresponds to the ``notificationReady`` notification in ``Object/_notification()``. See also the `@onready` annotation for variables.
    /// 
    /// Usually used for initialization. For even earlier initialization, ``Object/_init()`` may be used. See also ``_enterTree()``.
    /// 
    /// > Note: ``_ready()`` may be called only once for each node. After removing a node from the scene tree and adding it again, ``_ready()`` will not be called a second time. This can be bypassed by requesting another call with ``requestReady()``, which may be called anywhere before adding the node again.
    /// 
    @_documentation(visibility: public)
    open func _ready () {
    }
    
    /// The elements in the array returned from this method are displayed as warnings in the Scene dock if the script that overrides it is a `tool` script.
    /// 
    /// Returning an empty array produces no warnings.
    /// 
    /// Call ``updateConfigurationWarnings()`` when the warnings need to be updated for this node.
    /// 
    @_documentation(visibility: public)
    open func _getConfigurationWarnings ()-> PackedStringArray {
        return PackedStringArray ()
    }
    
    /// Called when there is an input event. The input event propagates up through the node tree until a node consumes it.
    /// 
    /// It is only called if input processing is enabled, which is done automatically if this method is overridden, and can be toggled with ``setProcessInput(enable:)``.
    /// 
    /// To consume the input event and stop it propagating further to other nodes, ``Viewport/setInputAsHandled()`` can be called.
    /// 
    /// For gameplay input, ``_unhandledInput(event:)`` and ``_unhandledKeyInput(event:)`` are usually a better fit as they allow the GUI to intercept the events first.
    /// 
    /// > Note: This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).
    /// 
    @_documentation(visibility: public)
    open func _input (event: InputEvent) {
    }
    
    /// Called when an ``InputEventKey`` or ``InputEventShortcut`` hasn't been consumed by ``_input(event:)`` or any GUI ``Control`` item. It is called before ``_unhandledKeyInput(event:)`` and ``_unhandledInput(event:)``. The input event propagates up through the node tree until a node consumes it.
    /// 
    /// It is only called if shortcut processing is enabled, which is done automatically if this method is overridden, and can be toggled with ``setProcessShortcutInput(enable:)``.
    /// 
    /// To consume the input event and stop it propagating further to other nodes, ``Viewport/setInputAsHandled()`` can be called.
    /// 
    /// This method can be used to handle shortcuts. For generic GUI events, use ``_input(event:)`` instead. Gameplay events should usually be handled with either ``_unhandledInput(event:)`` or ``_unhandledKeyInput(event:)``.
    /// 
    /// > Note: This method is only called if the node is present in the scene tree (i.e. if it's not orphan).
    /// 
    @_documentation(visibility: public)
    open func _shortcutInput (event: InputEvent?) {
    }
    
    /// Called when an ``InputEvent`` hasn't been consumed by ``_input(event:)`` or any GUI ``Control`` item. It is called after ``_shortcutInput(event:)`` and after ``_unhandledKeyInput(event:)``. The input event propagates up through the node tree until a node consumes it.
    /// 
    /// It is only called if unhandled input processing is enabled, which is done automatically if this method is overridden, and can be toggled with ``setProcessUnhandledInput(enable:)``.
    /// 
    /// To consume the input event and stop it propagating further to other nodes, ``Viewport/setInputAsHandled()`` can be called.
    /// 
    /// For gameplay input, this method is usually a better fit than ``_input(event:)``, as GUI events need a higher priority. For keyboard shortcuts, consider using ``_shortcutInput(event:)`` instead, as it is called before this method. Finally, to handle keyboard events, consider using ``_unhandledKeyInput(event:)`` for performance reasons.
    /// 
    /// > Note: This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).
    /// 
    @_documentation(visibility: public)
    open func _unhandledInput (event: InputEvent?) {
    }
    
    /// Called when an ``InputEventKey`` hasn't been consumed by ``_input(event:)`` or any GUI ``Control`` item. It is called after ``_shortcutInput(event:)`` but before ``_unhandledInput(event:)``. The input event propagates up through the node tree until a node consumes it.
    /// 
    /// It is only called if unhandled key input processing is enabled, which is done automatically if this method is overridden, and can be toggled with ``setProcessUnhandledKeyInput(enable:)``.
    /// 
    /// To consume the input event and stop it propagating further to other nodes, ``Viewport/setInputAsHandled()`` can be called.
    /// 
    /// This method can be used to handle Unicode character input with [kbd]Alt[/kbd], [kbd]Alt + Ctrl[/kbd], and [kbd]Alt + Shift[/kbd] modifiers, after shortcuts were handled.
    /// 
    /// For gameplay input, this and ``_unhandledInput(event:)`` are usually a better fit than ``_input(event:)``, as GUI events should be handled first. This method also performs better than ``_unhandledInput(event:)``, since unrelated events such as ``InputEventMouseMotion`` are automatically filtered. For shortcuts, consider using ``_shortcutInput(event:)`` instead.
    /// 
    /// > Note: This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).
    /// 
    @_documentation(visibility: public)
    open func _unhandledKeyInput (event: InputEvent?) {
    }
    
    fileprivate static var method_print_orphan_nodes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("print_orphan_nodes")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Prints all orphan nodes (nodes outside the ``SceneTree``). Used for debugging.
    /// 
    /// > Note: ``printOrphanNodes()`` only works in debug builds. When called in a project exported in release mode, ``printOrphanNodes()`` will not print anything.
    /// 
    public static func printOrphanNodes () {
        gi.object_method_bind_ptrcall (Node.method_print_orphan_nodes, nil, nil, nil)
    }
    
    fileprivate static var method_add_sibling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_sibling")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2570952461)!
            }
            
        }
        
    }()
    
    /// Adds a `sibling` node to current's node parent, at the same level as that node, right below it.
    /// 
    /// If `forceReadableName` is `true`, improves the readability of the added `sibling`. If not named, the `sibling` is renamed to its type, and if it shares ``name`` with a sibling, a number is suffixed more appropriately. This operation is very slow. As such, it is recommended leaving this to `false`, which assigns a dummy name featuring `@` in both situations.
    /// 
    /// Use ``addChild(node:forceReadableName:`internal`:)`` instead of this method if you don't need the child node to be added below a specific node in the list of children.
    /// 
    /// > Note: If this node is internal, the new sibling will be internal too (see `internal` parameter in ``addChild(node:forceReadableName:`internal`:)``).
    /// 
    public final func addSibling (_ sibling: Node?, forceReadableName: Bool = false) {
        #if false
        
        var copy_force_readable_name = forceReadableName
        var copy_sibling_handle = sibling?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_add_sibling, UnsafeMutableRawPointer (mutating: handle), nil, &copy_sibling_handle, &copy_force_readable_name)
        
        #else
        
        var copy_force_readable_name = forceReadableName
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: sibling?.handle) { p0 in
        _args.append (sibling == nil ? nil : p0)
            withUnsafePointer (to: &copy_force_readable_name) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_add_sibling, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_name")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_name (_ name: String) {
        #if false
        
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (Node.method_set_name, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_name.content)
        
        #else
        
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_name, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_name")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2002593661)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_name ()-> StringName {
        let _result: StringName = StringName ()
        gi.object_method_bind_ptrcall (Node.method_get_name, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_add_child: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_child")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3863233950)!
            }
            
        }
        
    }()
    
    /// Adds a child `node`. Nodes can have any number of children, but every child must have a unique name. Child nodes are automatically deleted when the parent node is deleted, so an entire scene can be removed by deleting its topmost node.
    /// 
    /// If `forceReadableName` is `true`, improves the readability of the added `node`. If not named, the `node` is renamed to its type, and if it shares ``name`` with a sibling, a number is suffixed more appropriately. This operation is very slow. As such, it is recommended leaving this to `false`, which assigns a dummy name featuring `@` in both situations.
    /// 
    /// If `internal` is different than .disabled, the child will be added as internal node. Such nodes are ignored by methods like ``getChildren(includeInternal:)``, unless their parameter `include_internal` is `true`. The intended usage is to hide the internal nodes from the user, so the user won't accidentally delete or modify them. Used by some GUI nodes, e.g. ``ColorPicker``. See ``Node/InternalMode`` for available modes.
    /// 
    /// > Note: If the child node already has a parent, the function will fail. Use ``removeChild(node:)`` first to remove the node from its current parent. For example:
    /// 
    /// If you need the child node to be added below a specific node in the list of children, use ``addSibling(_:forceReadableName:)`` instead of this method.
    /// 
    /// > Note: If you want a child to be persisted to a ``PackedScene``, you must set ``owner`` in addition to calling ``addChild(node:forceReadableName:`internal`:)``. This is typically relevant for [url=$DOCS_URL/tutorials/plugins/running_code_in_the_editor.html]tool scripts[/url] and [url=$DOCS_URL/tutorials/plugins/editor/index.html]editor plugins[/url]. If ``addChild(node:forceReadableName:`internal`:)`` is called without setting ``owner``, the newly added ``Node`` will not be visible in the scene tree, though it will be visible in the 2D/3D view.
    /// 
    public final func addChild (node: Node?, forceReadableName: Bool = false, `internal`: Node.InternalMode = .disabled) {
        #if false
        
        var copy_force_readable_name = forceReadableName
        var copy_internal = Int64 (`internal`.rawValue)
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_add_child, UnsafeMutableRawPointer (mutating: handle), nil, &copy_node_handle, &copy_force_readable_name, &copy_internal)
        
        #else
        
        var copy_force_readable_name = forceReadableName
        var copy_internal = Int64 (`internal`.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
            withUnsafePointer (to: &copy_force_readable_name) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_internal) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Node.method_add_child, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_child: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_child")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    /// Removes a child node. The node is NOT deleted and must be deleted manually.
    /// 
    /// > Note: This function may set the ``owner`` of the removed Node (or its descendants) to be `null`, if that ``owner`` is no longer a parent or ancestor.
    /// 
    public final func removeChild (node: Node?) {
        #if false
        
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_remove_child, UnsafeMutableRawPointer (mutating: handle), nil, &copy_node_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Node.method_remove_child, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_reparent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reparent")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3685795103)!
            }
            
        }
        
    }()
    
    /// Changes the parent of this ``Node`` to the `newParent`. The node needs to already have a parent.
    /// 
    /// If `keepGlobalTransform` is `true`, the node's global transform will be preserved if supported. ``Node2D``, ``Node3D`` and ``Control`` support this argument (but ``Control`` keeps only position).
    /// 
    public final func reparent (newParent: Node?, keepGlobalTransform: Bool = true) {
        #if false
        
        var copy_keep_global_transform = keepGlobalTransform
        var copy_new_parent_handle = newParent?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_reparent, UnsafeMutableRawPointer (mutating: handle), nil, &copy_new_parent_handle, &copy_keep_global_transform)
        
        #else
        
        var copy_keep_global_transform = keepGlobalTransform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: newParent?.handle) { p0 in
        _args.append (newParent == nil ? nil : p0)
            withUnsafePointer (to: &copy_keep_global_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_reparent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_child_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_child_count")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 894402480)!
            }
            
        }
        
    }()
    
    /// Returns the number of child nodes.
    /// 
    /// If `includeInternal` is `false`, internal children aren't counted (see `internal` parameter in ``addChild(node:forceReadableName:`internal`:)``).
    /// 
    public final func getChildCount (includeInternal: Bool = false)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_include_internal = includeInternal
        
        gi.object_method_bind_ptrcall_v (Node.method_get_child_count, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_include_internal)
        return _result
        #else
        
        var copy_include_internal = includeInternal
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_include_internal) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_get_child_count, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_children: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_children")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 873284517)!
            }
            
        }
        
    }()
    
    /// Returns an array of references to node's children.
    /// 
    /// If `includeInternal` is `false`, the returned array won't include internal children (see `internal` parameter in ``addChild(node:forceReadableName:`internal`:)``).
    /// 
    public final func getChildren (includeInternal: Bool = false)-> ObjectCollection<Node> {
        var _result: Int64 = 0
        #if false
        
        var copy_include_internal = includeInternal
        
        gi.object_method_bind_ptrcall_v (Node.method_get_children, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_include_internal)
        return ObjectCollection<Node>(content: _result)
        #else
        
        var copy_include_internal = includeInternal
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_include_internal) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_get_children, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return ObjectCollection<Node>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_get_child: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_child")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 541253412)!
            }
            
        }
        
    }()
    
    /// Returns a child node by its index (see ``getChildCount(includeInternal:)``). This method is often used for iterating all children of a node.
    /// 
    /// Negative indices access the children from the last one.
    /// 
    /// If `includeInternal` is `false`, internal children are skipped (see `internal` parameter in ``addChild(node:forceReadableName:`internal`:)``).
    /// 
    /// To access a child node via its name, use ``getNode(path:)``.
    /// 
    public final func getChild (idx: Int32, includeInternal: Bool = false)-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_idx: Int = Int (idx)
        var copy_include_internal = includeInternal
        
        gi.object_method_bind_ptrcall_v (Node.method_get_child, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_idx, &copy_include_internal)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_idx: Int = Int (idx)
        var copy_include_internal = includeInternal
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_include_internal) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_get_child, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_node: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_node")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 861721659)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node that the ``NodePath`` points to exists.
    public final func hasNode (path: NodePath)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_has_node, UnsafeMutableRawPointer (mutating: handle), &_result, &path.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_has_node, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_node: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_node")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2734337346)!
            }
            
        }
        
    }()
    
    /// Fetches a node. The ``NodePath`` can be either a relative path (from the current node) or an absolute path (in the scene tree) to a node. If the path does not exist, `null` is returned and an error is logged. Attempts to access methods on the return value will result in an "Attempt to call <method> on a null instance." error.
    /// 
    /// > Note: Fetching absolute paths only works when the node is inside the scene tree (see ``isInsideTree()``).
    /// 
    /// **Example:** Assume your current node is Character and the following tree:
    /// 
    /// Possible paths are:
    /// 
    public final func getNode (path: NodePath)-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_get_node, UnsafeMutableRawPointer (mutating: handle), &_result, &path.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_get_node, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_node_or_null: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_node_or_null")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2734337346)!
            }
            
        }
        
    }()
    
    /// Similar to ``getNode(path:)``, but does not log an error if `path` does not point to a valid ``Node``.
    public final func getNodeOrNull (path: NodePath)-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_get_node_or_null, UnsafeMutableRawPointer (mutating: handle), &_result, &path.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_get_node_or_null, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_parent")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3160264692)!
            }
            
        }
        
    }()
    
    /// Returns the parent node of the current node, or `null` if the node lacks a parent.
    public final func getParent ()-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Node.method_get_parent, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_find_child: GDExtensionMethodBindPtr = {
        let methodName = StringName ("find_child")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2008217037)!
            }
            
        }
        
    }()
    
    /// Finds the first descendant of this node whose name matches `pattern` as in ``String/match(expr:)``. Internal children are also searched over (see `internal` parameter in ``addChild(node:forceReadableName:`internal`:)``).
    /// 
    /// `pattern` does not match against the full path, just against individual node names. It is case-sensitive, with `"*"` matching zero or more characters and `"?"` matching any single character except `"."`).
    /// 
    /// If `recursive` is `true`, all child nodes are included, even if deeply nested. Nodes are checked in tree order, so this node's first direct child is checked first, then its own direct children, etc., before moving to the second direct child, and so on. If `recursive` is `false`, only this node's direct children are matched.
    /// 
    /// If `owned` is `true`, this method only finds nodes who have an assigned ``Node/owner``. This is especially important for scenes instantiated through a script, because those scenes don't have an owner.
    /// 
    /// Returns `null` if no matching ``Node`` is found.
    /// 
    /// > Note: As this method walks through all the descendants of the node, it is the slowest way to get a reference to another node. Whenever possible, consider using ``getNode(path:)`` with unique names instead (see ``uniqueNameInOwner``), or caching the node references into variable.
    /// 
    /// > Note: To find all descendant nodes matching a pattern or a class type, see ``findChildren(pattern:type:recursive:owned:)``.
    /// 
    public final func findChild (pattern: String, recursive: Bool = true, owned: Bool = true)-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        let gstr_pattern = GString (pattern)
        var copy_recursive = recursive
        var copy_owned = owned
        
        gi.object_method_bind_ptrcall_v (Node.method_find_child, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_pattern.content, &copy_recursive, &copy_owned)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_pattern = GString (pattern)
        var copy_recursive = recursive
        var copy_owned = owned
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_pattern.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_recursive) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_owned) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Node.method_find_child, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_find_children: GDExtensionMethodBindPtr = {
        let methodName = StringName ("find_children")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2560337219)!
            }
            
        }
        
    }()
    
    /// Finds descendants of this node whose name matches `pattern` as in ``String/match(expr:)``, and/or type matches `type` as in ``Object/isClass(_:)``. Internal children are also searched over (see `internal` parameter in ``addChild(node:forceReadableName:`internal`:)``).
    /// 
    /// `pattern` does not match against the full path, just against individual node names. It is case-sensitive, with `"*"` matching zero or more characters and `"?"` matching any single character except `"."`).
    /// 
    /// `type` will check equality or inheritance, and is case-sensitive. `"Object"` will match a node whose type is `"Node"` but not the other way around.
    /// 
    /// If `recursive` is `true`, all child nodes are included, even if deeply nested. Nodes are checked in tree order, so this node's first direct child is checked first, then its own direct children, etc., before moving to the second direct child, and so on. If `recursive` is `false`, only this node's direct children are matched.
    /// 
    /// If `owned` is `true`, this method only finds nodes who have an assigned ``Node/owner``. This is especially important for scenes instantiated through a script, because those scenes don't have an owner.
    /// 
    /// Returns an empty array if no matching nodes are found.
    /// 
    /// > Note: As this method walks through all the descendants of the node, it is the slowest way to get references to other nodes. Whenever possible, consider caching the node references into variables.
    /// 
    /// > Note: If you only want to find the first descendant node that matches a pattern, see ``findChild(pattern:recursive:owned:)``.
    /// 
    public final func findChildren (pattern: String, type: String = "", recursive: Bool = true, owned: Bool = true)-> ObjectCollection<Node> {
        var _result: Int64 = 0
        #if false
        
        let gstr_pattern = GString (pattern)
        let gstr_type = GString (type)
        var copy_recursive = recursive
        var copy_owned = owned
        
        gi.object_method_bind_ptrcall_v (Node.method_find_children, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_pattern.content, &gstr_type.content, &copy_recursive, &copy_owned)
        return ObjectCollection<Node>(content: _result)
        #else
        
        let gstr_pattern = GString (pattern)
        let gstr_type = GString (type)
        var copy_recursive = recursive
        var copy_owned = owned
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_pattern.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_type.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_recursive) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_owned) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Node.method_find_children, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return ObjectCollection<Node>(content: _result)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_find_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("find_parent")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1140089439)!
            }
            
        }
        
    }()
    
    /// Finds the first parent of the current node whose name matches `pattern` as in ``String/match(expr:)``.
    /// 
    /// `pattern` does not match against the full path, just against individual node names. It is case-sensitive, with `"*"` matching zero or more characters and `"?"` matching any single character except `"."`).
    /// 
    /// > Note: As this method walks upwards in the scene tree, it can be slow in large, deeply nested scene trees. Whenever possible, consider using ``getNode(path:)`` with unique names instead (see ``uniqueNameInOwner``), or caching the node references into variable.
    /// 
    public final func findParent (pattern: String)-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        let gstr_pattern = GString (pattern)
        
        gi.object_method_bind_ptrcall_v (Node.method_find_parent, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_pattern.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_pattern = GString (pattern)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_pattern.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_find_parent, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_has_node_and_resource: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_node_and_resource")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 861721659)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the ``NodePath`` points to a valid node and its subname points to a valid resource, e.g. `Area2D/CollisionShape2D:shape`. Properties with a non-``Resource`` type (e.g. nodes or primitive math types) are not considered resources.
    public final func hasNodeAndResource (path: NodePath)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_has_node_and_resource, UnsafeMutableRawPointer (mutating: handle), &_result, &path.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_has_node_and_resource, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_node_and_resource: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_node_and_resource")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 502563882)!
            }
            
        }
        
    }()
    
    /// Fetches a node and one of its resources as specified by the ``NodePath``'s subname (e.g. `Area2D/CollisionShape2D:shape`). If several nested resources are specified in the ``NodePath``, the last one will be fetched.
    /// 
    /// The return value is an array of size 3: the first index points to the ``Node`` (or `null` if not found), the second index points to the ``Resource`` (or `null` if not found), and the third index is the remaining ``NodePath``, if any.
    /// 
    /// For example, assuming that `Area2D/CollisionShape2D` is a valid node and that its `shape` property has been assigned a ``RectangleShape2D`` resource, one could have this kind of output:
    /// 
    public final func getNodeAndResource (path: NodePath)-> GArray {
        let _result: GArray = GArray ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_get_node_and_resource, UnsafeMutableRawPointer (mutating: handle), &_result.content, &path.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_get_node_and_resource, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_inside_tree: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_inside_tree")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this node is currently inside a ``SceneTree``.
    public final func isInsideTree ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_inside_tree, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_ancestor_of: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_ancestor_of")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3093956946)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the given node is a direct or indirect child of the current node.
    public final func isAncestorOf (node: Node?)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_is_ancestor_of, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_node_handle)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Node.method_is_ancestor_of, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_greater_than: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_greater_than")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3093956946)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the given node occurs later in the scene hierarchy than the current node.
    public final func isGreaterThan (node: Node?)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_is_greater_than, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_node_handle)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Node.method_is_greater_than, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_path: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_path")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4075236667)!
            }
            
        }
        
    }()
    
    /// Returns the absolute path of the current node. This only works if the current node is inside the scene tree (see ``isInsideTree()``).
    public final func getPath ()-> NodePath {
        let _result: NodePath = NodePath ()
        gi.object_method_bind_ptrcall (Node.method_get_path, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_path_to: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_path_to")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 498846349)!
            }
            
        }
        
    }()
    
    /// Returns the relative ``NodePath`` from this node to the specified `node`. Both nodes must be in the same scene or the function will fail.
    /// 
    /// If `useUniquePath` is `true`, returns the shortest path considering unique node.
    /// 
    /// > Note: If you get a relative path which starts from a unique node, the path may be longer than a normal relative path due to the addition of the unique node's name.
    /// 
    public final func getPathTo (node: Node?, useUniquePath: Bool = false)-> NodePath {
        let _result: NodePath = NodePath ()
        #if false
        
        var copy_use_unique_path = useUniquePath
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_get_path_to, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_node_handle, &copy_use_unique_path)
        return _result
        #else
        
        var copy_use_unique_path = useUniquePath
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
            return withUnsafePointer (to: &copy_use_unique_path) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_get_path_to, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_to_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_to_group")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3683006648)!
            }
            
        }
        
    }()
    
    /// Adds the node to a group. Groups are helpers to name and organize a subset of nodes, for example "enemies" or "collectables". A node can be in any number of groups. Nodes can be assigned a group at any time, but will not be added until they are inside the scene tree (see ``isInsideTree()``). See notes in the description, and the group methods in ``SceneTree``.
    /// 
    /// The `persistent` option is used when packing node to ``PackedScene`` and saving to file. Non-persistent groups aren't stored.
    /// 
    /// > Note: For performance reasons, the order of node groups is _not_ guaranteed. The order of node groups should not be relied upon as it can vary across project runs.
    /// 
    public final func addToGroup (_ group: StringName, persistent: Bool = false) {
        #if false
        
        var copy_persistent = persistent
        
        gi.object_method_bind_ptrcall_v (Node.method_add_to_group, UnsafeMutableRawPointer (mutating: handle), nil, &group.content, &copy_persistent)
        
        #else
        
        var copy_persistent = persistent
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &group.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_persistent) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_add_to_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_from_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_from_group")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a node from the `group`. Does nothing if the node is not in the `group`. See notes in the description, and the group methods in ``SceneTree``.
    public final func removeFromGroup (_ group: StringName) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_remove_from_group, UnsafeMutableRawPointer (mutating: handle), nil, &group.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &group.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_remove_from_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_in_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_in_group")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this node is in the specified group. See notes in the description, and the group methods in ``SceneTree``.
    public final func isInGroup (_ group: StringName)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_is_in_group, UnsafeMutableRawPointer (mutating: handle), &_result, &group.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &group.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_is_in_group, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_move_child: GDExtensionMethodBindPtr = {
        let methodName = StringName ("move_child")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3315886247)!
            }
            
        }
        
    }()
    
    /// Moves a child node to a different index (order) among the other children. Since calls, signals, etc. are performed by tree order, changing the order of children nodes may be useful. If `toIndex` is negative, the index will be counted from the end.
    /// 
    /// > Note: Internal children can only be moved within their expected "internal range" (see `internal` parameter in ``addChild(node:forceReadableName:`internal`:)``).
    /// 
    public final func moveChild (childNode: Node?, toIndex: Int32) {
        #if false
        
        var copy_to_index: Int = Int (toIndex)
        var copy_child_node_handle = childNode?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_move_child, UnsafeMutableRawPointer (mutating: handle), nil, &copy_child_node_handle, &copy_to_index)
        
        #else
        
        var copy_to_index: Int = Int (toIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: childNode?.handle) { p0 in
        _args.append (childNode == nil ? nil : p0)
            withUnsafePointer (to: &copy_to_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_move_child, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_groups: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_groups")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns an array listing the groups that the node is a member of.
    /// 
    /// > Note: For performance reasons, the order of node groups is _not_ guaranteed. The order of node groups should not be relied upon as it can vary across project runs.
    /// 
    /// > Note: The engine uses some group names internally (all starting with an underscore). To avoid conflicts with internal groups, do not add custom groups whose name starts with an underscore. To exclude internal groups while looping over ``getGroups()``, use the following snippet:
    /// 
    public final func getGroups ()-> VariantCollection<StringName> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (Node.method_get_groups, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<StringName>(content: _result)
    }
    
    fileprivate static var method_set_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_owner")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_owner (_ owner: Node?) {
        #if false
        
        var copy_owner_handle = owner?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_set_owner, UnsafeMutableRawPointer (mutating: handle), nil, &copy_owner_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: owner?.handle) { p0 in
        _args.append (owner == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_owner, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_owner")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3160264692)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_owner ()-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Node.method_get_owner, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_index")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 894402480)!
            }
            
        }
        
    }()
    
    /// Returns the node's order in the scene tree branch. For example, if called on the first child node the position is `0`.
    /// 
    /// If `includeInternal` is `false`, the index won't take internal children into account, i.e. first non-internal child will have index of 0 (see `internal` parameter in ``addChild(node:forceReadableName:`internal`:)``).
    /// 
    public final func getIndex (includeInternal: Bool = false)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_include_internal = includeInternal
        
        gi.object_method_bind_ptrcall_v (Node.method_get_index, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_include_internal)
        return _result
        #else
        
        var copy_include_internal = includeInternal
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_include_internal) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_get_index, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_print_tree: GDExtensionMethodBindPtr = {
        let methodName = StringName ("print_tree")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Prints the tree to stdout. Used mainly for debugging purposes. This version displays the path relative to the current node, and is good for copy/pasting into the ``getNode(path:)`` function.
    /// 
    /// **Example output:**
    /// 
    public final func printTree () {
        gi.object_method_bind_ptrcall (Node.method_print_tree, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_print_tree_pretty: GDExtensionMethodBindPtr = {
        let methodName = StringName ("print_tree_pretty")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Similar to ``printTree()``, this prints the tree to stdout. This version displays a more graphical representation similar to what is displayed in the Scene Dock. It is useful for inspecting larger trees.
    /// 
    /// **Example output:**
    /// 
    public final func printTreePretty () {
        gi.object_method_bind_ptrcall (Node.method_print_tree_pretty, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_tree_string: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tree_string")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2841200299)!
            }
            
        }
        
    }()
    
    /// Returns the tree as a ``String``. Used mainly for debugging purposes. This version displays the path relative to the current node, and is good for copy/pasting into the ``getNode(path:)`` function. It also can be used in game UI/UX.
    /// 
    /// **Example output:**
    /// 
    public final func getTreeString ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Node.method_get_tree_string, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_tree_string_pretty: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tree_string_pretty")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2841200299)!
            }
            
        }
        
    }()
    
    /// Similar to ``getTreeString()``, this returns the tree as a ``String``. This version displays a more graphical representation similar to what is displayed in the Scene Dock. It is useful for inspecting larger trees.
    /// 
    /// **Example output:**
    /// 
    public final func getTreeStringPretty ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Node.method_get_tree_string_pretty, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_scene_file_path: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scene_file_path")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scene_file_path (_ sceneFilePath: String) {
        #if false
        
        let gstr_scene_file_path = GString (sceneFilePath)
        
        gi.object_method_bind_ptrcall_v (Node.method_set_scene_file_path, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_scene_file_path.content)
        
        #else
        
        let gstr_scene_file_path = GString (sceneFilePath)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_scene_file_path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_scene_file_path, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_scene_file_path: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scene_file_path")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scene_file_path ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Node.method_get_scene_file_path, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_propagate_notification: GDExtensionMethodBindPtr = {
        let methodName = StringName ("propagate_notification")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Notifies the current node and all its children recursively by calling ``Object/notification(what:reversed:)`` on all of them.
    public final func propagateNotification (what: Int32) {
        #if false
        
        var copy_what: Int = Int (what)
        
        gi.object_method_bind_ptrcall_v (Node.method_propagate_notification, UnsafeMutableRawPointer (mutating: handle), nil, &copy_what)
        
        #else
        
        var copy_what: Int = Int (what)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_what) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_propagate_notification, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_propagate_call: GDExtensionMethodBindPtr = {
        let methodName = StringName ("propagate_call")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1871007965)!
            }
            
        }
        
    }()
    
    /// Calls the given method (if present) with the arguments given in `args` on this node and recursively on all its children. If the `parentFirst` argument is `true`, the method will be called on the current node first, then on all its children. If `parentFirst` is `false`, the children will be called first.
    public final func propagateCall (method: StringName, args: GArray = GArray (), parentFirst: Bool = false) {
        #if false
        
        var copy_parent_first = parentFirst
        
        gi.object_method_bind_ptrcall_v (Node.method_propagate_call, UnsafeMutableRawPointer (mutating: handle), nil, &method.content, &args.content, &copy_parent_first)
        
        #else
        
        var copy_parent_first = parentFirst
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &method.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &args.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_parent_first) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Node.method_propagate_call, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_physics_process: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_physics_process")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables or disables physics (i.e. fixed framerate) processing. When a node is being processed, it will receive a ``notificationPhysicsProcess`` at a fixed (usually 60 FPS, see ``Engine/physicsTicksPerSecond`` to change) interval (and the ``_physicsProcess(delta:)`` callback will be called if exists). Enabled automatically if ``_physicsProcess(delta:)`` is overridden. Any calls to this before ``_ready()`` will be ignored.
    public final func setPhysicsProcess (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_physics_process, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_physics_process, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_physics_process_delta_time: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_physics_process_delta_time")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the time elapsed (in seconds) since the last physics-bound frame (see ``_physicsProcess(delta:)``). This is always a constant value in physics processing unless the frames per second is changed via ``Engine/physicsTicksPerSecond``.
    public final func getPhysicsProcessDeltaTime ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Node.method_get_physics_process_delta_time, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_physics_processing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_physics_processing")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if physics processing is enabled (see ``setPhysicsProcess(enable:)``).
    public final func isPhysicsProcessing ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_physics_processing, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_process_delta_time: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_process_delta_time")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the time elapsed (in seconds) since the last process callback. This value may vary from frame to frame.
    public final func getProcessDeltaTime ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Node.method_get_process_delta_time, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables or disables processing. When a node is being processed, it will receive a ``notificationProcess`` on every drawn frame (and the ``_process(delta:)`` callback will be called if exists). Enabled automatically if ``_process(delta:)`` is overridden. Any calls to this before ``_ready()`` will be ignored.
    public final func setProcess (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_process_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_priority")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_process_priority (_ priority: Int32) {
        #if false
        
        var copy_priority: Int = Int (priority)
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_priority, UnsafeMutableRawPointer (mutating: handle), nil, &copy_priority)
        
        #else
        
        var copy_priority: Int = Int (priority)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_priority) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_priority, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_process_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_process_priority")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_process_priority ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Node.method_get_process_priority, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_physics_process_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_physics_process_priority")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_physics_process_priority (_ priority: Int32) {
        #if false
        
        var copy_priority: Int = Int (priority)
        
        gi.object_method_bind_ptrcall_v (Node.method_set_physics_process_priority, UnsafeMutableRawPointer (mutating: handle), nil, &copy_priority)
        
        #else
        
        var copy_priority: Int = Int (priority)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_priority) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_physics_process_priority, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_physics_process_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_physics_process_priority")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_physics_process_priority ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Node.method_get_physics_process_priority, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_processing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_processing")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if processing is enabled (see ``setProcess(enable:)``).
    public final func isProcessing ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_processing, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_input")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables or disables input processing. This is not required for GUI controls! Enabled automatically if ``_input(event:)`` is overridden. Any calls to this before ``_ready()`` will be ignored.
    public final func setProcessInput (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_input, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_processing_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_processing_input")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node is processing input (see ``setProcessInput(enable:)``).
    public final func isProcessingInput ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_processing_input, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process_shortcut_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_shortcut_input")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables shortcut processing. Enabled automatically if ``_shortcutInput(event:)`` is overridden. Any calls to this before ``_ready()`` will be ignored.
    public final func setProcessShortcutInput (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_shortcut_input, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_shortcut_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_processing_shortcut_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_processing_shortcut_input")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node is processing shortcuts (see ``setProcessShortcutInput(enable:)``).
    public final func isProcessingShortcutInput ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_processing_shortcut_input, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process_unhandled_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_unhandled_input")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables unhandled input processing. This is not required for GUI controls! It enables the node to receive all input that was not previously handled (usually by a ``Control``). Enabled automatically if ``_unhandledInput(event:)`` is overridden. Any calls to this before ``_ready()`` will be ignored.
    public final func setProcessUnhandledInput (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_unhandled_input, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_unhandled_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_processing_unhandled_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_processing_unhandled_input")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node is processing unhandled input (see ``setProcessUnhandledInput(enable:)``).
    public final func isProcessingUnhandledInput ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_processing_unhandled_input, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process_unhandled_key_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_unhandled_key_input")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables unhandled key input processing. Enabled automatically if ``_unhandledKeyInput(event:)`` is overridden. Any calls to this before ``_ready()`` will be ignored.
    public final func setProcessUnhandledKeyInput (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_unhandled_key_input, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_unhandled_key_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_processing_unhandled_key_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_processing_unhandled_key_input")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node is processing unhandled key input (see ``setProcessUnhandledKeyInput(enable:)``).
    public final func isProcessingUnhandledKeyInput ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_processing_unhandled_key_input, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_mode")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1841290486)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_process_mode (_ mode: Node.ProcessMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_process_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_process_mode")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 739966102)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_process_mode ()-> Node.ProcessMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Node.method_get_process_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Node.ProcessMode (rawValue: _result)!
    }
    
    fileprivate static var method_can_process: GDExtensionMethodBindPtr = {
        let methodName = StringName ("can_process")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node can process while the scene tree is paused (see ``processMode``). Always returns `true` if the scene tree is not paused, and `false` if the node is not in the tree.
    public final func canProcess ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_can_process, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process_thread_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_thread_group")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2275442745)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_process_thread_group (_ mode: Node.ProcessThreadGroup) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_thread_group, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_thread_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_process_thread_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_process_thread_group")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1866404740)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_process_thread_group ()-> Node.ProcessThreadGroup {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Node.method_get_process_thread_group, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Node.ProcessThreadGroup (rawValue: _result)!
    }
    
    fileprivate static var method_set_process_thread_messages: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_thread_messages")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1357280998)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_process_thread_messages (_ flags: Node.ProcessThreadMessages) {
        #if false
        
        var copy_flags = flags
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_thread_messages, UnsafeMutableRawPointer (mutating: handle), nil, &copy_flags)
        
        #else
        
        var copy_flags = flags
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_flags) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_thread_messages, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_process_thread_messages: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_process_thread_messages")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4228993612)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_process_thread_messages ()-> Node.ProcessThreadMessages {
        var _result: Node.ProcessThreadMessages = Node.ProcessThreadMessages ()
        gi.object_method_bind_ptrcall (Node.method_get_process_thread_messages, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process_thread_group_order: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_thread_group_order")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_process_thread_group_order (_ order: Int32) {
        #if false
        
        var copy_order: Int = Int (order)
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_thread_group_order, UnsafeMutableRawPointer (mutating: handle), nil, &copy_order)
        
        #else
        
        var copy_order: Int = Int (order)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_order) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_thread_group_order, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_process_thread_group_order: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_process_thread_group_order")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_process_thread_group_order ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Node.method_get_process_thread_group_order, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_display_folded: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_display_folded")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets the folded state of the node in the Scene dock. This method is only intended for use with editor tooling.
    public final func setDisplayFolded (fold: Bool) {
        #if false
        
        var copy_fold = fold
        
        gi.object_method_bind_ptrcall_v (Node.method_set_display_folded, UnsafeMutableRawPointer (mutating: handle), nil, &copy_fold)
        
        #else
        
        var copy_fold = fold
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_fold) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_display_folded, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_displayed_folded: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_displayed_folded")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node is folded (collapsed) in the Scene dock. This method is only intended for use with editor tooling.
    public final func isDisplayedFolded ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_displayed_folded, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_process_internal: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_process_internal")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables or disabled internal processing for this node. Internal processing happens in isolation from the normal ``_process(delta:)`` calls and is used by some nodes internally to guarantee proper functioning even if the node is paused or processing is disabled for scripting (``setProcess(enable:)``). Only useful for advanced uses to manipulate built-in nodes' behavior.
    /// 
    /// > Warning: Built-in Nodes rely on the internal processing for their own logic, so changing this value from your code may lead to unexpected behavior. Script access to this internal logic is provided for specific advanced uses, but is unsafe and not supported.
    /// 
    public final func setProcessInternal (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_process_internal, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_process_internal, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_processing_internal: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_processing_internal")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if internal processing is enabled (see ``setProcessInternal(enable:)``).
    public final func isProcessingInternal ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_processing_internal, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_physics_process_internal: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_physics_process_internal")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables or disables internal physics for this node. Internal physics processing happens in isolation from the normal ``_physicsProcess(delta:)`` calls and is used by some nodes internally to guarantee proper functioning even if the node is paused or physics processing is disabled for scripting (``setPhysicsProcess(enable:)``). Only useful for advanced uses to manipulate built-in nodes' behavior.
    /// 
    /// > Warning: Built-in Nodes rely on the internal processing for their own logic, so changing this value from your code may lead to unexpected behavior. Script access to this internal logic is provided for specific advanced uses, but is unsafe and not supported.
    /// 
    public final func setPhysicsProcessInternal (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_physics_process_internal, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_physics_process_internal, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_physics_processing_internal: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_physics_processing_internal")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if internal physics processing is enabled (see ``setPhysicsProcessInternal(enable:)``).
    public final func isPhysicsProcessingInternal ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_physics_processing_internal, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_window: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_window")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1757182445)!
            }
            
        }
        
    }()
    
    /// Returns the ``Window`` that contains this node. If the node is in the main window, this is equivalent to getting the root node (`get_tree().get_root()`).
    public final func getWindow ()-> Window? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Node.method_get_window, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_last_exclusive_window: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_last_exclusive_window")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1757182445)!
            }
            
        }
        
    }()
    
    /// Returns the ``Window`` that contains this node, or the last exclusive child in a chain of windows starting with the one that contains this node.
    public final func getLastExclusiveWindow ()-> Window? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Node.method_get_last_exclusive_window, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_tree: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tree")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2958820483)!
            }
            
        }
        
    }()
    
    /// Returns the ``SceneTree`` that contains this node. Returns `null` and prints an error if this node is not inside the scene tree. See also ``isInsideTree()``.
    public final func getTree ()-> SceneTree? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Node.method_get_tree, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_create_tween: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_tween")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3426978995)!
            }
            
        }
        
    }()
    
    /// Creates a new ``Tween`` and binds it to this node. This is equivalent of doing:
    /// 
    /// The Tween will start automatically on the next process frame or physics frame (depending on ``Tween.TweenProcessMode``).
    /// 
    public final func createTween ()-> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Node.method_create_tween, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_duplicate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("duplicate")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3511555459)!
            }
            
        }
        
    }()
    
    /// Duplicates the node, returning a new node.
    /// 
    /// You can fine-tune the behavior using the `flags` (see ``Node/DuplicateFlags``).
    /// 
    /// > Note: It will not work properly if the node contains a script with constructor arguments (i.e. needs to supply arguments to ``Object/_init()`` method). In that case, the node will be duplicated without a script.
    /// 
    public final func duplicate (flags: Int32 = 15)-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_flags: Int = Int (flags)
        
        gi.object_method_bind_ptrcall_v (Node.method_duplicate, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_flags)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_flags: Int = Int (flags)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_flags) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_duplicate, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_replace_by: GDExtensionMethodBindPtr = {
        let methodName = StringName ("replace_by")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2570952461)!
            }
            
        }
        
    }()
    
    /// Replaces a node in a scene by the given one. Subscriptions that pass through this node will be lost.
    /// 
    /// If `keepGroups` is `true`, the `node` is added to the same groups that the replaced node is in.
    /// 
    /// > Note: The given node will become the new parent of any child nodes that the replaced node had.
    /// 
    /// > Note: The replaced node is not automatically freed, so you either need to keep it in a variable for later use or free it using ``Object/free()``.
    /// 
    public final func replaceBy (node: Node?, keepGroups: Bool = false) {
        #if false
        
        var copy_keep_groups = keepGroups
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_replace_by, UnsafeMutableRawPointer (mutating: handle), nil, &copy_node_handle, &copy_keep_groups)
        
        #else
        
        var copy_keep_groups = keepGroups
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
            withUnsafePointer (to: &copy_keep_groups) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_replace_by, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_scene_instance_load_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scene_instance_load_placeholder")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets whether this is an instance load placeholder. See ``InstancePlaceholder``.
    public final func setSceneInstanceLoadPlaceholder (_ loadPlaceholder: Bool) {
        #if false
        
        var copy_load_placeholder = loadPlaceholder
        
        gi.object_method_bind_ptrcall_v (Node.method_set_scene_instance_load_placeholder, UnsafeMutableRawPointer (mutating: handle), nil, &copy_load_placeholder)
        
        #else
        
        var copy_load_placeholder = loadPlaceholder
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_load_placeholder) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_scene_instance_load_placeholder, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_scene_instance_load_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scene_instance_load_placeholder")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this is an instance load placeholder. See ``InstancePlaceholder``.
    public final func getSceneInstanceLoadPlaceholder ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_get_scene_instance_load_placeholder, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_editable_instance: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_editable_instance")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2731852923)!
            }
            
        }
        
    }()
    
    /// Sets the editable children state of `node` relative to this node. This method is only intended for use with editor tooling.
    public final func setEditableInstance (node: Node?, isEditable: Bool) {
        #if false
        
        var copy_is_editable = isEditable
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_set_editable_instance, UnsafeMutableRawPointer (mutating: handle), nil, &copy_node_handle, &copy_is_editable)
        
        #else
        
        var copy_is_editable = isEditable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
            withUnsafePointer (to: &copy_is_editable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_set_editable_instance, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_editable_instance: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_editable_instance")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3093956946)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `node` has editable children enabled relative to this node. This method is only intended for use with editor tooling.
    public final func isEditableInstance (node: Node?)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (Node.method_is_editable_instance, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_node_handle)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Node.method_is_editable_instance, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_viewport: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_viewport")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3596683776)!
            }
            
        }
        
    }()
    
    /// Returns the node's ``Viewport``.
    public final func getViewport ()-> Viewport? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Node.method_get_viewport, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_queue_free: GDExtensionMethodBindPtr = {
        let methodName = StringName ("queue_free")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Queues a node for deletion at the end of the current frame. When deleted, all of its child nodes will be deleted as well, and all references to the node and its children will become invalid, see ``Object/free()``.
    /// 
    /// It is safe to call ``queueFree()`` multiple times per frame on a node, and to ``Object/free()`` a node that is currently queued for deletion. Use ``Object/isQueuedForDeletion()`` to check whether a node will be deleted at the end of the frame.
    /// 
    /// The node will only be freed after all other deferred calls are finished, so using ``queueFree()`` is not always the same as calling ``Object/free()`` through ``Object/callDeferred(method:)``.
    /// 
    public final func queueFree () {
        gi.object_method_bind_ptrcall (Node.method_queue_free, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_request_ready: GDExtensionMethodBindPtr = {
        let methodName = StringName ("request_ready")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Requests that ``_ready()`` be called again. Note that the method won't be called immediately, but is scheduled for when the node is added to the scene tree again. ``_ready()`` is called only for the node which requested it, which means that you need to request ready for each child if you want them to call ``_ready()`` too (in which case, ``_ready()`` will be called in the same order as it would normally).
    public final func requestReady () {
        gi.object_method_bind_ptrcall (Node.method_request_ready, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_is_node_ready: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_node_ready")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node is ready, i.e. it's inside scene tree and all its children are initialized.
    /// 
    /// ``requestReady()`` resets it back to `false`.
    /// 
    public final func isNodeReady ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_node_ready, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_multiplayer_authority: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_multiplayer_authority")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 972357352)!
            }
            
        }
        
    }()
    
    /// Sets the node's multiplayer authority to the peer with the given peer ID. The multiplayer authority is the peer that has authority over the node on the network. Useful in conjunction with ``rpcConfig(method:config:)`` and the ``MultiplayerAPI``. Defaults to peer ID 1 (the server). If `recursive`, the given peer is recursively set as the authority for all children of this node.
    /// 
    /// > Warning: This does **not** automatically replicate the new authority to other peers. It is developer's responsibility to do so. You can propagate the information about the new authority using ``MultiplayerSpawner/spawnFunction``, an RPC, or using a ``MultiplayerSynchronizer``. Also, the parent's authority does **not** propagate to newly added children.
    /// 
    public final func setMultiplayerAuthority (id: Int32, recursive: Bool = true) {
        #if false
        
        var copy_id: Int = Int (id)
        var copy_recursive = recursive
        
        gi.object_method_bind_ptrcall_v (Node.method_set_multiplayer_authority, UnsafeMutableRawPointer (mutating: handle), nil, &copy_id, &copy_recursive)
        
        #else
        
        var copy_id: Int = Int (id)
        var copy_recursive = recursive
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_id) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_recursive) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_set_multiplayer_authority, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_multiplayer_authority: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_multiplayer_authority")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the peer ID of the multiplayer authority for this node. See ``setMultiplayerAuthority(id:recursive:)``.
    public final func getMultiplayerAuthority ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Node.method_get_multiplayer_authority, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_multiplayer_authority: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_multiplayer_authority")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the local system is the multiplayer authority of this node.
    public final func isMultiplayerAuthority ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_multiplayer_authority, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_multiplayer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_multiplayer")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 406750475)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_multiplayer ()-> MultiplayerAPI? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Node.method_get_multiplayer, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_rpc_config: GDExtensionMethodBindPtr = {
        let methodName = StringName ("rpc_config")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3776071444)!
            }
            
        }
        
    }()
    
    /// Changes the RPC mode for the given `method` with the given `config` which should be `null` (to disable) or a ``GDictionary`` in the form:
    /// 
    /// See ``MultiplayerAPI.RPCMode`` and ``MultiplayerPeer.TransferMode``. An alternative is annotating methods and properties with the corresponding [annotation @GDScript.@rpc] annotation (`@rpc("any_peer")`, `@rpc("authority")`). By default, methods are not exposed to networking (and RPCs).
    /// 
    public final func rpcConfig (method: StringName, config: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_rpc_config, UnsafeMutableRawPointer (mutating: handle), nil, &method.content, &config.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &method.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &config.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_rpc_config, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_editor_description: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_editor_description")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_editor_description (_ editorDescription: String) {
        #if false
        
        let gstr_editor_description = GString (editorDescription)
        
        gi.object_method_bind_ptrcall_v (Node.method_set_editor_description, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_editor_description.content)
        
        #else
        
        let gstr_editor_description = GString (editorDescription)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_editor_description.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_editor_description, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_editor_description: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_editor_description")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_editor_description ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Node.method_get_editor_description, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_unique_name_in_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_unique_name_in_owner")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_unique_name_in_owner (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Node.method_set_unique_name_in_owner, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_set_unique_name_in_owner, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_unique_name_in_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_unique_name_in_owner")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_unique_name_in_owner ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Node.method_is_unique_name_in_owner, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_rpc: GDExtensionMethodBindPtr = {
        let methodName = StringName ("rpc")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4047867050)!
            }
            
        }
        
    }()
    
    /// Sends a remote procedure call request for the given `method` to peers on the network (and locally), optionally sending all additional arguments as arguments to the method called by the RPC. The call request will only be received by nodes with the same ``NodePath``, including the exact same node name. Behavior depends on the RPC configuration for the given method, see ``rpcConfig(method:config:)`` and [annotation @GDScript.@rpc]. Methods are not exposed to RPCs by default. Returns `null`.
    /// 
    /// > Note: You can only safely use RPCs on clients after you received the `connected_to_server` signal from the ``MultiplayerAPI``. You also need to keep track of the connection state, either by the ``MultiplayerAPI`` signals like `server_disconnected` or by checking `get_multiplayer().peer.get_connection_status() == CONNECTION_CONNECTED`.
    /// 
    public final func rpc (method: StringName, _ arguments: Variant...)-> GodotError {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_method = Variant (method)
        
        gi.object_method_bind_call_v (Node.method_rpc, UnsafeMutableRawPointer (mutating: handle), &_result, nil, &copy_method.content)
        return GodotError (rawValue: Int64 (Variant (fromContentPtr: &_result))!)!
        #else
        
        let copy_method = Variant (method)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_method.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            gi.object_method_bind_call (Node.method_rpc, UnsafeMutableRawPointer (mutating: handle), &_args, Int64 (_args.count), &_result, nil)
            return GodotError (rawValue: Int64 (Variant (fromContentPtr: &_result))!)!
        }
        
        #endif
    }
    
    fileprivate static var method_rpc_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("rpc_id")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 361499283)!
            }
            
        }
        
    }()
    
    /// Sends a ``rpc(method:)`` to a specific peer identified by `peerId` (see ``MultiplayerPeer/setTargetPeer(id:)``). Returns `null`.
    public final func rpcId (peerId: Int64, method: StringName, _ arguments: Variant...)-> GodotError {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_peer_id = Variant (peerId)
        let copy_method = Variant (method)
        
        gi.object_method_bind_call_v (Node.method_rpc_id, UnsafeMutableRawPointer (mutating: handle), &_result, nil, &copy_peer_id.content, &copy_method.content)
        return GodotError (rawValue: Int64 (Variant (fromContentPtr: &_result))!)!
        #else
        
        let copy_peer_id = Variant (peerId)
        let copy_method = Variant (method)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_peer_id.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_method.content) { p1 in
                _args.append (p1)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
                gi.object_method_bind_call (Node.method_rpc_id, UnsafeMutableRawPointer (mutating: handle), &_args, Int64 (_args.count), &_result, nil)
                return GodotError (rawValue: Int64 (Variant (fromContentPtr: &_result))!)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_update_configuration_warnings: GDExtensionMethodBindPtr = {
        let methodName = StringName ("update_configuration_warnings")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Updates the warning displayed for this node in the Scene Dock.
    /// 
    /// Use ``_getConfigurationWarnings()`` to setup the warning message to display.
    /// 
    public final func updateConfigurationWarnings () {
        gi.object_method_bind_ptrcall (Node.method_update_configuration_warnings, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_call_deferred_thread_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("call_deferred_thread_group")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3400424181)!
            }
            
        }
        
    }()
    
    /// This function is similar to ``Object/callDeferred(method:)`` except that the call will take place when the node thread group is processed. If the node thread group processes in sub-threads, then the call will be done on that thread, right before ``notificationProcess`` or ``notificationPhysicsProcess``, the ``_process(delta:)`` or ``_physicsProcess(delta:)`` or their internal versions are called.
    public final func callDeferredThreadGroup (method: StringName, _ arguments: Variant...)-> Variant {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_method = Variant (method)
        
        gi.object_method_bind_call_v (Node.method_call_deferred_thread_group, UnsafeMutableRawPointer (mutating: handle), &_result, nil, &copy_method.content)
        return Variant (fromContentPtr: &_result)
        #else
        
        let copy_method = Variant (method)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_method.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            gi.object_method_bind_call (Node.method_call_deferred_thread_group, UnsafeMutableRawPointer (mutating: handle), &_args, Int64 (_args.count), &_result, nil)
            return Variant (fromContentPtr: &_result)
        }
        
        #endif
    }
    
    fileprivate static var method_set_deferred_thread_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_deferred_thread_group")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3776071444)!
            }
            
        }
        
    }()
    
    /// Similar to ``callDeferredThreadGroup(method:)``, but for setting properties.
    public final func setDeferredThreadGroup (property: StringName, value: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_set_deferred_thread_group, UnsafeMutableRawPointer (mutating: handle), nil, &property.content, &value.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &property.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &value.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_set_deferred_thread_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_notify_deferred_thread_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("notify_deferred_thread_group")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Similar to ``callDeferredThreadGroup(method:)``, but for notifications.
    public final func notifyDeferredThreadGroup (what: Int32) {
        #if false
        
        var copy_what: Int = Int (what)
        
        gi.object_method_bind_ptrcall_v (Node.method_notify_deferred_thread_group, UnsafeMutableRawPointer (mutating: handle), nil, &copy_what)
        
        #else
        
        var copy_what: Int = Int (what)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_what) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_notify_deferred_thread_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_call_thread_safe: GDExtensionMethodBindPtr = {
        let methodName = StringName ("call_thread_safe")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3400424181)!
            }
            
        }
        
    }()
    
    /// This function ensures that the calling of this function will succeed, no matter whether it's being done from a thread or not. If called from a thread that is not allowed to call the function, the call will become deferred. Otherwise, the call will go through directly.
    public final func callThreadSafe (method: StringName, _ arguments: Variant...)-> Variant {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_method = Variant (method)
        
        gi.object_method_bind_call_v (Node.method_call_thread_safe, UnsafeMutableRawPointer (mutating: handle), &_result, nil, &copy_method.content)
        return Variant (fromContentPtr: &_result)
        #else
        
        let copy_method = Variant (method)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_method.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            gi.object_method_bind_call (Node.method_call_thread_safe, UnsafeMutableRawPointer (mutating: handle), &_args, Int64 (_args.count), &_result, nil)
            return Variant (fromContentPtr: &_result)
        }
        
        #endif
    }
    
    fileprivate static var method_set_thread_safe: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_thread_safe")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3776071444)!
            }
            
        }
        
    }()
    
    /// Similar to ``callThreadSafe(method:)``, but for setting properties.
    public final func setThreadSafe (property: StringName, value: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Node.method_set_thread_safe, UnsafeMutableRawPointer (mutating: handle), nil, &property.content, &value.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &property.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &value.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Node.method_set_thread_safe, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_notify_thread_safe: GDExtensionMethodBindPtr = {
        let methodName = StringName ("notify_thread_safe")
        return withUnsafePointer (to: &Node.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Similar to ``callThreadSafe(method:)``, but for notifications.
    public final func notifyThreadSafe (what: Int32) {
        #if false
        
        var copy_what: Int = Int (what)
        
        gi.object_method_bind_ptrcall_v (Node.method_notify_thread_safe, UnsafeMutableRawPointer (mutating: handle), nil, &copy_what)
        
        #else
        
        var copy_what: Int = Int (what)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_what) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Node.method_notify_thread_safe, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_enter_tree":
                return _Node_proxy_enter_tree
            case "_exit_tree":
                return _Node_proxy_exit_tree
            case "_get_configuration_warnings":
                return _Node_proxy_get_configuration_warnings
            case "_input":
                return _Node_proxy_input
            case "_physics_process":
                return _Node_proxy_physics_process
            case "_process":
                return _Node_proxy_process
            case "_ready":
                return _Node_proxy_ready
            case "_shortcut_input":
                return _Node_proxy_shortcut_input
            case "_unhandled_input":
                return _Node_proxy_unhandled_input
            case "_unhandled_key_input":
                return _Node_proxy_unhandled_key_input
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Emitted when the node is ready. Comes after ``_ready()`` callback and follows the same rules.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.ready.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var ready: SimpleSignal { SimpleSignal (target: self, signalName: "ready") }
    
    /// Emitted when the node is renamed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.renamed.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var renamed: SimpleSignal { SimpleSignal (target: self, signalName: "renamed") }
    
    /// Emitted when the node enters the tree.
    /// 
    /// This signal is emitted _after_ the related ``notificationEnterTree`` notification.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.treeEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var treeEntered: SimpleSignal { SimpleSignal (target: self, signalName: "tree_entered") }
    
    /// Emitted when the node is still active but about to exit the tree. This is the right place for de-initialization (or a "destructor", if you will).
    /// 
    /// This signal is emitted _before_ the related ``notificationExitTree`` notification.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.treeExiting.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var treeExiting: SimpleSignal { SimpleSignal (target: self, signalName: "tree_exiting") }
    
    /// Emitted after the node exits the tree and is no longer active.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.treeExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var treeExited: SimpleSignal { SimpleSignal (target: self, signalName: "tree_exited") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a child node enters the scene tree, either because it entered on its own or because this node entered with it.
    /// 
    /// This signal is emitted _after_ the child node's own ``notificationEnterTree`` and [signal tree_entered].
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.childEnteredTree.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var childEnteredTree: Signal1 { Signal1 (target: self, signalName: "child_entered_tree") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a child node is about to exit the scene tree, either because it is being removed or freed directly, or because this node is exiting the tree.
    /// 
    /// When this signal is received, the child `node` is still in the tree and valid. This signal is emitted _after_ the child node's own [signal tree_exiting] and ``notificationExitTree``.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.childExitingTree.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var childExitingTree: Signal2 { Signal2 (target: self, signalName: "child_exiting_tree") }
    
    /// Emitted when the list of children is changed. This happens when child nodes are added, moved or removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.childOrderChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var childOrderChanged: SimpleSignal { SimpleSignal (target: self, signalName: "child_order_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when this node is being replaced by the `node`, see ``replaceBy(node:keepGroups:)``.
    /// 
    /// This signal is emitted _after_ `node` has been added as a child of the original parent node, but _before_ all original child nodes have been reparented to `node`.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.replacingBy.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var replacingBy: Signal3 { Signal3 (target: self, signalName: "replacing_by") }
    
}

// Support methods for proxies
func _Node_proxy_enter_tree (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._enterTree ()
}

func _Node_proxy_exit_tree (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._exitTree ()
}

func _Node_proxy_get_configuration_warnings (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getConfigurationWarnings ()
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedStringArray
    ret.content = PackedStringArray.zero
}

func _Node_proxy_input (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._input (event: lookupLiveObject (handleAddress: resolved_0) as? InputEvent ?? lookupObject (nativeHandle: resolved_0)!)
}

func _Node_proxy_physics_process (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._physicsProcess (delta: args [0]!.assumingMemoryBound (to: Double.self).pointee)
}

func _Node_proxy_process (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._process (delta: args [0]!.assumingMemoryBound (to: Double.self).pointee)
}

func _Node_proxy_ready (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._ready ()
}

func _Node_proxy_shortcut_input (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._shortcutInput (event: lookupLiveObject (handleAddress: resolved_0) as? InputEvent ?? lookupObject (nativeHandle: resolved_0)!)
}

func _Node_proxy_unhandled_input (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._unhandledInput (event: lookupLiveObject (handleAddress: resolved_0) as? InputEvent ?? lookupObject (nativeHandle: resolved_0)!)
}

func _Node_proxy_unhandled_key_input (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Node>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._unhandledKeyInput (event: lookupLiveObject (handleAddress: resolved_0) as? InputEvent ?? lookupObject (nativeHandle: resolved_0)!)
}

