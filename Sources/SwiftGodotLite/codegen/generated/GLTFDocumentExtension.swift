// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// ``GLTFDocument`` extension class.
/// 
/// Extends the functionality of the ``GLTFDocument`` class by allowing you to run arbitrary code at various stages of GLTF import or export.
/// 
/// To use, make a new class extending GLTFDocumentExtension, override any methods you need, make an instance of your class, and register it using ``GLTFDocument/registerGltfDocumentExtension(_:firstPriority:)``.
/// 
/// > Note: Like GLTFDocument itself, all GLTFDocumentExtension classes must be stateless in order to function properly. If you need to store data, use the `set_additional_data` and `get_additional_data` methods in ``GLTFState`` or ``GLTFNode``.
/// 
open class GLTFDocumentExtension: Resource {
    override open class var godotClassName: StringName { "GLTFDocumentExtension" }
    /* Methods */
    /// Part of the import process. This method is run first, before all other parts of the import process.
    /// 
    /// The return value is used to determine if this ``GLTFDocumentExtension`` instance should be used for importing a given GLTF file. If ``GodotError/ok``, the import will use this ``GLTFDocumentExtension`` instance. If not overridden, ``GodotError/ok`` is returned.
    /// 
    @_documentation(visibility: public)
    open func _importPreflight (state: GLTFState?, extensions: PackedStringArray)-> GodotError {
        return .ok
    }
    
    /// Part of the import process. This method is run after ``_importPreflight(state:extensions:)`` and before ``_parseNodeExtensions(state:gltfNode:extensions:)``.
    /// 
    /// Returns an array of the GLTF extensions supported by this GLTFDocumentExtension class. This is used to validate if a GLTF file with required extensions can be loaded.
    /// 
    @_documentation(visibility: public)
    open func _getSupportedExtensions ()-> PackedStringArray {
        return PackedStringArray ()
    }
    
    /// Part of the import process. This method is run after ``_getSupportedExtensions()`` and before ``_importPostParse(state:)``.
    /// 
    /// Runs when parsing the node extensions of a GLTFNode. This method can be used to process the extension JSON data into a format that can be used by ``_generateSceneNode(state:gltfNode:sceneParent:)``. The return value should be a member of the ``GodotError`` enum.
    /// 
    @_documentation(visibility: public)
    open func _parseNodeExtensions (state: GLTFState?, gltfNode: GLTFNode?, extensions: GDictionary)-> GodotError {
        return .ok
    }
    
    /// Part of the import process. This method is run after ``_parseNodeExtensions(state:gltfNode:extensions:)`` and before ``_parseTextureJson(state:textureJson:retGltfTexture:)``.
    /// 
    /// Runs when parsing image data from a GLTF file. The data could be sourced from a separate file, a URI, or a buffer, and then is passed as a byte array.
    /// 
    @_documentation(visibility: public)
    open func _parseImageData (state: GLTFState?, imageData: PackedByteArray, mimeType: String, retImage: Image?)-> GodotError {
        return .ok
    }
    
    /// Returns the file extension to use for saving image data into, for example, `".png"`. If defined, when this extension is used to handle images, and the images are saved to a separate file, the image bytes will be copied to a file with this extension. If this is set, there should be a ``ResourceImporter`` class able to import the file. If not defined or empty, Godot will save the image into a PNG file.
    @_documentation(visibility: public)
    open func _getImageFileExtension ()-> String {
        return String ()
    }
    
    /// Part of the import process. This method is run after ``_parseImageData(state:imageData:mimeType:retImage:)`` and before ``_generateSceneNode(state:gltfNode:sceneParent:)``.
    /// 
    /// Runs when parsing the texture JSON from the GLTF textures array. This can be used to set the source image index to use as the texture.
    /// 
    @_documentation(visibility: public)
    open func _parseTextureJson (state: GLTFState?, textureJson: GDictionary, retGltfTexture: GLTFTexture?)-> GodotError {
        return .ok
    }
    
    /// Part of the import process. This method is run after ``_importPostParse(state:)`` and before ``_importNode(state:gltfNode:json:node:)``.
    /// 
    /// Runs when generating a Godot scene node from a GLTFNode. The returned node will be added to the scene tree. Multiple nodes can be generated in this step if they are added as a child of the returned node.
    /// 
    /// > Note: The `sceneParent` parameter may be null if this is the single root node.
    /// 
    @_documentation(visibility: public)
    open func _generateSceneNode (state: GLTFState?, gltfNode: GLTFNode?, sceneParent: Node?)-> Node3D? {
        return Node3D ()
    }
    
    /// Part of the import process. This method is run after ``_parseNodeExtensions(state:gltfNode:extensions:)`` and before ``_generateSceneNode(state:gltfNode:sceneParent:)``.
    /// 
    /// This method can be used to modify any of the data imported so far, including any scene nodes, before running the final per-node import step.
    /// 
    @_documentation(visibility: public)
    open func _importPostParse (state: GLTFState?)-> GodotError {
        return .ok
    }
    
    /// Part of the import process. This method is run after ``_generateSceneNode(state:gltfNode:sceneParent:)`` and before ``_importPost(state:root:)``.
    /// 
    /// This method can be used to make modifications to each of the generated Godot scene nodes.
    /// 
    @_documentation(visibility: public)
    open func _importNode (state: GLTFState?, gltfNode: GLTFNode?, json: GDictionary, node: Node?)-> GodotError {
        return .ok
    }
    
    /// Part of the import process. This method is run last, after all other parts of the import process.
    /// 
    /// This method can be used to modify the final Godot scene generated by the import process.
    /// 
    @_documentation(visibility: public)
    open func _importPost (state: GLTFState?, root: Node?)-> GodotError {
        return .ok
    }
    
    /// Part of the export process. This method is run first, before all other parts of the export process.
    /// 
    /// The return value is used to determine if this ``GLTFDocumentExtension`` instance should be used for exporting a given GLTF file. If ``GodotError/ok``, the export will use this ``GLTFDocumentExtension`` instance. If not overridden, ``GodotError/ok`` is returned.
    /// 
    @_documentation(visibility: public)
    open func _exportPreflight (state: GLTFState?, root: Node?)-> GodotError {
        return .ok
    }
    
    /// Part of the export process. This method is run after ``_exportPreflight(state:root:)`` and before ``_exportPreserialize(state:)``.
    /// 
    /// Runs when converting the data from a Godot scene node. This method can be used to process the Godot scene node data into a format that can be used by ``_exportNode(state:gltfNode:json:node:)``.
    /// 
    @_documentation(visibility: public)
    open func _convertSceneNode (state: GLTFState?, gltfNode: GLTFNode?, sceneNode: Node?) {
    }
    
    /// Part of the export process. This method is run after ``_convertSceneNode(state:gltfNode:sceneNode:)`` and before ``_getSaveableImageFormats()``.
    /// 
    /// This method can be used to alter the state before performing serialization. It runs every time when generating a buffer with ``GLTFDocument/generateBuffer(state:)`` or writing to the file system with ``GLTFDocument/writeToFilesystem(state:path:)``.
    /// 
    @_documentation(visibility: public)
    open func _exportPreserialize (state: GLTFState?)-> GodotError {
        return .ok
    }
    
    /// Part of the export process. This method is run after ``_convertSceneNode(state:gltfNode:sceneNode:)`` and before ``_exportNode(state:gltfNode:json:node:)``.
    /// 
    /// Returns an array of the image formats that can be saved/exported by this extension. This extension will only be selected as the image exporter if the ``GLTFDocument``'s ``GLTFDocument/imageFormat`` is in this array. If this ``GLTFDocumentExtension`` is selected as the image exporter, one of the ``_saveImageAtPath(state:image:filePath:imageFormat:lossyQuality:)`` or ``_serializeImageToBytes(state:image:imageDict:imageFormat:lossyQuality:)`` methods will run next, otherwise ``_exportNode(state:gltfNode:json:node:)`` will run next. If the format name contains `"Lossy"`, the lossy quality slider will be displayed.
    /// 
    @_documentation(visibility: public)
    open func _getSaveableImageFormats ()-> PackedStringArray {
        return PackedStringArray ()
    }
    
    /// Part of the export process. This method is run after ``_getSaveableImageFormats()`` and before ``_serializeTextureJson(state:textureJson:gltfTexture:imageFormat:)``.
    /// 
    /// This method is run when embedding images in the GLTF file. When images are saved separately, ``_saveImageAtPath(state:image:filePath:imageFormat:lossyQuality:)`` runs instead. Note that these methods only run when this ``GLTFDocumentExtension`` is selected as the image exporter.
    /// 
    /// This method must set the image MIME type in the `imageDict` with the `"mimeType"` key. For example, for a PNG image, it would be set to `"image/png"`. The return value must be a ``PackedByteArray`` containing the image data.
    /// 
    @_documentation(visibility: public)
    open func _serializeImageToBytes (state: GLTFState?, image: Image?, imageDict: GDictionary, imageFormat: String, lossyQuality: Double)-> PackedByteArray {
        return PackedByteArray ()
    }
    
    /// Part of the export process. This method is run after ``_getSaveableImageFormats()`` and before ``_serializeTextureJson(state:textureJson:gltfTexture:imageFormat:)``.
    /// 
    /// This method is run when saving images separately from the GLTF file. When images are embedded, ``_serializeImageToBytes(state:image:imageDict:imageFormat:lossyQuality:)`` runs instead. Note that these methods only run when this ``GLTFDocumentExtension`` is selected as the image exporter.
    /// 
    @_documentation(visibility: public)
    open func _saveImageAtPath (state: GLTFState?, image: Image?, filePath: String, imageFormat: String, lossyQuality: Double)-> GodotError {
        return .ok
    }
    
    /// Part of the export process. This method is run after ``_saveImageAtPath(state:image:filePath:imageFormat:lossyQuality:)`` or ``_serializeImageToBytes(state:image:imageDict:imageFormat:lossyQuality:)``, and before ``_exportNode(state:gltfNode:json:node:)``. Note that this method only runs when this ``GLTFDocumentExtension`` is selected as the image exporter.
    /// 
    /// This method can be used to set up the extensions for the texture JSON by editing `textureJson`. The extension must also be added as used extension with ``GLTFState/addUsedExtension(extensionName:required:)``, be sure to set `required` to `true` if you are not providing a fallback.
    /// 
    @_documentation(visibility: public)
    open func _serializeTextureJson (state: GLTFState?, textureJson: GDictionary, gltfTexture: GLTFTexture?, imageFormat: String)-> GodotError {
        return .ok
    }
    
    /// Part of the export process. This method is run after ``_getSaveableImageFormats()`` and before ``_exportPost(state:)``. If this ``GLTFDocumentExtension`` is used for exporting images, this runs after ``_serializeTextureJson(state:textureJson:gltfTexture:imageFormat:)``.
    /// 
    /// This method can be used to modify the final JSON of each node.
    /// 
    @_documentation(visibility: public)
    open func _exportNode (state: GLTFState?, gltfNode: GLTFNode?, json: GDictionary, node: Node?)-> GodotError {
        return .ok
    }
    
    /// Part of the export process. This method is run last, after all other parts of the export process.
    /// 
    /// This method can be used to modify the final JSON of the generated GLTF file.
    /// 
    @_documentation(visibility: public)
    open func _exportPost (state: GLTFState?)-> GodotError {
        return .ok
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_convert_scene_node":
                return _GLTFDocumentExtension_proxy_convert_scene_node
            case "_export_node":
                return _GLTFDocumentExtension_proxy_export_node
            case "_export_post":
                return _GLTFDocumentExtension_proxy_export_post
            case "_export_preflight":
                return _GLTFDocumentExtension_proxy_export_preflight
            case "_export_preserialize":
                return _GLTFDocumentExtension_proxy_export_preserialize
            case "_generate_scene_node":
                return _GLTFDocumentExtension_proxy_generate_scene_node
            case "_get_image_file_extension":
                return _GLTFDocumentExtension_proxy_get_image_file_extension
            case "_get_saveable_image_formats":
                return _GLTFDocumentExtension_proxy_get_saveable_image_formats
            case "_get_supported_extensions":
                return _GLTFDocumentExtension_proxy_get_supported_extensions
            case "_import_node":
                return _GLTFDocumentExtension_proxy_import_node
            case "_import_post":
                return _GLTFDocumentExtension_proxy_import_post
            case "_import_post_parse":
                return _GLTFDocumentExtension_proxy_import_post_parse
            case "_import_preflight":
                return _GLTFDocumentExtension_proxy_import_preflight
            case "_parse_image_data":
                return _GLTFDocumentExtension_proxy_parse_image_data
            case "_parse_node_extensions":
                return _GLTFDocumentExtension_proxy_parse_node_extensions
            case "_parse_texture_json":
                return _GLTFDocumentExtension_proxy_parse_texture_json
            case "_save_image_at_path":
                return _GLTFDocumentExtension_proxy_save_image_at_path
            case "_serialize_image_to_bytes":
                return _GLTFDocumentExtension_proxy_serialize_image_to_bytes
            case "_serialize_texture_json":
                return _GLTFDocumentExtension_proxy_serialize_texture_json
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
}

// Support methods for proxies
func _GLTFDocumentExtension_proxy_convert_scene_node (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    let resolved_2 = args [2]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._convertSceneNode (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, gltfNode: lookupLiveObject (handleAddress: resolved_1) as? GLTFNode ?? lookupObject (nativeHandle: resolved_1)!, sceneNode: lookupLiveObject (handleAddress: resolved_2) as? Node ?? lookupObject (nativeHandle: resolved_2)!)
}

func _GLTFDocumentExtension_proxy_export_node (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    let resolved_3 = args [3]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._exportNode (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, gltfNode: lookupLiveObject (handleAddress: resolved_1) as? GLTFNode ?? lookupObject (nativeHandle: resolved_1)!, json: GDictionary (content: args [2]!.assumingMemoryBound (to: Int64.self).pointee), node: lookupLiveObject (handleAddress: resolved_3) as? Node ?? lookupObject (nativeHandle: resolved_3)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_export_post (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._exportPost (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_export_preflight (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._exportPreflight (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, root: lookupLiveObject (handleAddress: resolved_1) as? Node ?? lookupObject (nativeHandle: resolved_1)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_export_preserialize (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._exportPreserialize (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_generate_scene_node (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    let resolved_2 = args [2]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._generateSceneNode (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, gltfNode: lookupLiveObject (handleAddress: resolved_1) as? GLTFNode ?? lookupObject (nativeHandle: resolved_1)!, sceneParent: lookupLiveObject (handleAddress: resolved_2) as? Node ?? lookupObject (nativeHandle: resolved_2)!)
    retPtr!.storeBytes (of: ret?.handle, as: UnsafeRawPointer?.self) // Node3D
}

func _GLTFDocumentExtension_proxy_get_image_file_extension (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let ret = GString (swiftObject._getImageFileExtension ())
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _GLTFDocumentExtension_proxy_get_saveable_image_formats (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getSaveableImageFormats ()
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedStringArray
    ret.content = PackedStringArray.zero
}

func _GLTFDocumentExtension_proxy_get_supported_extensions (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getSupportedExtensions ()
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedStringArray
    ret.content = PackedStringArray.zero
}

func _GLTFDocumentExtension_proxy_import_node (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    let resolved_3 = args [3]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._importNode (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, gltfNode: lookupLiveObject (handleAddress: resolved_1) as? GLTFNode ?? lookupObject (nativeHandle: resolved_1)!, json: GDictionary (content: args [2]!.assumingMemoryBound (to: Int64.self).pointee), node: lookupLiveObject (handleAddress: resolved_3) as? Node ?? lookupObject (nativeHandle: resolved_3)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_import_post (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._importPost (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, root: lookupLiveObject (handleAddress: resolved_1) as? Node ?? lookupObject (nativeHandle: resolved_1)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_import_post_parse (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._importPostParse (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_import_preflight (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._importPreflight (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, extensions: PackedStringArray (content: args [1]!.assumingMemoryBound (to: (Int64, Int64).self).pointee))
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_parse_image_data (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_3 = args [3]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._parseImageData (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, imageData: PackedByteArray (content: args [1]!.assumingMemoryBound (to: (Int64, Int64).self).pointee), mimeType: GString.stringFromGStringPtr (ptr: args [2]!) ?? "", retImage: lookupLiveObject (handleAddress: resolved_3) as? Image ?? lookupObject (nativeHandle: resolved_3)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_parse_node_extensions (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._parseNodeExtensions (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, gltfNode: lookupLiveObject (handleAddress: resolved_1) as? GLTFNode ?? lookupObject (nativeHandle: resolved_1)!, extensions: GDictionary (content: args [2]!.assumingMemoryBound (to: Int64.self).pointee))
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_parse_texture_json (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_2 = args [2]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._parseTextureJson (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, textureJson: GDictionary (content: args [1]!.assumingMemoryBound (to: Int64.self).pointee), retGltfTexture: lookupLiveObject (handleAddress: resolved_2) as? GLTFTexture ?? lookupObject (nativeHandle: resolved_2)!)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_save_image_at_path (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._saveImageAtPath (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, image: lookupLiveObject (handleAddress: resolved_1) as? Image ?? lookupObject (nativeHandle: resolved_1)!, filePath: GString.stringFromGStringPtr (ptr: args [2]!) ?? "", imageFormat: GString.stringFromGStringPtr (ptr: args [3]!) ?? "", lossyQuality: args [4]!.assumingMemoryBound (to: Double.self).pointee)
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

func _GLTFDocumentExtension_proxy_serialize_image_to_bytes (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._serializeImageToBytes (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, image: lookupLiveObject (handleAddress: resolved_1) as? Image ?? lookupObject (nativeHandle: resolved_1)!, imageDict: GDictionary (content: args [2]!.assumingMemoryBound (to: Int64.self).pointee), imageFormat: GString.stringFromGStringPtr (ptr: args [3]!) ?? "", lossyQuality: args [4]!.assumingMemoryBound (to: Double.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedByteArray
    ret.content = PackedByteArray.zero
}

func _GLTFDocumentExtension_proxy_serialize_texture_json (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GLTFDocumentExtension>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_2 = args [2]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._serializeTextureJson (state: lookupLiveObject (handleAddress: resolved_0) as? GLTFState ?? lookupObject (nativeHandle: resolved_0)!, textureJson: GDictionary (content: args [1]!.assumingMemoryBound (to: Int64.self).pointee), gltfTexture: lookupLiveObject (handleAddress: resolved_2) as? GLTFTexture ?? lookupObject (nativeHandle: resolved_2)!, imageFormat: GString.stringFromGStringPtr (ptr: args [3]!) ?? "")
    retPtr!.storeBytes (of: Int32 (ret.rawValue), as: Int32.self)
}

