// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// An editor for graph-like structures, using ``GraphNode``s.
/// 
/// ``GraphEdit`` provides tools for creation, manipulation, and display of various graphs. Its main purpose in the engine is to power the visual programming systems, such as visual shaders, but it is also available for use in user projects.
/// 
/// ``GraphEdit`` by itself is only an empty container, representing an infinite grid where ``GraphNode``s can be placed. Each ``GraphNode`` represents a node in the graph, a single unit of data in the connected scheme. ``GraphEdit``, in turn, helps to control various interactions with nodes and between nodes. When the user attempts to connect, disconnect, or delete a ``GraphNode``, a signal is emitted in the ``GraphEdit``, but no action is taken by default. It is the responsibility of the programmer utilizing this control to implement the necessary logic to determine how each request should be handled.
/// 
/// **Performance:** It is greatly advised to enable low-processor usage mode (see ``OS/lowProcessorUsageMode``) when using GraphEdits.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``connectionRequest``
/// - ``disconnectionRequest``
/// - ``connectionToEmpty``
/// - ``connectionFromEmpty``
/// - ``connectionDragStarted``
/// - ``connectionDragEnded``
/// - ``copyNodesRequest``
/// - ``pasteNodesRequest``
/// - ``duplicateNodesRequest``
/// - ``deleteNodesRequest``
/// - ``nodeSelected``
/// - ``nodeDeselected``
/// - ``popupRequest``
/// - ``beginNodeMove``
/// - ``endNodeMove``
/// - ``scrollOffsetChanged``
open class GraphEdit: Control {
    override open class var godotClassName: StringName { "GraphEdit" }
    public enum PanningScheme: Int64 {
        /// [kbd]Mouse Wheel[/kbd] will zoom, [kbd]Ctrl + Mouse Wheel[/kbd] will move the view.
        case zooms = 0 // SCROLL_ZOOMS
        /// [kbd]Mouse Wheel[/kbd] will move the view, [kbd]Ctrl + Mouse Wheel[/kbd] will zoom.
        case pans = 1 // SCROLL_PANS
    }
    
    
    /* Properties */
    
    /// The scroll offset.
    final public var scrollOffset: Vector2 {
        get {
            return get_scroll_offset ()
        }
        
        set {
            set_scroll_offset (newValue)
        }
        
    }
    
    /// If `true`, the grid is visible.
    final public var showGrid: Bool {
        get {
            return is_showing_grid ()
        }
        
        set {
            set_show_grid (newValue)
        }
        
    }
    
    /// If `true`, enables snapping.
    final public var snappingEnabled: Bool {
        get {
            return is_snapping_enabled ()
        }
        
        set {
            set_snapping_enabled (newValue)
        }
        
    }
    
    /// The snapping distance in pixels, also determines the grid line distance.
    final public var snappingDistance: Int32 {
        get {
            return get_snapping_distance ()
        }
        
        set {
            set_snapping_distance (newValue)
        }
        
    }
    
    /// Defines the control scheme for panning with mouse wheel.
    final public var panningScheme: GraphEdit.PanningScheme {
        get {
            return get_panning_scheme ()
        }
        
        set {
            set_panning_scheme (newValue)
        }
        
    }
    
    /// If `true`, enables disconnection of existing connections in the GraphEdit by dragging the right end.
    final public var rightDisconnects: Bool {
        get {
            return is_right_disconnects_enabled ()
        }
        
        set {
            set_right_disconnects (newValue)
        }
        
    }
    
    /// The curvature of the lines between the nodes. 0 results in straight lines.
    final public var connectionLinesCurvature: Double {
        get {
            return get_connection_lines_curvature ()
        }
        
        set {
            set_connection_lines_curvature (newValue)
        }
        
    }
    
    /// The thickness of the lines between the nodes.
    final public var connectionLinesThickness: Double {
        get {
            return get_connection_lines_thickness ()
        }
        
        set {
            set_connection_lines_thickness (newValue)
        }
        
    }
    
    /// If `true`, the lines between nodes will use antialiasing.
    final public var connectionLinesAntialiased: Bool {
        get {
            return is_connection_lines_antialiased ()
        }
        
        set {
            set_connection_lines_antialiased (newValue)
        }
        
    }
    
    /// The current zoom value.
    final public var zoom: Double {
        get {
            return get_zoom ()
        }
        
        set {
            set_zoom (newValue)
        }
        
    }
    
    /// The lower zoom limit.
    final public var zoomMin: Double {
        get {
            return get_zoom_min ()
        }
        
        set {
            set_zoom_min (newValue)
        }
        
    }
    
    /// The upper zoom limit.
    final public var zoomMax: Double {
        get {
            return get_zoom_max ()
        }
        
        set {
            set_zoom_max (newValue)
        }
        
    }
    
    /// The step of each zoom level.
    final public var zoomStep: Double {
        get {
            return get_zoom_step ()
        }
        
        set {
            set_zoom_step (newValue)
        }
        
    }
    
    /// If `true`, the minimap is visible.
    final public var minimapEnabled: Bool {
        get {
            return is_minimap_enabled ()
        }
        
        set {
            set_minimap_enabled (newValue)
        }
        
    }
    
    /// The size of the minimap rectangle. The map itself is based on the size of the grid area and is scaled to fit this rectangle.
    final public var minimapSize: Vector2 {
        get {
            return get_minimap_size ()
        }
        
        set {
            set_minimap_size (newValue)
        }
        
    }
    
    /// The opacity of the minimap rectangle.
    final public var minimapOpacity: Double {
        get {
            return get_minimap_opacity ()
        }
        
        set {
            set_minimap_opacity (newValue)
        }
        
    }
    
    /// If `true`, the menu toolbar is visible.
    final public var showMenu: Bool {
        get {
            return is_showing_menu ()
        }
        
        set {
            set_show_menu (newValue)
        }
        
    }
    
    /// If `true`, the label with the current zoom level is visible. The zoom level is displayed in percents.
    final public var showZoomLabel: Bool {
        get {
            return is_showing_zoom_label ()
        }
        
        set {
            set_show_zoom_label (newValue)
        }
        
    }
    
    /// If `true`, buttons that allow to change and reset the zoom level are visible.
    final public var showZoomButtons: Bool {
        get {
            return is_showing_zoom_buttons ()
        }
        
        set {
            set_show_zoom_buttons (newValue)
        }
        
    }
    
    /// If `true`, buttons that allow to configure grid and snapping options are visible.
    final public var showGridButtons: Bool {
        get {
            return is_showing_grid_buttons ()
        }
        
        set {
            set_show_grid_buttons (newValue)
        }
        
    }
    
    /// If `true`, the button to toggle the minimap is visible.
    final public var showMinimapButton: Bool {
        get {
            return is_showing_minimap_button ()
        }
        
        set {
            set_show_minimap_button (newValue)
        }
        
    }
    
    /// If `true`, the button to automatically arrange graph nodes is visible.
    final public var showArrangeButton: Bool {
        get {
            return is_showing_arrange_button ()
        }
        
        set {
            set_show_arrange_button (newValue)
        }
        
    }
    
    /* Methods */
    /// Returns whether the `mousePosition` is in the input hot zone.
    /// 
    /// By default, a hot zone is a ``Rect2`` positioned such that its center is at `inNode`.``GraphNode/getInputPortPosition(portIdx:)``(`inPort`) (For output's case, call ``GraphNode/getOutputPortPosition(portIdx:)`` instead). The hot zone's width is twice the Theme Property `port_grab_distance_horizontal`, and its height is twice the `port_grab_distance_vertical`.
    /// 
    /// Below is a sample code to help get started:
    /// 
    @_documentation(visibility: public)
    open func _isInInputHotzone (inNode: Object?, inPort: Int32, mousePosition: Vector2)-> Bool {
        return false
    }
    
    /// Returns whether the `mousePosition` is in the output hot zone. For more information on hot zones, see ``_isInInputHotzone(inNode:inPort:mousePosition:)``.
    /// 
    /// Below is a sample code to help get started:
    /// 
    @_documentation(visibility: public)
    open func _isInOutputHotzone (inNode: Object?, inPort: Int32, mousePosition: Vector2)-> Bool {
        return false
    }
    
    /// Virtual method which can be overridden to customize how connections are drawn.
    @_documentation(visibility: public)
    open func _getConnectionLine (fromPosition: Vector2, toPosition: Vector2)-> PackedVector2Array {
        return PackedVector2Array ()
    }
    
    /// This virtual method can be used to insert additional error detection while the user is dragging a connection over a valid port.
    /// 
    /// Return `true` if the connection is indeed valid or return `false` if the connection is impossible. If the connection is impossible, no snapping to the port and thus no connection request to that port will happen.
    /// 
    /// In this example a connection to same node is suppressed:
    /// 
    @_documentation(visibility: public)
    open func _isNodeHoverValid (fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32)-> Bool {
        return false
    }
    
    fileprivate static var method_connect_node: GDExtensionMethodBindPtr = {
        let methodName = StringName ("connect_node")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 195065850)!
            }
            
        }
        
    }()
    
    /// Create a connection between the `fromPort` of the `fromNode` ``GraphNode`` and the `toPort` of the `toNode` ``GraphNode``. If the connection already exists, no connection is created.
    public final func connectNode (fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_from_port: Int = Int (fromPort)
        var copy_to_port: Int = Int (toPort)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_connect_node, UnsafeMutableRawPointer (mutating: handle), &_result, &fromNode.content, &copy_from_port, &toNode.content, &copy_to_port)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_from_port: Int = Int (fromPort)
        var copy_to_port: Int = Int (toPort)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fromNode.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_from_port) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &toNode.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_to_port) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (GraphEdit.method_connect_node, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return GodotError (rawValue: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_node_connected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_node_connected")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4216241294)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the `fromPort` of the `fromNode` ``GraphNode`` is connected to the `toPort` of the `toNode` ``GraphNode``.
    public final func isNodeConnected (fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_from_port: Int = Int (fromPort)
        var copy_to_port: Int = Int (toPort)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_is_node_connected, UnsafeMutableRawPointer (mutating: handle), &_result, &fromNode.content, &copy_from_port, &toNode.content, &copy_to_port)
        return _result
        #else
        
        var copy_from_port: Int = Int (fromPort)
        var copy_to_port: Int = Int (toPort)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fromNode.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_from_port) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &toNode.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_to_port) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (GraphEdit.method_is_node_connected, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_disconnect_node: GDExtensionMethodBindPtr = {
        let methodName = StringName ("disconnect_node")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1933654315)!
            }
            
        }
        
    }()
    
    /// Removes the connection between the `fromPort` of the `fromNode` ``GraphNode`` and the `toPort` of the `toNode` ``GraphNode``. If the connection does not exist, no connection is removed.
    public final func disconnectNode (fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32) {
        #if true
        
        var copy_from_port: Int = Int (fromPort)
        var copy_to_port: Int = Int (toPort)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_disconnect_node, UnsafeMutableRawPointer (mutating: handle), nil, &fromNode.content, &copy_from_port, &toNode.content, &copy_to_port)
        
        #else
        
        var copy_from_port: Int = Int (fromPort)
        var copy_to_port: Int = Int (toPort)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fromNode.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_from_port) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &toNode.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_to_port) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (GraphEdit.method_disconnect_node, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_connection_activity: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_connection_activity")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1141899943)!
            }
            
        }
        
    }()
    
    /// Sets the coloration of the connection between `fromNode`'s `fromPort` and `toNode`'s `toPort` with the color provided in the [theme_item activity] theme property. The color is linearly interpolated between the connection color and the activity color using `amount` as weight.
    public final func setConnectionActivity (fromNode: StringName, fromPort: Int32, toNode: StringName, toPort: Int32, amount: Double) {
        #if true
        
        var copy_from_port: Int = Int (fromPort)
        var copy_to_port: Int = Int (toPort)
        var copy_amount = amount
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_connection_activity, UnsafeMutableRawPointer (mutating: handle), nil, &fromNode.content, &copy_from_port, &toNode.content, &copy_to_port, &copy_amount)
        
        #else
        
        var copy_from_port: Int = Int (fromPort)
        var copy_to_port: Int = Int (toPort)
        var copy_amount = amount
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fromNode.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_from_port) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &toNode.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_to_port) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_amount) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (GraphEdit.method_set_connection_activity, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_connection_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_connection_list")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns an Array containing the list of connections. A connection consists in a structure of the form `{ from_port: 0, from: "GraphNode name 0", to_port: 1, to: "GraphNode name 1" }`.
    public final func getConnectionList ()-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_connection_list, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_clear_connections: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_connections")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all connections between nodes.
    public final func clearConnections () {
        gi.object_method_bind_ptrcall (GraphEdit.method_clear_connections, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_force_connection_drag_end: GDExtensionMethodBindPtr = {
        let methodName = StringName ("force_connection_drag_end")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Ends the creation of the current connection. In other words, if you are dragging a connection you can use this method to abort the process and remove the line that followed your cursor.
    /// 
    /// This is best used together with [signal connection_drag_started] and [signal connection_drag_ended] to add custom behavior like node addition through shortcuts.
    /// 
    /// > Note: This method suppresses any other connection request signals apart from [signal connection_drag_ended].
    /// 
    public final func forceConnectionDragEnd () {
        gi.object_method_bind_ptrcall (GraphEdit.method_force_connection_drag_end, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_scroll_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scroll_offset")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scroll_offset ()-> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall (GraphEdit.method_get_scroll_offset, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scroll_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scroll_offset")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scroll_offset (_ offset: Vector2) {
        #if true
        
        var copy_offset = offset
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_scroll_offset, UnsafeMutableRawPointer (mutating: handle), nil, &copy_offset)
        
        #else
        
        var copy_offset = offset
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_offset) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_scroll_offset, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_valid_right_disconnect_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_valid_right_disconnect_type")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Allows to disconnect nodes when dragging from the right port of the ``GraphNode``'s slot if it has the specified type. See also ``removeValidRightDisconnectType(_:)``.
    public final func addValidRightDisconnectType (_ type: Int32) {
        #if true
        
        var copy_type: Int = Int (type)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_add_valid_right_disconnect_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_type)
        
        #else
        
        var copy_type: Int = Int (type)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_add_valid_right_disconnect_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_valid_right_disconnect_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_valid_right_disconnect_type")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Disallows to disconnect nodes when dragging from the right port of the ``GraphNode``'s slot if it has the specified type. Use this to disable disconnection previously allowed with ``addValidRightDisconnectType(_:)``.
    public final func removeValidRightDisconnectType (_ type: Int32) {
        #if true
        
        var copy_type: Int = Int (type)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_remove_valid_right_disconnect_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_type)
        
        #else
        
        var copy_type: Int = Int (type)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_remove_valid_right_disconnect_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_valid_left_disconnect_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_valid_left_disconnect_type")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Allows to disconnect nodes when dragging from the left port of the ``GraphNode``'s slot if it has the specified type. See also ``removeValidLeftDisconnectType(_:)``.
    public final func addValidLeftDisconnectType (_ type: Int32) {
        #if true
        
        var copy_type: Int = Int (type)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_add_valid_left_disconnect_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_type)
        
        #else
        
        var copy_type: Int = Int (type)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_add_valid_left_disconnect_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_valid_left_disconnect_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_valid_left_disconnect_type")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Disallows to disconnect nodes when dragging from the left port of the ``GraphNode``'s slot if it has the specified type. Use this to disable disconnection previously allowed with ``addValidLeftDisconnectType(_:)``.
    public final func removeValidLeftDisconnectType (_ type: Int32) {
        #if true
        
        var copy_type: Int = Int (type)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_remove_valid_left_disconnect_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_type)
        
        #else
        
        var copy_type: Int = Int (type)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_remove_valid_left_disconnect_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_valid_connection_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_valid_connection_type")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Allows the connection between two different port types. The port type is defined individually for the left and the right port of each slot with the ``GraphNode/setSlot(slotIndex:enableLeftPort:typeLeft:colorLeft:enableRightPort:typeRight:colorRight:customIconLeft:customIconRight:drawStylebox:)`` method.
    /// 
    /// See also ``isValidConnectionType(fromType:toType:)`` and ``removeValidConnectionType(fromType:toType:)``.
    /// 
    public final func addValidConnectionType (fromType: Int32, toType: Int32) {
        #if true
        
        var copy_from_type: Int = Int (fromType)
        var copy_to_type: Int = Int (toType)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_add_valid_connection_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_type, &copy_to_type)
        
        #else
        
        var copy_from_type: Int = Int (fromType)
        var copy_to_type: Int = Int (toType)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from_type) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to_type) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (GraphEdit.method_add_valid_connection_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_valid_connection_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_valid_connection_type")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Disallows the connection between two different port types previously allowed by ``addValidConnectionType(fromType:toType:)``. The port type is defined individually for the left and the right port of each slot with the ``GraphNode/setSlot(slotIndex:enableLeftPort:typeLeft:colorLeft:enableRightPort:typeRight:colorRight:customIconLeft:customIconRight:drawStylebox:)`` method.
    /// 
    /// See also ``isValidConnectionType(fromType:toType:)``.
    /// 
    public final func removeValidConnectionType (fromType: Int32, toType: Int32) {
        #if true
        
        var copy_from_type: Int = Int (fromType)
        var copy_to_type: Int = Int (toType)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_remove_valid_connection_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_type, &copy_to_type)
        
        #else
        
        var copy_from_type: Int = Int (fromType)
        var copy_to_type: Int = Int (toType)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from_type) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to_type) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (GraphEdit.method_remove_valid_connection_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_valid_connection_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_valid_connection_type")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2522259332)!
            }
            
        }
        
    }()
    
    /// Returns whether it's possible to make a connection between two different port types. The port type is defined individually for the left and the right port of each slot with the ``GraphNode/setSlot(slotIndex:enableLeftPort:typeLeft:colorLeft:enableRightPort:typeRight:colorRight:customIconLeft:customIconRight:drawStylebox:)`` method.
    /// 
    /// See also ``addValidConnectionType(fromType:toType:)`` and ``removeValidConnectionType(fromType:toType:)``.
    /// 
    public final func isValidConnectionType (fromType: Int32, toType: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_from_type: Int = Int (fromType)
        var copy_to_type: Int = Int (toType)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_is_valid_connection_type, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_from_type, &copy_to_type)
        return _result
        #else
        
        var copy_from_type: Int = Int (fromType)
        var copy_to_type: Int = Int (toType)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from_type) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to_type) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (GraphEdit.method_is_valid_connection_type, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_connection_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_connection_line")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1562168077)!
            }
            
        }
        
    }()
    
    /// Returns the points which would make up a connection between `fromNode` and `toNode`.
    public final func getConnectionLine (fromNode: Vector2, toNode: Vector2)-> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        #if true
        
        var copy_from_node = fromNode
        var copy_to_node = toNode
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_get_connection_line, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_from_node, &copy_to_node)
        return _result
        #else
        
        var copy_from_node = fromNode
        var copy_to_node = toNode
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from_node) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to_node) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (GraphEdit.method_get_connection_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_panning_scheme: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_panning_scheme")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 18893313)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_panning_scheme (_ scheme: GraphEdit.PanningScheme) {
        #if true
        
        var copy_scheme = Int64 (scheme.rawValue)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_panning_scheme, UnsafeMutableRawPointer (mutating: handle), nil, &copy_scheme)
        
        #else
        
        var copy_scheme = Int64 (scheme.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_scheme) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_panning_scheme, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_panning_scheme: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_panning_scheme")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 549924446)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_panning_scheme ()-> GraphEdit.PanningScheme {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (GraphEdit.method_get_panning_scheme, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return GraphEdit.PanningScheme (rawValue: _result)!
    }
    
    fileprivate static var method_set_zoom: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_zoom")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_zoom (_ zoom: Double) {
        #if true
        
        var copy_zoom = zoom
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_zoom, UnsafeMutableRawPointer (mutating: handle), nil, &copy_zoom)
        
        #else
        
        var copy_zoom = zoom
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_zoom) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_zoom, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_zoom: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_zoom")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_zoom ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_zoom, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_zoom_min: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_zoom_min")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_zoom_min (_ zoomMin: Double) {
        #if true
        
        var copy_zoom_min = zoomMin
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_zoom_min, UnsafeMutableRawPointer (mutating: handle), nil, &copy_zoom_min)
        
        #else
        
        var copy_zoom_min = zoomMin
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_zoom_min) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_zoom_min, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_zoom_min: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_zoom_min")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_zoom_min ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_zoom_min, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_zoom_max: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_zoom_max")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_zoom_max (_ zoomMax: Double) {
        #if true
        
        var copy_zoom_max = zoomMax
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_zoom_max, UnsafeMutableRawPointer (mutating: handle), nil, &copy_zoom_max)
        
        #else
        
        var copy_zoom_max = zoomMax
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_zoom_max) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_zoom_max, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_zoom_max: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_zoom_max")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_zoom_max ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_zoom_max, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_zoom_step: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_zoom_step")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_zoom_step (_ zoomStep: Double) {
        #if true
        
        var copy_zoom_step = zoomStep
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_zoom_step, UnsafeMutableRawPointer (mutating: handle), nil, &copy_zoom_step)
        
        #else
        
        var copy_zoom_step = zoomStep
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_zoom_step) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_zoom_step, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_zoom_step: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_zoom_step")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_zoom_step ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_zoom_step, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_grid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_show_grid")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_grid (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_show_grid, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_show_grid, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_showing_grid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_showing_grid")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_grid ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_showing_grid, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snapping_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_snapping_enabled")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snapping_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_snapping_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_snapping_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_snapping_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_snapping_enabled")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_snapping_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_snapping_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snapping_distance: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_snapping_distance")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snapping_distance (_ pixels: Int32) {
        #if true
        
        var copy_pixels: Int = Int (pixels)
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_snapping_distance, UnsafeMutableRawPointer (mutating: handle), nil, &copy_pixels)
        
        #else
        
        var copy_pixels: Int = Int (pixels)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_pixels) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_snapping_distance, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_snapping_distance: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_snapping_distance")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_snapping_distance ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_snapping_distance, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_connection_lines_curvature: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_connection_lines_curvature")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_connection_lines_curvature (_ curvature: Double) {
        #if true
        
        var copy_curvature = curvature
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_connection_lines_curvature, UnsafeMutableRawPointer (mutating: handle), nil, &copy_curvature)
        
        #else
        
        var copy_curvature = curvature
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_curvature) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_connection_lines_curvature, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_connection_lines_curvature: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_connection_lines_curvature")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_connection_lines_curvature ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_connection_lines_curvature, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_connection_lines_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_connection_lines_thickness")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_connection_lines_thickness (_ pixels: Double) {
        #if true
        
        var copy_pixels = pixels
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_connection_lines_thickness, UnsafeMutableRawPointer (mutating: handle), nil, &copy_pixels)
        
        #else
        
        var copy_pixels = pixels
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_pixels) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_connection_lines_thickness, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_connection_lines_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_connection_lines_thickness")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_connection_lines_thickness ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_connection_lines_thickness, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_connection_lines_antialiased: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_connection_lines_antialiased")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_connection_lines_antialiased (_ pixels: Bool) {
        #if true
        
        var copy_pixels = pixels
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_connection_lines_antialiased, UnsafeMutableRawPointer (mutating: handle), nil, &copy_pixels)
        
        #else
        
        var copy_pixels = pixels
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_pixels) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_connection_lines_antialiased, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_connection_lines_antialiased: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_connection_lines_antialiased")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_connection_lines_antialiased ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_connection_lines_antialiased, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_minimap_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_minimap_size")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_minimap_size (_ size: Vector2) {
        #if true
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_minimap_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_minimap_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_minimap_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_minimap_size")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_minimap_size ()-> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall (GraphEdit.method_get_minimap_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_minimap_opacity: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_minimap_opacity")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_minimap_opacity (_ opacity: Double) {
        #if true
        
        var copy_opacity = opacity
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_minimap_opacity, UnsafeMutableRawPointer (mutating: handle), nil, &copy_opacity)
        
        #else
        
        var copy_opacity = opacity
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_opacity) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_minimap_opacity, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_minimap_opacity: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_minimap_opacity")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_minimap_opacity ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (GraphEdit.method_get_minimap_opacity, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_minimap_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_minimap_enabled")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_minimap_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_minimap_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_minimap_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_minimap_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_minimap_enabled")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_minimap_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_minimap_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_show_menu")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_menu (_ hidden: Bool) {
        #if true
        
        var copy_hidden = hidden
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_show_menu, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hidden)
        
        #else
        
        var copy_hidden = hidden
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hidden) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_show_menu, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_showing_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_showing_menu")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_menu ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_showing_menu, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_zoom_label: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_show_zoom_label")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_zoom_label (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_show_zoom_label, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_show_zoom_label, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_showing_zoom_label: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_showing_zoom_label")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_zoom_label ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_showing_zoom_label, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_grid_buttons: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_show_grid_buttons")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_grid_buttons (_ hidden: Bool) {
        #if true
        
        var copy_hidden = hidden
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_show_grid_buttons, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hidden)
        
        #else
        
        var copy_hidden = hidden
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hidden) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_show_grid_buttons, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_showing_grid_buttons: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_showing_grid_buttons")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_grid_buttons ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_showing_grid_buttons, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_zoom_buttons: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_show_zoom_buttons")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_zoom_buttons (_ hidden: Bool) {
        #if true
        
        var copy_hidden = hidden
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_show_zoom_buttons, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hidden)
        
        #else
        
        var copy_hidden = hidden
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hidden) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_show_zoom_buttons, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_showing_zoom_buttons: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_showing_zoom_buttons")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_zoom_buttons ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_showing_zoom_buttons, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_minimap_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_show_minimap_button")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_minimap_button (_ hidden: Bool) {
        #if true
        
        var copy_hidden = hidden
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_show_minimap_button, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hidden)
        
        #else
        
        var copy_hidden = hidden
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hidden) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_show_minimap_button, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_showing_minimap_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_showing_minimap_button")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_minimap_button ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_showing_minimap_button, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_show_arrange_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_show_arrange_button")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_show_arrange_button (_ hidden: Bool) {
        #if true
        
        var copy_hidden = hidden
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_show_arrange_button, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hidden)
        
        #else
        
        var copy_hidden = hidden
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hidden) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_show_arrange_button, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_showing_arrange_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_showing_arrange_button")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_showing_arrange_button ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_showing_arrange_button, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_right_disconnects: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_right_disconnects")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_right_disconnects (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_right_disconnects, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_right_disconnects, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_right_disconnects_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_right_disconnects_enabled")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_right_disconnects_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (GraphEdit.method_is_right_disconnects_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_menu_hbox: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_menu_hbox")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3590609951)!
            }
            
        }
        
    }()
    
    /// Gets the ``HBoxContainer`` that contains the zooming and grid snap controls in the top left of the graph. You can use this method to reposition the toolbar or to add your own custom controls to it.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``CanvasItem/visible`` property.
    /// 
    public final func getMenuHbox ()-> HBoxContainer? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (GraphEdit.method_get_menu_hbox, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_arrange_nodes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("arrange_nodes")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Rearranges selected nodes in a layout with minimum crossings between connections and uniform horizontal and vertical gap between nodes.
    public final func arrangeNodes () {
        gi.object_method_bind_ptrcall (GraphEdit.method_arrange_nodes, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_selected")
        return withUnsafePointer (to: &GraphEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    /// Sets the specified `node` as the one selected.
    public final func setSelected (node: Node?) {
        #if true
        
        var copy_node_handle = node?.handle
        
        gi.object_method_bind_ptrcall_v (GraphEdit.method_set_selected, UnsafeMutableRawPointer (mutating: handle), nil, &copy_node_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: node?.handle) { p0 in
        _args.append (node == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (GraphEdit.method_set_selected, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_get_connection_line":
                return _GraphEdit_proxy_get_connection_line
            case "_is_in_input_hotzone":
                return _GraphEdit_proxy_is_in_input_hotzone
            case "_is_in_output_hotzone":
                return _GraphEdit_proxy_is_in_output_hotzone
            case "_is_node_hover_valid":
                return _GraphEdit_proxy_is_node_hover_valid
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromNode: StringName, _ fromPort: Int64, _ toNode: StringName, _ toPort: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = StringName (args [2])!
                let arg_3 = Int64 (args [3])!
                
                callback (arg_0, arg_1, arg_2, arg_3)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted to the GraphEdit when the connection between the `fromPort` of the `fromNode` ``GraphNode`` and the `toPort` of the `toNode` ``GraphNode`` is attempted to be created.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionRequest.connect { fromNode, fromPort, toNode, toPort in
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionRequest: Signal1 { Signal1 (target: self, signalName: "connection_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromNode: StringName, _ fromPort: Int64, _ toNode: StringName, _ toPort: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = StringName (args [2])!
                let arg_3 = Int64 (args [3])!
                
                callback (arg_0, arg_1, arg_2, arg_3)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted to the GraphEdit when the connection between `fromPort` of `fromNode` ``GraphNode`` and `toPort` of `toNode` ``GraphNode`` is attempted to be removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.disconnectionRequest.connect { fromNode, fromPort, toNode, toPort in
    ///    print ("caught signal")
    /// }
    /// ```
    public var disconnectionRequest: Signal2 { Signal2 (target: self, signalName: "disconnection_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromNode: StringName, _ fromPort: Int64, _ releasePosition: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = Vector2 (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when user drags a connection from an output port into the empty space of the graph.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionToEmpty.connect { fromNode, fromPort, releasePosition in
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionToEmpty: Signal3 { Signal3 (target: self, signalName: "connection_to_empty") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ toNode: StringName, _ toPort: Int64, _ releasePosition: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = Vector2 (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when user drags a connection from an input port into the empty space of the graph.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionFromEmpty.connect { toNode, toPort, releasePosition in
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionFromEmpty: Signal4 { Signal4 (target: self, signalName: "connection_from_empty") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromNode: StringName, _ fromPort: Int64, _ isOutput: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                let arg_2 = Bool (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted at the beginning of a connection drag.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionDragStarted.connect { fromNode, fromPort, isOutput in
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionDragStarted: Signal5 { Signal5 (target: self, signalName: "connection_drag_started") }
    
    /// Emitted at the end of a connection drag.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.connectionDragEnded.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var connectionDragEnded: SimpleSignal { SimpleSignal (target: self, signalName: "connection_drag_ended") }
    
    /// Emitted when the user presses [kbd]Ctrl + C[/kbd].
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.copyNodesRequest.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var copyNodesRequest: SimpleSignal { SimpleSignal (target: self, signalName: "copy_nodes_request") }
    
    /// Emitted when the user presses [kbd]Ctrl + V[/kbd].
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.pasteNodesRequest.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var pasteNodesRequest: SimpleSignal { SimpleSignal (target: self, signalName: "paste_nodes_request") }
    
    /// Emitted when a GraphNode is attempted to be duplicated in the GraphEdit.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.duplicateNodesRequest.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var duplicateNodesRequest: SimpleSignal { SimpleSignal (target: self, signalName: "duplicate_nodes_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal6/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal6/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal6/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal6 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal6 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ nodes: VariantCollection<StringName>) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = VariantCollection<StringName> (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when attempting to remove a GraphNode from the GraphEdit. Provides a list of node names to be removed (all selected nodes, excluding nodes without closing button).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.deleteNodesRequest.connect { nodes in
    ///    print ("caught signal")
    /// }
    /// ```
    public var deleteNodesRequest: Signal6 { Signal6 (target: self, signalName: "delete_nodes_request") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal7/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal7/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal7/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal7 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal7 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a GraphNode is selected.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeSelected.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeSelected: Signal7 { Signal7 (target: self, signalName: "node_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal8/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal8/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal8/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal8 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal8 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeDeselected.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeDeselected: Signal8 { Signal8 (target: self, signalName: "node_deselected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal9/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal9/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal9/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal9 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal9 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ position: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector2 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a popup is requested. Happens on right-clicking in the GraphEdit. `position` is the position of the mouse pointer when the signal is sent.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.popupRequest.connect { position in
    ///    print ("caught signal")
    /// }
    /// ```
    public var popupRequest: Signal9 { Signal9 (target: self, signalName: "popup_request") }
    
    /// Emitted at the beginning of a GraphNode movement.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.beginNodeMove.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var beginNodeMove: SimpleSignal { SimpleSignal (target: self, signalName: "begin_node_move") }
    
    /// Emitted at the end of a GraphNode movement.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.endNodeMove.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var endNodeMove: SimpleSignal { SimpleSignal (target: self, signalName: "end_node_move") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal10/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal10/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal10/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal10 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal10 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ offset: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector2 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the scroll offset is changed by the user. It will not be emitted when changed in code.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.scrollOffsetChanged.connect { offset in
    ///    print ("caught signal")
    /// }
    /// ```
    public var scrollOffsetChanged: Signal10 { Signal10 (target: self, signalName: "scroll_offset_changed") }
    
}

// Support methods for proxies
func _GraphEdit_proxy_get_connection_line (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GraphEdit>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getConnectionLine (fromPosition: args [0]!.assumingMemoryBound (to: Vector2.self).pointee, toPosition: args [1]!.assumingMemoryBound (to: Vector2.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // PackedVector2Array
    ret.content = PackedVector2Array.zero
}

func _GraphEdit_proxy_is_in_input_hotzone (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GraphEdit>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._isInInputHotzone (inNode: lookupLiveObject (handleAddress: resolved_0) as? Object ?? Object (nativeHandle: resolved_0), inPort: args [1]!.assumingMemoryBound (to: Int32.self).pointee, mousePosition: args [2]!.assumingMemoryBound (to: Vector2.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _GraphEdit_proxy_is_in_output_hotzone (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GraphEdit>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._isInOutputHotzone (inNode: lookupLiveObject (handleAddress: resolved_0) as? Object ?? Object (nativeHandle: resolved_0), inPort: args [1]!.assumingMemoryBound (to: Int32.self).pointee, mousePosition: args [2]!.assumingMemoryBound (to: Vector2.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

func _GraphEdit_proxy_is_node_hover_valid (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<GraphEdit>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._isNodeHoverValid (fromNode: StringName (content: args [0]!.assumingMemoryBound (to: Int64.self).pointee), fromPort: args [1]!.assumingMemoryBound (to: Int32.self).pointee, toNode: StringName (content: args [2]!.assumingMemoryBound (to: Int64.self).pointee), toPort: args [3]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

