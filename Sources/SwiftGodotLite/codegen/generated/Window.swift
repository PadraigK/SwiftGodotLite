// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for all windows, dialogs, and popups.
/// 
/// A node that creates a window. The window can either be a native system window or embedded inside another ``Window`` (see ``Viewport/guiEmbedSubwindows``).
/// 
/// At runtime, ``Window``s will not close automatically when requested. You need to handle it manually using the [signal close_requested] signal (this applies both to pressing the close button and clicking outside of a popup).
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``windowInput``
/// - ``filesDropped``
/// - ``mouseEntered``
/// - ``mouseExited``
/// - ``focusEntered``
/// - ``focusExited``
/// - ``closeRequested``
/// - ``goBackRequested``
/// - ``visibilityChanged``
/// - ``aboutToPopup``
/// - ``themeChanged``
/// - ``dpiChanged``
/// - ``titlebarChanged``
open class Window: Viewport {
    override open class var godotClassName: StringName { "Window" }
    public enum Mode: Int64 {
        /// Windowed mode, i.e. ``Window`` doesn't occupy the whole screen (unless set to the size of the screen).
        case windowed = 0 // MODE_WINDOWED
        /// Minimized window mode, i.e. ``Window`` is not visible and available on window manager's window list. Normally happens when the minimize button is pressed.
        case minimized = 1 // MODE_MINIMIZED
        /// Maximized window mode, i.e. ``Window`` will occupy whole screen area except task bar and still display its borders. Normally happens when the maximize button is pressed.
        case maximized = 2 // MODE_MAXIMIZED
        /// Full screen mode with full multi-window support.
        /// 
        /// Full screen window covers the entire display area of a screen and has no decorations. The display's video mode is not changed.
        /// 
        /// **On Windows:** Multi-window full-screen mode has a 1px border of the ``ProjectSettings/rendering/environment/defaults/defaultClearColor`` color.
        /// 
        /// **On macOS:** A new desktop is used to display the running project.
        /// 
        /// > Note: Regardless of the platform, enabling full screen will change the window size to match the monitor's size. Therefore, make sure your project supports [url=$DOCS_URL/tutorials/rendering/multiple_resolutions.html]multiple resolutions[/url] when enabling full screen mode.
        /// 
        case fullscreen = 3 // MODE_FULLSCREEN
        /// A single window full screen mode. This mode has less overhead, but only one window can be open on a given screen at a time (opening a child window or application switching will trigger a full screen transition).
        /// 
        /// Full screen window covers the entire display area of a screen and has no border or decorations. The display's video mode is not changed.
        /// 
        /// **On Windows:** Depending on video driver, full screen transition might cause screens to go black for a moment.
        /// 
        /// **On macOS:** A new desktop is used to display the running project. Exclusive full screen mode prevents Dock and Menu from showing up when the mouse pointer is hovering the edge of the screen.
        /// 
        /// **On Linux (X11):** Exclusive full screen mode bypasses compositor.
        /// 
        /// > Note: Regardless of the platform, enabling full screen will change the window size to match the monitor's size. Therefore, make sure your project supports [url=$DOCS_URL/tutorials/rendering/multiple_resolutions.html]multiple resolutions[/url] when enabling full screen mode.
        /// 
        case exclusiveFullscreen = 4 // MODE_EXCLUSIVE_FULLSCREEN
    }
    
    public enum Flags: Int64 {
        /// The window can't be resized by dragging its resize grip. It's still possible to resize the window using ``size``. This flag is ignored for full screen windows. Set with ``unresizable``.
        case resizeDisabled = 0 // FLAG_RESIZE_DISABLED
        /// The window do not have native title bar and other decorations. This flag is ignored for full-screen windows. Set with ``borderless``.
        case borderless = 1 // FLAG_BORDERLESS
        /// The window is floating on top of all other windows. This flag is ignored for full-screen windows. Set with ``alwaysOnTop``.
        case alwaysOnTop = 2 // FLAG_ALWAYS_ON_TOP
        /// The window background can be transparent. Set with ``transparent``.
        /// 
        /// > Note: This flag has no effect if either ``ProjectSettings/display/window/perPixelTransparency/allowed``, or the window's ``Viewport/transparentBg`` is set to `false`.
        /// 
        case transparent = 3 // FLAG_TRANSPARENT
        /// The window can't be focused. No-focus window will ignore all input, except mouse clicks. Set with ``unfocusable``.
        case noFocus = 4 // FLAG_NO_FOCUS
        /// Window is part of menu or ``OptionButton`` dropdown. This flag can't be changed when the window is visible. An active popup window will exclusively receive all input, without stealing focus from its parent. Popup windows are automatically closed when uses click outside it, or when an application is switched. Popup window must have transient parent set (see ``transient``).
        /// 
        /// > Note: This flag has no effect in embedded windows (unless said window is a ``Popup``).
        /// 
        case popup = 5 // FLAG_POPUP
        /// Window content is expanded to the full size of the window. Unlike borderless window, the frame is left intact and can be used to resize the window, title bar is transparent, but have minimize/maximize/close buttons. Set with ``extendToTitle``.
        /// 
        /// > Note: This flag is implemented only on macOS.
        /// 
        /// > Note: This flag has no effect in embedded windows.
        /// 
        case extendToTitle = 6 // FLAG_EXTEND_TO_TITLE
        /// All mouse events are passed to the underlying window of the same application.
        /// 
        /// > Note: This flag has no effect in embedded windows.
        /// 
        case mousePassthrough = 7 // FLAG_MOUSE_PASSTHROUGH
        /// Max value of the ``Window/Flags``.
        case max = 8 // FLAG_MAX
    }
    
    public enum ContentScaleMode: Int64 {
        /// The content will not be scaled to match the ``Window``'s size.
        case disabled = 0 // CONTENT_SCALE_MODE_DISABLED
        /// The content will be rendered at the target size. This is more performance-expensive than .viewport, but provides better results.
        case canvasItems = 1 // CONTENT_SCALE_MODE_CANVAS_ITEMS
        /// The content will be rendered at the base size and then scaled to the target size. More performant than .canvasItems, but results in pixelated image.
        case viewport = 2 // CONTENT_SCALE_MODE_VIEWPORT
    }
    
    public enum ContentScaleAspect: Int64 {
        /// The aspect will be ignored. Scaling will simply stretch the content to fit the target size.
        case ignore = 0 // CONTENT_SCALE_ASPECT_IGNORE
        /// The content's aspect will be preserved. If the target size has different aspect from the base one, the image will be centered and black bars will appear on left and right sides.
        case keep = 1 // CONTENT_SCALE_ASPECT_KEEP
        /// The content can be expanded vertically. Scaling horizontally will result in keeping the width ratio and then black bars on left and right sides.
        case keepWidth = 2 // CONTENT_SCALE_ASPECT_KEEP_WIDTH
        /// The content can be expanded horizontally. Scaling vertically will result in keeping the height ratio and then black bars on top and bottom sides.
        case keepHeight = 3 // CONTENT_SCALE_ASPECT_KEEP_HEIGHT
        /// The content's aspect will be preserved. If the target size has different aspect from the base one, the content will stay in the top-left corner and add an extra visible area in the stretched space.
        case expand = 4 // CONTENT_SCALE_ASPECT_EXPAND
    }
    
    public enum ContentScaleStretch: Int64 {
        /// The content will be stretched according to a fractional factor. This fills all the space available in the window, but allows "pixel wobble" to occur due to uneven pixel scaling.
        case fractional = 0 // CONTENT_SCALE_STRETCH_FRACTIONAL
        /// The content will be stretched only according to an integer factor, preserving sharp pixels. This may leave a black background visible on the window's edges depending on the window size.
        case integer = 1 // CONTENT_SCALE_STRETCH_INTEGER
    }
    
    public enum LayoutDirection: Int64 {
        /// Automatic layout direction, determined from the parent window layout direction.
        case inherited = 0 // LAYOUT_DIRECTION_INHERITED
        /// Automatic layout direction, determined from the current locale.
        case locale = 1 // LAYOUT_DIRECTION_LOCALE
        /// Left-to-right layout direction.
        case ltr = 2 // LAYOUT_DIRECTION_LTR
        /// Right-to-left layout direction.
        case rtl = 3 // LAYOUT_DIRECTION_RTL
    }
    
    public enum WindowInitialPosition: Int64 {
        /// Initial window position is determined by ``position``.
        case absolute = 0 // WINDOW_INITIAL_POSITION_ABSOLUTE
        /// Initial window position is the center of the primary screen.
        case centerPrimaryScreen = 1 // WINDOW_INITIAL_POSITION_CENTER_PRIMARY_SCREEN
        /// Initial window position is the center of the main window screen.
        case centerMainWindowScreen = 2 // WINDOW_INITIAL_POSITION_CENTER_MAIN_WINDOW_SCREEN
        /// Initial window position is the center of ``currentScreen`` screen.
        case centerOtherScreen = 3 // WINDOW_INITIAL_POSITION_CENTER_OTHER_SCREEN
        /// Initial window position is the center of the screen containing the mouse pointer.
        case centerScreenWithMouseFocus = 4 // WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_MOUSE_FOCUS
        /// Initial window position is the center of the screen containing the window with the keyboard focus.
        case centerScreenWithKeyboardFocus = 5 // WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_KEYBOARD_FOCUS
    }
    
    /* Constants */
    /// Emitted when ``Window``'s visibility changes, right before [signal visibility_changed].
    public static let notificationVisibilityChanged = 30
    /// Sent when the node needs to refresh its theme items. This happens in one of the following cases:
    /// 
    /// - The ``theme`` property is changed on this node or any of its ancestors.
    /// 
    /// - The ``themeTypeVariation`` property is changed on this node.
    /// 
    /// - The node enters the scene tree.
    /// 
    /// > Note: As an optimization, this notification won't be sent from changes that occur while this node is outside of the scene tree. Instead, all of the theme item updates can be applied at once when the node enters the scene tree.
    /// 
    public static let notificationThemeChanged = 32
    
    /* Properties */
    
    /// Set's the window's current mode.
    /// 
    /// > Note: Fullscreen mode is not exclusive full screen on Windows and Linux.
    /// 
    /// > Note: This method only works with native windows, i.e. the main window and ``Window``-derived nodes when ``Viewport/guiEmbedSubwindows`` is disabled in the main viewport.
    /// 
    final public var mode: Window.Mode {
        get {
            return get_mode ()
        }
        
        set {
            set_mode (newValue)
        }
        
    }
    
    /// The window's title. If the ``Window`` is native, title styles set in ``Theme`` will have no effect.
    final public var title: String {
        get {
            return get_title ()
        }
        
        set {
            set_title (newValue)
        }
        
    }
    
    /// Specifies the initial type of position for the ``Window``. See ``Window/WindowInitialPosition`` constants.
    final public var initialPosition: Window.WindowInitialPosition {
        get {
            return get_initial_position ()
        }
        
        set {
            set_initial_position (newValue)
        }
        
    }
    
    /// The window's position in pixels.
    /// 
    /// If ``ProjectSettings/display/window/subwindows/embedSubwindows`` is `false`, the position is in absolute screen coordinates. This typically applies to editor plugins. If the setting is `true`, the window's position is in the coordinates of its parent ``Viewport``.
    /// 
    /// > Note: This property only works if ``initialPosition`` is set to .absolute.
    /// 
    final public var position: Vector2i {
        get {
            return get_position ()
        }
        
        set {
            set_position (newValue)
        }
        
    }
    
    /// The window's size in pixels.
    final public var size: Vector2i {
        get {
            return get_size ()
        }
        
        set {
            set_size (newValue)
        }
        
    }
    
    /// The screen the window is currently on.
    final public var currentScreen: Int32 {
        get {
            return get_current_screen ()
        }
        
        set {
            set_current_screen (newValue)
        }
        
    }
    
    /// Sets a polygonal region of the window which accepts mouse events. Mouse events outside the region will be passed through.
    /// 
    /// Passing an empty array will disable passthrough support (all mouse events will be intercepted by the window, which is the default behavior).
    /// 
    /// > Note: This property is ignored if ``mousePassthrough`` is set to `true`.
    /// 
    /// > Note: On Windows, the portion of a window that lies outside the region is not drawn, while on Linux (X11) and macOS it is.
    /// 
    /// > Note: This property is implemented on Linux (X11), macOS and Windows.
    /// 
    final public var mousePassthroughPolygon: PackedVector2Array {
        get {
            return get_mouse_passthrough_polygon ()
        }
        
        set {
            set_mouse_passthrough_polygon (newValue)
        }
        
    }
    
    /// If `true`, the window is visible.
    final public var visible: Bool {
        get {
            return is_visible ()
        }
        
        set {
            set_visible (newValue)
        }
        
    }
    
    /// If `true`, the window's size will automatically update when a child node is added or removed, ignoring ``minSize`` if the new size is bigger.
    /// 
    /// If `false`, you need to call ``childControlsChanged()`` manually.
    /// 
    final public var wrapControls: Bool {
        get {
            return is_wrapping_controls ()
        }
        
        set {
            set_wrap_controls (newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` is transient, i.e. it's considered a child of another ``Window``. The transient window will be destroyed with its transient parent and will return focus to their parent when closed. The transient window is displayed on top of a non-exclusive full-screen parent window. Transient windows can't enter full-screen mode.
    /// 
    /// Note that behavior might be different depending on the platform.
    /// 
    final public var transient: Bool {
        get {
            return is_transient ()
        }
        
        set {
            set_transient (newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` will be in exclusive mode. Exclusive windows are always on top of their parent and will block all input going to the parent ``Window``.
    /// 
    /// Needs ``transient`` enabled to work.
    /// 
    final public var exclusive: Bool {
        get {
            return is_exclusive ()
        }
        
        set {
            set_exclusive (newValue)
        }
        
    }
    
    /// If `true`, the window can't be resized. Minimize and maximize buttons are disabled.
    final public var unresizable: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 0)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 0)!, newValue)
        }
        
    }
    
    /// If `true`, the window will have no borders.
    final public var borderless: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 1)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 1)!, newValue)
        }
        
    }
    
    /// If `true`, the window will be on top of all other windows. Does not work if ``transient`` is enabled.
    final public var alwaysOnTop: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 2)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 2)!, newValue)
        }
        
    }
    
    /// If `true`, the ``Window``'s background can be transparent. This is best used with embedded windows.
    /// 
    /// > Note: Transparency support is implemented on Linux, macOS and Windows, but availability might vary depending on GPU driver, display manager, and compositor capabilities.
    /// 
    /// > Note: This property has no effect if either ``ProjectSettings/display/window/perPixelTransparency/allowed``, or the window's ``Viewport/transparentBg`` is set to `false`.
    /// 
    final public var transparent: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 3)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 3)!, newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` can't be focused nor interacted with. It can still be visible.
    final public var unfocusable: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 4)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 4)!, newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` will be considered a popup. Popups are sub-windows that don't show as separate windows in system's window manager's window list and will send close request when anything is clicked outside of them (unless ``exclusive`` is enabled).
    final public var popupWindow: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 5)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 5)!, newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` contents is expanded to the full size of the window, window title bar is transparent.
    /// 
    /// > Note: This property is implemented only on macOS.
    /// 
    /// > Note: This property only works with native windows.
    /// 
    final public var extendToTitle: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 6)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 6)!, newValue)
        }
        
    }
    
    /// If `true`, all mouse events will be passed to the underlying window of the same application. See also ``mousePassthroughPolygon``.
    /// 
    /// > Note: This property is implemented on Linux (X11), macOS and Windows.
    /// 
    /// > Note: This property only works with native windows.
    /// 
    final public var mousePassthrough: Bool {
        get {
            return get_flag (Window.Flags (rawValue: 7)!)
        }
        
        set {
            set_flag (Window.Flags (rawValue: 7)!, newValue)
        }
        
    }
    
    /// If non-zero, the ``Window`` can't be resized to be smaller than this size.
    /// 
    /// > Note: This property will be ignored in favor of ``getContentsMinimumSize()`` if ``wrapControls`` is enabled and if its size is bigger.
    /// 
    final public var minSize: Vector2i {
        get {
            return get_min_size ()
        }
        
        set {
            set_min_size (newValue)
        }
        
    }
    
    /// If non-zero, the ``Window`` can't be resized to be bigger than this size.
    /// 
    /// > Note: This property will be ignored if the value is lower than ``minSize``.
    /// 
    final public var maxSize: Vector2i {
        get {
            return get_max_size ()
        }
        
        set {
            set_max_size (newValue)
        }
        
    }
    
    /// If `true`, the ``Window`` width is expanded to keep the title bar text fully visible.
    final public var keepTitleVisible: Bool {
        get {
            return get_keep_title_visible ()
        }
        
        set {
            set_keep_title_visible (newValue)
        }
        
    }
    
    /// Base size of the content (i.e. nodes that are drawn inside the window). If non-zero, ``Window``'s content will be scaled when the window is resized to a different size.
    final public var contentScaleSize: Vector2i {
        get {
            return get_content_scale_size ()
        }
        
        set {
            set_content_scale_size (newValue)
        }
        
    }
    
    /// Specifies how the content is scaled when the ``Window`` is resized.
    final public var contentScaleMode: Window.ContentScaleMode {
        get {
            return get_content_scale_mode ()
        }
        
        set {
            set_content_scale_mode (newValue)
        }
        
    }
    
    /// Specifies how the content's aspect behaves when the ``Window`` is resized. The base aspect is determined by ``contentScaleSize``.
    final public var contentScaleAspect: Window.ContentScaleAspect {
        get {
            return get_content_scale_aspect ()
        }
        
        set {
            set_content_scale_aspect (newValue)
        }
        
    }
    
    /// The policy to use to determine the final scale factor for 2D elements. This affects how ``contentScaleFactor`` is applied, in addition to the automatic scale factor determined by ``contentScaleSize``.
    final public var contentScaleStretch: Window.ContentScaleStretch {
        get {
            return get_content_scale_stretch ()
        }
        
        set {
            set_content_scale_stretch (newValue)
        }
        
    }
    
    /// Specifies the base scale of ``Window``'s content when its ``size`` is equal to ``contentScaleSize``.
    final public var contentScaleFactor: Double {
        get {
            return get_content_scale_factor ()
        }
        
        set {
            set_content_scale_factor (newValue)
        }
        
    }
    
    /// Toggles if any text should automatically change to its translated version depending on the current locale.
    final public var autoTranslate: Bool {
        get {
            return is_auto_translating ()
        }
        
        set {
            set_auto_translate (newValue)
        }
        
    }
    
    /// The ``Theme`` resource this node and all its ``Control`` and ``Window`` children use. If a child node has its own ``Theme`` resource set, theme items are merged with child's definitions having higher priority.
    /// 
    /// > Note: ``Window`` styles will have no effect unless the window is embedded.
    /// 
    final public var theme: Theme? {
        get {
            return get_theme ()
        }
        
        set {
            set_theme (newValue)
        }
        
    }
    
    /// The name of a theme type variation used by this ``Window`` to look up its own theme items. See ``Control/themeTypeVariation`` for more details.
    final public var themeTypeVariation: StringName {
        get {
            return get_theme_type_variation ()
        }
        
        set {
            set_theme_type_variation (newValue)
        }
        
    }
    
    /* Methods */
    /// Virtual method to be implemented by the user. Overrides the value returned by ``getContentsMinimumSize()``.
    @_documentation(visibility: public)
    open func _getContentsMinimumSize ()-> Vector2 {
        return Vector2 ()
    }
    
    fileprivate static var method_set_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_title")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_title (_ title: String) {
        #if true
        
        let gstr_title = GString (title)
        
        gi.object_method_bind_ptrcall_v (Window.method_set_title, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_title.content)
        
        #else
        
        let gstr_title = GString (title)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_title.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_title, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_title")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_title ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Window.method_get_title, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_window_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_window_id")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the ID of the window.
    public final func getWindowId ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Window.method_get_window_id, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_initial_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_initial_position")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4084468099)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_initial_position (_ initialPosition: Window.WindowInitialPosition) {
        #if true
        
        var copy_initial_position = Int64 (initialPosition.rawValue)
        
        gi.object_method_bind_ptrcall_v (Window.method_set_initial_position, UnsafeMutableRawPointer (mutating: handle), nil, &copy_initial_position)
        
        #else
        
        var copy_initial_position = Int64 (initialPosition.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_initial_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_initial_position, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_initial_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_initial_position")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4294066647)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_initial_position ()-> Window.WindowInitialPosition {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Window.method_get_initial_position, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Window.WindowInitialPosition (rawValue: _result)!
    }
    
    fileprivate static var method_set_current_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_current_screen")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_current_screen (_ index: Int32) {
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (Window.method_set_current_screen, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_current_screen, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_current_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_current_screen")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_current_screen ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Window.method_get_current_screen, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_position")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_position (_ position: Vector2i) {
        #if true
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (Window.method_set_position, UnsafeMutableRawPointer (mutating: handle), nil, &copy_position)
        
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_position, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_position")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_position ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (Window.method_get_position, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_move_to_center: GDExtensionMethodBindPtr = {
        let methodName = StringName ("move_to_center")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Centers a native window on the current screen and an embedded window on its embedder ``Viewport``.
    public final func moveToCenter () {
        gi.object_method_bind_ptrcall (Window.method_move_to_center, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_size (_ size: Vector2i) {
        #if true
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (Window.method_set_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_size ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (Window.method_get_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_reset_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reset_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Resets the size to the minimum size, which is the max of ``minSize`` and (if ``wrapControls`` is enabled) ``getContentsMinimumSize()``. This is equivalent to calling `set_size(Vector2i())` (or any size below the minimum).
    public final func resetSize () {
        gi.object_method_bind_ptrcall (Window.method_reset_size, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_position_with_decorations: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_position_with_decorations")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    /// Returns the window's position including its border.
    public final func getPositionWithDecorations ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (Window.method_get_position_with_decorations, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_size_with_decorations: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_size_with_decorations")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    /// Returns the window's size including its border.
    public final func getSizeWithDecorations ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (Window.method_get_size_with_decorations, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_max_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_max_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_size (_ maxSize: Vector2i) {
        #if true
        
        var copy_max_size = maxSize
        
        gi.object_method_bind_ptrcall_v (Window.method_set_max_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_max_size)
        
        #else
        
        var copy_max_size = maxSize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_max_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_max_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_max_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_max_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_size ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (Window.method_get_max_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_min_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_min_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_min_size (_ minSize: Vector2i) {
        #if true
        
        var copy_min_size = minSize
        
        gi.object_method_bind_ptrcall_v (Window.method_set_min_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_min_size)
        
        #else
        
        var copy_min_size = minSize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_min_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_min_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_min_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_min_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_min_size ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (Window.method_get_min_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_mode")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3095236531)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mode (_ mode: Window.Mode) {
        #if true
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Window.method_set_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_mode")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2566346114)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mode ()-> Window.Mode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Window.method_get_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Window.Mode (rawValue: _result)!
    }
    
    fileprivate static var method_set_flag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_flag")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3426449779)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Sets a specified window flag.
    fileprivate final func set_flag (_ flag: Window.Flags, _ enabled: Bool) {
        #if true
        
        var copy_flag = Int64 (flag.rawValue)
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (Window.method_set_flag, UnsafeMutableRawPointer (mutating: handle), nil, &copy_flag, &copy_enabled)
        
        #else
        
        var copy_flag = Int64 (flag.rawValue)
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_flag) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_set_flag, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_flag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_flag")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3062752289)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Returns `true` if the `flag` is set.
    fileprivate final func get_flag (_ flag: Window.Flags)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_flag = Int64 (flag.rawValue)
        
        gi.object_method_bind_ptrcall_v (Window.method_get_flag, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_flag)
        return _result
        #else
        
        var copy_flag = Int64 (flag.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_flag) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_get_flag, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_maximize_allowed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_maximize_allowed")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the window can be maximized (the maximize button is enabled).
    public final func isMaximizeAllowed ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_maximize_allowed, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_request_attention: GDExtensionMethodBindPtr = {
        let methodName = StringName ("request_attention")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Tells the OS that the ``Window`` needs an attention. This makes the window stand out in some way depending on the system, e.g. it might blink on the task bar.
    public final func requestAttention () {
        gi.object_method_bind_ptrcall (Window.method_request_attention, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_move_to_foreground: GDExtensionMethodBindPtr = {
        let methodName = StringName ("move_to_foreground")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Moves the ``Window`` on top of other windows and focuses it.
    public final func moveToForeground () {
        gi.object_method_bind_ptrcall (Window.method_move_to_foreground, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_visible")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible (_ visible: Bool) {
        #if true
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (Window.method_set_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_visible")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_hide: GDExtensionMethodBindPtr = {
        let methodName = StringName ("hide")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Hides the window. This is not the same as minimized state. Hidden window can't be interacted with and needs to be made visible with ``show()``.
    public final func hide () {
        gi.object_method_bind_ptrcall (Window.method_hide, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_show: GDExtensionMethodBindPtr = {
        let methodName = StringName ("show")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Makes the ``Window`` appear. This enables interactions with the ``Window`` and doesn't change any of its property other than visibility (unlike e.g. ``popup(rect:)``).
    public final func show () {
        gi.object_method_bind_ptrcall (Window.method_show, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_transient: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_transient")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_transient (_ transient: Bool) {
        #if true
        
        var copy_transient = transient
        
        gi.object_method_bind_ptrcall_v (Window.method_set_transient, UnsafeMutableRawPointer (mutating: handle), nil, &copy_transient)
        
        #else
        
        var copy_transient = transient
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_transient) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_transient, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_transient: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_transient")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_transient ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_transient, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_exclusive: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_exclusive")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_exclusive (_ exclusive: Bool) {
        #if true
        
        var copy_exclusive = exclusive
        
        gi.object_method_bind_ptrcall_v (Window.method_set_exclusive, UnsafeMutableRawPointer (mutating: handle), nil, &copy_exclusive)
        
        #else
        
        var copy_exclusive = exclusive
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_exclusive) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_exclusive, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_exclusive: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_exclusive")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_exclusive ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_exclusive, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_unparent_when_invisible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_unparent_when_invisible")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `unparent` is `true`, the window is automatically unparented when going invisible.
    /// 
    /// > Note: Make sure to keep a reference to the node, otherwise it will be orphaned. You also need to manually call ``Node/queueFree()`` to free the window if it's not parented.
    /// 
    public final func setUnparentWhenInvisible (unparent: Bool) {
        #if true
        
        var copy_unparent = unparent
        
        gi.object_method_bind_ptrcall_v (Window.method_set_unparent_when_invisible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_unparent)
        
        #else
        
        var copy_unparent = unparent
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_unparent) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_unparent_when_invisible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_can_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("can_draw")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the window is being drawn to the screen.
    public final func canDraw ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_can_draw, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_has_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_focus")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the window is focused.
    public final func hasFocus ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_has_focus, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_grab_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName ("grab_focus")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Causes the window to grab focus, allowing it to receive user input.
    public final func grabFocus () {
        gi.object_method_bind_ptrcall (Window.method_grab_focus, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_ime_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_ime_active")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `active` is `true`, enables system's native IME (Input Method Editor).
    public final func setImeActive (_ active: Bool) {
        #if true
        
        var copy_active = active
        
        gi.object_method_bind_ptrcall_v (Window.method_set_ime_active, UnsafeMutableRawPointer (mutating: handle), nil, &copy_active)
        
        #else
        
        var copy_active = active
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_active) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_ime_active, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_ime_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_ime_position")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    /// Moves IME to the given position.
    public final func setImePosition (_ position: Vector2i) {
        #if true
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (Window.method_set_ime_position, UnsafeMutableRawPointer (mutating: handle), nil, &copy_position)
        
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_ime_position, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_embedded: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_embedded")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the window is currently embedded in another window.
    public final func isEmbedded ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_embedded, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_contents_minimum_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_contents_minimum_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the combined minimum size from the child ``Control`` nodes of the window. Use ``childControlsChanged()`` to update it when children nodes have changed.
    /// 
    /// The value returned by this method can be overridden with ``_getContentsMinimumSize()``.
    /// 
    public final func getContentsMinimumSize ()-> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall (Window.method_get_contents_minimum_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_content_scale_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_content_scale_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_size (_ size: Vector2i) {
        #if true
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (Window.method_set_content_scale_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_content_scale_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_content_scale_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_content_scale_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_size ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (Window.method_get_content_scale_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_content_scale_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_content_scale_mode")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2937716473)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_mode (_ mode: Window.ContentScaleMode) {
        #if true
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Window.method_set_content_scale_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_content_scale_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_content_scale_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_content_scale_mode")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 161585230)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_mode ()-> Window.ContentScaleMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Window.method_get_content_scale_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Window.ContentScaleMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_content_scale_aspect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_content_scale_aspect")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2370399418)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_aspect (_ aspect: Window.ContentScaleAspect) {
        #if true
        
        var copy_aspect = Int64 (aspect.rawValue)
        
        gi.object_method_bind_ptrcall_v (Window.method_set_content_scale_aspect, UnsafeMutableRawPointer (mutating: handle), nil, &copy_aspect)
        
        #else
        
        var copy_aspect = Int64 (aspect.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_aspect) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_content_scale_aspect, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_content_scale_aspect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_content_scale_aspect")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4158790715)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_aspect ()-> Window.ContentScaleAspect {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Window.method_get_content_scale_aspect, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Window.ContentScaleAspect (rawValue: _result)!
    }
    
    fileprivate static var method_set_content_scale_stretch: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_content_scale_stretch")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 349355940)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_stretch (_ stretch: Window.ContentScaleStretch) {
        #if true
        
        var copy_stretch = Int64 (stretch.rawValue)
        
        gi.object_method_bind_ptrcall_v (Window.method_set_content_scale_stretch, UnsafeMutableRawPointer (mutating: handle), nil, &copy_stretch)
        
        #else
        
        var copy_stretch = Int64 (stretch.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_stretch) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_content_scale_stretch, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_content_scale_stretch: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_content_scale_stretch")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 536857316)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_stretch ()-> Window.ContentScaleStretch {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Window.method_get_content_scale_stretch, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Window.ContentScaleStretch (rawValue: _result)!
    }
    
    fileprivate static var method_set_keep_title_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_keep_title_visible")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_keep_title_visible (_ titleVisible: Bool) {
        #if true
        
        var copy_title_visible = titleVisible
        
        gi.object_method_bind_ptrcall_v (Window.method_set_keep_title_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_title_visible)
        
        #else
        
        var copy_title_visible = titleVisible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_title_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_keep_title_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_keep_title_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_keep_title_visible")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_keep_title_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_get_keep_title_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_content_scale_factor: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_content_scale_factor")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_content_scale_factor (_ factor: Double) {
        #if true
        
        var copy_factor = factor
        
        gi.object_method_bind_ptrcall_v (Window.method_set_content_scale_factor, UnsafeMutableRawPointer (mutating: handle), nil, &copy_factor)
        
        #else
        
        var copy_factor = factor
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_factor) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_content_scale_factor, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_content_scale_factor: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_content_scale_factor")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_content_scale_factor ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Window.method_get_content_scale_factor, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_font_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_font_oversampling")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables font oversampling. This makes fonts look better when they are scaled up.
    public final func setUseFontOversampling (enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Window.method_set_use_font_oversampling, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_use_font_oversampling, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_font_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_font_oversampling")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if font oversampling is enabled. See ``setUseFontOversampling(enable:)``.
    public final func isUsingFontOversampling ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_using_font_oversampling, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_mouse_passthrough_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_mouse_passthrough_polygon")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1509147220)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mouse_passthrough_polygon (_ polygon: PackedVector2Array) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_set_mouse_passthrough_polygon, UnsafeMutableRawPointer (mutating: handle), nil, &polygon.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &polygon.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_mouse_passthrough_polygon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_mouse_passthrough_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_mouse_passthrough_polygon")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2961356807)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mouse_passthrough_polygon ()-> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        gi.object_method_bind_ptrcall (Window.method_get_mouse_passthrough_polygon, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_wrap_controls: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_wrap_controls")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_wrap_controls (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Window.method_set_wrap_controls, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_wrap_controls, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_wrapping_controls: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_wrapping_controls")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_wrapping_controls ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_wrapping_controls, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_child_controls_changed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("child_controls_changed")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Requests an update of the ``Window`` size to fit underlying ``Control`` nodes.
    public final func childControlsChanged () {
        gi.object_method_bind_ptrcall (Window.method_child_controls_changed, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_theme: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_theme")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2326690814)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_theme (_ theme: Theme?) {
        #if true
        
        var copy_theme_handle = theme?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_set_theme, UnsafeMutableRawPointer (mutating: handle), nil, &copy_theme_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: theme?.handle) { p0 in
        _args.append (theme == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_theme, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3846893731)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_theme ()-> Theme? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Window.method_get_theme, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_theme_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_theme_type_variation")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_theme_type_variation (_ themeType: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_set_theme_type_variation, UnsafeMutableRawPointer (mutating: handle), nil, &themeType.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &themeType.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_theme_type_variation, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme_type_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_type_variation")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2002593661)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_theme_type_variation ()-> StringName {
        let _result: StringName = StringName ()
        gi.object_method_bind_ptrcall (Window.method_get_theme_type_variation, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_begin_bulk_theme_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("begin_bulk_theme_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Prevents `*_theme_*_override` methods from emitting ``notificationThemeChanged`` until ``endBulkThemeOverride()`` is called.
    public final func beginBulkThemeOverride () {
        gi.object_method_bind_ptrcall (Window.method_begin_bulk_theme_override, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_end_bulk_theme_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("end_bulk_theme_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Ends a bulk theme override update. See ``beginBulkThemeOverride()``.
    public final func endBulkThemeOverride () {
        gi.object_method_bind_ptrcall (Window.method_end_bulk_theme_override, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_add_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_theme_icon_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1373065600)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme icon with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeIconOverride(name:)``.
    /// 
    /// See also ``getThemeIcon(name:themeType:)``.
    /// 
    public final func addThemeIconOverride (name: StringName, texture: Texture2D?) {
        #if true
        
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_add_theme_icon_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &copy_texture_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: texture?.handle) { p1 in
            _args.append (texture == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (Window.method_add_theme_icon_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_theme_stylebox_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4188838905)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``StyleBox`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeStyleboxOverride(name:)``.
    /// 
    /// See also ``getThemeStylebox(name:themeType:)`` and ``Control/addThemeStyleboxOverride(name:stylebox:)`` for more details.
    /// 
    public final func addThemeStyleboxOverride (name: StringName, stylebox: StyleBox?) {
        #if true
        
        var copy_stylebox_handle = stylebox?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_add_theme_stylebox_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &copy_stylebox_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: stylebox?.handle) { p1 in
            _args.append (stylebox == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (Window.method_add_theme_stylebox_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_theme_font_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3518018674)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``Font`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeFontOverride(name:)``.
    /// 
    /// See also ``getThemeFont(name:themeType:)``.
    /// 
    public final func addThemeFontOverride (name: StringName, font: Font?) {
        #if true
        
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_add_theme_font_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &copy_font_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: font?.handle) { p1 in
            _args.append (font == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (Window.method_add_theme_font_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_theme_font_size_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2415702435)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme font size with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeFontSizeOverride(name:)``.
    /// 
    /// See also ``getThemeFontSize(name:themeType:)``.
    /// 
    public final func addThemeFontSizeOverride (name: StringName, fontSize: Int32) {
        #if true
        
        var copy_font_size: Int = Int (fontSize)
        
        gi.object_method_bind_ptrcall_v (Window.method_add_theme_font_size_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &copy_font_size)
        
        #else
        
        var copy_font_size: Int = Int (fontSize)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_font_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_add_theme_font_size_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_theme_color_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4260178595)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme ``Color`` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeColorOverride(name:)``.
    /// 
    /// See also ``getThemeColor(name:themeType:)`` and ``Control/addThemeColorOverride(name:color:)`` for more details.
    /// 
    public final func addThemeColorOverride (name: StringName, color: Color) {
        #if true
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (Window.method_add_theme_color_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_add_theme_color_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_theme_constant_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2415702435)!
            }
            
        }
        
    }()
    
    /// Creates a local override for a theme constant with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with ``removeThemeConstantOverride(name:)``.
    /// 
    /// See also ``getThemeConstant(name:themeType:)``.
    /// 
    public final func addThemeConstantOverride (name: StringName, constant: Int32) {
        #if true
        
        var copy_constant: Int = Int (constant)
        
        gi.object_method_bind_ptrcall_v (Window.method_add_theme_constant_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &copy_constant)
        
        #else
        
        var copy_constant: Int = Int (constant)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_constant) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_add_theme_constant_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_theme_icon_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme icon with the specified `name` previously added by ``addThemeIconOverride(name:texture:)`` or via the Inspector dock.
    public final func removeThemeIconOverride (name: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_remove_theme_icon_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_remove_theme_icon_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_theme_stylebox_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``StyleBox`` with the specified `name` previously added by ``addThemeStyleboxOverride(name:stylebox:)`` or via the Inspector dock.
    public final func removeThemeStyleboxOverride (name: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_remove_theme_stylebox_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_remove_theme_stylebox_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_theme_font_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``Font`` with the specified `name` previously added by ``addThemeFontOverride(name:font:)`` or via the Inspector dock.
    public final func removeThemeFontOverride (name: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_remove_theme_font_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_remove_theme_font_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_theme_font_size_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme font size with the specified `name` previously added by ``addThemeFontSizeOverride(name:fontSize:)`` or via the Inspector dock.
    public final func removeThemeFontSizeOverride (name: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_remove_theme_font_size_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_remove_theme_font_size_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_theme_color_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme ``Color`` with the specified `name` previously added by ``addThemeColorOverride(name:color:)`` or via the Inspector dock.
    public final func removeThemeColorOverride (name: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_remove_theme_color_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_remove_theme_color_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_theme_constant_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes a local override for a theme constant with the specified `name` previously added by ``addThemeConstantOverride(name:constant:)`` or via the Inspector dock.
    public final func removeThemeConstantOverride (name: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_remove_theme_constant_override, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_remove_theme_constant_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_icon")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3163973443)!
            }
            
        }
        
    }()
    
    /// Returns an icon from the first matching ``Theme`` in the tree if that ``Theme`` has an icon item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeIcon (name: StringName, themeType: StringName = StringName (""))-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_get_theme_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_get_theme_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_stylebox")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 604739069)!
            }
            
        }
        
    }()
    
    /// Returns a ``StyleBox`` from the first matching ``Theme`` in the tree if that ``Theme`` has a stylebox item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeStylebox (name: StringName, themeType: StringName = StringName (""))-> StyleBox? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_get_theme_stylebox, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_get_theme_stylebox, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme_font: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_font")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2826986490)!
            }
            
        }
        
    }()
    
    /// Returns a ``Font`` from the first matching ``Theme`` in the tree if that ``Theme`` has a font item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeFont (name: StringName, themeType: StringName = StringName (""))-> Font? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_get_theme_font, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_get_theme_font, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_font_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1327056374)!
            }
            
        }
        
    }()
    
    /// Returns a font size from the first matching ``Theme`` in the tree if that ``Theme`` has a font size item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeFontSize (name: StringName, themeType: StringName = StringName (""))-> Int32 {
        var _result: Int32 = 0
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_get_theme_font_size, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_get_theme_font_size, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_color")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2798751242)!
            }
            
        }
        
    }()
    
    /// Returns a ``Color`` from the first matching ``Theme`` in the tree if that ``Theme`` has a color item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for more details.
    /// 
    public final func getThemeColor (name: StringName, themeType: StringName = StringName (""))-> Color {
        var _result: Color = Color ()
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_get_theme_color, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_get_theme_color, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_constant")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1327056374)!
            }
            
        }
        
    }()
    
    /// Returns a constant from the first matching ``Theme`` in the tree if that ``Theme`` has a constant item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for more details.
    /// 
    public final func getThemeConstant (name: StringName, themeType: StringName = StringName (""))-> Int32 {
        var _result: Int32 = 0
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_get_theme_constant, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_get_theme_constant, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_icon_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_icon_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme icon with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeIconOverride(name:texture:)``.
    /// 
    public final func hasThemeIconOverride (name: StringName)-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_icon_override, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_has_theme_icon_override, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_stylebox_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_stylebox_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``StyleBox`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeStyleboxOverride(name:stylebox:)``.
    /// 
    public final func hasThemeStyleboxOverride (name: StringName)-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_stylebox_override, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_has_theme_stylebox_override, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_font_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_font_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``Font`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeFontOverride(name:font:)``.
    /// 
    public final func hasThemeFontOverride (name: StringName)-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_font_override, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_has_theme_font_override, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_font_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_font_size_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme font size with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeFontSizeOverride(name:fontSize:)``.
    /// 
    public final func hasThemeFontSizeOverride (name: StringName)-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_font_size_override, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_has_theme_font_size_override, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_color_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_color_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme ``Color`` with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeColorOverride(name:color:)``.
    /// 
    public final func hasThemeColorOverride (name: StringName)-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_color_override, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_has_theme_color_override, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_constant_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_constant_override")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a local override for a theme constant with the specified `name` in this ``Control`` node.
    /// 
    /// See ``addThemeConstantOverride(name:constant:)``.
    /// 
    public final func hasThemeConstantOverride (name: StringName)-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_constant_override, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_has_theme_constant_override, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_icon")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866386512)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has an icon item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeIcon (name: StringName, themeType: StringName = StringName (""))-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_has_theme_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_stylebox: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_stylebox")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866386512)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a stylebox item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeStylebox (name: StringName, themeType: StringName = StringName (""))-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_stylebox, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_has_theme_stylebox, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_font: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_font")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866386512)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a font item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeFont (name: StringName, themeType: StringName = StringName (""))-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_font, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_has_theme_font, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_font_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866386512)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a font size item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeFontSize (name: StringName, themeType: StringName = StringName (""))-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_font_size, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_has_theme_font_size, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_color")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866386512)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a color item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeColor (name: StringName, themeType: StringName = StringName (""))-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_color, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_has_theme_color, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_theme_constant: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_theme_constant")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866386512)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a matching ``Theme`` in the tree that has a constant item with the specified `name` and `themeType`.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func hasThemeConstant (name: StringName, themeType: StringName = StringName (""))-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Window.method_has_theme_constant, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &themeType.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &themeType.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_has_theme_constant, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_theme_default_base_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_default_base_scale")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the default base scale value from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultBaseScale`` value.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultBaseScale ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Window.method_get_theme_default_base_scale, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_theme_default_font: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_default_font")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3229501585)!
            }
            
        }
        
    }()
    
    /// Returns the default font from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultFont`` value.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultFont ()-> Font? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Window.method_get_theme_default_font, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_theme_default_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_theme_default_font_size")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the default font size value from the first matching ``Theme`` in the tree if that ``Theme`` has a valid ``Theme/defaultFontSize`` value.
    /// 
    /// See ``Control/getThemeColor(name:themeType:)`` for details.
    /// 
    public final func getThemeDefaultFontSize ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Window.method_get_theme_default_font_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_layout_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_layout_direction")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3094704184)!
            }
            
        }
        
    }()
    
    /// Sets layout direction and text writing direction. Right-to-left layouts are necessary for certain languages (e.g. Arabic and Hebrew).
    public final func setLayoutDirection (_ direction: Window.LayoutDirection) {
        #if true
        
        var copy_direction = Int64 (direction.rawValue)
        
        gi.object_method_bind_ptrcall_v (Window.method_set_layout_direction, UnsafeMutableRawPointer (mutating: handle), nil, &copy_direction)
        
        #else
        
        var copy_direction = Int64 (direction.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_direction) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_layout_direction, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_layout_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_layout_direction")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3909617982)!
            }
            
        }
        
    }()
    
    /// Returns layout direction and text writing direction.
    public final func getLayoutDirection ()-> Window.LayoutDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Window.method_get_layout_direction, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Window.LayoutDirection (rawValue: _result)!
    }
    
    fileprivate static var method_is_layout_rtl: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_layout_rtl")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if layout is right-to-left.
    public final func isLayoutRtl ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_layout_rtl, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_translate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_auto_translate")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_translate (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Window.method_set_auto_translate, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_set_auto_translate, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_auto_translating: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_auto_translating")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_translating ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Window.method_is_auto_translating, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_popup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1680304321)!
            }
            
        }
        
    }()
    
    /// Shows the ``Window`` and makes it transient (see ``transient``). If `rect` is provided, it will be set as the ``Window``'s size. Fails if called on the main window.
    public final func popup (rect: Rect2i = Rect2i (x: 0, y: 0, width: 0, height: 0)) {
        #if true
        
        var copy_rect = rect
        
        gi.object_method_bind_ptrcall_v (Window.method_popup, UnsafeMutableRawPointer (mutating: handle), nil, &copy_rect)
        
        #else
        
        var copy_rect = rect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_rect) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_popup, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_popup_on_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_on_parent")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1763793166)!
            }
            
        }
        
    }()
    
    /// Popups the ``Window`` with a position shifted by parent ``Window``'s position. If the ``Window`` is embedded, has the same effect as ``popup(rect:)``.
    public final func popupOnParent (parentRect: Rect2i) {
        #if true
        
        var copy_parent_rect = parentRect
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_on_parent, UnsafeMutableRawPointer (mutating: handle), nil, &copy_parent_rect)
        
        #else
        
        var copy_parent_rect = parentRect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_parent_rect) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_popup_on_parent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_popup_centered: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_centered")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3447975422)!
            }
            
        }
        
    }()
    
    /// Popups the ``Window`` at the center of the current screen, with optionally given minimum size. If the ``Window`` is embedded, it will be centered in the parent ``Viewport`` instead.
    /// 
    /// > Note: Calling it with the default value of `minsize` is equivalent to calling it with ``size``.
    /// 
    public final func popupCentered (minsize: Vector2i = Vector2i (x: 0, y: 0)) {
        #if true
        
        var copy_minsize = minsize
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_centered, UnsafeMutableRawPointer (mutating: handle), nil, &copy_minsize)
        
        #else
        
        var copy_minsize = minsize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_minsize) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_popup_centered, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_popup_centered_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_centered_ratio")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1014814997)!
            }
            
        }
        
    }()
    
    /// If ``Window`` is embedded, popups the ``Window`` centered inside its embedder and sets its size as a `ratio` of embedder's size.
    /// 
    /// If ``Window`` is a native window, popups the ``Window`` centered inside the screen of its parent ``Window`` and sets its size as a `ratio` of the screen size.
    /// 
    public final func popupCenteredRatio (_ ratio: Double = 0.8) {
        #if true
        
        var copy_ratio = ratio
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_centered_ratio, UnsafeMutableRawPointer (mutating: handle), nil, &copy_ratio)
        
        #else
        
        var copy_ratio = ratio
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_ratio) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Window.method_popup_centered_ratio, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_popup_centered_clamped: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_centered_clamped")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2613752477)!
            }
            
        }
        
    }()
    
    /// Popups the ``Window`` centered inside its parent ``Window``. `fallbackRatio` determines the maximum size of the ``Window``, in relation to its parent.
    /// 
    /// > Note: Calling it with the default value of `minsize` is equivalent to calling it with ``size``.
    /// 
    public final func popupCenteredClamped (minsize: Vector2i = Vector2i (x: 0, y: 0), fallbackRatio: Double = 0.75) {
        #if true
        
        var copy_minsize = minsize
        var copy_fallback_ratio = fallbackRatio
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_centered_clamped, UnsafeMutableRawPointer (mutating: handle), nil, &copy_minsize, &copy_fallback_ratio)
        
        #else
        
        var copy_minsize = minsize
        var copy_fallback_ratio = fallbackRatio
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_minsize) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_fallback_ratio) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_popup_centered_clamped, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_popup_exclusive: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_exclusive")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2134721627)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popup(rect:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusive (fromNode: Node?, rect: Rect2i = Rect2i (x: 0, y: 0, width: 0, height: 0)) {
        #if true
        
        var copy_rect = rect
        var copy_from_node_handle = fromNode?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_exclusive, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_node_handle, &copy_rect)
        
        #else
        
        var copy_rect = rect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: fromNode?.handle) { p0 in
        _args.append (fromNode == nil ? nil : p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_popup_exclusive, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_popup_exclusive_on_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_exclusive_on_parent")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2344671043)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popupOnParent(parentRect:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusiveOnParent (fromNode: Node?, parentRect: Rect2i) {
        #if true
        
        var copy_parent_rect = parentRect
        var copy_from_node_handle = fromNode?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_exclusive_on_parent, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_node_handle, &copy_parent_rect)
        
        #else
        
        var copy_parent_rect = parentRect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: fromNode?.handle) { p0 in
        _args.append (fromNode == nil ? nil : p0)
            withUnsafePointer (to: &copy_parent_rect) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_popup_exclusive_on_parent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_popup_exclusive_centered: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_exclusive_centered")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3357594017)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popupCentered(minsize:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusiveCentered (fromNode: Node?, minsize: Vector2i = Vector2i (x: 0, y: 0)) {
        #if true
        
        var copy_minsize = minsize
        var copy_from_node_handle = fromNode?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_exclusive_centered, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_node_handle, &copy_minsize)
        
        #else
        
        var copy_minsize = minsize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: fromNode?.handle) { p0 in
        _args.append (fromNode == nil ? nil : p0)
            withUnsafePointer (to: &copy_minsize) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_popup_exclusive_centered, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_popup_exclusive_centered_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_exclusive_centered_ratio")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2284776287)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popupCenteredRatio(_:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusiveCenteredRatio (fromNode: Node?, ratio: Double = 0.8) {
        #if true
        
        var copy_ratio = ratio
        var copy_from_node_handle = fromNode?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_exclusive_centered_ratio, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_node_handle, &copy_ratio)
        
        #else
        
        var copy_ratio = ratio
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: fromNode?.handle) { p0 in
        _args.append (fromNode == nil ? nil : p0)
            withUnsafePointer (to: &copy_ratio) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Window.method_popup_exclusive_centered_ratio, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_popup_exclusive_centered_clamped: GDExtensionMethodBindPtr = {
        let methodName = StringName ("popup_exclusive_centered_clamped")
        return withUnsafePointer (to: &Window.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2612708785)!
            }
            
        }
        
    }()
    
    /// Attempts to parent this dialog to the last exclusive window relative to `fromNode`, and then calls ``Window/popupCenteredClamped(minsize:fallbackRatio:)`` on it. The dialog must have no current parent, otherwise the method fails.
    /// 
    /// See also ``setUnparentWhenInvisible(unparent:)`` and ``Node/getLastExclusiveWindow()``.
    /// 
    public final func popupExclusiveCenteredClamped (fromNode: Node?, minsize: Vector2i = Vector2i (x: 0, y: 0), fallbackRatio: Double = 0.75) {
        #if true
        
        var copy_minsize = minsize
        var copy_fallback_ratio = fallbackRatio
        var copy_from_node_handle = fromNode?.handle
        
        gi.object_method_bind_ptrcall_v (Window.method_popup_exclusive_centered_clamped, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_node_handle, &copy_minsize, &copy_fallback_ratio)
        
        #else
        
        var copy_minsize = minsize
        var copy_fallback_ratio = fallbackRatio
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: fromNode?.handle) { p0 in
        _args.append (fromNode == nil ? nil : p0)
            withUnsafePointer (to: &copy_minsize) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_fallback_ratio) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Window.method_popup_exclusive_centered_clamped, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_get_contents_minimum_size":
                return _Window_proxy_get_contents_minimum_size
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ event: InputEvent) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? InputEvent ?? InputEvent (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the ``Window`` is currently focused and receives any input, passing the received event as an argument. The event's position, if present, is in the embedder's coordinate system.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.windowInput.connect { event in
    ///    print ("caught signal")
    /// }
    /// ```
    public var windowInput: Signal1 { Signal1 (target: self, signalName: "window_input") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ files: PackedStringArray) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = PackedStringArray (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when files are dragged from the OS file manager and dropped in the game window. The argument is a list of file paths.
    /// 
    /// Note that this method only works with native windows, i.e. the main window and ``Window``-derived nodes when ``Viewport/guiEmbedSubwindows`` is disabled in the main viewport.
    /// 
    /// Example usage:
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.filesDropped.connect { files in
    ///    print ("caught signal")
    /// }
    /// ```
    public var filesDropped: Signal2 { Signal2 (target: self, signalName: "files_dropped") }
    
    /// Emitted when the mouse cursor enters the ``Window``'s visible area, that is not occluded behind other ``Control``s or windows, provided its ``Viewport/guiDisableInput`` is `false` and regardless if it's currently focused or not.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseEntered: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_entered") }
    
    /// Emitted when the mouse cursor leaves the ``Window``'s visible area, that is not occluded behind other ``Control``s or windows, provided its ``Viewport/guiDisableInput`` is `false` and regardless if it's currently focused or not.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mouseExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mouseExited: SimpleSignal { SimpleSignal (target: self, signalName: "mouse_exited") }
    
    /// Emitted when the ``Window`` gains focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.focusEntered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var focusEntered: SimpleSignal { SimpleSignal (target: self, signalName: "focus_entered") }
    
    /// Emitted when the ``Window`` loses its focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.focusExited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var focusExited: SimpleSignal { SimpleSignal (target: self, signalName: "focus_exited") }
    
    /// Emitted when the ``Window``'s close button is pressed or when ``popupWindow`` is enabled and user clicks outside the window.
    /// 
    /// This signal can be used to handle window closing, e.g. by connecting it to ``hide()``.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.closeRequested.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var closeRequested: SimpleSignal { SimpleSignal (target: self, signalName: "close_requested") }
    
    /// Emitted when a go back request is sent (e.g. pressing the "Back" button on Android), right after ``Node/``notificationWmGoBackRequest````.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.goBackRequested.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var goBackRequested: SimpleSignal { SimpleSignal (target: self, signalName: "go_back_requested") }
    
    /// Emitted when ``Window`` is made visible or disappears.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.visibilityChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var visibilityChanged: SimpleSignal { SimpleSignal (target: self, signalName: "visibility_changed") }
    
    /// Emitted right after ``popup(rect:)`` call, before the ``Window`` appears or does anything.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.aboutToPopup.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var aboutToPopup: SimpleSignal { SimpleSignal (target: self, signalName: "about_to_popup") }
    
    /// Emitted when the ``notificationThemeChanged`` notification is sent.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.themeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var themeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "theme_changed") }
    
    /// Emitted when the ``Window``'s DPI changes as a result of OS-level changes (e.g. moving the window from a Retina display to a lower resolution one).
    /// 
    /// > Note: Only implemented on macOS.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.dpiChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var dpiChanged: SimpleSignal { SimpleSignal (target: self, signalName: "dpi_changed") }
    
    /// Emitted when window title bar decorations are changed, e.g. macOS window enter/exit full screen mode, or extend-to-title flag is changed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.titlebarChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var titlebarChanged: SimpleSignal { SimpleSignal (target: self, signalName: "titlebar_changed") }
    
}

// Support methods for proxies
func _Window_proxy_get_contents_minimum_size (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Window>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getContentsMinimumSize ()
    retPtr!.storeBytes (of: ret, as: Vector2.self)
}

