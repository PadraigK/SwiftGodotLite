// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A TCP server.
/// 
/// A TCP server. Listens to connections on a port and returns a ``StreamPeerTCP`` when it gets an incoming connection.
/// 
/// > Note: When exporting to Android, make sure to enable the `INTERNET` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
/// 
open class TCPServer: RefCounted {
    override open class var godotClassName: StringName { "TCPServer" }
    /* Methods */
    fileprivate static var method_listen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("listen")
        return withUnsafePointer (to: &TCPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3167955072)!
            }
            
        }
        
    }()
    
    /// Listen on the `port` binding to `bindAddress`.
    /// 
    /// If `bindAddress` is set as `"*"` (default), the server will listen on all available addresses (both IPv4 and IPv6).
    /// 
    /// If `bindAddress` is set as `"0.0.0.0"` (for IPv4) or `"::"` (for IPv6), the server will listen on all available addresses matching that IP type.
    /// 
    /// If `bindAddress` is set to any valid address (e.g. `"192.168.1.101"`, `"::1"`, etc), the server will only listen on the interface with that addresses (or fail if no interface with the given address exists).
    /// 
    public final func listen (port: UInt16, bindAddress: String = "*")-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_port: Int = Int (port)
        let gstr_bind_address = GString (bindAddress)
        
        gi.object_method_bind_ptrcall_v (TCPServer.method_listen, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_port, &gstr_bind_address.content)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_port: Int = Int (port)
        let gstr_bind_address = GString (bindAddress)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_port) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_bind_address.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TCPServer.method_listen, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_connection_available: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_connection_available")
        return withUnsafePointer (to: &TCPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a connection is available for taking.
    public final func isConnectionAvailable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TCPServer.method_is_connection_available, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_listening: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_listening")
        return withUnsafePointer (to: &TCPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the server is currently listening for connections.
    public final func isListening ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TCPServer.method_is_listening, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_local_port: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_local_port")
        return withUnsafePointer (to: &TCPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the local port this server is listening to.
    public final func getLocalPort ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TCPServer.method_get_local_port, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_take_connection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("take_connection")
        return withUnsafePointer (to: &TCPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 30545006)!
            }
            
        }
        
    }()
    
    /// If a connection is available, returns a StreamPeerTCP with the connection.
    public final func takeConnection ()-> StreamPeerTCP? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TCPServer.method_take_connection, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_stop: GDExtensionMethodBindPtr = {
        let methodName = StringName ("stop")
        return withUnsafePointer (to: &TCPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Stops listening.
    public final func stop () {
        gi.object_method_bind_ptrcall (TCPServer.method_stop, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
}

