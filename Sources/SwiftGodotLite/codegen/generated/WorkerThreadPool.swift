// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A singleton that allocates some ``Thread``s on startup, used to offload tasks to these threads.
/// 
/// The ``WorkerThreadPool`` singleton allocates a set of ``Thread``s (called worker threads) on project startup and provides methods for offloading tasks to them. This can be used for simple multithreading without having to create ``Thread``s.
/// 
/// Tasks hold the ``Callable`` to be run by the threads. ``WorkerThreadPool`` can be used to create regular tasks, which will be taken by one worker thread, or group tasks, which can be distributed between multiple worker threads. Group tasks execute the ``Callable`` multiple times, which makes them useful for iterating over a lot of elements, such as the enemies in an arena.
/// 
/// Here's a sample on how to offload an expensive function to worker threads:
/// 
/// The above code relies on the number of elements in the `enemies` array remaining constant during the multithreaded part.
/// 
/// > Note: Using this singleton could affect performance negatively if the task being distributed between threads is not computationally expensive.
/// 
open class WorkerThreadPool: Object {
    /// The shared instance of this class
    public static var shared: WorkerThreadPool = {
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { ptr in
            WorkerThreadPool (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "WorkerThreadPool" }
    /* Methods */
    fileprivate static var method_add_task: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_task")
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3745067146)!
            }
            
        }
        
    }()
    
    /// Adds `action` as a task to be executed by a worker thread. `highPriority` determines if the task has a high priority or a low priority (default). You can optionally provide a `description` to help with debugging.
    /// 
    /// Returns a task ID that can be used by other methods.
    /// 
    public static func addTask (action: Callable, highPriority: Bool = false, description: String = "")-> Int {
        var _result: Int = 0
        #if true
        
        var copy_high_priority = highPriority
        let gstr_description = GString (description)
        
        gi.object_method_bind_ptrcall_v (WorkerThreadPool.method_add_task, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &action.content, &copy_high_priority, &gstr_description.content)
        return _result
        #else
        
        var copy_high_priority = highPriority
        let gstr_description = GString (description)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &action.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_high_priority) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &gstr_description.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (WorkerThreadPool.method_add_task, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_task_completed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_task_completed")
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the task with the given ID is completed.
    public static func isTaskCompleted (taskId: Int)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_task_id = taskId
        
        gi.object_method_bind_ptrcall_v (WorkerThreadPool.method_is_task_completed, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_task_id)
        return _result
        #else
        
        var copy_task_id = taskId
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_task_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (WorkerThreadPool.method_is_task_completed, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_wait_for_task_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName ("wait_for_task_completion")
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844576869)!
            }
            
        }
        
    }()
    
    /// Pauses the thread that calls this method until the task with the given ID is completed.
    /// 
    /// Returns ``@GlobalScope.OK`` if the task could be successfully awaited.
    /// 
    /// Returns ``@GlobalScope.ERR_INVALID_PARAMETER`` if a task with the passed ID does not exist (maybe because it was already awaited and disposed of).
    /// 
    /// Returns ``@GlobalScope.ERR_BUSY`` if the call is made from another running task and, due to task scheduling, the task to await is at a lower level in the call stack and therefore can't progress. This is an advanced situation that should only matter when some tasks depend on others.
    /// 
    public static func waitForTaskCompletion (taskId: Int)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_task_id = taskId
        
        gi.object_method_bind_ptrcall_v (WorkerThreadPool.method_wait_for_task_completion, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_task_id)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_task_id = taskId
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_task_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (WorkerThreadPool.method_wait_for_task_completion, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return GodotError (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_add_group_task: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_group_task")
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1801953219)!
            }
            
        }
        
    }()
    
    /// Adds `action` as a group task to be executed by the worker threads. The ``Callable`` will be called a number of times based on `elements`, with the first thread calling it with the value `0` as a parameter, and each consecutive execution incrementing this value by 1 until it reaches `element - 1`.
    /// 
    /// The number of threads the task is distributed to is defined by `tasksNeeded`, where the default value `-1` means it is distributed to all worker threads. `highPriority` determines if the task has a high priority or a low priority (default). You can optionally provide a `description` to help with debugging.
    /// 
    /// Returns a group task ID that can be used by other methods.
    /// 
    public static func addGroupTask (action: Callable, elements: Int32, tasksNeeded: Int32 = -1, highPriority: Bool = false, description: String = "")-> Int {
        var _result: Int = 0
        #if true
        
        var copy_elements: Int = Int (elements)
        var copy_tasks_needed: Int = Int (tasksNeeded)
        var copy_high_priority = highPriority
        let gstr_description = GString (description)
        
        gi.object_method_bind_ptrcall_v (WorkerThreadPool.method_add_group_task, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &action.content, &copy_elements, &copy_tasks_needed, &copy_high_priority, &gstr_description.content)
        return _result
        #else
        
        var copy_elements: Int = Int (elements)
        var copy_tasks_needed: Int = Int (tasksNeeded)
        var copy_high_priority = highPriority
        let gstr_description = GString (description)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &action.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_elements) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_tasks_needed) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_high_priority) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &gstr_description.content) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (WorkerThreadPool.method_add_group_task, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                            return _result
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_group_task_completed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_group_task_completed")
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the group task with the given ID is completed.
    public static func isGroupTaskCompleted (groupId: Int)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_group_id = groupId
        
        gi.object_method_bind_ptrcall_v (WorkerThreadPool.method_is_group_task_completed, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_group_id)
        return _result
        #else
        
        var copy_group_id = groupId
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_group_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (WorkerThreadPool.method_is_group_task_completed, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_group_processed_element_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_group_processed_element_count")
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns how many times the ``Callable`` of the group task with the given ID has already been executed by the worker threads.
    /// 
    /// > Note: If a thread has started executing the ``Callable`` but is yet to finish, it won't be counted.
    /// 
    public static func getGroupProcessedElementCount (groupId: Int)-> UInt32 {
        var _result: UInt32 = 0
        #if true
        
        var copy_group_id = groupId
        
        gi.object_method_bind_ptrcall_v (WorkerThreadPool.method_get_group_processed_element_count, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_group_id)
        return _result
        #else
        
        var copy_group_id = groupId
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_group_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (WorkerThreadPool.method_get_group_processed_element_count, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_wait_for_group_task_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName ("wait_for_group_task_completion")
        return withUnsafePointer (to: &WorkerThreadPool.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Pauses the thread that calls this method until the group task with the given ID is completed.
    public static func waitForGroupTaskCompletion (groupId: Int) {
        #if true
        
        var copy_group_id = groupId
        
        gi.object_method_bind_ptrcall_v (WorkerThreadPool.method_wait_for_group_task_completion, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_group_id)
        
        #else
        
        var copy_group_id = groupId
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_group_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (WorkerThreadPool.method_wait_for_group_task_completion, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
}

