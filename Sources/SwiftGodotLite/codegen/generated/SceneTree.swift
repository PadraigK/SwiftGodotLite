// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Manages the game loop via a hierarchy of nodes.
/// 
/// As one of the most important classes, the ``SceneTree`` manages the hierarchy of nodes in a scene as well as scenes themselves. Nodes can be added, retrieved and removed. The whole scene tree (and thus the current scene) can be paused. Scenes can be loaded, switched and reloaded.
/// 
/// You can also use the ``SceneTree`` to organize your nodes into groups: every node can be assigned as many groups as you want to create, e.g. an "enemy" group. You can then iterate these groups or even call methods and set properties on all the group's members at once.
/// 
/// ``SceneTree`` is the default ``MainLoop`` implementation used by scenes, and is thus in charge of the game loop.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``treeChanged``
/// - ``treeProcessModeChanged``
/// - ``nodeAdded``
/// - ``nodeRemoved``
/// - ``nodeRenamed``
/// - ``nodeConfigurationWarningChanged``
/// - ``processFrame``
/// - ``physicsFrame``
open class SceneTree: MainLoop {
    override open class var godotClassName: StringName { "SceneTree" }
    public enum GroupCallFlags: Int64 {
        /// Call a group with no flags (default).
        case `default` = 0 // GROUP_CALL_DEFAULT
        /// Call a group in reverse scene order.
        case reverse = 1 // GROUP_CALL_REVERSE
        /// Call a group at the end of the current frame (process or physics).
        case deferred = 2 // GROUP_CALL_DEFERRED
        /// Call a group only once even if the call is executed many times.
        /// 
        /// > Note: Arguments are not taken into account when deciding whether the call is unique or not. Therefore when the same method is called with different arguments, only the first call will be performed.
        /// 
        case unique = 4 // GROUP_CALL_UNIQUE
    }
    
    
    /* Properties */
    
    /// If `true`, the application automatically accepts quitting requests.
    /// 
    /// For mobile platforms, see ``quitOnGoBack``.
    /// 
    final public var autoAcceptQuit: Bool {
        get {
            return is_auto_accept_quit ()
        }
        
        set {
            set_auto_accept_quit (newValue)
        }
        
    }
    
    /// If `true`, the application quits automatically when navigating back (e.g. using the system "Back" button on Android).
    /// 
    /// To handle 'Go Back' button when this option is disabled, use ``DisplayServer/WindowEvent/goBackRequest``.
    /// 
    final public var quitOnGoBack: Bool {
        get {
            return is_quit_on_go_back ()
        }
        
        set {
            set_quit_on_go_back (newValue)
        }
        
    }
    
    /// If `true`, collision shapes will be visible when running the game from the editor for debugging purposes.
    /// 
    /// > Note: This property is not designed to be changed at run-time. Changing the value of ``debugCollisionsHint`` while the project is running will not have the desired effect.
    /// 
    final public var debugCollisionsHint: Bool {
        get {
            return is_debugging_collisions_hint ()
        }
        
        set {
            set_debug_collisions_hint (newValue)
        }
        
    }
    
    /// If `true`, curves from ``Path2D`` and ``Path3D`` nodes will be visible when running the game from the editor for debugging purposes.
    /// 
    /// > Note: This property is not designed to be changed at run-time. Changing the value of ``debugPathsHint`` while the project is running will not have the desired effect.
    /// 
    final public var debugPathsHint: Bool {
        get {
            return is_debugging_paths_hint ()
        }
        
        set {
            set_debug_paths_hint (newValue)
        }
        
    }
    
    /// If `true`, navigation polygons will be visible when running the game from the editor for debugging purposes.
    /// 
    /// > Note: This property is not designed to be changed at run-time. Changing the value of ``debugNavigationHint`` while the project is running will not have the desired effect.
    /// 
    final public var debugNavigationHint: Bool {
        get {
            return is_debugging_navigation_hint ()
        }
        
        set {
            set_debug_navigation_hint (newValue)
        }
        
    }
    
    /// If `true`, the ``SceneTree`` is paused. Doing so will have the following behavior:
    /// 
    /// - 2D and 3D physics will be stopped. This includes signals and collision detection.
    /// 
    /// - ``Node/_process(delta:)``, ``Node/_physicsProcess(delta:)`` and ``Node/_input(event:)`` will not be called anymore in nodes.
    /// 
    final public var paused: Bool {
        get {
            return is_paused ()
        }
        
        set {
            set_pause (newValue)
        }
        
    }
    
    /// The root of the edited scene.
    final public var editedSceneRoot: Node? {
        get {
            return get_edited_scene_root ()
        }
        
        set {
            set_edited_scene_root (newValue)
        }
        
    }
    
    /// Returns the root node of the currently running scene, regardless of its structure.
    /// 
    /// > Warning: Setting this directly might not work as expected, and will _not_ add or remove any nodes from the tree, consider using ``changeSceneToFile(path:)`` or ``changeSceneToPacked(packedScene:)`` instead.
    /// 
    final public var currentScene: Node? {
        get {
            return get_current_scene ()
        }
        
        set {
            set_current_scene (newValue)
        }
        
    }
    
    /// The ``SceneTree``'s root ``Window``.
    final public var root: Window? {
        get {
            return get_root ()
        }
        
    }
    
    /// If `true` (default value), enables automatic polling of the ``MultiplayerAPI`` for this SceneTree during [signal process_frame].
    /// 
    /// If `false`, you need to manually call ``MultiplayerAPI/poll()`` to process network packets and deliver RPCs. This allows running RPCs in a different loop (e.g. physics, thread, specific time step) and for manual ``Mutex`` protection when accessing the ``MultiplayerAPI`` from threads.
    /// 
    final public var multiplayerPoll: Bool {
        get {
            return is_multiplayer_poll_enabled ()
        }
        
        set {
            set_multiplayer_poll_enabled (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_root: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1757182445)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_root ()-> Window? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (SceneTree.method_get_root, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_has_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_group")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the given group exists.
    /// 
    /// A group exists if any ``Node`` in the tree belongs to it (see ``Node/addToGroup(_:persistent:)``). Groups without nodes are removed automatically.
    /// 
    public final func hasGroup (name: StringName)-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_has_group, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_has_group, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_auto_accept_quit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_auto_accept_quit")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_accept_quit ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (SceneTree.method_is_auto_accept_quit, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_accept_quit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_auto_accept_quit")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_accept_quit (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_auto_accept_quit, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_auto_accept_quit, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_quit_on_go_back: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_quit_on_go_back")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_quit_on_go_back ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (SceneTree.method_is_quit_on_go_back, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_quit_on_go_back: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_quit_on_go_back")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_quit_on_go_back (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_quit_on_go_back, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_quit_on_go_back, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_debug_collisions_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_debug_collisions_hint")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_debug_collisions_hint (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_debug_collisions_hint, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_debug_collisions_hint, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_debugging_collisions_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_debugging_collisions_hint")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_debugging_collisions_hint ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (SceneTree.method_is_debugging_collisions_hint, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_debug_paths_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_debug_paths_hint")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_debug_paths_hint (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_debug_paths_hint, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_debug_paths_hint, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_debugging_paths_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_debugging_paths_hint")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_debugging_paths_hint ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (SceneTree.method_is_debugging_paths_hint, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_debug_navigation_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_debug_navigation_hint")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_debug_navigation_hint (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_debug_navigation_hint, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_debug_navigation_hint, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_debugging_navigation_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_debugging_navigation_hint")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_debugging_navigation_hint ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (SceneTree.method_is_debugging_navigation_hint, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_edited_scene_root: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_edited_scene_root")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_edited_scene_root (_ scene: Node?) {
        #if true
        
        var copy_scene_handle = scene?.handle
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_edited_scene_root, UnsafeMutableRawPointer (mutating: handle), nil, &copy_scene_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: scene?.handle) { p0 in
        _args.append (scene == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_edited_scene_root, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_edited_scene_root: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_edited_scene_root")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3160264692)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_edited_scene_root ()-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (SceneTree.method_get_edited_scene_root, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_pause: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_pause")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_pause (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_pause, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_pause, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_paused: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_paused")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_paused ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (SceneTree.method_is_paused, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_create_timer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_timer")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2709170273)!
            }
            
        }
        
    }()
    
    /// Returns a ``SceneTreeTimer`` which will emit [signal SceneTreeTimer.timeout] after the given time in seconds elapsed in this ``SceneTree``.
    /// 
    /// If `processAlways` is set to `false`, pausing the ``SceneTree`` will also pause the timer.
    /// 
    /// If `processInPhysics` is set to `true`, will update the ``SceneTreeTimer`` during the physics frame instead of the process frame (fixed framerate processing).
    /// 
    /// If `ignoreTimeScale` is set to `true`, will ignore ``Engine/timeScale`` and update the ``SceneTreeTimer`` with the actual frame delta.
    /// 
    /// Commonly used to create a one-shot delay timer as in the following example:
    /// 
    /// The timer will be automatically freed after its time elapses.
    /// 
    /// > Note: The timer is processed after all of the nodes in the current frame, i.e. node's ``Node/_process(delta:)`` method would be called before the timer (or ``Node/_physicsProcess(delta:)`` if `processInPhysics` is set to `true`).
    /// 
    public final func createTimer (timeSec: Double, processAlways: Bool = true, processInPhysics: Bool = false, ignoreTimeScale: Bool = false)-> SceneTreeTimer? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_time_sec = timeSec
        var copy_process_always = processAlways
        var copy_process_in_physics = processInPhysics
        var copy_ignore_time_scale = ignoreTimeScale
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_create_timer, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_time_sec, &copy_process_always, &copy_process_in_physics, &copy_ignore_time_scale)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_time_sec = timeSec
        var copy_process_always = processAlways
        var copy_process_in_physics = processInPhysics
        var copy_ignore_time_scale = ignoreTimeScale
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_time_sec) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_process_always) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_process_in_physics) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_ignore_time_scale) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (SceneTree.method_create_timer, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_create_tween: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_tween")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3426978995)!
            }
            
        }
        
    }()
    
    /// Creates and returns a new ``Tween``. The Tween will start automatically on the next process frame or physics frame (depending on ``Tween.TweenProcessMode``).
    /// 
    /// > Note: When creating a ``Tween`` using this method, the ``Tween`` will not be tied to the ``Node`` that called it. It will continue to animate even if the ``Node`` is freed, but it will automatically finish if there's nothing left to animate. If you want the ``Tween`` to be automatically killed when the ``Node`` is freed, use ``Node/createTween()`` or ``Tween/bindNode(_:)``.
    /// 
    public final func createTween ()-> Tween? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (SceneTree.method_create_tween, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_processed_tweens: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_processed_tweens")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2915620761)!
            }
            
        }
        
    }()
    
    /// Returns an array of currently existing ``Tween``s in the ``SceneTree`` (both running and paused).
    public final func getProcessedTweens ()-> ObjectCollection<Tween> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (SceneTree.method_get_processed_tweens, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return ObjectCollection<Tween>(content: _result)
    }
    
    fileprivate static var method_get_node_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_node_count")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of nodes in this ``SceneTree``.
    public final func getNodeCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (SceneTree.method_get_node_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_frame")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the current frame number, i.e. the total frame count since the application started.
    public final func getFrame ()-> Int {
        var _result: Int = 0
        gi.object_method_bind_ptrcall (SceneTree.method_get_frame, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_quit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("quit")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1995695955)!
            }
            
        }
        
    }()
    
    /// Quits the application at the end of the current iteration. Argument `exitCode` can optionally be given (defaulting to 0) to customize the exit status code.
    /// 
    /// By convention, an exit code of `0` indicates success whereas a non-zero exit code indicates an error.
    /// 
    /// For portability reasons, the exit code should be set between 0 and 125 (inclusive).
    /// 
    /// > Note: On iOS this method doesn't work. Instead, as recommended by the iOS Human Interface Guidelines, the user is expected to close apps via the Home button.
    /// 
    public final func quit (exitCode: Int32 = 0) {
        #if true
        
        var copy_exit_code: Int = Int (exitCode)
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_quit, UnsafeMutableRawPointer (mutating: handle), nil, &copy_exit_code)
        
        #else
        
        var copy_exit_code: Int = Int (exitCode)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_exit_code) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_quit, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_queue_delete: GDExtensionMethodBindPtr = {
        let methodName = StringName ("queue_delete")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3975164845)!
            }
            
        }
        
    }()
    
    /// Queues the given object for deletion, delaying the call to ``Object/free()`` to the end of the current frame.
    public final func queueDelete (obj: Object?) {
        #if true
        
        var copy_obj_handle = obj?.handle
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_queue_delete, UnsafeMutableRawPointer (mutating: handle), nil, &copy_obj_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: obj?.handle) { p0 in
        _args.append (obj == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_queue_delete, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_call_group_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName ("call_group_flags")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1527739229)!
            }
            
        }
        
    }()
    
    /// Calls `method` on each member of the given group, respecting the given ``SceneTree/GroupCallFlags``. You can pass arguments to `method` by specifying them at the end of the method call. If a node doesn't have the given method or the argument list does not match (either in count or in types), it will be skipped.
    /// 
    /// > Note: Group call flags are used to control the method calling behavior. By default, methods will be called immediately in a way similar to ``callGroup(_:method:)``. However, if the .groupCallDeferred flag is present in the `flags` argument, methods will be called at the end of the frame in a way similar to ``Object/setDeferred(property:value:)``.
    /// 
    public final func callGroupFlags (_ flags: Int64, group: StringName, method: StringName, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_flags = Variant (flags)
        let copy_group = Variant (group)
        let copy_method = Variant (method)
        
        gi.object_method_bind_call_v (SceneTree.method_call_group_flags, UnsafeMutableRawPointer (mutating: handle), &_result, nil, &copy_flags.content, &copy_group.content, &copy_method.content)
        
        #else
        
        let copy_flags = Variant (flags)
        let copy_group = Variant (group)
        let copy_method = Variant (method)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_flags.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_group.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_method.content) { p2 in
                    _args.append (p2)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
                    gi.object_method_bind_call (SceneTree.method_call_group_flags, UnsafeMutableRawPointer (mutating: handle), &_args, Int64 (_args.count), &_result, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_notify_group_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName ("notify_group_flags")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1245489420)!
            }
            
        }
        
    }()
    
    /// Sends the given notification to all members of the `group`, respecting the given ``SceneTree/GroupCallFlags``.
    /// 
    /// > Note: Group call flags are used to control the notification sending behavior. By default, notifications will be sent immediately in a way similar to ``notifyGroup(_:notification:)``. However, if the .groupCallDeferred flag is present in the `callFlags` argument, notifications will be sent at the end of the current frame in a way similar to using `Object.call_deferred("notification", ...)`.
    /// 
    public final func notifyGroupFlags (callFlags: UInt32, group: StringName, notification: Int32) {
        #if true
        
        var copy_call_flags: Int = Int (callFlags)
        var copy_notification: Int = Int (notification)
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_notify_group_flags, UnsafeMutableRawPointer (mutating: handle), nil, &copy_call_flags, &group.content, &copy_notification)
        
        #else
        
        var copy_call_flags: Int = Int (callFlags)
        var copy_notification: Int = Int (notification)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_call_flags) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &group.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_notification) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (SceneTree.method_notify_group_flags, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_group_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_group_flags")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3497599527)!
            }
            
        }
        
    }()
    
    /// Sets the given `property` to `value` on all members of the given group, respecting the given ``SceneTree/GroupCallFlags``.
    /// 
    /// > Note: Group call flags are used to control the property setting behavior. By default, properties will be set immediately in a way similar to ``setGroup(_:property:value:)``. However, if the .groupCallDeferred flag is present in the `callFlags` argument, properties will be set at the end of the frame in a way similar to ``Object/callDeferred(method:)``.
    /// 
    public final func setGroupFlags (callFlags: UInt32, group: StringName, property: String, value: Variant) {
        #if true
        
        var copy_call_flags: Int = Int (callFlags)
        let gstr_property = GString (property)
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_group_flags, UnsafeMutableRawPointer (mutating: handle), nil, &copy_call_flags, &group.content, &gstr_property.content, &value.content)
        
        #else
        
        var copy_call_flags: Int = Int (callFlags)
        let gstr_property = GString (property)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_call_flags) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &group.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_property.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &value.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (SceneTree.method_set_group_flags, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_call_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("call_group")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1257962832)!
            }
            
        }
        
    }()
    
    /// Calls `method` on each member of the given group. You can pass arguments to `method` by specifying them at the end of the method call. If a node doesn't have the given method or the argument list does not match (either in count or in types), it will be skipped.
    /// 
    /// > Note: ``callGroup(_:method:)`` will call methods immediately on all members at once, which can cause stuttering if an expensive method is called on lots of members.
    /// 
    public final func callGroup (_ group: StringName, method: StringName, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_group = Variant (group)
        let copy_method = Variant (method)
        
        gi.object_method_bind_call_v (SceneTree.method_call_group, UnsafeMutableRawPointer (mutating: handle), &_result, nil, &copy_group.content, &copy_method.content)
        
        #else
        
        let copy_group = Variant (group)
        let copy_method = Variant (method)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_group.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_method.content) { p1 in
                _args.append (p1)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
                gi.object_method_bind_call (SceneTree.method_call_group, UnsafeMutableRawPointer (mutating: handle), &_args, Int64 (_args.count), &_result, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_notify_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("notify_group")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2415702435)!
            }
            
        }
        
    }()
    
    /// Sends the given notification to all members of the `group`.
    /// 
    /// > Note: ``notifyGroup(_:notification:)`` will immediately notify all members at once, which can cause stuttering if an expensive method is called as a result of sending the notification to lots of members.
    /// 
    public final func notifyGroup (_ group: StringName, notification: Int32) {
        #if true
        
        var copy_notification: Int = Int (notification)
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_notify_group, UnsafeMutableRawPointer (mutating: handle), nil, &group.content, &copy_notification)
        
        #else
        
        var copy_notification: Int = Int (notification)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &group.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_notification) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (SceneTree.method_notify_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_group")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1279312029)!
            }
            
        }
        
    }()
    
    /// Sets the given `property` to `value` on all members of the given group.
    /// 
    /// > Note: ``setGroup(_:property:value:)`` will set the property immediately on all members at once, which can cause stuttering if a property with an expensive setter is set on lots of members.
    /// 
    public final func setGroup (_ group: StringName, property: String, value: Variant) {
        #if true
        
        let gstr_property = GString (property)
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_group, UnsafeMutableRawPointer (mutating: handle), nil, &group.content, &gstr_property.content, &value.content)
        
        #else
        
        let gstr_property = GString (property)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &group.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_property.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &value.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (SceneTree.method_set_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_nodes_in_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_nodes_in_group")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 689397652)!
            }
            
        }
        
    }()
    
    /// Returns a list of all nodes assigned to the given group.
    public final func getNodesInGroup (_ group: StringName)-> ObjectCollection<Node> {
        var _result: Int64 = 0
        #if true
        
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_get_nodes_in_group, UnsafeMutableRawPointer (mutating: handle), &_result, &group.content)
        return ObjectCollection<Node>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &group.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_get_nodes_in_group, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return ObjectCollection<Node>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_get_first_node_in_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_first_node_in_group")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4071044623)!
            }
            
        }
        
    }()
    
    /// Returns the first node in the specified group, or `null` if the group is empty or does not exist.
    public final func getFirstNodeInGroup (_ group: StringName)-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_get_first_node_in_group, UnsafeMutableRawPointer (mutating: handle), &_result, &group.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &group.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_get_first_node_in_group, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_current_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_current_scene")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_current_scene (_ childNode: Node?) {
        #if true
        
        var copy_child_node_handle = childNode?.handle
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_current_scene, UnsafeMutableRawPointer (mutating: handle), nil, &copy_child_node_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: childNode?.handle) { p0 in
        _args.append (childNode == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_current_scene, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_current_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_current_scene")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3160264692)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_current_scene ()-> Node? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (SceneTree.method_get_current_scene, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_change_scene_to_file: GDExtensionMethodBindPtr = {
        let methodName = StringName ("change_scene_to_file")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 166001499)!
            }
            
        }
        
    }()
    
    /// Changes the running scene to the one at the given `path`, after loading it into a ``PackedScene`` and creating a new instance.
    /// 
    /// Returns ``GodotError/ok`` on success, ``GodotError/errCantOpen`` if the `path` cannot be loaded into a ``PackedScene``, or ``GodotError/errCantCreate`` if that scene cannot be instantiated.
    /// 
    /// > Note: See ``changeSceneToPacked(packedScene:)`` for details on the order of operations.
    /// 
    public final func changeSceneToFile (path: String)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        let gstr_path = GString (path)
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_change_scene_to_file, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_path.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_path = GString (path)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_change_scene_to_file, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return GodotError (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_change_scene_to_packed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("change_scene_to_packed")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 107349098)!
            }
            
        }
        
    }()
    
    /// Changes the running scene to a new instance of the given ``PackedScene`` (which must be valid).
    /// 
    /// Returns ``GodotError/ok`` on success, ``GodotError/errCantCreate`` if the scene cannot be instantiated, or ``GodotError/errInvalidParameter`` if the scene is invalid.
    /// 
    /// > Note: Operations happen in the following order when ``changeSceneToPacked(packedScene:)`` is called:
    /// 
    /// 1. The current scene node is immediately removed from the tree. From that point, ``Node/getTree()`` called on the current (outgoing) scene will return `null`. ``currentScene`` will be `null`, too, because the new scene is not available yet.
    /// 
    /// 2. At the end of the frame, the formerly current scene, already removed from the tree, will be deleted (freed from memory) and then the new scene will be instantiated and added to the tree. ``Node/getTree()`` and ``currentScene`` will be back to working as usual.
    /// 
    /// This ensures that both scenes aren't running at the same time, while still freeing the previous scene in a safe way similar to ``Node/queueFree()``.
    /// 
    public final func changeSceneToPacked (packedScene: PackedScene?)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_packed_scene_handle = packedScene?.handle
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_change_scene_to_packed, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_packed_scene_handle)
        return GodotError (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: packedScene?.handle) { p0 in
        _args.append (packedScene == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_change_scene_to_packed, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return GodotError (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_reload_current_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reload_current_scene")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Reloads the currently active scene.
    /// 
    /// Returns ``GodotError/ok`` on success, ``GodotError/errUnconfigured`` if no ``currentScene`` was defined yet, ``GodotError/errCantOpen`` if ``currentScene`` cannot be loaded into a ``PackedScene``, or ``GodotError/errCantCreate`` if the scene cannot be instantiated.
    /// 
    public final func reloadCurrentScene ()-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (SceneTree.method_reload_current_scene, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_unload_current_scene: GDExtensionMethodBindPtr = {
        let methodName = StringName ("unload_current_scene")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// If a current scene is loaded, calling this method will unload it.
    public final func unloadCurrentScene () {
        gi.object_method_bind_ptrcall (SceneTree.method_unload_current_scene, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_multiplayer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_multiplayer")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2385607013)!
            }
            
        }
        
    }()
    
    /// Sets a custom ``MultiplayerAPI`` with the given `rootPath` (controlling also the relative subpaths), or override the default one if `rootPath` is empty.
    /// 
    /// > Note: No ``MultiplayerAPI`` must be configured for the subpath containing `rootPath`, nested custom multiplayers are not allowed. I.e. if one is configured for `"/root/Foo"` setting one for `"/root/Foo/Bar"` will cause an error.
    /// 
    public final func setMultiplayer (_ multiplayer: MultiplayerAPI?, rootPath: NodePath = NodePath("")) {
        #if true
        
        var copy_multiplayer_handle = multiplayer?.handle
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_multiplayer, UnsafeMutableRawPointer (mutating: handle), nil, &copy_multiplayer_handle, &rootPath.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: multiplayer?.handle) { p0 in
        _args.append (multiplayer == nil ? nil : p0)
            withUnsafePointer (to: &rootPath.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (SceneTree.method_set_multiplayer, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_multiplayer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_multiplayer")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3453401404)!
            }
            
        }
        
    }()
    
    /// Searches for the ``MultiplayerAPI`` configured for the given path, if one does not exist it searches the parent paths until one is found. If the path is empty, or none is found, the default one is returned. See ``setMultiplayer(_:rootPath:)``.
    public final func getMultiplayer (forPath: NodePath = NodePath(""))-> MultiplayerAPI? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_get_multiplayer, UnsafeMutableRawPointer (mutating: handle), &_result, &forPath.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &forPath.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_get_multiplayer, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_multiplayer_poll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_multiplayer_poll_enabled")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_multiplayer_poll_enabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (SceneTree.method_set_multiplayer_poll_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (SceneTree.method_set_multiplayer_poll_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_multiplayer_poll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_multiplayer_poll_enabled")
        return withUnsafePointer (to: &SceneTree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_multiplayer_poll_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (SceneTree.method_is_multiplayer_poll_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    // Signals 
    /// Emitted whenever the ``SceneTree`` hierarchy changed (children being moved or renamed, etc.).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.treeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var treeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "tree_changed") }
    
    /// This signal is only emitted in the editor, it allows the editor to update the visibility of disabled nodes. Emitted whenever any node's ``Node/processMode`` is changed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.treeProcessModeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var treeProcessModeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "tree_process_mode_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted whenever a node is added to the ``SceneTree``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeAdded.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeAdded: Signal1 { Signal1 (target: self, signalName: "node_added") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted whenever a node is removed from the ``SceneTree``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeRemoved.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeRemoved: Signal2 { Signal2 (target: self, signalName: "node_removed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted whenever a node is renamed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeRenamed.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeRenamed: Signal3 { Signal3 (target: self, signalName: "node_renamed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Node) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Node ?? Node (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a node's configuration changed. Only emitted in `tool` mode.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nodeConfigurationWarningChanged.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var nodeConfigurationWarningChanged: Signal4 { Signal4 (target: self, signalName: "node_configuration_warning_changed") }
    
    /// Emitted immediately before ``Node/_process(delta:)`` is called on every node in the ``SceneTree``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.processFrame.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var processFrame: SimpleSignal { SimpleSignal (target: self, signalName: "process_frame") }
    
    /// Emitted immediately before ``Node/_physicsProcess(delta:)`` is called on every node in the ``SceneTree``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.physicsFrame.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var physicsFrame: SimpleSignal { SimpleSignal (target: self, signalName: "physics_frame") }
    
}

