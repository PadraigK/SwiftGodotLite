// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A control that displays a texture.
/// 
/// A control that displays a texture, for example an icon inside a GUI. The texture's placement can be controlled with the ``stretchMode`` property. It can scale, tile, or stay centered inside its bounding rectangle.
open class TextureRect: Control {
    override open class var godotClassName: StringName { "TextureRect" }
    public enum ExpandMode: Int64 {
        /// The minimum size will be equal to texture size, i.e. ``TextureRect`` can't be smaller than the texture.
        case keepSize = 0 // EXPAND_KEEP_SIZE
        /// The size of the texture won't be considered for minimum size calculation, so the ``TextureRect`` can be shrunk down past the texture size.
        case ignoreSize = 1 // EXPAND_IGNORE_SIZE
        /// The height of the texture will be ignored. Minimum width will be equal to the current height. Useful for horizontal layouts, e.g. inside ``HBoxContainer``.
        case fitWidth = 2 // EXPAND_FIT_WIDTH
        /// Same as .expandFitWidth, but keeps texture's aspect ratio.
        case fitWidthProportional = 3 // EXPAND_FIT_WIDTH_PROPORTIONAL
        /// The width of the texture will be ignored. Minimum height will be equal to the current width. Useful for vertical layouts, e.g. inside ``VBoxContainer``.
        case fitHeight = 4 // EXPAND_FIT_HEIGHT
        /// Same as .expandFitHeight, but keeps texture's aspect ratio.
        case fitHeightProportional = 5 // EXPAND_FIT_HEIGHT_PROPORTIONAL
    }
    
    public enum StretchMode: Int64 {
        /// Scale to fit the node's bounding rectangle.
        case scale = 0 // STRETCH_SCALE
        /// Tile inside the node's bounding rectangle.
        case tile = 1 // STRETCH_TILE
        /// The texture keeps its original size and stays in the bounding rectangle's top-left corner.
        case keep = 2 // STRETCH_KEEP
        /// The texture keeps its original size and stays centered in the node's bounding rectangle.
        case keepCentered = 3 // STRETCH_KEEP_CENTERED
        /// Scale the texture to fit the node's bounding rectangle, but maintain the texture's aspect ratio.
        case keepAspect = 4 // STRETCH_KEEP_ASPECT
        /// Scale the texture to fit the node's bounding rectangle, center it and maintain its aspect ratio.
        case keepAspectCentered = 5 // STRETCH_KEEP_ASPECT_CENTERED
        /// Scale the texture so that the shorter side fits the bounding rectangle. The other side clips to the node's limits.
        case keepAspectCovered = 6 // STRETCH_KEEP_ASPECT_COVERED
    }
    
    
    /* Properties */
    
    /// The node's ``Texture2D`` resource.
    final public var texture: Texture2D? {
        get {
            return get_texture ()
        }
        
        set {
            set_texture (newValue)
        }
        
    }
    
    /// Defines how minimum size is determined based on the texture's size. See ``TextureRect/ExpandMode`` for options.
    /// 
    /// > Note: Using .expandFitWidth, .expandFitWidthProportional, .expandFitHeight or .expandFitHeightProportional may result in unstable behavior in some containers. This functionality is being re-evaluated and will change in the future.
    /// 
    final public var expandMode: TextureRect.ExpandMode {
        get {
            return get_expand_mode ()
        }
        
        set {
            set_expand_mode (newValue)
        }
        
    }
    
    /// Controls the texture's behavior when resizing the node's bounding rectangle. See ``TextureRect/StretchMode``.
    final public var stretchMode: TextureRect.StretchMode {
        get {
            return get_stretch_mode ()
        }
        
        set {
            set_stretch_mode (newValue)
        }
        
    }
    
    /// If `true`, texture is flipped horizontally.
    final public var flipH: Bool {
        get {
            return is_flipped_h ()
        }
        
        set {
            set_flip_h (newValue)
        }
        
    }
    
    /// If `true`, texture is flipped vertically.
    final public var flipV: Bool {
        get {
            return is_flipped_v ()
        }
        
        set {
            set_flip_v (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_texture")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4051416890)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_texture (_ texture: Texture2D?) {
        #if true
        
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (TextureRect.method_set_texture, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (TextureRect.method_set_texture, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_texture")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3635182373)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_texture ()-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TextureRect.method_get_texture, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_expand_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_expand_mode")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1870766882)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_expand_mode (_ expandMode: TextureRect.ExpandMode) {
        #if true
        
        var copy_expand_mode = Int64 (expandMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextureRect.method_set_expand_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_expand_mode)
        
        #else
        
        var copy_expand_mode = Int64 (expandMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_expand_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextureRect.method_set_expand_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_expand_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_expand_mode")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3863824733)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_expand_mode ()-> TextureRect.ExpandMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TextureRect.method_get_expand_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextureRect.ExpandMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_flip_h: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_flip_h")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_flip_h (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextureRect.method_set_flip_h, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextureRect.method_set_flip_h, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_flipped_h: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_flipped_h")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_flipped_h ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextureRect.method_is_flipped_h, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_flip_v: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_flip_v")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_flip_v (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextureRect.method_set_flip_v, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextureRect.method_set_flip_v, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_flipped_v: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_flipped_v")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_flipped_v ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextureRect.method_is_flipped_v, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_stretch_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_stretch_mode")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 58788729)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_stretch_mode (_ stretchMode: TextureRect.StretchMode) {
        #if true
        
        var copy_stretch_mode = Int64 (stretchMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextureRect.method_set_stretch_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_stretch_mode)
        
        #else
        
        var copy_stretch_mode = Int64 (stretchMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_stretch_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextureRect.method_set_stretch_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_stretch_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_stretch_mode")
        return withUnsafePointer (to: &TextureRect.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 346396079)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_stretch_mode ()-> TextureRect.StretchMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TextureRect.method_get_stretch_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextureRect.StretchMode (rawValue: _result)!
    }
    
}

