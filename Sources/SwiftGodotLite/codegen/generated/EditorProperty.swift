// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Custom control for editing properties that can be added to the ``EditorInspector``.
/// 
/// A custom control for editing properties that can be added to the ``EditorInspector``. It is added via ``EditorInspectorPlugin``.
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``propertyChanged``
/// - ``multiplePropertiesChanged``
/// - ``propertyKeyed``
/// - ``propertyDeleted``
/// - ``propertyKeyedWithValue``
/// - ``propertyChecked``
/// - ``propertyPinned``
/// - ``propertyCanRevertChanged``
/// - ``resourceSelected``
/// - ``objectIdSelected``
/// - ``selected``
open class EditorProperty: Container {
    override open class var godotClassName: StringName { "EditorProperty" }
    
    /* Properties */
    
    /// Set this property to change the label (if you want to show one).
    final public var label: String {
        get {
            return get_label ()
        }
        
        set {
            set_label (newValue)
        }
        
    }
    
    /// Used by the inspector, set to `true` when the property is read-only.
    final public var readOnly: Bool {
        get {
            return is_read_only ()
        }
        
        set {
            set_read_only (newValue)
        }
        
    }
    
    /// Used by the inspector, set to `true` when the property is checkable.
    final public var checkable: Bool {
        get {
            return is_checkable ()
        }
        
        set {
            set_checkable (newValue)
        }
        
    }
    
    /// Used by the inspector, set to `true` when the property is checked.
    final public var checked: Bool {
        get {
            return is_checked ()
        }
        
        set {
            set_checked (newValue)
        }
        
    }
    
    /// Used by the inspector, set to `true` when the property is drawn with the editor theme's warning color. This is used for editable children's properties.
    final public var drawWarning: Bool {
        get {
            return is_draw_warning ()
        }
        
        set {
            set_draw_warning (newValue)
        }
        
    }
    
    /// Used by the inspector, set to `true` when the property can add keys for animation.
    final public var keying: Bool {
        get {
            return is_keying ()
        }
        
        set {
            set_keying (newValue)
        }
        
    }
    
    /// Used by the inspector, set to `true` when the property can be deleted by the user.
    final public var deletable: Bool {
        get {
            return is_deletable ()
        }
        
        set {
            set_deletable (newValue)
        }
        
    }
    
    /* Methods */
    /// When this virtual function is called, you must update your editor.
    @_documentation(visibility: public)
    open func _updateProperty () {
    }
    
    /// Called when the read-only status of the property is changed. It may be used to change custom controls into a read-only or modifiable state.
    @_documentation(visibility: public)
    open func _setReadOnly (_ readOnly: Bool) {
    }
    
    fileprivate static var method_set_label: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_label")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_label (_ text: String) {
        #if false
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_set_label, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_set_label, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_label: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_label")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_label ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (EditorProperty.method_get_label, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_read_only: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_read_only")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_read_only (_ readOnly: Bool) {
        #if false
        
        var copy_read_only = readOnly
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_set_read_only, UnsafeMutableRawPointer (mutating: handle), nil, &copy_read_only)
        
        #else
        
        var copy_read_only = readOnly
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_read_only) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_set_read_only, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_read_only: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_read_only")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_read_only ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (EditorProperty.method_is_read_only, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_checkable")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_checkable (_ checkable: Bool) {
        #if false
        
        var copy_checkable = checkable
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_set_checkable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_checkable)
        
        #else
        
        var copy_checkable = checkable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_checkable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_set_checkable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_checkable")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_checkable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (EditorProperty.method_is_checkable, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_checked")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_checked (_ checked: Bool) {
        #if false
        
        var copy_checked = checked
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_set_checked, UnsafeMutableRawPointer (mutating: handle), nil, &copy_checked)
        
        #else
        
        var copy_checked = checked
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_checked) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_set_checked, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_checked")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_checked ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (EditorProperty.method_is_checked, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_warning: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_warning")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_warning (_ drawWarning: Bool) {
        #if false
        
        var copy_draw_warning = drawWarning
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_set_draw_warning, UnsafeMutableRawPointer (mutating: handle), nil, &copy_draw_warning)
        
        #else
        
        var copy_draw_warning = drawWarning
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_draw_warning) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_set_draw_warning, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_draw_warning: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_draw_warning")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_draw_warning ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (EditorProperty.method_is_draw_warning, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_keying: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_keying")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_keying (_ keying: Bool) {
        #if false
        
        var copy_keying = keying
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_set_keying, UnsafeMutableRawPointer (mutating: handle), nil, &copy_keying)
        
        #else
        
        var copy_keying = keying
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_keying) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_set_keying, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_keying: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_keying")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_keying ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (EditorProperty.method_is_keying, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_deletable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_deletable")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_deletable (_ deletable: Bool) {
        #if false
        
        var copy_deletable = deletable
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_set_deletable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_deletable)
        
        #else
        
        var copy_deletable = deletable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_deletable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_set_deletable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_deletable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_deletable")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_deletable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (EditorProperty.method_is_deletable, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_edited_property: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_edited_property")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2002593661)!
            }
            
        }
        
    }()
    
    /// Gets the edited property. If your editor is for a single property (added via ``EditorInspectorPlugin/_parseProperty(object:type:name:hintType:hintString:usageFlags:wide:)``), then this will return the property.
    public final func getEditedProperty ()-> StringName {
        let _result: StringName = StringName ()
        gi.object_method_bind_ptrcall (EditorProperty.method_get_edited_property, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_edited_object: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_edited_object")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2050059866)!
            }
            
        }
        
    }()
    
    /// Gets the edited object.
    public final func getEditedObject ()-> Object? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (EditorProperty.method_get_edited_object, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_update_property: GDExtensionMethodBindPtr = {
        let methodName = StringName ("update_property")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Forces refresh of the property display.
    public final func updateProperty () {
        gi.object_method_bind_ptrcall (EditorProperty.method_update_property, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_add_focusable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_focusable")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1496901182)!
            }
            
        }
        
    }()
    
    /// If any of the controls added can gain keyboard focus, add it here. This ensures that focus will be restored if the inspector is refreshed.
    public final func addFocusable (control: Control?) {
        #if false
        
        var copy_control_handle = control?.handle
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_add_focusable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_control_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: control?.handle) { p0 in
        _args.append (control == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_add_focusable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_bottom_editor: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_bottom_editor")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1496901182)!
            }
            
        }
        
    }()
    
    /// Puts the `editor` control below the property label. The control must be previously added using ``Node/addChild(node:forceReadableName:`internal`:)``.
    public final func setBottomEditor (_ editor: Control?) {
        #if false
        
        var copy_editor_handle = editor?.handle
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_set_bottom_editor, UnsafeMutableRawPointer (mutating: handle), nil, &copy_editor_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: editor?.handle) { p0 in
        _args.append (editor == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (EditorProperty.method_set_bottom_editor, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_emit_changed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("emit_changed")
        return withUnsafePointer (to: &EditorProperty.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3069422438)!
            }
            
        }
        
    }()
    
    /// If one or several properties have changed, this must be called. `field` is used in case your editor can modify fields separately (as an example, Vector3.x). The `changing` argument avoids the editor requesting this property to be refreshed (leave as `false` if unsure).
    public final func emitChanged (property: StringName, value: Variant, field: StringName = StringName (""), changing: Bool = false) {
        #if false
        
        var copy_changing = changing
        
        gi.object_method_bind_ptrcall_v (EditorProperty.method_emit_changed, UnsafeMutableRawPointer (mutating: handle), nil, &property.content, &value.content, &field.content, &copy_changing)
        
        #else
        
        var copy_changing = changing
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &property.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &value.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &field.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_changing) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (EditorProperty.method_emit_changed, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_set_read_only":
                return _EditorProperty_proxy_set_read_only
            case "_update_property":
                return _EditorProperty_proxy_update_property
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ property: StringName, _ value: Variant, _ field: StringName, _ changing: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = args [1]
                let arg_2 = StringName (args [2])!
                let arg_3 = Bool (args [3])!
                
                callback (arg_0, arg_1, arg_2, arg_3)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Do not emit this manually, use the ``emitChanged(property:value:field:changing:)`` method instead.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.propertyChanged.connect { property, value, field, changing in
    ///    print ("caught signal")
    /// }
    /// ```
    public var propertyChanged: Signal1 { Signal1 (target: self, signalName: "property_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ properties: PackedStringArray, _ value: GArray) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = PackedStringArray (args [0])!
                let arg_1 = GArray (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emit it if you want multiple properties modified at the same time. Do not use if added via ``EditorInspectorPlugin/_parseProperty(object:type:name:hintType:hintString:usageFlags:wide:)``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.multiplePropertiesChanged.connect { properties, value in
    ///    print ("caught signal")
    /// }
    /// ```
    public var multiplePropertiesChanged: Signal2 { Signal2 (target: self, signalName: "multiple_properties_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ property: StringName) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emit it if you want to add this value as an animation key (check for keying being enabled first).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.propertyKeyed.connect { property in
    ///    print ("caught signal")
    /// }
    /// ```
    public var propertyKeyed: Signal3 { Signal3 (target: self, signalName: "property_keyed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ property: StringName) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a property was deleted. Used internally.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.propertyDeleted.connect { property in
    ///    print ("caught signal")
    /// }
    /// ```
    public var propertyDeleted: Signal4 { Signal4 (target: self, signalName: "property_deleted") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ property: StringName, _ value: Variant) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = args [1]
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emit it if you want to key a property with a single value.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.propertyKeyedWithValue.connect { property, value in
    ///    print ("caught signal")
    /// }
    /// ```
    public var propertyKeyedWithValue: Signal5 { Signal5 (target: self, signalName: "property_keyed_with_value") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal6/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal6/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal6/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal6 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal6 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ property: StringName, _ checked: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Bool (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a property was checked. Used internally.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.propertyChecked.connect { property, checked in
    ///    print ("caught signal")
    /// }
    /// ```
    public var propertyChecked: Signal6 { Signal6 (target: self, signalName: "property_checked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal7/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal7/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal7/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal7 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal7 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ property: StringName, _ pinned: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Bool (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emit it if you want to mark (or unmark) the value of a property for being saved regardless of being equal to the default value.
    /// 
    /// The default value is the one the property will get when the node is just instantiated and can come from an ancestor scene in the inheritance/instantiation chain, a script or a builtin class.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.propertyPinned.connect { property, pinned in
    ///    print ("caught signal")
    /// }
    /// ```
    public var propertyPinned: Signal7 { Signal7 (target: self, signalName: "property_pinned") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal8/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal8/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal8/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal8 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal8 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ property: StringName, _ canRevert: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Bool (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the revertability (i.e., whether it has a non-default value and thus is displayed with a revert icon) of a property has changed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.propertyCanRevertChanged.connect { property, canRevert in
    ///    print ("caught signal")
    /// }
    /// ```
    public var propertyCanRevertChanged: Signal8 { Signal8 (target: self, signalName: "property_can_revert_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal9/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal9/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal9/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal9 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal9 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ path: String, _ resource: Resource) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                var ptr_1: UnsafeMutableRawPointer?
                args [1].toType (Variant.GType.object, dest: &ptr_1)
                let arg_1 = lookupLiveObject (handleAddress: ptr_1!) as? Resource ?? Resource (nativeHandle: ptr_1!)
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// If you want a sub-resource to be edited, emit this signal with the resource.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.resourceSelected.connect { path, resource in
    ///    print ("caught signal")
    /// }
    /// ```
    public var resourceSelected: Signal9 { Signal9 (target: self, signalName: "resource_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal10/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal10/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal10/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal10 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal10 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ property: StringName, _ id: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                let arg_1 = Int64 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Used by sub-inspectors. Emit it if what was selected was an Object ID.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.objectIdSelected.connect { property, id in
    ///    print ("caught signal")
    /// }
    /// ```
    public var objectIdSelected: Signal10 { Signal10 (target: self, signalName: "object_id_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal11/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal11/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal11/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal11 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal11 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ path: String, _ focusableIdx: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                let arg_1 = Int64 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when selected. Used internally.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.selected.connect { path, focusableIdx in
    ///    print ("caught signal")
    /// }
    /// ```
    public var selected: Signal11 { Signal11 (target: self, signalName: "selected") }
    
}

// Support methods for proxies
func _EditorProperty_proxy_set_read_only (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EditorProperty>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._setReadOnly (args [0]!.assumingMemoryBound (to: Bool.self).pointee)
}

func _EditorProperty_proxy_update_property (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<EditorProperty>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._updateProperty ()
}

