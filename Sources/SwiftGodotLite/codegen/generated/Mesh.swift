// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A ``Resource`` that contains vertex array-based geometry.
/// 
/// Mesh is a type of ``Resource`` that contains vertex array-based geometry, divided in _surfaces_. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
open class Mesh: Resource {
    override open class var godotClassName: StringName { "Mesh" }
    public enum PrimitiveType: Int64 {
        /// Render array as points (one vertex equals one point).
        case points = 0 // PRIMITIVE_POINTS
        /// Render array as lines (every two vertices a line is created).
        case lines = 1 // PRIMITIVE_LINES
        /// Render array as line strip.
        case lineStrip = 2 // PRIMITIVE_LINE_STRIP
        /// Render array as triangles (every three vertices a triangle is created).
        case triangles = 3 // PRIMITIVE_TRIANGLES
        /// Render array as triangle strips.
        case triangleStrip = 4 // PRIMITIVE_TRIANGLE_STRIP
    }
    
    public enum ArrayType: Int64 {
        /// ``PackedVector3Array``, ``PackedVector2Array``, or ``GArray`` of vertex positions.
        case vertex = 0 // ARRAY_VERTEX
        /// ``PackedVector3Array`` of vertex normals.
        case normal = 1 // ARRAY_NORMAL
        /// ``PackedFloat32Array`` of vertex tangents. Each element in groups of 4 floats, first 3 floats determine the tangent, and the last the binormal direction as -1 or 1.
        case tangent = 2 // ARRAY_TANGENT
        /// ``PackedColorArray`` of vertex colors.
        case color = 3 // ARRAY_COLOR
        /// ``PackedVector2Array`` for UV coordinates.
        case texUv = 4 // ARRAY_TEX_UV
        /// ``PackedVector2Array`` for second UV coordinates.
        case texUv2 = 5 // ARRAY_TEX_UV2
        /// Contains custom color channel 0. ``PackedByteArray`` if `(format >> Mesh.ARRAY_FORMAT_CUSTOM0_SHIFT) & Mesh.ARRAY_FORMAT_CUSTOM_MASK` is .arrayCustomRgba8Unorm, .arrayCustomRgba8Unorm, .arrayCustomRgHalf or .arrayCustomRgbaHalf. ``PackedFloat32Array`` otherwise.
        case custom0 = 6 // ARRAY_CUSTOM0
        /// Contains custom color channel 1. ``PackedByteArray`` if `(format >> Mesh.ARRAY_FORMAT_CUSTOM1_SHIFT) & Mesh.ARRAY_FORMAT_CUSTOM_MASK` is .arrayCustomRgba8Unorm, .arrayCustomRgba8Unorm, .arrayCustomRgHalf or .arrayCustomRgbaHalf. ``PackedFloat32Array`` otherwise.
        case custom1 = 7 // ARRAY_CUSTOM1
        /// Contains custom color channel 2. ``PackedByteArray`` if `(format >> Mesh.ARRAY_FORMAT_CUSTOM2_SHIFT) & Mesh.ARRAY_FORMAT_CUSTOM_MASK` is .arrayCustomRgba8Unorm, .arrayCustomRgba8Unorm, .arrayCustomRgHalf or .arrayCustomRgbaHalf. ``PackedFloat32Array`` otherwise.
        case custom2 = 8 // ARRAY_CUSTOM2
        /// Contains custom color channel 3. ``PackedByteArray`` if `(format >> Mesh.ARRAY_FORMAT_CUSTOM3_SHIFT) & Mesh.ARRAY_FORMAT_CUSTOM_MASK` is .arrayCustomRgba8Unorm, .arrayCustomRgba8Unorm, .arrayCustomRgHalf or .arrayCustomRgbaHalf. ``PackedFloat32Array`` otherwise.
        case custom3 = 9 // ARRAY_CUSTOM3
        /// ``PackedFloat32Array`` or ``PackedInt32Array`` of bone indices. Contains either 4 or 8 numbers per vertex depending on the presence of the .arrayFlagUse8BoneWeights flag.
        case bones = 10 // ARRAY_BONES
        /// ``PackedFloat32Array`` or ``PackedFloat64Array`` of bone weights in the range `0.0` to `1.0` (inclusive). Contains either 4 or 8 numbers per vertex depending on the presence of the .arrayFlagUse8BoneWeights flag.
        case weights = 11 // ARRAY_WEIGHTS
        /// ``PackedInt32Array`` of integers used as indices referencing vertices, colors, normals, tangents, and textures. All of those arrays must have the same number of elements as the vertex array. No index can be beyond the vertex array size. When this index array is present, it puts the function into "index mode," where the index selects the _i_'th vertex, normal, tangent, color, UV, etc. This means if you want to have different normals or colors along an edge, you have to duplicate the vertices.
        /// 
        /// For triangles, the index array is interpreted as triples, referring to the vertices of each triangle. For lines, the index array is in pairs indicating the start and end of each line.
        /// 
        case index = 12 // ARRAY_INDEX
        /// Represents the size of the ``Mesh/ArrayType`` enum.
        case max = 13 // ARRAY_MAX
    }
    
    public enum ArrayCustomFormat: Int64 {
        /// Indicates this custom channel contains unsigned normalized byte colors from 0 to 1, encoded as ``PackedByteArray``.
        case rgba8Unorm = 0 // ARRAY_CUSTOM_RGBA8_UNORM
        /// Indicates this custom channel contains signed normalized byte colors from -1 to 1, encoded as ``PackedByteArray``.
        case rgba8Snorm = 1 // ARRAY_CUSTOM_RGBA8_SNORM
        /// Indicates this custom channel contains half precision float colors, encoded as ``PackedByteArray``. Only red and green channels are used.
        case rgHalf = 2 // ARRAY_CUSTOM_RG_HALF
        /// Indicates this custom channel contains half precision float colors, encoded as ``PackedByteArray``.
        case rgbaHalf = 3 // ARRAY_CUSTOM_RGBA_HALF
        /// Indicates this custom channel contains full float colors, in a ``PackedFloat32Array``. Only the red channel is used.
        case rFloat = 4 // ARRAY_CUSTOM_R_FLOAT
        /// Indicates this custom channel contains full float colors, in a ``PackedFloat32Array``. Only red and green channels are used.
        case rgFloat = 5 // ARRAY_CUSTOM_RG_FLOAT
        /// Indicates this custom channel contains full float colors, in a ``PackedFloat32Array``. Only red, green and blue channels are used.
        case rgbFloat = 6 // ARRAY_CUSTOM_RGB_FLOAT
        /// Indicates this custom channel contains full float colors, in a ``PackedFloat32Array``.
        case rgbaFloat = 7 // ARRAY_CUSTOM_RGBA_FLOAT
        /// Represents the size of the ``Mesh/ArrayCustomFormat`` enum.
        case max = 8 // ARRAY_CUSTOM_MAX
    }
    
    public struct ArrayFormat: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int64
        public init (rawValue: Int64) {
            self.rawValue = rawValue
        }
        
        /// Mesh array contains vertices. All meshes require a vertex array so this should always be present.
        public static let formatVertex = ArrayFormat (rawValue: 1)
        /// Mesh array contains normals.
        public static let formatNormal = ArrayFormat (rawValue: 2)
        /// Mesh array contains tangents.
        public static let formatTangent = ArrayFormat (rawValue: 4)
        /// Mesh array contains colors.
        public static let formatColor = ArrayFormat (rawValue: 8)
        /// Mesh array contains UVs.
        public static let formatTexUv = ArrayFormat (rawValue: 16)
        /// Mesh array contains second UV.
        public static let formatTexUv2 = ArrayFormat (rawValue: 32)
        /// Mesh array contains custom channel index 0.
        public static let formatCustom0 = ArrayFormat (rawValue: 64)
        /// Mesh array contains custom channel index 1.
        public static let formatCustom1 = ArrayFormat (rawValue: 128)
        /// Mesh array contains custom channel index 2.
        public static let formatCustom2 = ArrayFormat (rawValue: 256)
        /// Mesh array contains custom channel index 3.
        public static let formatCustom3 = ArrayFormat (rawValue: 512)
        /// Mesh array contains bones.
        public static let formatBones = ArrayFormat (rawValue: 1024)
        /// Mesh array contains bone weights.
        public static let formatWeights = ArrayFormat (rawValue: 2048)
        /// Mesh array uses indices.
        public static let formatIndex = ArrayFormat (rawValue: 4096)
        /// Mask of mesh channels permitted in blend shapes.
        public static let formatBlendShapeMask = ArrayFormat (rawValue: 7)
        /// Shift of first custom channel.
        public static let formatCustomBase = ArrayFormat (rawValue: 13)
        /// Number of format bits per custom channel. See ``Mesh/ArrayCustomFormat``.
        public static let formatCustomBits = ArrayFormat (rawValue: 3)
        /// Amount to shift ``Mesh/ArrayCustomFormat`` for custom channel index 0.
        public static let formatCustom0Shift = ArrayFormat (rawValue: 13)
        /// Amount to shift ``Mesh/ArrayCustomFormat`` for custom channel index 1.
        public static let formatCustom1Shift = ArrayFormat (rawValue: 16)
        /// Amount to shift ``Mesh/ArrayCustomFormat`` for custom channel index 2.
        public static let formatCustom2Shift = ArrayFormat (rawValue: 19)
        /// Amount to shift ``Mesh/ArrayCustomFormat`` for custom channel index 3.
        public static let formatCustom3Shift = ArrayFormat (rawValue: 22)
        /// Mask of custom format bits per custom channel. Must be shifted by one of the SHIFT constants. See ``Mesh/ArrayCustomFormat``.
        public static let formatCustomMask = ArrayFormat (rawValue: 7)
        /// Shift of first compress flag. Compress flags should be passed to ``ArrayMesh/addSurfaceFromArrays(primitive:arrays:blendShapes:lods:flags:)`` and ``SurfaceTool/commit(existing:flags:)``.
        public static let compressFlagsBase = ArrayFormat (rawValue: 25)
        /// Flag used to mark that the array contains 2D vertices.
        public static let flagUse2dVertices = ArrayFormat (rawValue: 33554432)
        /// Flag indices that the mesh data will use `GL_DYNAMIC_DRAW` on GLES. Unused on Vulkan.
        public static let flagUseDynamicUpdate = ArrayFormat (rawValue: 67108864)
        /// Flag used to mark that the mesh contains up to 8 bone influences per vertex. This flag indicates that .arrayBones and .arrayWeights elements will have double length.
        public static let flagUse8BoneWeights = ArrayFormat (rawValue: 134217728)
        /// Flag used to mark that the mesh intentionally contains no vertex array.
        public static let flagUsesEmptyVertexArray = ArrayFormat (rawValue: 268435456)
        /// Flag used to mark that a mesh is using compressed attributes (vertices, normals, tangents, UVs). When this form of compression is enabled, vertex positions will be packed into an RGBA16UNORM attribute and scaled in the vertex shader. The normal and tangent will be packed into an RG16UNORM representing an axis, and a 16-bit float stored in the A-channel of the vertex. UVs will use 16-bit normalized floats instead of full 32-bit signed floats. When using this compression mode you must use either vertices, normals, and tangents or only vertices. You cannot use normals without tangents. Importers will automatically enable this compression if they can.
        public static let flagCompressAttributes = ArrayFormat (rawValue: 536870912)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.formatVertex) { result += "formatVertex, " }
            if self.contains (.formatNormal) { result += "formatNormal, " }
            if self.contains (.formatTangent) { result += "formatTangent, " }
            if self.contains (.formatColor) { result += "formatColor, " }
            if self.contains (.formatTexUv) { result += "formatTexUv, " }
            if self.contains (.formatTexUv2) { result += "formatTexUv2, " }
            if self.contains (.formatCustom0) { result += "formatCustom0, " }
            if self.contains (.formatCustom1) { result += "formatCustom1, " }
            if self.contains (.formatCustom2) { result += "formatCustom2, " }
            if self.contains (.formatCustom3) { result += "formatCustom3, " }
            if self.contains (.formatBones) { result += "formatBones, " }
            if self.contains (.formatWeights) { result += "formatWeights, " }
            if self.contains (.formatIndex) { result += "formatIndex, " }
            if self.contains (.formatBlendShapeMask) { result += "formatBlendShapeMask, " }
            if self.contains (.formatCustomBase) { result += "formatCustomBase, " }
            if self.contains (.formatCustomBits) { result += "formatCustomBits, " }
            if self.contains (.formatCustom0Shift) { result += "formatCustom0Shift, " }
            if self.contains (.formatCustom1Shift) { result += "formatCustom1Shift, " }
            if self.contains (.formatCustom2Shift) { result += "formatCustom2Shift, " }
            if self.contains (.formatCustom3Shift) { result += "formatCustom3Shift, " }
            if self.contains (.formatCustomMask) { result += "formatCustomMask, " }
            if self.contains (.compressFlagsBase) { result += "compressFlagsBase, " }
            if self.contains (.flagUse2dVertices) { result += "flagUse2dVertices, " }
            if self.contains (.flagUseDynamicUpdate) { result += "flagUseDynamicUpdate, " }
            if self.contains (.flagUse8BoneWeights) { result += "flagUse8BoneWeights, " }
            if self.contains (.flagUsesEmptyVertexArray) { result += "flagUsesEmptyVertexArray, " }
            if self.contains (.flagCompressAttributes) { result += "flagCompressAttributes, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum BlendShapeMode: Int64 {
        /// Blend shapes are normalized.
        case normalized = 0 // BLEND_SHAPE_MODE_NORMALIZED
        /// Blend shapes are relative to base weight.
        case relative = 1 // BLEND_SHAPE_MODE_RELATIVE
    }
    
    
    /* Properties */
    
    /// Sets a hint to be used for lightmap resolution.
    final public var lightmapSizeHint: Vector2i {
        get {
            return get_lightmap_size_hint ()
        }
        
        set {
            set_lightmap_size_hint (newValue)
        }
        
    }
    
    /* Methods */
    /// Virtual method to override the surface count for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _getSurfaceCount ()-> Int32 {
        return 0
    }
    
    /// Virtual method to override the surface array length for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceGetArrayLen (index: Int32)-> Int32 {
        return 0
    }
    
    /// Virtual method to override the surface array index length for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceGetArrayIndexLen (index: Int32)-> Int32 {
        return 0
    }
    
    /// Virtual method to override the surface arrays for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceGetArrays (index: Int32)-> GArray {
        return GArray ()
    }
    
    /// Virtual method to override the blend shape arrays for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceGetBlendShapeArrays (index: Int32)-> VariantCollection<GArray> {
        return VariantCollection<GArray>()
    }
    
    /// Virtual method to override the surface LODs for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceGetLods (index: Int32)-> GDictionary {
        return GDictionary ()
    }
    
    /// Virtual method to override the surface format for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceGetFormat (index: Int32)-> UInt32 {
        return 0
    }
    
    /// Virtual method to override the surface primitive type for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceGetPrimitiveType (index: Int32)-> UInt32 {
        return 0
    }
    
    /// Virtual method to override the setting of a `material` at the given `index` for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceSetMaterial (index: Int32, material: Material?) {
    }
    
    /// Virtual method to override the surface material for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _surfaceGetMaterial (index: Int32)-> Material? {
        return Material ()
    }
    
    /// Virtual method to override the number of blend shapes for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _getBlendShapeCount ()-> Int32 {
        return 0
    }
    
    /// Virtual method to override the retrieval of blend shape names for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _getBlendShapeName (index: Int32)-> StringName {
        return StringName ()
    }
    
    /// Virtual method to override the names of blend shapes for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _setBlendShapeName (index: Int32, name: StringName) {
    }
    
    /// Virtual method to override the ``AABB`` for a custom class extending ``Mesh``.
    @_documentation(visibility: public)
    open func _getAabb ()-> AABB {
        return AABB ()
    }
    
    fileprivate static var method_set_lightmap_size_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_lightmap_size_hint")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_lightmap_size_hint (_ size: Vector2i) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (Mesh.method_set_lightmap_size_hint, UnsafeMutableRawPointer (mutating: handle), nil, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Mesh.method_set_lightmap_size_hint, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_lightmap_size_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_lightmap_size_hint")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_lightmap_size_hint ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (Mesh.method_get_lightmap_size_hint, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_aabb")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1068685055)!
            }
            
        }
        
    }()
    
    /// Returns the smallest ``AABB`` enclosing this mesh in local space. Not affected by `custom_aabb`.
    /// 
    /// > Note: This is only implemented for ``ArrayMesh`` and ``PrimitiveMesh``.
    /// 
    public final func getAabb ()-> AABB {
        var _result: AABB = AABB ()
        gi.object_method_bind_ptrcall (Mesh.method_get_aabb, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_faces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_faces")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 497664490)!
            }
            
        }
        
    }()
    
    /// Returns all the vertices that make up the faces of the mesh. Each three vertices represent one triangle.
    public final func getFaces ()-> PackedVector3Array {
        let _result: PackedVector3Array = PackedVector3Array ()
        gi.object_method_bind_ptrcall (Mesh.method_get_faces, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_surface_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_surface_count")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of surfaces that the ``Mesh`` holds. This is equivalent to ``MeshInstance3D/getSurfaceOverrideMaterialCount()``.
    public final func getSurfaceCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Mesh.method_get_surface_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_surface_get_arrays: GDExtensionMethodBindPtr = {
        let methodName = StringName ("surface_get_arrays")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 663333327)!
            }
            
        }
        
    }()
    
    /// Returns the arrays for the vertices, normals, UVs, etc. that make up the requested surface (see ``ArrayMesh/addSurfaceFromArrays(primitive:arrays:blendShapes:lods:flags:)``).
    public final func surfaceGetArrays (surfIdx: Int32)-> GArray {
        let _result: GArray = GArray ()
        #if false
        
        var copy_surf_idx: Int = Int (surfIdx)
        
        gi.object_method_bind_ptrcall_v (Mesh.method_surface_get_arrays, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_surf_idx)
        return _result
        #else
        
        var copy_surf_idx: Int = Int (surfIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_surf_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Mesh.method_surface_get_arrays, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_surface_get_blend_shape_arrays: GDExtensionMethodBindPtr = {
        let methodName = StringName ("surface_get_blend_shape_arrays")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 663333327)!
            }
            
        }
        
    }()
    
    /// Returns the blend shape arrays for the requested surface.
    public final func surfaceGetBlendShapeArrays (surfIdx: Int32)-> VariantCollection<GArray> {
        var _result: Int64 = 0
        #if false
        
        var copy_surf_idx: Int = Int (surfIdx)
        
        gi.object_method_bind_ptrcall_v (Mesh.method_surface_get_blend_shape_arrays, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_surf_idx)
        return VariantCollection<GArray>(content: _result)
        #else
        
        var copy_surf_idx: Int = Int (surfIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_surf_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Mesh.method_surface_get_blend_shape_arrays, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return VariantCollection<GArray>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_surface_set_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("surface_set_material")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3671737478)!
            }
            
        }
        
    }()
    
    /// Sets a ``Material`` for a given surface. Surface will be rendered using this material.
    /// 
    /// > Note: This assigns the material within the ``Mesh`` resource, not the ``Material`` associated to the ``MeshInstance3D``'s Surface Material Override properties. To set the ``Material`` associated to the ``MeshInstance3D``'s Surface Material Override properties, use ``MeshInstance3D/setSurfaceOverrideMaterial(surface:material:)`` instead.
    /// 
    public final func surfaceSetMaterial (surfIdx: Int32, material: Material?) {
        #if false
        
        var copy_surf_idx: Int = Int (surfIdx)
        var copy_material_handle = material?.handle
        
        gi.object_method_bind_ptrcall_v (Mesh.method_surface_set_material, UnsafeMutableRawPointer (mutating: handle), nil, &copy_surf_idx, &copy_material_handle)
        
        #else
        
        var copy_surf_idx: Int = Int (surfIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_surf_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: material?.handle) { p1 in
            _args.append (material == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (Mesh.method_surface_set_material, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_surface_get_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("surface_get_material")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2897466400)!
            }
            
        }
        
    }()
    
    /// Returns a ``Material`` in a given surface. Surface is rendered using this material.
    /// 
    /// > Note: This returns the material within the ``Mesh`` resource, not the ``Material`` associated to the ``MeshInstance3D``'s Surface Material Override properties. To get the ``Material`` associated to the ``MeshInstance3D``'s Surface Material Override properties, use ``MeshInstance3D/getSurfaceOverrideMaterial(surface:)`` instead.
    /// 
    public final func surfaceGetMaterial (surfIdx: Int32)-> Material? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_surf_idx: Int = Int (surfIdx)
        
        gi.object_method_bind_ptrcall_v (Mesh.method_surface_get_material, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_surf_idx)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_surf_idx: Int = Int (surfIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_surf_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Mesh.method_surface_get_material, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_create_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_placeholder")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 121922552)!
            }
            
        }
        
    }()
    
    /// Creates a placeholder version of this resource (``PlaceholderMesh``).
    public final func createPlaceholder ()-> Resource? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Mesh.method_create_placeholder, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_create_trimesh_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_trimesh_shape")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4160111210)!
            }
            
        }
        
    }()
    
    /// Calculate a ``ConcavePolygonShape3D`` from the mesh.
    public final func createTrimeshShape ()-> ConcavePolygonShape3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Mesh.method_create_trimesh_shape, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_create_convex_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_convex_shape")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2529984628)!
            }
            
        }
        
    }()
    
    /// Calculate a ``ConvexPolygonShape3D`` from the mesh.
    /// 
    /// If `clean` is `true` (default), duplicate and interior vertices are removed automatically. You can set it to `false` to make the process faster if not needed.
    /// 
    /// If `simplify` is `true`, the geometry can be further simplified to reduce the number of vertices. Disabled by default.
    /// 
    public final func createConvexShape (clean: Bool = true, simplify: Bool = false)-> ConvexPolygonShape3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_clean = clean
        var copy_simplify = simplify
        
        gi.object_method_bind_ptrcall_v (Mesh.method_create_convex_shape, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_clean, &copy_simplify)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_clean = clean
        var copy_simplify = simplify
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_clean) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_simplify) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Mesh.method_create_convex_shape, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_create_outline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_outline")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1208642001)!
            }
            
        }
        
    }()
    
    /// Calculate an outline mesh at a defined offset (margin) from the original mesh.
    /// 
    /// > Note: This method typically returns the vertices in reverse order (e.g. clockwise to counterclockwise).
    /// 
    public final func createOutline (margin: Double)-> Mesh? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_margin = margin
        
        gi.object_method_bind_ptrcall_v (Mesh.method_create_outline, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_margin)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_margin = margin
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_margin) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Mesh.method_create_outline, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_generate_triangle_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_triangle_mesh")
        return withUnsafePointer (to: &Mesh.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3476533166)!
            }
            
        }
        
    }()
    
    /// Generate a ``TriangleMesh`` from the mesh. Considers only surfaces using one of these primitive types: .primitiveTriangles, .primitiveTriangleStrip.
    public final func generateTriangleMesh ()-> TriangleMesh? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Mesh.method_generate_triangle_mesh, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_get_aabb":
                return _Mesh_proxy_get_aabb
            case "_get_blend_shape_count":
                return _Mesh_proxy_get_blend_shape_count
            case "_get_blend_shape_name":
                return _Mesh_proxy_get_blend_shape_name
            case "_get_surface_count":
                return _Mesh_proxy_get_surface_count
            case "_set_blend_shape_name":
                return _Mesh_proxy_set_blend_shape_name
            case "_surface_get_array_index_len":
                return _Mesh_proxy_surface_get_array_index_len
            case "_surface_get_array_len":
                return _Mesh_proxy_surface_get_array_len
            case "_surface_get_arrays":
                return _Mesh_proxy_surface_get_arrays
            case "_surface_get_blend_shape_arrays":
                return _Mesh_proxy_surface_get_blend_shape_arrays
            case "_surface_get_format":
                return _Mesh_proxy_surface_get_format
            case "_surface_get_lods":
                return _Mesh_proxy_surface_get_lods
            case "_surface_get_material":
                return _Mesh_proxy_surface_get_material
            case "_surface_get_primitive_type":
                return _Mesh_proxy_surface_get_primitive_type
            case "_surface_set_material":
                return _Mesh_proxy_surface_set_material
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
}

// Support methods for proxies
func _Mesh_proxy_get_aabb (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getAabb ()
    retPtr!.storeBytes (of: ret, as: AABB.self)
}

func _Mesh_proxy_get_blend_shape_count (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getBlendShapeCount ()
    retPtr!.storeBytes (of: ret, as: Int32.self)
}

func _Mesh_proxy_get_blend_shape_name (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getBlendShapeName (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // StringName
    ret.content = StringName.zero
}

func _Mesh_proxy_get_surface_count (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getSurfaceCount ()
    retPtr!.storeBytes (of: ret, as: Int32.self)
}

func _Mesh_proxy_set_blend_shape_name (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._setBlendShapeName (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee, name: StringName (content: args [1]!.assumingMemoryBound (to: Int64.self).pointee))
}

func _Mesh_proxy_surface_get_array_index_len (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._surfaceGetArrayIndexLen (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret, as: Int32.self)
}

func _Mesh_proxy_surface_get_array_len (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._surfaceGetArrayLen (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret, as: Int32.self)
}

func _Mesh_proxy_surface_get_arrays (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._surfaceGetArrays (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // Array
    ret.content = GArray.zero
}

func _Mesh_proxy_surface_get_blend_shape_arrays (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._surfaceGetBlendShapeArrays (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret.array.content, as: type (of: ret.array.content)) // typedarray::Array
}

func _Mesh_proxy_surface_get_format (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._surfaceGetFormat (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret, as: UInt32.self)
}

func _Mesh_proxy_surface_get_lods (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._surfaceGetLods (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // Dictionary
    ret.content = GDictionary.zero
}

func _Mesh_proxy_surface_get_material (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._surfaceGetMaterial (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret?.handle, as: UnsafeRawPointer?.self) // Material
}

func _Mesh_proxy_surface_get_primitive_type (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._surfaceGetPrimitiveType (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret, as: UInt32.self)
}

func _Mesh_proxy_surface_set_material (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<Mesh>.fromOpaque(instance).takeUnretainedValue()
    let resolved_1 = args [1]!.load (as: UnsafeRawPointer.self)
    
    swiftObject._surfaceSetMaterial (index: args [0]!.assumingMemoryBound (to: Int32.self).pointee, material: lookupLiveObject (handleAddress: resolved_1) as? Material ?? lookupObject (nativeHandle: resolved_1)!)
}

