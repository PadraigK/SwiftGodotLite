// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Node supporting finger tracking in OpenXR.
/// 
/// This node enables OpenXR's hand tracking functionality. The node should be a child node of an ``XROrigin3D`` node, tracking will update its position to where the player's actual hand is positioned. This node also updates the skeleton of a properly skinned hand model. The hand mesh should be a child node of this node.
open class OpenXRHand: Node3D {
    override open class var godotClassName: StringName { "OpenXRHand" }
    public enum Hands: Int64 {
        /// Tracking the player's left hand.
        case left = 0 // HAND_LEFT
        /// Tracking the player's right hand.
        case right = 1 // HAND_RIGHT
        /// Maximum supported hands.
        case max = 2 // HAND_MAX
    }
    
    public enum MotionRange: Int64 {
        /// When player grips, hand skeleton will form a full fist.
        case unobstructed = 0 // MOTION_RANGE_UNOBSTRUCTED
        /// When player grips, hand skeleton conforms to the controller the player is holding.
        case conformToController = 1 // MOTION_RANGE_CONFORM_TO_CONTROLLER
        /// Maximum supported motion ranges.
        case max = 2 // MOTION_RANGE_MAX
    }
    
    
    /* Properties */
    
    /// Specifies whether this node tracks the left or right hand of the player.
    final public var hand: OpenXRHand.Hands {
        get {
            return get_hand ()
        }
        
        set {
            set_hand (newValue)
        }
        
    }
    
    /// Set the motion range (if supported) limiting the hand motion.
    final public var motionRange: OpenXRHand.MotionRange {
        get {
            return get_motion_range ()
        }
        
        set {
            set_motion_range (newValue)
        }
        
    }
    
    /// Set a ``Skeleton3D`` node for which the pose positions will be updated.
    final public var handSkeleton: NodePath {
        get {
            return get_hand_skeleton ()
        }
        
        set {
            set_hand_skeleton (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_hand: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hand")
        return withUnsafePointer (to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1849328560)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hand (_ hand: OpenXRHand.Hands) {
        #if false
        
        var copy_hand = Int64 (hand.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRHand.method_set_hand, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hand)
        
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRHand.method_set_hand, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_hand: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hand")
        return withUnsafePointer (to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2850644561)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_hand ()-> OpenXRHand.Hands {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (OpenXRHand.method_get_hand, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return OpenXRHand.Hands (rawValue: _result)!
    }
    
    fileprivate static var method_set_hand_skeleton: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hand_skeleton")
        return withUnsafePointer (to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1348162250)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hand_skeleton (_ handSkeleton: NodePath) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (OpenXRHand.method_set_hand_skeleton, UnsafeMutableRawPointer (mutating: handle), nil, &handSkeleton.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &handSkeleton.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRHand.method_set_hand_skeleton, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_hand_skeleton: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hand_skeleton")
        return withUnsafePointer (to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4075236667)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_hand_skeleton ()-> NodePath {
        let _result: NodePath = NodePath ()
        gi.object_method_bind_ptrcall (OpenXRHand.method_get_hand_skeleton, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_motion_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_motion_range")
        return withUnsafePointer (to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3326516003)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_motion_range (_ motionRange: OpenXRHand.MotionRange) {
        #if false
        
        var copy_motion_range = Int64 (motionRange.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRHand.method_set_motion_range, UnsafeMutableRawPointer (mutating: handle), nil, &copy_motion_range)
        
        #else
        
        var copy_motion_range = Int64 (motionRange.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_motion_range) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRHand.method_set_motion_range, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_motion_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_motion_range")
        return withUnsafePointer (to: &OpenXRHand.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2191822314)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_motion_range ()-> OpenXRHand.MotionRange {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (OpenXRHand.method_get_motion_range, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return OpenXRHand.MotionRange (rawValue: _result)!
    }
    
}

