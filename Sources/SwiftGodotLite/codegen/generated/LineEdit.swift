// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// An input field for single-line text.
/// 
/// ``LineEdit`` provides an input field for editing a single line of text. It features many built-in shortcuts that are always available ([kbd]Ctrl[/kbd] here maps to [kbd]Cmd[/kbd] on macOS):
/// 
/// - [kbd]Ctrl + C[/kbd]: Copy
/// 
/// - [kbd]Ctrl + X[/kbd]: Cut
/// 
/// - [kbd]Ctrl + V[/kbd] or [kbd]Ctrl + Y[/kbd]: Paste/"yank"
/// 
/// - [kbd]Ctrl + Z[/kbd]: Undo
/// 
/// - [kbd]Ctrl + ~[/kbd]: Swap input direction.
/// 
/// - [kbd]Ctrl + Shift + Z[/kbd]: Redo
/// 
/// - [kbd]Ctrl + U[/kbd]: Delete text from the caret position to the beginning of the line
/// 
/// - [kbd]Ctrl + K[/kbd]: Delete text from the caret position to the end of the line
/// 
/// - [kbd]Ctrl + A[/kbd]: Select all text
/// 
/// - [kbd]Up Arrow[/kbd]/[kbd]Down Arrow[/kbd]: Move the caret to the beginning/end of the line
/// 
/// On macOS, some extra keyboard shortcuts are available:
/// 
/// - [kbd]Cmd + F[/kbd]: Same as [kbd]Right Arrow[/kbd], move the caret one character right
/// 
/// - [kbd]Cmd + B[/kbd]: Same as [kbd]Left Arrow[/kbd], move the caret one character left
/// 
/// - [kbd]Cmd + P[/kbd]: Same as [kbd]Up Arrow[/kbd], move the caret to the previous line
/// 
/// - [kbd]Cmd + N[/kbd]: Same as [kbd]Down Arrow[/kbd], move the caret to the next line
/// 
/// - [kbd]Cmd + D[/kbd]: Same as [kbd]Delete[/kbd], delete the character on the right side of caret
/// 
/// - [kbd]Cmd + H[/kbd]: Same as [kbd]Backspace[/kbd], delete the character on the left side of the caret
/// 
/// - [kbd]Cmd + A[/kbd]: Same as [kbd]Home[/kbd], move the caret to the beginning of the line
/// 
/// - [kbd]Cmd + E[/kbd]: Same as [kbd]End[/kbd], move the caret to the end of the line
/// 
/// - [kbd]Cmd + Left Arrow[/kbd]: Same as [kbd]Home[/kbd], move the caret to the beginning of the line
/// 
/// - [kbd]Cmd + Right Arrow[/kbd]: Same as [kbd]End[/kbd], move the caret to the end of the line
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``textChanged``
/// - ``textChangeRejected``
/// - ``textSubmitted``
open class LineEdit: Control {
    override open class var godotClassName: StringName { "LineEdit" }
    public enum MenuItems: Int64 {
        /// Cuts (copies and clears) the selected text.
        case cut = 0 // MENU_CUT
        /// Copies the selected text.
        case copy = 1 // MENU_COPY
        /// Pastes the clipboard text over the selected text (or at the caret's position).
        /// 
        /// Non-printable escape characters are automatically stripped from the OS clipboard via ``String/stripEscapes()``.
        /// 
        case paste = 2 // MENU_PASTE
        /// Erases the whole ``LineEdit`` text.
        case clear = 3 // MENU_CLEAR
        /// Selects the whole ``LineEdit`` text.
        case selectAll = 4 // MENU_SELECT_ALL
        /// Undoes the previous action.
        case undo = 5 // MENU_UNDO
        /// Reverse the last undo action.
        case redo = 6 // MENU_REDO
        /// ID of "Text Writing Direction" submenu.
        case submenuTextDir = 7 // MENU_SUBMENU_TEXT_DIR
        /// Sets text direction to inherited.
        case dirInherited = 8 // MENU_DIR_INHERITED
        /// Sets text direction to automatic.
        case dirAuto = 9 // MENU_DIR_AUTO
        /// Sets text direction to left-to-right.
        case dirLtr = 10 // MENU_DIR_LTR
        /// Sets text direction to right-to-left.
        case dirRtl = 11 // MENU_DIR_RTL
        /// Toggles control character display.
        case displayUcc = 12 // MENU_DISPLAY_UCC
        /// ID of "Insert Control Character" submenu.
        case submenuInsertUcc = 13 // MENU_SUBMENU_INSERT_UCC
        /// Inserts left-to-right mark (LRM) character.
        case insertLrm = 14 // MENU_INSERT_LRM
        /// Inserts right-to-left mark (RLM) character.
        case insertRlm = 15 // MENU_INSERT_RLM
        /// Inserts start of left-to-right embedding (LRE) character.
        case insertLre = 16 // MENU_INSERT_LRE
        /// Inserts start of right-to-left embedding (RLE) character.
        case insertRle = 17 // MENU_INSERT_RLE
        /// Inserts start of left-to-right override (LRO) character.
        case insertLro = 18 // MENU_INSERT_LRO
        /// Inserts start of right-to-left override (RLO) character.
        case insertRlo = 19 // MENU_INSERT_RLO
        /// Inserts pop direction formatting (PDF) character.
        case insertPdf = 20 // MENU_INSERT_PDF
        /// Inserts Arabic letter mark (ALM) character.
        case insertAlm = 21 // MENU_INSERT_ALM
        /// Inserts left-to-right isolate (LRI) character.
        case insertLri = 22 // MENU_INSERT_LRI
        /// Inserts right-to-left isolate (RLI) character.
        case insertRli = 23 // MENU_INSERT_RLI
        /// Inserts first strong isolate (FSI) character.
        case insertFsi = 24 // MENU_INSERT_FSI
        /// Inserts pop direction isolate (PDI) character.
        case insertPdi = 25 // MENU_INSERT_PDI
        /// Inserts zero width joiner (ZWJ) character.
        case insertZwj = 26 // MENU_INSERT_ZWJ
        /// Inserts zero width non-joiner (ZWNJ) character.
        case insertZwnj = 27 // MENU_INSERT_ZWNJ
        /// Inserts word joiner (WJ) character.
        case insertWj = 28 // MENU_INSERT_WJ
        /// Inserts soft hyphen (SHY) character.
        case insertShy = 29 // MENU_INSERT_SHY
        /// Represents the size of the ``LineEdit/MenuItems`` enum.
        case max = 30 // MENU_MAX
    }
    
    public enum VirtualKeyboardType: Int64 {
        /// Default text virtual keyboard.
        case `default` = 0 // KEYBOARD_TYPE_DEFAULT
        /// Multiline virtual keyboard.
        case multiline = 1 // KEYBOARD_TYPE_MULTILINE
        /// Virtual number keypad, useful for PIN entry.
        case number = 2 // KEYBOARD_TYPE_NUMBER
        /// Virtual number keypad, useful for entering fractional numbers.
        case numberDecimal = 3 // KEYBOARD_TYPE_NUMBER_DECIMAL
        /// Virtual phone number keypad.
        case phone = 4 // KEYBOARD_TYPE_PHONE
        /// Virtual keyboard with additional keys to assist with typing email addresses.
        case emailAddress = 5 // KEYBOARD_TYPE_EMAIL_ADDRESS
        /// Virtual keyboard for entering a password. On most platforms, this should disable autocomplete and autocapitalization.
        /// 
        /// > Note: This is not supported on Web. Instead, this behaves identically to .keyboardTypeDefault.
        /// 
        case password = 6 // KEYBOARD_TYPE_PASSWORD
        /// Virtual keyboard with additional keys to assist with typing URLs.
        case url = 7 // KEYBOARD_TYPE_URL
    }
    
    
    /* Properties */
    
    /// String value of the ``LineEdit``.
    /// 
    /// > Note: Changing text using this property won't emit the [signal text_changed] signal.
    /// 
    final public var text: String {
        get {
            return get_text ()
        }
        
        set {
            set_text (newValue)
        }
        
    }
    
    /// Text shown when the ``LineEdit`` is empty. It is **not** the ``LineEdit``'s default value (see ``text``).
    final public var placeholderText: String {
        get {
            return get_placeholder ()
        }
        
        set {
            set_placeholder (newValue)
        }
        
    }
    
    /// Text alignment as defined in the ``HorizontalAlignment`` enum.
    final public var alignment: HorizontalAlignment {
        get {
            return get_horizontal_alignment ()
        }
        
        set {
            set_horizontal_alignment (newValue)
        }
        
    }
    
    /// Maximum number of characters that can be entered inside the ``LineEdit``. If `0`, there is no limit.
    /// 
    /// When a limit is defined, characters that would exceed ``maxLength`` are truncated. This happens both for existing ``text`` contents when setting the max length, or for new text inserted in the ``LineEdit``, including pasting. If any input text is truncated, the [signal text_change_rejected] signal is emitted with the truncated substring as parameter.
    /// 
    /// **Example:**
    /// 
    final public var maxLength: Int32 {
        get {
            return get_max_length ()
        }
        
        set {
            set_max_length (newValue)
        }
        
    }
    
    /// If `false`, existing text cannot be modified and new text cannot be added.
    final public var editable: Bool {
        get {
            return is_editable ()
        }
        
        set {
            set_editable (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` width will increase to stay longer than the ``text``. It will **not** compress if the ``text`` is shortened.
    final public var expandToTextLength: Bool {
        get {
            return is_expand_to_text_length_enabled ()
        }
        
        set {
            set_expand_to_text_length_enabled (newValue)
        }
        
    }
    
    /// If `true`, the context menu will appear when right-clicked.
    final public var contextMenuEnabled: Bool {
        get {
            return is_context_menu_enabled ()
        }
        
        set {
            set_context_menu_enabled (newValue)
        }
        
    }
    
    /// If `true`, the native virtual keyboard is shown when focused on platforms that support it.
    final public var virtualKeyboardEnabled: Bool {
        get {
            return is_virtual_keyboard_enabled ()
        }
        
        set {
            set_virtual_keyboard_enabled (newValue)
        }
        
    }
    
    /// Specifies the type of virtual keyboard to show.
    final public var virtualKeyboardType: LineEdit.VirtualKeyboardType {
        get {
            return get_virtual_keyboard_type ()
        }
        
        set {
            set_virtual_keyboard_type (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` will show a clear button if ``text`` is not empty, which can be used to clear the text quickly.
    final public var clearButtonEnabled: Bool {
        get {
            return is_clear_button_enabled ()
        }
        
        set {
            set_clear_button_enabled (newValue)
        }
        
    }
    
    /// If `false`, using shortcuts will be disabled.
    final public var shortcutKeysEnabled: Bool {
        get {
            return is_shortcut_keys_enabled ()
        }
        
        set {
            set_shortcut_keys_enabled (newValue)
        }
        
    }
    
    /// If `false`, using middle mouse button to paste clipboard will be disabled.
    /// 
    /// > Note: This method is only implemented on Linux.
    /// 
    final public var middleMousePasteEnabled: Bool {
        get {
            return is_middle_mouse_paste_enabled ()
        }
        
        set {
            set_middle_mouse_paste_enabled (newValue)
        }
        
    }
    
    /// If `false`, it's impossible to select the text using mouse nor keyboard.
    final public var selectingEnabled: Bool {
        get {
            return is_selecting_enabled ()
        }
        
        set {
            set_selecting_enabled (newValue)
        }
        
    }
    
    /// If `true`, the selected text will be deselected when focus is lost.
    final public var deselectOnFocusLossEnabled: Bool {
        get {
            return is_deselect_on_focus_loss_enabled ()
        }
        
        set {
            set_deselect_on_focus_loss_enabled (newValue)
        }
        
    }
    
    /// If `true`, allow drag and drop of selected text.
    final public var dragAndDropSelectionEnabled: Bool {
        get {
            return is_drag_and_drop_selection_enabled ()
        }
        
        set {
            set_drag_and_drop_selection_enabled (newValue)
        }
        
    }
    
    /// Sets the icon that will appear in the right end of the ``LineEdit`` if there's no ``text``, or always, if ``clearButtonEnabled`` is set to `false`.
    final public var rightIcon: Texture2D? {
        get {
            return get_right_icon ()
        }
        
        set {
            set_right_icon (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` doesn't display decoration.
    final public var flat: Bool {
        get {
            return is_flat ()
        }
        
        set {
            set_flat (newValue)
        }
        
    }
    
    /// If `true`, control characters are displayed.
    final public var drawControlChars: Bool {
        get {
            return get_draw_control_chars ()
        }
        
        set {
            set_draw_control_chars (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` will select the whole text when it gains focus.
    final public var selectAllOnFocus: Bool {
        get {
            return is_select_all_on_focus ()
        }
        
        set {
            set_select_all_on_focus (newValue)
        }
        
    }
    
    /// If `true`, makes the caret blink.
    final public var caretBlink: Bool {
        get {
            return is_caret_blink_enabled ()
        }
        
        set {
            set_caret_blink_enabled (newValue)
        }
        
    }
    
    /// The interval at which the caret blinks (in seconds).
    final public var caretBlinkInterval: Double {
        get {
            return get_caret_blink_interval ()
        }
        
        set {
            set_caret_blink_interval (newValue)
        }
        
    }
    
    /// The caret's column position inside the ``LineEdit``. When set, the text may scroll to accommodate it.
    final public var caretColumn: Int32 {
        get {
            return get_caret_column ()
        }
        
        set {
            set_caret_column (newValue)
        }
        
    }
    
    /// If `true`, the ``LineEdit`` will always show the caret, even if focus is lost.
    final public var caretForceDisplayed: Bool {
        get {
            return is_caret_force_displayed ()
        }
        
        set {
            set_caret_force_displayed (newValue)
        }
        
    }
    
    /// Allow moving caret, selecting and removing the individual composite character components.
    /// 
    /// > Note: [kbd]Backspace[/kbd] is always removing individual composite character components.
    /// 
    final public var caretMidGrapheme: Bool {
        get {
            return is_caret_mid_grapheme_enabled ()
        }
        
        set {
            set_caret_mid_grapheme_enabled (newValue)
        }
        
    }
    
    /// If `true`, every character is replaced with the secret character (see ``secretCharacter``).
    final public var secret: Bool {
        get {
            return is_secret ()
        }
        
        set {
            set_secret (newValue)
        }
        
    }
    
    /// The character to use to mask secret input. Only a single character can be used as the secret character. If it is longer than one character, only the first one will be used. If it is empty, a space will be used instead.
    final public var secretCharacter: String {
        get {
            return get_secret_character ()
        }
        
        set {
            set_secret_character (newValue)
        }
        
    }
    
    /// Base text writing direction.
    final public var textDirection: Control.TextDirection {
        get {
            return get_text_direction ()
        }
        
        set {
            set_text_direction (newValue)
        }
        
    }
    
    /// Language code used for line-breaking and text shaping algorithms. If left empty, current locale is used instead.
    final public var language: String {
        get {
            return get_language ()
        }
        
        set {
            set_language (newValue)
        }
        
    }
    
    /// Set BiDi algorithm override for the structured text.
    final public var structuredTextBidiOverride: TextServer.StructuredTextParser {
        get {
            return get_structured_text_bidi_override ()
        }
        
        set {
            set_structured_text_bidi_override (newValue)
        }
        
    }
    
    /// Set additional options for BiDi override.
    final public var structuredTextBidiOverrideOptions: GArray {
        get {
            return get_structured_text_bidi_override_options ()
        }
        
        set {
            set_structured_text_bidi_override_options (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_horizontal_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_horizontal_alignment")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2312603777)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_horizontal_alignment (_ alignment: HorizontalAlignment) {
        #if false
        
        var copy_alignment = Int64 (alignment.rawValue)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_horizontal_alignment, UnsafeMutableRawPointer (mutating: handle), nil, &copy_alignment)
        
        #else
        
        var copy_alignment = Int64 (alignment.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_alignment) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_horizontal_alignment, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_horizontal_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_horizontal_alignment")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 341400642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_horizontal_alignment ()-> HorizontalAlignment {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (LineEdit.method_get_horizontal_alignment, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return HorizontalAlignment (rawValue: _result)!
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Erases the ``LineEdit``'s ``text``.
    public final func clear () {
        gi.object_method_bind_ptrcall (LineEdit.method_clear, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_select: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1328111411)!
            }
            
        }
        
    }()
    
    /// Selects characters inside ``LineEdit`` between `from` and `to`. By default, `from` is at the beginning and `to` at the end.
    /// 
    public final func select (from: Int32 = 0, to: Int32 = -1) {
        #if false
        
        var copy_from: Int = Int (from)
        var copy_to: Int = Int (to)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_select, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from, &copy_to)
        
        #else
        
        var copy_from: Int = Int (from)
        var copy_to: Int = Int (to)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (LineEdit.method_select, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_select_all: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select_all")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Selects the whole ``String``.
    public final func selectAll () {
        gi.object_method_bind_ptrcall (LineEdit.method_select_all, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_deselect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("deselect")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the current selection.
    public final func deselect () {
        gi.object_method_bind_ptrcall (LineEdit.method_deselect, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_has_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_selection")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the user has selected text.
    public final func hasSelection ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_has_selection, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selected_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selected_text")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2841200299)!
            }
            
        }
        
    }()
    
    /// Returns the text inside the selection.
    public final func getSelectedText ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (LineEdit.method_get_selected_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_selection_from_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_from_column")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the selection begin column.
    public final func getSelectionFromColumn ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (LineEdit.method_get_selection_from_column, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selection_to_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_to_column")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the selection end column.
    public final func getSelectionToColumn ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (LineEdit.method_get_selection_to_column, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_text")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text (_ text: String) {
        #if false
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_text, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (LineEdit.method_get_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_draw_control_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_draw_control_chars")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_draw_control_chars ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_get_draw_control_chars, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_control_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_control_chars")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_control_chars (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_draw_control_chars, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_draw_control_chars, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_text_direction")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 119160795)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text_direction (_ direction: Control.TextDirection) {
        #if false
        
        var copy_direction = Int64 (direction.rawValue)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_text_direction, UnsafeMutableRawPointer (mutating: handle), nil, &copy_direction)
        
        #else
        
        var copy_direction = Int64 (direction.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_direction) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_text_direction, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text_direction")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 797257663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text_direction ()-> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (LineEdit.method_get_text_direction, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Control.TextDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_language")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_language (_ language: String) {
        #if false
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_language, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_language.content)
        
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_language.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_language, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_language")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_language ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (LineEdit.method_get_language, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_structured_text_bidi_override")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 55961453)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override (_ parser: TextServer.StructuredTextParser) {
        #if false
        
        var copy_parser = Int64 (parser.rawValue)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), nil, &copy_parser)
        
        #else
        
        var copy_parser = Int64 (parser.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_parser) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_structured_text_bidi_override")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3385126229)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override ()-> TextServer.StructuredTextParser {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (LineEdit.method_get_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextServer.StructuredTextParser (rawValue: _result)!
    }
    
    fileprivate static var method_set_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_structured_text_bidi_override_options")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override_options (_ args: GArray) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), nil, &args.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &args.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_structured_text_bidi_override_options")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override_options ()-> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall (LineEdit.method_get_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_placeholder")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_placeholder (_ text: String) {
        #if false
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_placeholder, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_placeholder, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_placeholder")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_placeholder ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (LineEdit.method_get_placeholder, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_caret_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_column")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_column (_ position: Int32) {
        #if false
        
        var copy_position: Int = Int (position)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_caret_column, UnsafeMutableRawPointer (mutating: handle), nil, &copy_position)
        
        #else
        
        var copy_position: Int = Int (position)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_caret_column, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_column")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_caret_column ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (LineEdit.method_get_caret_column, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_scroll_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scroll_offset")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the scroll offset due to ``caretColumn``, as a number of characters.
    public final func getScrollOffset ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (LineEdit.method_get_scroll_offset, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_expand_to_text_length_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_expand_to_text_length_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_expand_to_text_length_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_expand_to_text_length_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_expand_to_text_length_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_expand_to_text_length_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_expand_to_text_length_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_expand_to_text_length_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_expand_to_text_length_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_blink_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_blink_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_blink_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_caret_blink_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_caret_blink_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_caret_blink_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_caret_blink_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_caret_blink_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_caret_blink_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_mid_grapheme_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_mid_grapheme_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_mid_grapheme_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_caret_mid_grapheme_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_caret_mid_grapheme_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_caret_mid_grapheme_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_caret_mid_grapheme_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_caret_mid_grapheme_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_caret_mid_grapheme_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_force_displayed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_force_displayed")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_force_displayed (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_caret_force_displayed, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_caret_force_displayed, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_caret_force_displayed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_caret_force_displayed")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_caret_force_displayed ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_caret_force_displayed, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_blink_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_blink_interval")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_blink_interval (_ interval: Double) {
        #if false
        
        var copy_interval = interval
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_caret_blink_interval, UnsafeMutableRawPointer (mutating: handle), nil, &copy_interval)
        
        #else
        
        var copy_interval = interval
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_interval) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_caret_blink_interval, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_blink_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_blink_interval")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_caret_blink_interval ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (LineEdit.method_get_caret_blink_interval, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_max_length: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_max_length")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_length (_ chars: Int32) {
        #if false
        
        var copy_chars: Int = Int (chars)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_max_length, UnsafeMutableRawPointer (mutating: handle), nil, &copy_chars)
        
        #else
        
        var copy_chars: Int = Int (chars)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_chars) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_max_length, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_max_length: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_max_length")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_length ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (LineEdit.method_get_max_length, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_insert_text_at_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("insert_text_at_caret")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Inserts `text` at the caret. If the resulting value is longer than ``maxLength``, nothing happens.
    public final func insertTextAtCaret (text: String) {
        #if false
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_insert_text_at_caret, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_insert_text_at_caret, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_delete_char_at_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("delete_char_at_caret")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Deletes one character at the caret's current position (equivalent to pressing [kbd]Delete[/kbd]).
    public final func deleteCharAtCaret () {
        gi.object_method_bind_ptrcall (LineEdit.method_delete_char_at_caret, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_delete_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("delete_text")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Deletes a section of the ``text`` going from position `fromColumn` to `toColumn`. Both parameters should be within the text's length.
    public final func deleteText (fromColumn: Int32, toColumn: Int32) {
        #if false
        
        var copy_from_column: Int = Int (fromColumn)
        var copy_to_column: Int = Int (toColumn)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_delete_text, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_column, &copy_to_column)
        
        #else
        
        var copy_from_column: Int = Int (fromColumn)
        var copy_to_column: Int = Int (toColumn)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (LineEdit.method_delete_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_editable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_editable")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_editable (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_editable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_editable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_editable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_editable")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_editable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_editable, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_secret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_secret")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_secret (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_secret, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_secret, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_secret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_secret")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_secret ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_secret, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_secret_character: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_secret_character")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_secret_character (_ character: String) {
        #if false
        
        let gstr_character = GString (character)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_secret_character, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_character.content)
        
        #else
        
        let gstr_character = GString (character)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_character.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_secret_character, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_secret_character: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_secret_character")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_secret_character ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (LineEdit.method_get_secret_character, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_menu_option: GDExtensionMethodBindPtr = {
        let methodName = StringName ("menu_option")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Executes a given action as defined in the ``LineEdit/MenuItems`` enum.
    public final func menuOption (_ option: Int32) {
        #if false
        
        var copy_option: Int = Int (option)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_menu_option, UnsafeMutableRawPointer (mutating: handle), nil, &copy_option)
        
        #else
        
        var copy_option: Int = Int (option)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_option) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_menu_option, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_menu")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 229722558)!
            }
            
        }
        
    }()
    
    /// Returns the ``PopupMenu`` of this ``LineEdit``. By default, this menu is displayed when right-clicking on the ``LineEdit``.
    /// 
    /// You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see ``LineEdit/MenuItems``). For example:
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``Window/visible`` property.
    /// 
    public final func getMenu ()-> PopupMenu? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (LineEdit.method_get_menu, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_is_menu_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_menu_visible")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the menu is visible. Use this instead of `get_menu().visible` to improve performance (so the creation of the menu is avoided).
    public final func isMenuVisible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_menu_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_context_menu_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_context_menu_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_context_menu_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_context_menu_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_virtual_keyboard_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_virtual_keyboard_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_virtual_keyboard_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_virtual_keyboard_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_virtual_keyboard_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_virtual_keyboard_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_virtual_keyboard_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_virtual_keyboard_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_virtual_keyboard_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_virtual_keyboard_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_virtual_keyboard_type")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2696893573)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_virtual_keyboard_type (_ type: LineEdit.VirtualKeyboardType) {
        #if false
        
        var copy_type = Int64 (type.rawValue)
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_virtual_keyboard_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_type)
        
        #else
        
        var copy_type = Int64 (type.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_virtual_keyboard_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_virtual_keyboard_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_virtual_keyboard_type")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1928699316)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_virtual_keyboard_type ()-> LineEdit.VirtualKeyboardType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (LineEdit.method_get_virtual_keyboard_type, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return LineEdit.VirtualKeyboardType (rawValue: _result)!
    }
    
    fileprivate static var method_set_clear_button_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_clear_button_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_clear_button_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_clear_button_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_clear_button_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_clear_button_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_clear_button_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_clear_button_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_clear_button_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_shortcut_keys_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_shortcut_keys_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_shortcut_keys_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_shortcut_keys_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_middle_mouse_paste_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_middle_mouse_paste_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_middle_mouse_paste_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_middle_mouse_paste_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_middle_mouse_paste_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_middle_mouse_paste_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_middle_mouse_paste_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_middle_mouse_paste_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_middle_mouse_paste_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_selecting_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_selecting_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_selecting_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_selecting_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_selecting_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_selecting_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_selecting_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_selecting_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_selecting_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_deselect_on_focus_loss_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_deselect_on_focus_loss_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_deselect_on_focus_loss_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_deselect_on_focus_loss_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_drag_and_drop_selection_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drag_and_drop_selection_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drag_and_drop_selection_enabled")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drag_and_drop_selection_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_right_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_right_icon")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4051416890)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_right_icon (_ icon: Texture2D?) {
        #if false
        
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_right_icon, UnsafeMutableRawPointer (mutating: handle), nil, &copy_icon_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: icon?.handle) { p0 in
        _args.append (icon == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_right_icon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_right_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_right_icon")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 255860311)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_right_icon ()-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (LineEdit.method_get_right_icon, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_flat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_flat")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_flat (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_flat, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_flat, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_flat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_flat")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_flat ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_flat, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_select_all_on_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_select_all_on_focus")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_select_all_on_focus (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (LineEdit.method_set_select_all_on_focus, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LineEdit.method_set_select_all_on_focus, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_select_all_on_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_select_all_on_focus")
        return withUnsafePointer (to: &LineEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_select_all_on_focus ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LineEdit.method_is_select_all_on_focus, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ newText: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the text changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.textChanged.connect { newText in
    ///    print ("caught signal")
    /// }
    /// ```
    public var textChanged: Signal1 { Signal1 (target: self, signalName: "text_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ rejectedSubstring: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when appending text that overflows the ``maxLength``. The appended text is truncated to fit ``maxLength``, and the part that couldn't fit is passed as the `rejectedSubstring` argument.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.textChangeRejected.connect { rejectedSubstring in
    ///    print ("caught signal")
    /// }
    /// ```
    public var textChangeRejected: Signal2 { Signal2 (target: self, signalName: "text_change_rejected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ newText: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user presses ``Key/enter`` on the ``LineEdit``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.textSubmitted.connect { newText in
    ///    print ("caught signal")
    /// }
    /// ```
    public var textSubmitted: Signal3 { Signal3 (target: self, signalName: "text_submitted") }
    
}

