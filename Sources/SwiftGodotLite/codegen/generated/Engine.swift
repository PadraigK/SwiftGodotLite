// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Provides access to engine properties.
/// 
/// The ``Engine`` singleton allows you to query and modify the project's run-time parameters, such as frames per second, time scale, and others.
open class Engine: Object {
    /// The shared instance of this class
    public static var shared: Engine = {
        return withUnsafePointer (to: &Engine.godotClassName.content) { ptr in
            Engine (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "Engine" }
    
    /* Properties */
    
    /// If `false`, stops printing error and warning messages to the console and editor Output log. This can be used to hide error and warning messages during unit test suite runs. This property is equivalent to the ``ProjectSettings/application/run/disableStderr`` project setting.
    /// 
    /// > Warning: If you set this to `false` anywhere in the project, important error messages may be hidden even if they are emitted from other scripts. If this is set to `false` in a `@tool` script, this will also impact the editor itself. Do _not_ report bugs before ensuring error messages are enabled (as they are by default).
    /// 
    /// > Note: This property does not impact the editor's Errors tab when running a project from the editor.
    /// 
    static public var printErrorMessages: Bool {
        get {
            return is_printing_error_messages ()
        }
        
        set {
            set_print_error_messages (newValue)
        }
        
    }
    
    /// The number of fixed iterations per second. This controls how often physics simulation and ``Node/_physicsProcess(delta:)`` methods are run. This value should generally always be set to `60` or above, as Godot doesn't interpolate the physics step. As a result, values lower than `60` will look stuttery. This value can be increased to make input more reactive or work around collision tunneling issues, but keep in mind doing so will increase CPU usage. See also ``maxFps`` and ``ProjectSettings/physics/common/physicsTicksPerSecond``.
    /// 
    /// > Note: Only ``maxPhysicsStepsPerFrame`` physics ticks may be simulated per rendered frame at most. If more physics ticks have to be simulated per rendered frame to keep up with rendering, the project will appear to slow down (even if `delta` is used consistently in physics calculations). Therefore, it is recommended to also increase ``maxPhysicsStepsPerFrame`` if increasing ``physicsTicksPerSecond`` significantly above its default value.
    /// 
    static public var physicsTicksPerSecond: Int32 {
        get {
            return get_physics_ticks_per_second ()
        }
        
        set {
            set_physics_ticks_per_second (newValue)
        }
        
    }
    
    /// Controls the maximum number of physics steps that can be simulated each rendered frame. The default value is tuned to avoid "spiral of death" situations where expensive physics simulations trigger more expensive simulations indefinitely. However, the game will appear to slow down if the rendering FPS is less than `1 / max_physics_steps_per_frame` of ``physicsTicksPerSecond``. This occurs even if `delta` is consistently used in physics calculations. To avoid this, increase ``maxPhysicsStepsPerFrame`` if you have increased ``physicsTicksPerSecond`` significantly above its default value.
    static public var maxPhysicsStepsPerFrame: Int32 {
        get {
            return get_max_physics_steps_per_frame ()
        }
        
        set {
            set_max_physics_steps_per_frame (newValue)
        }
        
    }
    
    /// The maximum number of frames per second that can be rendered. A value of `0` means "no limit". The actual number of frames per second may still be below this value if the CPU or GPU cannot keep up with the project logic and rendering.
    /// 
    /// Limiting the FPS can be useful to reduce system power consumption, which reduces heat and noise emissions (and improves battery life on mobile devices).
    /// 
    /// If ``ProjectSettings/display/window/vsync/vsyncMode`` is `Enabled` or `Adaptive`, it takes precedence and the forced FPS number cannot exceed the monitor's refresh rate.
    /// 
    /// If ``ProjectSettings/display/window/vsync/vsyncMode`` is `Enabled`, on monitors with variable refresh rate enabled (G-Sync/FreeSync), using a FPS limit a few frames lower than the monitor's refresh rate will [url=https://blurbusters.com/howto-low-lag-vsync-on/]reduce input lag while avoiding tearing[/url].
    /// 
    /// If ``ProjectSettings/display/window/vsync/vsyncMode`` is `Disabled`, limiting the FPS to a high value that can be consistently reached on the system can reduce input lag compared to an uncapped framerate. Since this works by ensuring the GPU load is lower than 100%, this latency reduction is only effective in GPU-bottlenecked scenarios, not CPU-bottlenecked scenarios.
    /// 
    /// See also ``physicsTicksPerSecond`` and ``ProjectSettings/application/run/maxFps``.
    /// 
    static public var maxFps: Int32 {
        get {
            return get_max_fps ()
        }
        
        set {
            set_max_fps (newValue)
        }
        
    }
    
    /// Controls how fast or slow the in-game clock ticks versus the real life one. It defaults to 1.0. A value of 2.0 means the game moves twice as fast as real life, whilst a value of 0.5 means the game moves at half the regular speed. This also affects ``Timer`` and ``SceneTreeTimer`` (see ``SceneTree/createTimer(timeSec:processAlways:processInPhysics:ignoreTimeScale:)`` for how to control this).
    static public var timeScale: Double {
        get {
            return get_time_scale ()
        }
        
        set {
            set_time_scale (newValue)
        }
        
    }
    
    /// Controls how much physics ticks are synchronized with real time. For 0 or less, the ticks are synchronized. Such values are recommended for network games, where clock synchronization matters. Higher values cause higher deviation of the in-game clock and real clock but smooth out framerate jitters. The default value of 0.5 should be fine for most; values above 2 could cause the game to react to dropped frames with a noticeable delay and are not recommended.
    /// 
    /// > Note: For best results, when using a custom physics interpolation solution, the physics jitter fix should be disabled by setting ``physicsJitterFix`` to `0`.
    /// 
    static public var physicsJitterFix: Double {
        get {
            return get_physics_jitter_fix ()
        }
        
        set {
            set_physics_jitter_fix (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_physics_ticks_per_second: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_physics_ticks_per_second")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_physics_ticks_per_second (_ physicsTicksPerSecond: Int32) {
        #if true
        
        var copy_physics_ticks_per_second: Int = Int (physicsTicksPerSecond)
        
        gi.object_method_bind_ptrcall_v (Engine.method_set_physics_ticks_per_second, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_physics_ticks_per_second)
        
        #else
        
        var copy_physics_ticks_per_second: Int = Int (physicsTicksPerSecond)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_physics_ticks_per_second) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_set_physics_ticks_per_second, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_physics_ticks_per_second: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_physics_ticks_per_second")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func get_physics_ticks_per_second ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Engine.method_get_physics_ticks_per_second, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_max_physics_steps_per_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_max_physics_steps_per_frame")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_max_physics_steps_per_frame (_ maxPhysicsSteps: Int32) {
        #if true
        
        var copy_max_physics_steps: Int = Int (maxPhysicsSteps)
        
        gi.object_method_bind_ptrcall_v (Engine.method_set_max_physics_steps_per_frame, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_max_physics_steps)
        
        #else
        
        var copy_max_physics_steps: Int = Int (maxPhysicsSteps)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_max_physics_steps) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_set_max_physics_steps_per_frame, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_max_physics_steps_per_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_max_physics_steps_per_frame")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func get_max_physics_steps_per_frame ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Engine.method_get_max_physics_steps_per_frame, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_physics_jitter_fix: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_physics_jitter_fix")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_physics_jitter_fix (_ physicsJitterFix: Double) {
        #if true
        
        var copy_physics_jitter_fix = physicsJitterFix
        
        gi.object_method_bind_ptrcall_v (Engine.method_set_physics_jitter_fix, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_physics_jitter_fix)
        
        #else
        
        var copy_physics_jitter_fix = physicsJitterFix
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_physics_jitter_fix) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_set_physics_jitter_fix, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_physics_jitter_fix: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_physics_jitter_fix")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func get_physics_jitter_fix ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Engine.method_get_physics_jitter_fix, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_physics_interpolation_fraction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_physics_interpolation_fraction")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the fraction through the current physics tick we are at the time of rendering the frame. This can be used to implement fixed timestep interpolation.
    public static func getPhysicsInterpolationFraction ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Engine.method_get_physics_interpolation_fraction, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_max_fps: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_max_fps")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_max_fps (_ maxFps: Int32) {
        #if true
        
        var copy_max_fps: Int = Int (maxFps)
        
        gi.object_method_bind_ptrcall_v (Engine.method_set_max_fps, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_max_fps)
        
        #else
        
        var copy_max_fps: Int = Int (maxFps)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_max_fps) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_set_max_fps, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_max_fps: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_max_fps")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func get_max_fps ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Engine.method_get_max_fps, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_time_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_time_scale")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_time_scale (_ timeScale: Double) {
        #if true
        
        var copy_time_scale = timeScale
        
        gi.object_method_bind_ptrcall_v (Engine.method_set_time_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_time_scale)
        
        #else
        
        var copy_time_scale = timeScale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_time_scale) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_set_time_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_time_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_time_scale")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 191475506)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func get_time_scale ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Engine.method_get_time_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_frames_drawn: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_frames_drawn")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2455072627)!
            }
            
        }
        
    }()
    
    /// Returns the total number of frames drawn. On headless platforms, or if the render loop is disabled with `--disable-render-loop` via command line, ``getFramesDrawn()`` always returns `0`. See ``getProcessFrames()``.
    public static func getFramesDrawn ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Engine.method_get_frames_drawn, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_frames_per_second: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_frames_per_second")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the frames per second of the running game.
    public static func getFramesPerSecond ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Engine.method_get_frames_per_second, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_physics_frames: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_physics_frames")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of frames passed since engine initialization which is advanced on each **physics frame**. See also ``getProcessFrames()``.
    /// 
    /// ``getPhysicsFrames()`` can be used to run expensive logic less often without relying on a ``Timer``:
    /// 
    public static func getPhysicsFrames ()-> UInt {
        var _result: UInt = 0
        gi.object_method_bind_ptrcall (Engine.method_get_physics_frames, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_process_frames: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_process_frames")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of frames passed since engine initialization which is advanced on each **process frame**, regardless of whether the render loop is enabled. See also ``getFramesDrawn()`` and ``getPhysicsFrames()``.
    /// 
    /// ``getProcessFrames()`` can be used to run expensive logic less often without relying on a ``Timer``:
    /// 
    public static func getProcessFrames ()-> UInt {
        var _result: UInt = 0
        gi.object_method_bind_ptrcall (Engine.method_get_process_frames, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_main_loop: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_main_loop")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1016888095)!
            }
            
        }
        
    }()
    
    /// Returns the main loop object (see ``MainLoop`` and ``SceneTree``).
    public static func getMainLoop ()-> MainLoop? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Engine.method_get_main_loop, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_version_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_version_info")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3102165223)!
            }
            
        }
        
    }()
    
    /// Returns the current engine version information in a Dictionary.
    /// 
    /// `major`    - Holds the major version number as an int
    /// 
    /// `minor`    - Holds the minor version number as an int
    /// 
    /// `patch`    - Holds the patch version number as an int
    /// 
    /// `hex`      - Holds the full version number encoded as a hexadecimal int with one byte (2 places) per number (see example below)
    /// 
    /// `status`   - Holds the status (e.g. "beta", "rc1", "rc2", ... "stable") as a String
    /// 
    /// `build`    - Holds the build name (e.g. "custom_build") as a String
    /// 
    /// `hash`     - Holds the full Git commit hash as a String
    /// 
    /// `year`     - Holds the year the version was released in as an int
    /// 
    /// `string`   - `major` + `minor` + `patch` + `status` + `build` in a single String
    /// 
    /// The `hex` value is encoded as follows, from left to right: one byte for the major, one byte for the minor, one byte for the patch version. For example, "3.1.12" would be `0x03010C`. > Note: It's still an int internally, and printing it will give you its decimal representation, which is not particularly meaningful. Use hexadecimal literals for easy version comparisons from code:
    /// 
    public static func getVersionInfo ()-> GDictionary {
        let _result: GDictionary = GDictionary ()
        gi.object_method_bind_ptrcall (Engine.method_get_version_info, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_author_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_author_info")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3102165223)!
            }
            
        }
        
    }()
    
    /// Returns engine author information in a Dictionary.
    /// 
    /// `lead_developers`    - Array of Strings, lead developer names
    /// 
    /// `founders`           - Array of Strings, founder names
    /// 
    /// `project_managers`   - Array of Strings, project manager names
    /// 
    /// `developers`         - Array of Strings, developer names
    /// 
    public static func getAuthorInfo ()-> GDictionary {
        let _result: GDictionary = GDictionary ()
        gi.object_method_bind_ptrcall (Engine.method_get_author_info, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_copyright_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_copyright_info")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns an Array of copyright information Dictionaries.
    /// 
    /// `name`    - String, component name
    /// 
    /// `parts`   - Array of Dictionaries {`files`, `copyright`, `license`} describing subsections of the component
    /// 
    public static func getCopyrightInfo ()-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (Engine.method_get_copyright_info, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_get_donor_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_donor_info")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3102165223)!
            }
            
        }
        
    }()
    
    /// Returns a Dictionary of Arrays of donor names.
    /// 
    /// {`platinum_sponsors`, `gold_sponsors`, `silver_sponsors`, `bronze_sponsors`, `mini_sponsors`, `gold_donors`, `silver_donors`, `bronze_donors`}
    /// 
    public static func getDonorInfo ()-> GDictionary {
        let _result: GDictionary = GDictionary ()
        gi.object_method_bind_ptrcall (Engine.method_get_donor_info, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_license_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_license_info")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3102165223)!
            }
            
        }
        
    }()
    
    /// Returns Dictionary of licenses used by Godot and included third party components.
    public static func getLicenseInfo ()-> GDictionary {
        let _result: GDictionary = GDictionary ()
        gi.object_method_bind_ptrcall (Engine.method_get_license_info, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_license_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_license_text")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns Godot license text.
    public static func getLicenseText ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Engine.method_get_license_text, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_architecture_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_architecture_name")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the name of the CPU architecture the Godot binary was built for. Possible return values are `x86_64`, `x86_32`, `arm64`, `arm32`, `rv64`, `riscv`, `ppc64`, `ppc`, `wasm64` and `wasm32`.
    /// 
    /// To detect whether the current CPU architecture is 64-bit, you can use the fact that all 64-bit architecture names have `64` in their name:
    /// 
    /// > Note: ``getArchitectureName()`` does _not_ return the name of the host CPU architecture. For example, if running an x86_32 Godot binary on a x86_64 system, the returned value will be `x86_32`.
    /// 
    public static func getArchitectureName ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Engine.method_get_architecture_name, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_is_in_physics_frame: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_in_physics_frame")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the game is inside the fixed process and physics phase of the game loop.
    public static func isInPhysicsFrame ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Engine.method_is_in_physics_frame, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_has_singleton: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_singleton")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a singleton with given `name` exists in global scope.
    public static func hasSingleton (name: StringName)-> Bool {
        var _result: Bool = false
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Engine.method_has_singleton, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_has_singleton, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_singleton: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_singleton")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1371597918)!
            }
            
        }
        
    }()
    
    /// Returns a global singleton with given `name`. Often used for plugins, e.g. GodotPayments.
    public static func getSingleton (name: StringName)-> Object? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Engine.method_get_singleton, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &name.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_get_singleton, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_register_singleton: GDExtensionMethodBindPtr = {
        let methodName = StringName ("register_singleton")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 965313290)!
            }
            
        }
        
    }()
    
    /// Registers the given object as a singleton, globally available under `name`.
    public static func registerSingleton (name: StringName, instance: Object?) {
        #if true
        
        var copy_instance_handle = instance?.handle
        
        gi.object_method_bind_ptrcall_v (Engine.method_register_singleton, UnsafeMutableRawPointer (mutating: shared.handle), nil, &name.content, &copy_instance_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: instance?.handle) { p1 in
            _args.append (instance == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (Engine.method_register_singleton, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_unregister_singleton: GDExtensionMethodBindPtr = {
        let methodName = StringName ("unregister_singleton")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Unregisters the singleton registered under `name`. The singleton object is not freed. Only works with user-defined singletons created with ``registerSingleton(name:instance:)``.
    public static func unregisterSingleton (name: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (Engine.method_unregister_singleton, UnsafeMutableRawPointer (mutating: shared.handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_unregister_singleton, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_singleton_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_singleton_list")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns a list of available global singletons.
    public static func getSingletonList ()-> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall (Engine.method_get_singleton_list, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_register_script_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("register_script_language")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1850254898)!
            }
            
        }
        
    }()
    
    /// Registers a ``ScriptLanguage`` instance to be available with `ScriptServer`.
    /// 
    /// Returns:
    /// 
    /// - ``GodotError/ok`` on success
    /// 
    /// - ``GodotError/errUnavailable`` if `ScriptServer` has reached it limit and cannot register any new language
    /// 
    /// - ``GodotError/errAlreadyExists`` if `ScriptServer` already contains a language with similar extension/name/type
    /// 
    public static func registerScriptLanguage (_ language: ScriptLanguage?)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_language_handle = language?.handle
        
        gi.object_method_bind_ptrcall_v (Engine.method_register_script_language, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_language_handle)
        return GodotError (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: language?.handle) { p0 in
        _args.append (language == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Engine.method_register_script_language, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return GodotError (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_unregister_script_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("unregister_script_language")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1850254898)!
            }
            
        }
        
    }()
    
    /// Unregisters the ``ScriptLanguage`` instance from `ScriptServer`.
    /// 
    /// Returns:
    /// 
    /// - ``GodotError/ok`` on success
    /// 
    /// - ``GodotError/errDoesNotExist`` if the language is already not registered in `ScriptServer`
    /// 
    public static func unregisterScriptLanguage (_ language: ScriptLanguage?)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_language_handle = language?.handle
        
        gi.object_method_bind_ptrcall_v (Engine.method_unregister_script_language, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_language_handle)
        return GodotError (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: language?.handle) { p0 in
        _args.append (language == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Engine.method_unregister_script_language, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return GodotError (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_script_language_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_script_language_count")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2455072627)!
            }
            
        }
        
    }()
    
    /// Returns the number of available script languages. Use with ``getScriptLanguage(index:)``.
    public static func getScriptLanguageCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Engine.method_get_script_language_count, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_script_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_script_language")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2151255799)!
            }
            
        }
        
    }()
    
    /// Returns an instance of a ``ScriptLanguage`` with the given index.
    public static func getScriptLanguage (index: Int32)-> ScriptLanguage? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (Engine.method_get_script_language, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_index)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_get_script_language, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_is_editor_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_editor_hint")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the script is currently running inside the editor, `false` otherwise. This is useful for `@tool` scripts to conditionally draw editor helpers, or prevent accidentally running "game" code that would affect the scene state while in the editor:
    /// 
    /// See [url=$DOCS_URL/tutorials/plugins/running_code_in_the_editor.html]Running code in the editor[/url] in the documentation for more information.
    /// 
    /// > Note: To detect whether the script is run from an editor _build_ (e.g. when pressing [kbd]F5[/kbd]), use ``OS/hasFeature(tagName:)`` with the `"editor"` argument instead. `OS.has_feature("editor")` will evaluate to `true` both when the code is running in the editor and when running the project from the editor, but it will evaluate to `false` when the code is run from an exported project.
    /// 
    public static func isEditorHint ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Engine.method_is_editor_hint, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_write_movie_path: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_write_movie_path")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the path to the ``MovieWriter``'s output file, or an empty string if the engine wasn't started in Movie Maker mode. This path can be absolute or relative depending on how the user specified it.
    public static func getWriteMoviePath ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Engine.method_get_write_movie_path, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_print_error_messages: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_print_error_messages")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_print_error_messages (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (Engine.method_set_print_error_messages, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Engine.method_set_print_error_messages, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_printing_error_messages: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_printing_error_messages")
        return withUnsafePointer (to: &Engine.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func is_printing_error_messages ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Engine.method_is_printing_error_messages, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
}

