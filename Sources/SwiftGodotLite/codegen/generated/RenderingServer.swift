// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Server for anything visible.
/// 
/// The rendering server is the API backend for everything visible. The whole scene system mounts on it to display. The rendering server is completely opaque: the internals are entirely implementation-specific and cannot be accessed.
/// 
/// The rendering server can be used to bypass the scene/``Node`` system entirely. This can improve performance in cases where the scene system is the bottleneck, but won't improve performance otherwise (for instance, if the GPU is already fully utilized).
/// 
/// Resources are created using the `*_create` functions. These functions return ``RID``s which are not references to the objects themselves, but opaque _pointers_ towards these objects.
/// 
/// All objects are drawn to a viewport. You can use the ``Viewport`` attached to the ``SceneTree`` or you can create one yourself with ``viewportCreate()``. When using a custom scenario or canvas, the scenario or canvas needs to be attached to the viewport using ``viewportSetScenario(viewport:scenario:)`` or ``viewportAttachCanvas(viewport:canvas:)``.
/// 
/// **Scenarios:** In 3D, all visual objects must be associated with a scenario. The scenario is a visual representation of the world. If accessing the rendering server from a running game, the scenario can be accessed from the scene tree from any ``Node3D`` node with ``Node3D/getWorld3d()``. Otherwise, a scenario can be created with ``scenarioCreate()``.
/// 
/// Similarly, in 2D, a canvas is needed to draw all canvas items.
/// 
/// **3D:** In 3D, all visible objects are comprised of a resource and an instance. A resource can be a mesh, a particle system, a light, or any other 3D object. In order to be visible resources must be attached to an instance using ``instanceSetBase(instance:base:)``. The instance must also be attached to the scenario using ``instanceSetScenario(instance:scenario:)`` in order to be visible. RenderingServer methods that don't have a prefix are usually 3D-specific (but not always).
/// 
/// **2D:** In 2D, all visible objects are some form of canvas item. In order to be visible, a canvas item needs to be the child of a canvas attached to a viewport, or it needs to be the child of another canvas item that is eventually attached to the canvas. 2D-specific RenderingServer methods generally start with `canvas_*`.
/// 
/// **Headless mode:** Starting the engine with the `--headless` [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url] disables all rendering and window management functions. Most functions from ``RenderingServer`` will return dummy values in this case.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``framePreDraw``
/// - ``framePostDraw``
open class RenderingServer: Object {
    /// The shared instance of this class
    public static var shared: RenderingServer = {
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { ptr in
            RenderingServer (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "RenderingServer" }
    public enum TextureLayeredType: Int64 {
        /// Array of 2-dimensional textures (see ``Texture2DArray``).
        case textureLayered2dArray = 0 // TEXTURE_LAYERED_2D_ARRAY
        /// Cubemap texture (see ``Cubemap``).
        case cubemap = 1 // TEXTURE_LAYERED_CUBEMAP
        /// Array of cubemap textures (see ``CubemapArray``).
        case cubemapArray = 2 // TEXTURE_LAYERED_CUBEMAP_ARRAY
    }
    
    public enum CubeMapLayer: Int64 {
        /// Left face of a ``Cubemap``.
        case left = 0 // CUBEMAP_LAYER_LEFT
        /// Right face of a ``Cubemap``.
        case right = 1 // CUBEMAP_LAYER_RIGHT
        /// Bottom face of a ``Cubemap``.
        case bottom = 2 // CUBEMAP_LAYER_BOTTOM
        /// Top face of a ``Cubemap``.
        case top = 3 // CUBEMAP_LAYER_TOP
        /// Front face of a ``Cubemap``.
        case front = 4 // CUBEMAP_LAYER_FRONT
        /// Back face of a ``Cubemap``.
        case back = 5 // CUBEMAP_LAYER_BACK
    }
    
    public enum ShaderMode: Int64 {
        /// Shader is a 3D shader.
        case spatial = 0 // SHADER_SPATIAL
        /// Shader is a 2D shader.
        case canvasItem = 1 // SHADER_CANVAS_ITEM
        /// Shader is a particle shader (can be used in both 2D and 3D).
        case particles = 2 // SHADER_PARTICLES
        /// Shader is a 3D sky shader.
        case sky = 3 // SHADER_SKY
        /// Shader is a 3D fog shader.
        case fog = 4 // SHADER_FOG
        /// Represents the size of the ``RenderingServer/ShaderMode`` enum.
        case max = 5 // SHADER_MAX
    }
    
    public enum ArrayType: Int64 {
        /// Array is a vertex position array.
        case vertex = 0 // ARRAY_VERTEX
        /// Array is a normal array.
        case normal = 1 // ARRAY_NORMAL
        /// Array is a tangent array.
        case tangent = 2 // ARRAY_TANGENT
        /// Array is a vertex color array.
        case color = 3 // ARRAY_COLOR
        /// Array is a UV coordinates array.
        case texUv = 4 // ARRAY_TEX_UV
        /// Array is a UV coordinates array for the second set of UV coordinates.
        case texUv2 = 5 // ARRAY_TEX_UV2
        /// Array is a custom data array for the first set of custom data.
        case custom0 = 6 // ARRAY_CUSTOM0
        /// Array is a custom data array for the second set of custom data.
        case custom1 = 7 // ARRAY_CUSTOM1
        /// Array is a custom data array for the third set of custom data.
        case custom2 = 8 // ARRAY_CUSTOM2
        /// Array is a custom data array for the fourth set of custom data.
        case custom3 = 9 // ARRAY_CUSTOM3
        /// Array contains bone information.
        case bones = 10 // ARRAY_BONES
        /// Array is weight information.
        case weights = 11 // ARRAY_WEIGHTS
        /// Array is an index array.
        case index = 12 // ARRAY_INDEX
        /// Represents the size of the ``RenderingServer/ArrayType`` enum.
        case max = 13 // ARRAY_MAX
    }
    
    public enum ArrayCustomFormat: Int64 {
        /// Custom data array contains 8-bit-per-channel red/green/blue/alpha color data. Values are normalized, unsigned floating-point in the `[0.0, 1.0]` range.
        case rgba8Unorm = 0 // ARRAY_CUSTOM_RGBA8_UNORM
        /// Custom data array contains 8-bit-per-channel red/green/blue/alpha color data. Values are normalized, signed floating-point in the `[-1.0, 1.0]` range.
        case rgba8Snorm = 1 // ARRAY_CUSTOM_RGBA8_SNORM
        /// Custom data array contains 16-bit-per-channel red/green color data. Values are floating-point in half precision.
        case rgHalf = 2 // ARRAY_CUSTOM_RG_HALF
        /// Custom data array contains 16-bit-per-channel red/green/blue/alpha color data. Values are floating-point in half precision.
        case rgbaHalf = 3 // ARRAY_CUSTOM_RGBA_HALF
        /// Custom data array contains 32-bit-per-channel red color data. Values are floating-point in single precision.
        case rFloat = 4 // ARRAY_CUSTOM_R_FLOAT
        /// Custom data array contains 32-bit-per-channel red/green color data. Values are floating-point in single precision.
        case rgFloat = 5 // ARRAY_CUSTOM_RG_FLOAT
        /// Custom data array contains 32-bit-per-channel red/green/blue color data. Values are floating-point in single precision.
        case rgbFloat = 6 // ARRAY_CUSTOM_RGB_FLOAT
        /// Custom data array contains 32-bit-per-channel red/green/blue/alpha color data. Values are floating-point in single precision.
        case rgbaFloat = 7 // ARRAY_CUSTOM_RGBA_FLOAT
        /// Represents the size of the ``RenderingServer/ArrayCustomFormat`` enum.
        case max = 8 // ARRAY_CUSTOM_MAX
    }
    
    public struct ArrayFormat: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Flag used to mark a vertex position array.
        public static let formatVertex = ArrayFormat (rawValue: 1)
        /// Flag used to mark a normal array.
        public static let formatNormal = ArrayFormat (rawValue: 2)
        /// Flag used to mark a tangent array.
        public static let formatTangent = ArrayFormat (rawValue: 4)
        /// Flag used to mark a vertex color array.
        public static let formatColor = ArrayFormat (rawValue: 8)
        /// Flag used to mark a UV coordinates array.
        public static let formatTexUv = ArrayFormat (rawValue: 16)
        /// Flag used to mark a UV coordinates array for the second UV coordinates.
        public static let formatTexUv2 = ArrayFormat (rawValue: 32)
        /// Flag used to mark an array of custom per-vertex data for the first set of custom data.
        public static let formatCustom0 = ArrayFormat (rawValue: 64)
        /// Flag used to mark an array of custom per-vertex data for the second set of custom data.
        public static let formatCustom1 = ArrayFormat (rawValue: 128)
        /// Flag used to mark an array of custom per-vertex data for the third set of custom data.
        public static let formatCustom2 = ArrayFormat (rawValue: 256)
        /// Flag used to mark an array of custom per-vertex data for the fourth set of custom data.
        public static let formatCustom3 = ArrayFormat (rawValue: 512)
        /// Flag used to mark a bone information array.
        public static let formatBones = ArrayFormat (rawValue: 1024)
        /// Flag used to mark a weights array.
        public static let formatWeights = ArrayFormat (rawValue: 2048)
        /// Flag used to mark an index array.
        public static let formatIndex = ArrayFormat (rawValue: 4096)
        /// 
        public static let formatBlendShapeMask = ArrayFormat (rawValue: 7)
        /// 
        public static let formatCustomBase = ArrayFormat (rawValue: 13)
        /// 
        public static let formatCustomBits = ArrayFormat (rawValue: 3)
        /// 
        public static let formatCustom0Shift = ArrayFormat (rawValue: 13)
        /// 
        public static let formatCustom1Shift = ArrayFormat (rawValue: 16)
        /// 
        public static let formatCustom2Shift = ArrayFormat (rawValue: 19)
        /// 
        public static let formatCustom3Shift = ArrayFormat (rawValue: 22)
        /// 
        public static let formatCustomMask = ArrayFormat (rawValue: 7)
        /// 
        public static let compressFlagsBase = ArrayFormat (rawValue: 25)
        /// Flag used to mark that the array contains 2D vertices.
        public static let flagUse2dVertices = ArrayFormat (rawValue: 33554432)
        /// 
        public static let flagUseDynamicUpdate = ArrayFormat (rawValue: 67108864)
        /// Flag used to mark that the array uses 8 bone weights instead of 4.
        public static let flagUse8BoneWeights = ArrayFormat (rawValue: 134217728)
        /// Flag used to mark that the mesh does not have a vertex array and instead will infer vertex positions in the shader using indices and other information.
        public static let flagUsesEmptyVertexArray = ArrayFormat (rawValue: 268435456)
        /// Flag used to mark that a mesh is using compressed attributes (vertices, normals, tangents, UVs). When this form of compression is enabled, vertex positions will be packed into an RGBA16UNORM attribute and scaled in the vertex shader. The normal and tangent will be packed into an RG16UNORM representing an axis, and a 16-bit float stored in the A-channel of the vertex. UVs will use 16-bit normalized floats instead of full 32-bit signed floats. When using this compression mode you must use either vertices, normals, and tangents or only vertices. You cannot use normals without tangents. Importers will automatically enable this compression if they can.
        public static let flagCompressAttributes = ArrayFormat (rawValue: 536870912)
        /// Flag used to mark the start of the bits used to store the mesh version.
        public static let flagFormatVersionBase = ArrayFormat (rawValue: 35)
        /// Flag used to shift a mesh format int to bring the version into the lowest digits.
        public static let flagFormatVersionShift = ArrayFormat (rawValue: 35)
        /// Flag used to record the second iteration of the mesh version flag. The primary difference between this and .arrayFlagFormatVersion1 is that this version supports .arrayFlagCompressAttributes and in this version vertex positions are de-interleaved from normals and tangents.
        public static let flagFormatVersion2 = ArrayFormat (rawValue: 34359738368)
        /// Flag used to record the current version that the engine expects. Currently this is the same as .arrayFlagFormatVersion2.
        public static let flagFormatCurrentVersion = ArrayFormat (rawValue: 34359738368)
        /// Flag used to isolate the bits used for mesh version after using .arrayFlagFormatVersionShift to shift them into place.
        public static let flagFormatVersionMask = ArrayFormat (rawValue: 255)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.formatVertex) { result += "formatVertex, " }
            if self.contains (.formatNormal) { result += "formatNormal, " }
            if self.contains (.formatTangent) { result += "formatTangent, " }
            if self.contains (.formatColor) { result += "formatColor, " }
            if self.contains (.formatTexUv) { result += "formatTexUv, " }
            if self.contains (.formatTexUv2) { result += "formatTexUv2, " }
            if self.contains (.formatCustom0) { result += "formatCustom0, " }
            if self.contains (.formatCustom1) { result += "formatCustom1, " }
            if self.contains (.formatCustom2) { result += "formatCustom2, " }
            if self.contains (.formatCustom3) { result += "formatCustom3, " }
            if self.contains (.formatBones) { result += "formatBones, " }
            if self.contains (.formatWeights) { result += "formatWeights, " }
            if self.contains (.formatIndex) { result += "formatIndex, " }
            if self.contains (.formatBlendShapeMask) { result += "formatBlendShapeMask, " }
            if self.contains (.formatCustomBase) { result += "formatCustomBase, " }
            if self.contains (.formatCustomBits) { result += "formatCustomBits, " }
            if self.contains (.formatCustom0Shift) { result += "formatCustom0Shift, " }
            if self.contains (.formatCustom1Shift) { result += "formatCustom1Shift, " }
            if self.contains (.formatCustom2Shift) { result += "formatCustom2Shift, " }
            if self.contains (.formatCustom3Shift) { result += "formatCustom3Shift, " }
            if self.contains (.formatCustomMask) { result += "formatCustomMask, " }
            if self.contains (.compressFlagsBase) { result += "compressFlagsBase, " }
            if self.contains (.flagUse2dVertices) { result += "flagUse2dVertices, " }
            if self.contains (.flagUseDynamicUpdate) { result += "flagUseDynamicUpdate, " }
            if self.contains (.flagUse8BoneWeights) { result += "flagUse8BoneWeights, " }
            if self.contains (.flagUsesEmptyVertexArray) { result += "flagUsesEmptyVertexArray, " }
            if self.contains (.flagCompressAttributes) { result += "flagCompressAttributes, " }
            if self.contains (.flagFormatVersionBase) { result += "flagFormatVersionBase, " }
            if self.contains (.flagFormatVersionShift) { result += "flagFormatVersionShift, " }
            if self.contains (.flagFormatVersion2) { result += "flagFormatVersion2, " }
            if self.contains (.flagFormatCurrentVersion) { result += "flagFormatCurrentVersion, " }
            if self.contains (.flagFormatVersionMask) { result += "flagFormatVersionMask, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum PrimitiveType: Int64 {
        /// Primitive to draw consists of points.
        case points = 0 // PRIMITIVE_POINTS
        /// Primitive to draw consists of lines.
        case lines = 1 // PRIMITIVE_LINES
        /// Primitive to draw consists of a line strip from start to end.
        case lineStrip = 2 // PRIMITIVE_LINE_STRIP
        /// Primitive to draw consists of triangles.
        case triangles = 3 // PRIMITIVE_TRIANGLES
        /// Primitive to draw consists of a triangle strip (the last 3 vertices are always combined to make a triangle).
        case triangleStrip = 4 // PRIMITIVE_TRIANGLE_STRIP
        /// Represents the size of the ``RenderingServer/PrimitiveType`` enum.
        case max = 5 // PRIMITIVE_MAX
    }
    
    public enum BlendShapeMode: Int64 {
        /// Blend shapes are normalized.
        case normalized = 0 // BLEND_SHAPE_MODE_NORMALIZED
        /// Blend shapes are relative to base weight.
        case relative = 1 // BLEND_SHAPE_MODE_RELATIVE
    }
    
    public enum MultimeshTransformFormat: Int64 {
        /// Use ``Transform2D`` to store MultiMesh transform.
        case multimeshTransform2d = 0 // MULTIMESH_TRANSFORM_2D
        /// Use ``Transform3D`` to store MultiMesh transform.
        case multimeshTransform3d = 1 // MULTIMESH_TRANSFORM_3D
    }
    
    public enum LightProjectorFilter: Int64 {
        /// Nearest-neighbor filter for light projectors (use for pixel art light projectors). No mipmaps are used for rendering, which means light projectors at a distance will look sharp but grainy. This has roughly the same performance cost as using mipmaps.
        case nearest = 0 // LIGHT_PROJECTOR_FILTER_NEAREST
        /// Linear filter for light projectors (use for non-pixel art light projectors). No mipmaps are used for rendering, which means light projectors at a distance will look smooth but blurry. This has roughly the same performance cost as using mipmaps.
        case linear = 1 // LIGHT_PROJECTOR_FILTER_LINEAR
        /// Nearest-neighbor filter for light projectors (use for pixel art light projectors). Isotropic mipmaps are used for rendering, which means light projectors at a distance will look smooth but blurry. This has roughly the same performance cost as not using mipmaps.
        case nearestMipmaps = 2 // LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS
        /// Linear filter for light projectors (use for non-pixel art light projectors). Isotropic mipmaps are used for rendering, which means light projectors at a distance will look smooth but blurry. This has roughly the same performance cost as not using mipmaps.
        case linearMipmaps = 3 // LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS
        /// Nearest-neighbor filter for light projectors (use for pixel art light projectors). Anisotropic mipmaps are used for rendering, which means light projectors at a distance will look smooth and sharp when viewed from oblique angles. This looks better compared to isotropic mipmaps, but is slower. The level of anisotropic filtering is defined by ``ProjectSettings/rendering/textures/defaultFilters/anisotropicFilteringLevel``.
        case nearestMipmapsAnisotropic = 4 // LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS_ANISOTROPIC
        /// Linear filter for light projectors (use for non-pixel art light projectors). Anisotropic mipmaps are used for rendering, which means light projectors at a distance will look smooth and sharp when viewed from oblique angles. This looks better compared to isotropic mipmaps, but is slower. The level of anisotropic filtering is defined by ``ProjectSettings/rendering/textures/defaultFilters/anisotropicFilteringLevel``.
        case linearMipmapsAnisotropic = 5 // LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS_ANISOTROPIC
    }
    
    public enum LightType: Int64 {
        /// Directional (sun/moon) light (see ``DirectionalLight3D``).
        case directional = 0 // LIGHT_DIRECTIONAL
        /// Omni light (see ``OmniLight3D``).
        case omni = 1 // LIGHT_OMNI
        /// Spot light (see ``SpotLight3D``).
        case spot = 2 // LIGHT_SPOT
    }
    
    public enum LightParam: Int64 {
        /// The light's energy multiplier.
        case energy = 0 // LIGHT_PARAM_ENERGY
        /// The light's indirect energy multiplier (final indirect energy is .energy * .indirectEnergy).
        case indirectEnergy = 1 // LIGHT_PARAM_INDIRECT_ENERGY
        /// The light's volumetric fog energy multiplier (final volumetric fog energy is .energy * .volumetricFogEnergy).
        case volumetricFogEnergy = 2 // LIGHT_PARAM_VOLUMETRIC_FOG_ENERGY
        /// The light's influence on specularity.
        case specular = 3 // LIGHT_PARAM_SPECULAR
        /// The light's range.
        case range = 4 // LIGHT_PARAM_RANGE
        /// The size of the light when using spot light or omni light. The angular size of the light when using directional light.
        case size = 5 // LIGHT_PARAM_SIZE
        /// The light's attenuation.
        case attenuation = 6 // LIGHT_PARAM_ATTENUATION
        /// The spotlight's angle.
        case spotAngle = 7 // LIGHT_PARAM_SPOT_ANGLE
        /// The spotlight's attenuation.
        case spotAttenuation = 8 // LIGHT_PARAM_SPOT_ATTENUATION
        /// The maximum distance for shadow splits. Increasing this value will make directional shadows visible from further away, at the cost of lower overall shadow detail and performance (since more objects need to be included in the directional shadow rendering).
        case shadowMaxDistance = 9 // LIGHT_PARAM_SHADOW_MAX_DISTANCE
        /// Proportion of shadow atlas occupied by the first split.
        case shadowSplit1Offset = 10 // LIGHT_PARAM_SHADOW_SPLIT_1_OFFSET
        /// Proportion of shadow atlas occupied by the second split.
        case shadowSplit2Offset = 11 // LIGHT_PARAM_SHADOW_SPLIT_2_OFFSET
        /// Proportion of shadow atlas occupied by the third split. The fourth split occupies the rest.
        case shadowSplit3Offset = 12 // LIGHT_PARAM_SHADOW_SPLIT_3_OFFSET
        /// Proportion of shadow max distance where the shadow will start to fade out.
        case shadowFadeStart = 13 // LIGHT_PARAM_SHADOW_FADE_START
        /// Normal bias used to offset shadow lookup by object normal. Can be used to fix self-shadowing artifacts.
        case shadowNormalBias = 14 // LIGHT_PARAM_SHADOW_NORMAL_BIAS
        /// Bias the shadow lookup to fix self-shadowing artifacts.
        case shadowBias = 15 // LIGHT_PARAM_SHADOW_BIAS
        /// Sets the size of the directional shadow pancake. The pancake offsets the start of the shadow's camera frustum to provide a higher effective depth resolution for the shadow. However, a high pancake size can cause artifacts in the shadows of large objects that are close to the edge of the frustum. Reducing the pancake size can help. Setting the size to `0` turns off the pancaking effect.
        case shadowPancakeSize = 16 // LIGHT_PARAM_SHADOW_PANCAKE_SIZE
        /// The light's shadow opacity. Values lower than `1.0` make the light appear through shadows. This can be used to fake global illumination at a low performance cost.
        case shadowOpacity = 17 // LIGHT_PARAM_SHADOW_OPACITY
        /// Blurs the edges of the shadow. Can be used to hide pixel artifacts in low resolution shadow maps. A high value can make shadows appear grainy and can cause other unwanted artifacts. Try to keep as near default as possible.
        case shadowBlur = 18 // LIGHT_PARAM_SHADOW_BLUR
        /// 
        case transmittanceBias = 19 // LIGHT_PARAM_TRANSMITTANCE_BIAS
        /// Constant representing the intensity of the light, measured in Lumens when dealing with a ``SpotLight3D`` or ``OmniLight3D``, or measured in Lux with a ``DirectionalLight3D``. Only used when ``ProjectSettings/rendering/lightsAndShadows/usePhysicalLightUnits`` is `true`.
        case intensity = 20 // LIGHT_PARAM_INTENSITY
        /// Represents the size of the ``RenderingServer/LightParam`` enum.
        case max = 21 // LIGHT_PARAM_MAX
    }
    
    public enum LightBakeMode: Int64 {
        /// Light is ignored when baking. This is the fastest mode, but the light will be taken into account when baking global illumination. This mode should generally be used for dynamic lights that change quickly, as the effect of global illumination is less noticeable on those lights.
        case disabled = 0 // LIGHT_BAKE_DISABLED
        /// Light is taken into account in static baking (``VoxelGI``, ``LightmapGI``, SDFGI (``Environment/sdfgiEnabled``)). The light can be moved around or modified, but its global illumination will not update in real-time. This is suitable for subtle changes (such as flickering torches), but generally not large changes such as toggling a light on and off.
        case `static` = 1 // LIGHT_BAKE_STATIC
        /// Light is taken into account in dynamic baking (``VoxelGI`` and SDFGI (``Environment/sdfgiEnabled``) only). The light can be moved around or modified with global illumination updating in real-time. The light's global illumination appearance will be slightly different compared to .lightBakeStatic. This has a greater performance cost compared to .lightBakeStatic. When using SDFGI, the update speed of dynamic lights is affected by ``ProjectSettings/rendering/globalIllumination/sdfgi/framesToUpdateLights``.
        case dynamic = 2 // LIGHT_BAKE_DYNAMIC
    }
    
    public enum LightOmniShadowMode: Int64 {
        /// Use a dual paraboloid shadow map for omni lights.
        case dualParaboloid = 0 // LIGHT_OMNI_SHADOW_DUAL_PARABOLOID
        /// Use a cubemap shadow map for omni lights. Slower but better quality than dual paraboloid.
        case cube = 1 // LIGHT_OMNI_SHADOW_CUBE
    }
    
    public enum LightDirectionalShadowMode: Int64 {
        /// Use orthogonal shadow projection for directional light.
        case orthogonal = 0 // LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL
        /// Use 2 splits for shadow projection when using directional light.
        case parallel2Splits = 1 // LIGHT_DIRECTIONAL_SHADOW_PARALLEL_2_SPLITS
        /// Use 4 splits for shadow projection when using directional light.
        case parallel4Splits = 2 // LIGHT_DIRECTIONAL_SHADOW_PARALLEL_4_SPLITS
    }
    
    public enum LightDirectionalSkyMode: Int64 {
        /// Use DirectionalLight3D in both sky rendering and scene lighting.
        case lightAndSky = 0 // LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_AND_SKY
        /// Only use DirectionalLight3D in scene lighting.
        case lightOnly = 1 // LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_ONLY
        /// Only use DirectionalLight3D in sky rendering.
        case skyOnly = 2 // LIGHT_DIRECTIONAL_SKY_MODE_SKY_ONLY
    }
    
    public enum ShadowQuality: Int64 {
        /// Lowest shadow filtering quality (fastest). Soft shadows are not available with this quality setting, which means the ``Light3D/shadowBlur`` property is ignored if ``Light3D/lightSize`` and ``Light3D/lightAngularDistance`` is `0.0`.
        /// 
        /// > Note: The variable shadow blur performed by ``Light3D/lightSize`` and ``Light3D/lightAngularDistance`` is still effective when using hard shadow filtering. In this case, ``Light3D/shadowBlur`` _is_ taken into account. However, the results will not be blurred, instead the blur amount is treated as a maximum radius for the penumbra.
        /// 
        case hard = 0 // SHADOW_QUALITY_HARD
        /// Very low shadow filtering quality (faster). When using this quality setting, ``Light3D/shadowBlur`` is automatically multiplied by 0.75× to avoid introducing too much noise. This division only applies to lights whose ``Light3D/lightSize`` or ``Light3D/lightAngularDistance`` is `0.0`).
        case softVeryLow = 1 // SHADOW_QUALITY_SOFT_VERY_LOW
        /// Low shadow filtering quality (fast).
        case softLow = 2 // SHADOW_QUALITY_SOFT_LOW
        /// Medium low shadow filtering quality (average).
        case softMedium = 3 // SHADOW_QUALITY_SOFT_MEDIUM
        /// High low shadow filtering quality (slow). When using this quality setting, ``Light3D/shadowBlur`` is automatically multiplied by 1.5× to better make use of the high sample count. This increased blur also improves the stability of dynamic object shadows. This multiplier only applies to lights whose ``Light3D/lightSize`` or ``Light3D/lightAngularDistance`` is `0.0`).
        case softHigh = 4 // SHADOW_QUALITY_SOFT_HIGH
        /// Highest low shadow filtering quality (slowest). When using this quality setting, ``Light3D/shadowBlur`` is automatically multiplied by 2× to better make use of the high sample count. This increased blur also improves the stability of dynamic object shadows. This multiplier only applies to lights whose ``Light3D/lightSize`` or ``Light3D/lightAngularDistance`` is `0.0`).
        case softUltra = 5 // SHADOW_QUALITY_SOFT_ULTRA
        /// Represents the size of the ``RenderingServer/ShadowQuality`` enum.
        case max = 6 // SHADOW_QUALITY_MAX
    }
    
    public enum ReflectionProbeUpdateMode: Int64 {
        /// Reflection probe will update reflections once and then stop.
        case once = 0 // REFLECTION_PROBE_UPDATE_ONCE
        /// Reflection probe will update each frame. This mode is necessary to capture moving objects.
        case always = 1 // REFLECTION_PROBE_UPDATE_ALWAYS
    }
    
    public enum ReflectionProbeAmbientMode: Int64 {
        /// Do not apply any ambient lighting inside the reflection probe's box defined by its size.
        case disabled = 0 // REFLECTION_PROBE_AMBIENT_DISABLED
        /// Apply automatically-sourced environment lighting inside the reflection probe's box defined by its size.
        case environment = 1 // REFLECTION_PROBE_AMBIENT_ENVIRONMENT
        /// Apply custom ambient lighting inside the reflection probe's box defined by its size. See ``reflectionProbeSetAmbientColor(probe:color:)`` and ``reflectionProbeSetAmbientEnergy(probe:energy:)``.
        case color = 2 // REFLECTION_PROBE_AMBIENT_COLOR
    }
    
    public enum DecalTexture: Int64 {
        /// Albedo texture slot in a decal (``Decal/textureAlbedo``).
        case albedo = 0 // DECAL_TEXTURE_ALBEDO
        /// Normal map texture slot in a decal (``Decal/textureNormal``).
        case normal = 1 // DECAL_TEXTURE_NORMAL
        /// Occlusion/Roughness/Metallic texture slot in a decal (``Decal/textureOrm``).
        case orm = 2 // DECAL_TEXTURE_ORM
        /// Emission texture slot in a decal (``Decal/textureEmission``).
        case emission = 3 // DECAL_TEXTURE_EMISSION
        /// Represents the size of the ``RenderingServer/DecalTexture`` enum.
        case max = 4 // DECAL_TEXTURE_MAX
    }
    
    public enum DecalFilter: Int64 {
        /// Nearest-neighbor filter for decals (use for pixel art decals). No mipmaps are used for rendering, which means decals at a distance will look sharp but grainy. This has roughly the same performance cost as using mipmaps.
        case nearest = 0 // DECAL_FILTER_NEAREST
        /// Linear filter for decals (use for non-pixel art decals). No mipmaps are used for rendering, which means decals at a distance will look smooth but blurry. This has roughly the same performance cost as using mipmaps.
        case linear = 1 // DECAL_FILTER_LINEAR
        /// Nearest-neighbor filter for decals (use for pixel art decals). Isotropic mipmaps are used for rendering, which means decals at a distance will look smooth but blurry. This has roughly the same performance cost as not using mipmaps.
        case nearestMipmaps = 2 // DECAL_FILTER_NEAREST_MIPMAPS
        /// Linear filter for decals (use for non-pixel art decals). Isotropic mipmaps are used for rendering, which means decals at a distance will look smooth but blurry. This has roughly the same performance cost as not using mipmaps.
        case linearMipmaps = 3 // DECAL_FILTER_LINEAR_MIPMAPS
        /// Nearest-neighbor filter for decals (use for pixel art decals). Anisotropic mipmaps are used for rendering, which means decals at a distance will look smooth and sharp when viewed from oblique angles. This looks better compared to isotropic mipmaps, but is slower. The level of anisotropic filtering is defined by ``ProjectSettings/rendering/textures/defaultFilters/anisotropicFilteringLevel``.
        case nearestMipmapsAnisotropic = 4 // DECAL_FILTER_NEAREST_MIPMAPS_ANISOTROPIC
        /// Linear filter for decals (use for non-pixel art decals). Anisotropic mipmaps are used for rendering, which means decals at a distance will look smooth and sharp when viewed from oblique angles. This looks better compared to isotropic mipmaps, but is slower. The level of anisotropic filtering is defined by ``ProjectSettings/rendering/textures/defaultFilters/anisotropicFilteringLevel``.
        case linearMipmapsAnisotropic = 5 // DECAL_FILTER_LINEAR_MIPMAPS_ANISOTROPIC
    }
    
    public enum VoxelGIQuality: Int64 {
        /// Low ``VoxelGI`` rendering quality using 4 cones.
        case low = 0 // VOXEL_GI_QUALITY_LOW
        /// High ``VoxelGI`` rendering quality using 6 cones.
        case high = 1 // VOXEL_GI_QUALITY_HIGH
    }
    
    public enum ParticlesMode: Int64 {
        /// 2D particles.
        case particlesMode2d = 0 // PARTICLES_MODE_2D
        /// 3D particles.
        case particlesMode3d = 1 // PARTICLES_MODE_3D
    }
    
    public enum ParticlesTransformAlign: Int64 {
        /// 
        case disabled = 0 // PARTICLES_TRANSFORM_ALIGN_DISABLED
        /// 
        case zBillboard = 1 // PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD
        /// 
        case yToVelocity = 2 // PARTICLES_TRANSFORM_ALIGN_Y_TO_VELOCITY
        /// 
        case zBillboardYToVelocity = 3 // PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY
    }
    
    public enum ParticlesDrawOrder: Int64 {
        /// Draw particles in the order that they appear in the particles array.
        case index = 0 // PARTICLES_DRAW_ORDER_INDEX
        /// Sort particles based on their lifetime. In other words, the particle with the highest lifetime is drawn at the front.
        case lifetime = 1 // PARTICLES_DRAW_ORDER_LIFETIME
        /// Sort particles based on the inverse of their lifetime. In other words, the particle with the lowest lifetime is drawn at the front.
        case reverseLifetime = 2 // PARTICLES_DRAW_ORDER_REVERSE_LIFETIME
        /// Sort particles based on their distance to the camera.
        case viewDepth = 3 // PARTICLES_DRAW_ORDER_VIEW_DEPTH
    }
    
    public enum ParticlesCollisionType: Int64 {
        /// 
        case sphereAttract = 0 // PARTICLES_COLLISION_TYPE_SPHERE_ATTRACT
        /// 
        case boxAttract = 1 // PARTICLES_COLLISION_TYPE_BOX_ATTRACT
        /// 
        case vectorFieldAttract = 2 // PARTICLES_COLLISION_TYPE_VECTOR_FIELD_ATTRACT
        /// 
        case sphereCollide = 3 // PARTICLES_COLLISION_TYPE_SPHERE_COLLIDE
        /// 
        case boxCollide = 4 // PARTICLES_COLLISION_TYPE_BOX_COLLIDE
        /// 
        case sdfCollide = 5 // PARTICLES_COLLISION_TYPE_SDF_COLLIDE
        /// 
        case heightfieldCollide = 6 // PARTICLES_COLLISION_TYPE_HEIGHTFIELD_COLLIDE
    }
    
    public enum ParticlesCollisionHeightfieldResolution: Int64 {
        /// 
        case particlesCollisionHeightfieldResolution256 = 0 // PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_256
        /// 
        case particlesCollisionHeightfieldResolution512 = 1 // PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_512
        /// 
        case particlesCollisionHeightfieldResolution1024 = 2 // PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_1024
        /// 
        case particlesCollisionHeightfieldResolution2048 = 3 // PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_2048
        /// 
        case particlesCollisionHeightfieldResolution4096 = 4 // PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_4096
        /// 
        case particlesCollisionHeightfieldResolution8192 = 5 // PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_8192
        /// Represents the size of the ``RenderingServer/ParticlesCollisionHeightfieldResolution`` enum.
        case max = 6 // PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_MAX
    }
    
    public enum FogVolumeShape: Int64 {
        /// ``FogVolume`` will be shaped like an ellipsoid (stretched sphere).
        case ellipsoid = 0 // FOG_VOLUME_SHAPE_ELLIPSOID
        /// ``FogVolume`` will be shaped like a cone pointing upwards (in local coordinates). The cone's angle is set automatically to fill the size. The cone will be adjusted to fit within the size. Rotate the ``FogVolume`` node to reorient the cone. Non-uniform scaling via size is not supported (scale the ``FogVolume`` node instead).
        case cone = 1 // FOG_VOLUME_SHAPE_CONE
        /// ``FogVolume`` will be shaped like an upright cylinder (in local coordinates). Rotate the ``FogVolume`` node to reorient the cylinder. The cylinder will be adjusted to fit within the size. Non-uniform scaling via size is not supported (scale the ``FogVolume`` node instead).
        case cylinder = 2 // FOG_VOLUME_SHAPE_CYLINDER
        /// ``FogVolume`` will be shaped like a box.
        case box = 3 // FOG_VOLUME_SHAPE_BOX
        /// ``FogVolume`` will have no shape, will cover the whole world and will not be culled.
        case world = 4 // FOG_VOLUME_SHAPE_WORLD
        /// Represents the size of the ``RenderingServer/FogVolumeShape`` enum.
        case max = 5 // FOG_VOLUME_SHAPE_MAX
    }
    
    public enum ViewportScaling3DMode: Int64 {
        /// Use bilinear scaling for the viewport's 3D buffer. The amount of scaling can be set using ``Viewport/scaling3dScale``. Values less than `1.0` will result in undersampling while values greater than `1.0` will result in supersampling. A value of `1.0` disables scaling.
        case bilinear = 0 // VIEWPORT_SCALING_3D_MODE_BILINEAR
        /// Use AMD FidelityFX Super Resolution 1.0 upscaling for the viewport's 3D buffer. The amount of scaling can be set using ``Viewport/scaling3dScale``. Values less than `1.0` will be result in the viewport being upscaled using FSR. Values greater than `1.0` are not supported and bilinear downsampling will be used instead. A value of `1.0` disables scaling.
        case fsr = 1 // VIEWPORT_SCALING_3D_MODE_FSR
        /// Use AMD FidelityFX Super Resolution 2.2 upscaling for the viewport's 3D buffer. The amount of scaling can be set using ``Viewport/scaling3dScale``. Values less than `1.0` will be result in the viewport being upscaled using FSR2. Values greater than `1.0` are not supported and bilinear downsampling will be used instead. A value of `1.0` will use FSR2 at native resolution as a TAA solution.
        case fsr2 = 2 // VIEWPORT_SCALING_3D_MODE_FSR2
        /// Represents the size of the ``RenderingServer/ViewportScaling3DMode`` enum.
        case max = 3 // VIEWPORT_SCALING_3D_MODE_MAX
    }
    
    public enum ViewportUpdateMode: Int64 {
        /// Do not update the viewport's render target.
        case disabled = 0 // VIEWPORT_UPDATE_DISABLED
        /// Update the viewport's render target once, then switch to .viewportUpdateDisabled.
        case once = 1 // VIEWPORT_UPDATE_ONCE
        /// Update the viewport's render target only when it is visible. This is the default value.
        case whenVisible = 2 // VIEWPORT_UPDATE_WHEN_VISIBLE
        /// Update the viewport's render target only when its parent is visible.
        case whenParentVisible = 3 // VIEWPORT_UPDATE_WHEN_PARENT_VISIBLE
        /// Always update the viewport's render target.
        case always = 4 // VIEWPORT_UPDATE_ALWAYS
    }
    
    public enum ViewportClearMode: Int64 {
        /// Always clear the viewport's render target before drawing.
        case always = 0 // VIEWPORT_CLEAR_ALWAYS
        /// Never clear the viewport's render target.
        case never = 1 // VIEWPORT_CLEAR_NEVER
        /// Clear the viewport's render target on the next frame, then switch to .viewportClearNever.
        case onlyNextFrame = 2 // VIEWPORT_CLEAR_ONLY_NEXT_FRAME
    }
    
    public enum ViewportEnvironmentMode: Int64 {
        /// Disable rendering of 3D environment over 2D canvas.
        case disabled = 0 // VIEWPORT_ENVIRONMENT_DISABLED
        /// Enable rendering of 3D environment over 2D canvas.
        case enabled = 1 // VIEWPORT_ENVIRONMENT_ENABLED
        /// Inherit enable/disable value from parent. If the topmost parent is also set to .viewportEnvironmentInherit, then this has the same behavior as .viewportEnvironmentEnabled.
        case inherit = 2 // VIEWPORT_ENVIRONMENT_INHERIT
        /// Represents the size of the ``RenderingServer/ViewportEnvironmentMode`` enum.
        case max = 3 // VIEWPORT_ENVIRONMENT_MAX
    }
    
    public enum ViewportSDFOversize: Int64 {
        /// Do not oversize the 2D signed distance field. Occluders may disappear when touching the viewport's edges, and ``GPUParticles3D`` collision may stop working earlier than intended. This has the lowest GPU requirements.
        case viewportSdfOversize100Percent = 0 // VIEWPORT_SDF_OVERSIZE_100_PERCENT
        /// 2D signed distance field covers 20% of the viewport's size outside the viewport on each side (top, right, bottom, left).
        case viewportSdfOversize120Percent = 1 // VIEWPORT_SDF_OVERSIZE_120_PERCENT
        /// 2D signed distance field covers 50% of the viewport's size outside the viewport on each side (top, right, bottom, left).
        case viewportSdfOversize150Percent = 2 // VIEWPORT_SDF_OVERSIZE_150_PERCENT
        /// 2D signed distance field covers 100% of the viewport's size outside the viewport on each side (top, right, bottom, left). This has the highest GPU requirements.
        case viewportSdfOversize200Percent = 3 // VIEWPORT_SDF_OVERSIZE_200_PERCENT
        /// Represents the size of the ``RenderingServer/ViewportSDFOversize`` enum.
        case max = 4 // VIEWPORT_SDF_OVERSIZE_MAX
    }
    
    public enum ViewportSDFScale: Int64 {
        /// Full resolution 2D signed distance field scale. This has the highest GPU requirements.
        case viewportSdfScale100Percent = 0 // VIEWPORT_SDF_SCALE_100_PERCENT
        /// Half resolution 2D signed distance field scale on each axis (25% of the viewport pixel count).
        case viewportSdfScale50Percent = 1 // VIEWPORT_SDF_SCALE_50_PERCENT
        /// Quarter resolution 2D signed distance field scale on each axis (6.25% of the viewport pixel count). This has the lowest GPU requirements.
        case viewportSdfScale25Percent = 2 // VIEWPORT_SDF_SCALE_25_PERCENT
        /// Represents the size of the ``RenderingServer/ViewportSDFScale`` enum.
        case max = 3 // VIEWPORT_SDF_SCALE_MAX
    }
    
    public enum ViewportMSAA: Int64 {
        /// Multisample antialiasing for 3D is disabled. This is the default value, and also the fastest setting.
        case disabled = 0 // VIEWPORT_MSAA_DISABLED
        /// Multisample antialiasing uses 2 samples per pixel for 3D. This has a moderate impact on performance.
        case viewportMsaa2x = 1 // VIEWPORT_MSAA_2X
        /// Multisample antialiasing uses 4 samples per pixel for 3D. This has a high impact on performance.
        case viewportMsaa4x = 2 // VIEWPORT_MSAA_4X
        /// Multisample antialiasing uses 8 samples per pixel for 3D. This has a very high impact on performance. Likely unsupported on low-end and older hardware.
        case viewportMsaa8x = 3 // VIEWPORT_MSAA_8X
        /// Represents the size of the ``RenderingServer/ViewportMSAA`` enum.
        case max = 4 // VIEWPORT_MSAA_MAX
    }
    
    public enum ViewportScreenSpaceAA: Int64 {
        /// Do not perform any antialiasing in the full screen post-process.
        case disabled = 0 // VIEWPORT_SCREEN_SPACE_AA_DISABLED
        /// Use fast approximate antialiasing. FXAA is a popular screen-space antialiasing method, which is fast but will make the image look blurry, especially at lower resolutions. It can still work relatively well at large resolutions such as 1440p and 4K.
        case fxaa = 1 // VIEWPORT_SCREEN_SPACE_AA_FXAA
        /// Represents the size of the ``RenderingServer/ViewportScreenSpaceAA`` enum.
        case max = 2 // VIEWPORT_SCREEN_SPACE_AA_MAX
    }
    
    public enum ViewportOcclusionCullingBuildQuality: Int64 {
        /// Low occlusion culling BVH build quality (as defined by Embree). Results in the lowest CPU usage, but least effective culling.
        case low = 0 // VIEWPORT_OCCLUSION_BUILD_QUALITY_LOW
        /// Medium occlusion culling BVH build quality (as defined by Embree).
        case medium = 1 // VIEWPORT_OCCLUSION_BUILD_QUALITY_MEDIUM
        /// High occlusion culling BVH build quality (as defined by Embree). Results in the highest CPU usage, but most effective culling.
        case high = 2 // VIEWPORT_OCCLUSION_BUILD_QUALITY_HIGH
    }
    
    public enum ViewportRenderInfo: Int64 {
        /// Number of objects drawn in a single frame.
        case objectsInFrame = 0 // VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME
        /// Number of points, lines, or triangles drawn in a single frame.
        case primitivesInFrame = 1 // VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME
        /// Number of draw calls during this frame.
        case drawCallsInFrame = 2 // VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME
        /// Represents the size of the ``RenderingServer/ViewportRenderInfo`` enum.
        case max = 3 // VIEWPORT_RENDER_INFO_MAX
    }
    
    public enum ViewportRenderInfoType: Int64 {
        /// Visible render pass (excluding shadows).
        case visible = 0 // VIEWPORT_RENDER_INFO_TYPE_VISIBLE
        /// Shadow render pass. Objects will be rendered several times depending on the number of amounts of lights with shadows and the number of directional shadow splits.
        case shadow = 1 // VIEWPORT_RENDER_INFO_TYPE_SHADOW
        /// Represents the size of the ``RenderingServer/ViewportRenderInfoType`` enum.
        case max = 2 // VIEWPORT_RENDER_INFO_TYPE_MAX
    }
    
    public enum ViewportDebugDraw: Int64 {
        /// Debug draw is disabled. Default setting.
        case disabled = 0 // VIEWPORT_DEBUG_DRAW_DISABLED
        /// Objects are displayed without light information.
        case unshaded = 1 // VIEWPORT_DEBUG_DRAW_UNSHADED
        /// Objects are displayed with only light information.
        case lighting = 2 // VIEWPORT_DEBUG_DRAW_LIGHTING
        /// Objects are displayed semi-transparent with additive blending so you can see where they are drawing over top of one another. A higher overdraw (represented by brighter colors) means you are wasting performance on drawing pixels that are being hidden behind others.
        /// 
        /// > Note: When using this debug draw mode, custom shaders will be ignored. This means vertex displacement won't be visible anymore.
        /// 
        case overdraw = 3 // VIEWPORT_DEBUG_DRAW_OVERDRAW
        /// Debug draw draws objects in wireframe.
        case wireframe = 4 // VIEWPORT_DEBUG_DRAW_WIREFRAME
        /// Normal buffer is drawn instead of regular scene so you can see the per-pixel normals that will be used by post-processing effects.
        case normalBuffer = 5 // VIEWPORT_DEBUG_DRAW_NORMAL_BUFFER
        /// Objects are displayed with only the albedo value from ``VoxelGI``s.
        case voxelGiAlbedo = 6 // VIEWPORT_DEBUG_DRAW_VOXEL_GI_ALBEDO
        /// Objects are displayed with only the lighting value from ``VoxelGI``s.
        case voxelGiLighting = 7 // VIEWPORT_DEBUG_DRAW_VOXEL_GI_LIGHTING
        /// Objects are displayed with only the emission color from ``VoxelGI``s.
        case voxelGiEmission = 8 // VIEWPORT_DEBUG_DRAW_VOXEL_GI_EMISSION
        /// Draws the shadow atlas that stores shadows from ``OmniLight3D``s and ``SpotLight3D``s in the upper left quadrant of the ``Viewport``.
        case shadowAtlas = 9 // VIEWPORT_DEBUG_DRAW_SHADOW_ATLAS
        /// Draws the shadow atlas that stores shadows from ``DirectionalLight3D``s in the upper left quadrant of the ``Viewport``.
        /// 
        /// The slice of the camera frustum related to the shadow map cascade is superimposed to visualize coverage. The color of each slice matches the colors used for .pssmSplits. When shadow cascades are blended the overlap is taken into account when drawing the frustum slices.
        /// 
        /// The last cascade shows all frustum slices to illustrate the coverage of all slices.
        /// 
        case directionalShadowAtlas = 10 // VIEWPORT_DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS
        /// Draws the estimated scene luminance. This is a 1×1 texture that is generated when autoexposure is enabled to control the scene's exposure.
        case sceneLuminance = 11 // VIEWPORT_DEBUG_DRAW_SCENE_LUMINANCE
        /// Draws the screen space ambient occlusion texture instead of the scene so that you can clearly see how it is affecting objects. In order for this display mode to work, you must have ``Environment/ssaoEnabled`` set in your ``WorldEnvironment``.
        case ssao = 12 // VIEWPORT_DEBUG_DRAW_SSAO
        /// Draws the screen space indirect lighting texture instead of the scene so that you can clearly see how it is affecting objects. In order for this display mode to work, you must have ``Environment/ssilEnabled`` set in your ``WorldEnvironment``.
        case ssil = 13 // VIEWPORT_DEBUG_DRAW_SSIL
        /// Colors each PSSM split for the ``DirectionalLight3D``s in the scene a different color so you can see where the splits are. In order they will be colored red, green, blue, yellow.
        case pssmSplits = 14 // VIEWPORT_DEBUG_DRAW_PSSM_SPLITS
        /// Draws the decal atlas that stores decal textures from ``Decal``s.
        case decalAtlas = 15 // VIEWPORT_DEBUG_DRAW_DECAL_ATLAS
        /// Draws SDFGI cascade data. This is the data structure that is used to bounce lighting against and create reflections.
        case sdfgi = 16 // VIEWPORT_DEBUG_DRAW_SDFGI
        /// Draws SDFGI probe data. This is the data structure that is used to give indirect lighting dynamic objects moving within the scene.
        case sdfgiProbes = 17 // VIEWPORT_DEBUG_DRAW_SDFGI_PROBES
        /// Draws the global illumination buffer (``VoxelGI`` or SDFGI).
        case giBuffer = 18 // VIEWPORT_DEBUG_DRAW_GI_BUFFER
        /// Disable mesh LOD. All meshes are drawn with full detail, which can be used to compare performance.
        case disableLod = 19 // VIEWPORT_DEBUG_DRAW_DISABLE_LOD
        /// Draws the ``OmniLight3D`` cluster. Clustering determines where lights are positioned in screen-space, which allows the engine to only process these portions of the screen for lighting.
        case clusterOmniLights = 20 // VIEWPORT_DEBUG_DRAW_CLUSTER_OMNI_LIGHTS
        /// Draws the ``SpotLight3D`` cluster. Clustering determines where lights are positioned in screen-space, which allows the engine to only process these portions of the screen for lighting.
        case clusterSpotLights = 21 // VIEWPORT_DEBUG_DRAW_CLUSTER_SPOT_LIGHTS
        /// Draws the ``Decal`` cluster. Clustering determines where decals are positioned in screen-space, which allows the engine to only process these portions of the screen for decals.
        case clusterDecals = 22 // VIEWPORT_DEBUG_DRAW_CLUSTER_DECALS
        /// Draws the ``ReflectionProbe`` cluster. Clustering determines where reflection probes are positioned in screen-space, which allows the engine to only process these portions of the screen for reflection probes.
        case clusterReflectionProbes = 23 // VIEWPORT_DEBUG_DRAW_CLUSTER_REFLECTION_PROBES
        /// Draws the occlusion culling buffer. This low-resolution occlusion culling buffer is rasterized on the CPU and is used to check whether instances are occluded by other objects.
        case occluders = 24 // VIEWPORT_DEBUG_DRAW_OCCLUDERS
        /// Draws the motion vectors buffer. This is used by temporal antialiasing to correct for motion that occurs during gameplay.
        case motionVectors = 25 // VIEWPORT_DEBUG_DRAW_MOTION_VECTORS
        /// Internal buffer is drawn instead of regular scene so you can see the per-pixel output that will be used by post-processing effects.
        case internalBuffer = 26 // VIEWPORT_DEBUG_DRAW_INTERNAL_BUFFER
    }
    
    public enum ViewportVRSMode: Int64 {
        /// Variable rate shading is disabled.
        case disabled = 0 // VIEWPORT_VRS_DISABLED
        /// Variable rate shading uses a texture. Note, for stereoscopic use a texture atlas with a texture for each view.
        case texture = 1 // VIEWPORT_VRS_TEXTURE
        /// Variable rate shading texture is supplied by the primary ``XRInterface``.
        case xr = 2 // VIEWPORT_VRS_XR
        /// Represents the size of the ``RenderingServer/ViewportVRSMode`` enum.
        case max = 3 // VIEWPORT_VRS_MAX
    }
    
    public enum SkyMode: Int64 {
        /// Automatically selects the appropriate process mode based on your sky shader. If your shader uses `TIME` or `POSITION`, this will use .realtime. If your shader uses any of the `LIGHT_*` variables or any custom uniforms, this uses .incremental. Otherwise, this defaults to .quality.
        case automatic = 0 // SKY_MODE_AUTOMATIC
        /// Uses high quality importance sampling to process the radiance map. In general, this results in much higher quality than .realtime but takes much longer to generate. This should not be used if you plan on changing the sky at runtime. If you are finding that the reflection is not blurry enough and is showing sparkles or fireflies, try increasing ``ProjectSettings/rendering/reflections/skyReflections/ggxSamples``.
        case quality = 1 // SKY_MODE_QUALITY
        /// Uses the same high quality importance sampling to process the radiance map as .quality, but updates over several frames. The number of frames is determined by ``ProjectSettings/rendering/reflections/skyReflections/roughnessLayers``. Use this when you need highest quality radiance maps, but have a sky that updates slowly.
        case incremental = 2 // SKY_MODE_INCREMENTAL
        /// Uses the fast filtering algorithm to process the radiance map. In general this results in lower quality, but substantially faster run times. If you need better quality, but still need to update the sky every frame, consider turning on ``ProjectSettings/rendering/reflections/skyReflections/fastFilterHighQuality``.
        /// 
        /// > Note: The fast filtering algorithm is limited to 256×256 cubemaps, so ``skySetRadianceSize(sky:radianceSize:)`` must be set to `256`. Otherwise, a warning is printed and the overridden radiance size is ignored.
        /// 
        case realtime = 3 // SKY_MODE_REALTIME
    }
    
    public enum EnvironmentBG: Int64 {
        /// Use the clear color as background.
        case clearColor = 0 // ENV_BG_CLEAR_COLOR
        /// Use a specified color as the background.
        case color = 1 // ENV_BG_COLOR
        /// Use a sky resource for the background.
        case sky = 2 // ENV_BG_SKY
        /// Use a specified canvas layer as the background. This can be useful for instantiating a 2D scene in a 3D world.
        case canvas = 3 // ENV_BG_CANVAS
        /// Do not clear the background, use whatever was rendered last frame as the background.
        case keep = 4 // ENV_BG_KEEP
        /// Displays a camera feed in the background.
        case cameraFeed = 5 // ENV_BG_CAMERA_FEED
        /// Represents the size of the ``RenderingServer/EnvironmentBG`` enum.
        case max = 6 // ENV_BG_MAX
    }
    
    public enum EnvironmentAmbientSource: Int64 {
        /// Gather ambient light from whichever source is specified as the background.
        case bg = 0 // ENV_AMBIENT_SOURCE_BG
        /// Disable ambient light.
        case disabled = 1 // ENV_AMBIENT_SOURCE_DISABLED
        /// Specify a specific ``Color`` for ambient light.
        case color = 2 // ENV_AMBIENT_SOURCE_COLOR
        /// Gather ambient light from the ``Sky`` regardless of what the background is.
        case sky = 3 // ENV_AMBIENT_SOURCE_SKY
    }
    
    public enum EnvironmentReflectionSource: Int64 {
        /// Use the background for reflections.
        case bg = 0 // ENV_REFLECTION_SOURCE_BG
        /// Disable reflections.
        case disabled = 1 // ENV_REFLECTION_SOURCE_DISABLED
        /// Use the ``Sky`` for reflections regardless of what the background is.
        case sky = 2 // ENV_REFLECTION_SOURCE_SKY
    }
    
    public enum EnvironmentGlowBlendMode: Int64 {
        /// Additive glow blending mode. Mostly used for particles, glows (bloom), lens flare, bright sources.
        case additive = 0 // ENV_GLOW_BLEND_MODE_ADDITIVE
        /// Screen glow blending mode. Increases brightness, used frequently with bloom.
        case screen = 1 // ENV_GLOW_BLEND_MODE_SCREEN
        /// Soft light glow blending mode. Modifies contrast, exposes shadows and highlights (vivid bloom).
        case softlight = 2 // ENV_GLOW_BLEND_MODE_SOFTLIGHT
        /// Replace glow blending mode. Replaces all pixels' color by the glow value. This can be used to simulate a full-screen blur effect by tweaking the glow parameters to match the original image's brightness.
        case replace = 3 // ENV_GLOW_BLEND_MODE_REPLACE
        /// Mixes the glow with the underlying color to avoid increasing brightness as much while still maintaining a glow effect.
        case mix = 4 // ENV_GLOW_BLEND_MODE_MIX
    }
    
    public enum EnvironmentToneMapper: Int64 {
        /// Output color as they came in. This can cause bright lighting to look blown out, with noticeable clipping in the output colors.
        case linear = 0 // ENV_TONE_MAPPER_LINEAR
        /// Use the Reinhard tonemapper. Performs a variation on rendered pixels' colors by this formula: `color = color / (1 + color)`. This avoids clipping bright highlights, but the resulting image can look a bit dull.
        case reinhard = 1 // ENV_TONE_MAPPER_REINHARD
        /// Use the filmic tonemapper. This avoids clipping bright highlights, with a resulting image that usually looks more vivid than .envToneMapperReinhard.
        case filmic = 2 // ENV_TONE_MAPPER_FILMIC
        /// Use the Academy Color Encoding System tonemapper. ACES is slightly more expensive than other options, but it handles bright lighting in a more realistic fashion by desaturating it as it becomes brighter. ACES typically has a more contrasted output compared to .envToneMapperReinhard and .envToneMapperFilmic.
        /// 
        /// > Note: This tonemapping operator is called "ACES Fitted" in Godot 3.x.
        /// 
        case aces = 3 // ENV_TONE_MAPPER_ACES
    }
    
    public enum EnvironmentSSRRoughnessQuality: Int64 {
        /// Lowest quality of roughness filter for screen-space reflections. Rough materials will not have blurrier screen-space reflections compared to smooth (non-rough) materials. This is the fastest option.
        case disabled = 0 // ENV_SSR_ROUGHNESS_QUALITY_DISABLED
        /// Low quality of roughness filter for screen-space reflections.
        case low = 1 // ENV_SSR_ROUGHNESS_QUALITY_LOW
        /// Medium quality of roughness filter for screen-space reflections.
        case medium = 2 // ENV_SSR_ROUGHNESS_QUALITY_MEDIUM
        /// High quality of roughness filter for screen-space reflections. This is the slowest option.
        case high = 3 // ENV_SSR_ROUGHNESS_QUALITY_HIGH
    }
    
    public enum EnvironmentSSAOQuality: Int64 {
        /// Lowest quality of screen-space ambient occlusion.
        case veryLow = 0 // ENV_SSAO_QUALITY_VERY_LOW
        /// Low quality screen-space ambient occlusion.
        case low = 1 // ENV_SSAO_QUALITY_LOW
        /// Medium quality screen-space ambient occlusion.
        case medium = 2 // ENV_SSAO_QUALITY_MEDIUM
        /// High quality screen-space ambient occlusion.
        case high = 3 // ENV_SSAO_QUALITY_HIGH
        /// Highest quality screen-space ambient occlusion. Uses the adaptive target setting which can be dynamically adjusted to smoothly balance performance and visual quality.
        case ultra = 4 // ENV_SSAO_QUALITY_ULTRA
    }
    
    public enum EnvironmentSSILQuality: Int64 {
        /// Lowest quality of screen-space indirect lighting.
        case veryLow = 0 // ENV_SSIL_QUALITY_VERY_LOW
        /// Low quality screen-space indirect lighting.
        case low = 1 // ENV_SSIL_QUALITY_LOW
        /// High quality screen-space indirect lighting.
        case medium = 2 // ENV_SSIL_QUALITY_MEDIUM
        /// High quality screen-space indirect lighting.
        case high = 3 // ENV_SSIL_QUALITY_HIGH
        /// Highest quality screen-space indirect lighting. Uses the adaptive target setting which can be dynamically adjusted to smoothly balance performance and visual quality.
        case ultra = 4 // ENV_SSIL_QUALITY_ULTRA
    }
    
    public enum EnvironmentSDFGIYScale: Int64 {
        /// Use 50% scale for SDFGI on the Y (vertical) axis. SDFGI cells will be twice as short as they are wide. This allows providing increased GI detail and reduced light leaking with thin floors and ceilings. This is usually the best choice for scenes that don't feature much verticality.
        case envSdfgiYScale50Percent = 0 // ENV_SDFGI_Y_SCALE_50_PERCENT
        /// Use 75% scale for SDFGI on the Y (vertical) axis. This is a balance between the 50% and 100% SDFGI Y scales.
        case envSdfgiYScale75Percent = 1 // ENV_SDFGI_Y_SCALE_75_PERCENT
        /// Use 100% scale for SDFGI on the Y (vertical) axis. SDFGI cells will be as tall as they are wide. This is usually the best choice for highly vertical scenes. The downside is that light leaking may become more noticeable with thin floors and ceilings.
        case envSdfgiYScale100Percent = 2 // ENV_SDFGI_Y_SCALE_100_PERCENT
    }
    
    public enum EnvironmentSDFGIRayCount: Int64 {
        /// Throw 4 rays per frame when converging SDFGI. This has the lowest GPU requirements, but creates the most noisy result.
        case envSdfgiRayCount4 = 0 // ENV_SDFGI_RAY_COUNT_4
        /// Throw 8 rays per frame when converging SDFGI.
        case envSdfgiRayCount8 = 1 // ENV_SDFGI_RAY_COUNT_8
        /// Throw 16 rays per frame when converging SDFGI.
        case envSdfgiRayCount16 = 2 // ENV_SDFGI_RAY_COUNT_16
        /// Throw 32 rays per frame when converging SDFGI.
        case envSdfgiRayCount32 = 3 // ENV_SDFGI_RAY_COUNT_32
        /// Throw 64 rays per frame when converging SDFGI.
        case envSdfgiRayCount64 = 4 // ENV_SDFGI_RAY_COUNT_64
        /// Throw 96 rays per frame when converging SDFGI. This has high GPU requirements.
        case envSdfgiRayCount96 = 5 // ENV_SDFGI_RAY_COUNT_96
        /// Throw 128 rays per frame when converging SDFGI. This has very high GPU requirements, but creates the least noisy result.
        case envSdfgiRayCount128 = 6 // ENV_SDFGI_RAY_COUNT_128
        /// Represents the size of the ``RenderingServer/EnvironmentSDFGIRayCount`` enum.
        case max = 7 // ENV_SDFGI_RAY_COUNT_MAX
    }
    
    public enum EnvironmentSDFGIFramesToConverge: Int64 {
        /// Converge SDFGI over 5 frames. This is the most responsive, but creates the most noisy result with a given ray count.
        case in5Frames = 0 // ENV_SDFGI_CONVERGE_IN_5_FRAMES
        /// Configure SDFGI to fully converge over 10 frames.
        case in10Frames = 1 // ENV_SDFGI_CONVERGE_IN_10_FRAMES
        /// Configure SDFGI to fully converge over 15 frames.
        case in15Frames = 2 // ENV_SDFGI_CONVERGE_IN_15_FRAMES
        /// Configure SDFGI to fully converge over 20 frames.
        case in20Frames = 3 // ENV_SDFGI_CONVERGE_IN_20_FRAMES
        /// Configure SDFGI to fully converge over 25 frames.
        case in25Frames = 4 // ENV_SDFGI_CONVERGE_IN_25_FRAMES
        /// Configure SDFGI to fully converge over 30 frames. This is the least responsive, but creates the least noisy result with a given ray count.
        case in30Frames = 5 // ENV_SDFGI_CONVERGE_IN_30_FRAMES
        /// Represents the size of the ``RenderingServer/EnvironmentSDFGIFramesToConverge`` enum.
        case max = 6 // ENV_SDFGI_CONVERGE_MAX
    }
    
    public enum EnvironmentSDFGIFramesToUpdateLight: Int64 {
        /// Update indirect light from dynamic lights in SDFGI over 1 frame. This is the most responsive, but has the highest GPU requirements.
        case in1Frame = 0 // ENV_SDFGI_UPDATE_LIGHT_IN_1_FRAME
        /// Update indirect light from dynamic lights in SDFGI over 2 frames.
        case in2Frames = 1 // ENV_SDFGI_UPDATE_LIGHT_IN_2_FRAMES
        /// Update indirect light from dynamic lights in SDFGI over 4 frames.
        case in4Frames = 2 // ENV_SDFGI_UPDATE_LIGHT_IN_4_FRAMES
        /// Update indirect light from dynamic lights in SDFGI over 8 frames.
        case in8Frames = 3 // ENV_SDFGI_UPDATE_LIGHT_IN_8_FRAMES
        /// Update indirect light from dynamic lights in SDFGI over 16 frames. This is the least responsive, but has the lowest GPU requirements.
        case in16Frames = 4 // ENV_SDFGI_UPDATE_LIGHT_IN_16_FRAMES
        /// Represents the size of the ``RenderingServer/EnvironmentSDFGIFramesToUpdateLight`` enum.
        case max = 5 // ENV_SDFGI_UPDATE_LIGHT_MAX
    }
    
    public enum SubSurfaceScatteringQuality: Int64 {
        /// Disables subsurface scattering entirely, even on materials that have ``BaseMaterial3D/subsurfScatterEnabled`` set to `true`. This has the lowest GPU requirements.
        case disabled = 0 // SUB_SURFACE_SCATTERING_QUALITY_DISABLED
        /// Low subsurface scattering quality.
        case low = 1 // SUB_SURFACE_SCATTERING_QUALITY_LOW
        /// Medium subsurface scattering quality.
        case medium = 2 // SUB_SURFACE_SCATTERING_QUALITY_MEDIUM
        /// High subsurface scattering quality. This has the highest GPU requirements.
        case high = 3 // SUB_SURFACE_SCATTERING_QUALITY_HIGH
    }
    
    public enum DOFBokehShape: Int64 {
        /// Calculate the DOF blur using a box filter. The fastest option, but results in obvious lines in blur pattern.
        case box = 0 // DOF_BOKEH_BOX
        /// Calculates DOF blur using a hexagon shaped filter.
        case hexagon = 1 // DOF_BOKEH_HEXAGON
        /// Calculates DOF blur using a circle shaped filter. Best quality and most realistic, but slowest. Use only for areas where a lot of performance can be dedicated to post-processing (e.g. cutscenes).
        case circle = 2 // DOF_BOKEH_CIRCLE
    }
    
    public enum DOFBlurQuality: Int64 {
        /// Lowest quality DOF blur. This is the fastest setting, but you may be able to see filtering artifacts.
        case veryLow = 0 // DOF_BLUR_QUALITY_VERY_LOW
        /// Low quality DOF blur.
        case low = 1 // DOF_BLUR_QUALITY_LOW
        /// Medium quality DOF blur.
        case medium = 2 // DOF_BLUR_QUALITY_MEDIUM
        /// Highest quality DOF blur. Results in the smoothest looking blur by taking the most samples, but is also significantly slower.
        case high = 3 // DOF_BLUR_QUALITY_HIGH
    }
    
    public enum InstanceType: Int64 {
        /// The instance does not have a type.
        case none = 0 // INSTANCE_NONE
        /// The instance is a mesh.
        case mesh = 1 // INSTANCE_MESH
        /// The instance is a multimesh.
        case multimesh = 2 // INSTANCE_MULTIMESH
        /// The instance is a particle emitter.
        case particles = 3 // INSTANCE_PARTICLES
        /// The instance is a GPUParticles collision shape.
        case particlesCollision = 4 // INSTANCE_PARTICLES_COLLISION
        /// The instance is a light.
        case light = 5 // INSTANCE_LIGHT
        /// The instance is a reflection probe.
        case reflectionProbe = 6 // INSTANCE_REFLECTION_PROBE
        /// The instance is a decal.
        case decal = 7 // INSTANCE_DECAL
        /// The instance is a VoxelGI.
        case voxelGi = 8 // INSTANCE_VOXEL_GI
        /// The instance is a lightmap.
        case lightmap = 9 // INSTANCE_LIGHTMAP
        /// The instance is an occlusion culling occluder.
        case occluder = 10 // INSTANCE_OCCLUDER
        /// The instance is a visible on-screen notifier.
        case visiblityNotifier = 11 // INSTANCE_VISIBLITY_NOTIFIER
        /// The instance is a fog volume.
        case fogVolume = 12 // INSTANCE_FOG_VOLUME
        /// Represents the size of the ``RenderingServer/InstanceType`` enum.
        case max = 13 // INSTANCE_MAX
        /// A combination of the flags of geometry instances (mesh, multimesh, immediate and particles).
        case geometryMask = 14 // INSTANCE_GEOMETRY_MASK
    }
    
    public enum InstanceFlags: Int64 {
        /// Allows the instance to be used in baked lighting.
        case useBakedLight = 0 // INSTANCE_FLAG_USE_BAKED_LIGHT
        /// Allows the instance to be used with dynamic global illumination.
        case useDynamicGi = 1 // INSTANCE_FLAG_USE_DYNAMIC_GI
        /// When set, manually requests to draw geometry on next frame.
        case drawNextFrameIfVisible = 2 // INSTANCE_FLAG_DRAW_NEXT_FRAME_IF_VISIBLE
        /// Always draw, even if the instance would be culled by occlusion culling. Does not affect view frustum culling.
        case ignoreOcclusionCulling = 3 // INSTANCE_FLAG_IGNORE_OCCLUSION_CULLING
        /// Represents the size of the ``RenderingServer/InstanceFlags`` enum.
        case max = 4 // INSTANCE_FLAG_MAX
    }
    
    public enum ShadowCastingSetting: Int64 {
        /// Disable shadows from this instance.
        case off = 0 // SHADOW_CASTING_SETTING_OFF
        /// Cast shadows from this instance.
        case on = 1 // SHADOW_CASTING_SETTING_ON
        /// Disable backface culling when rendering the shadow of the object. This is slightly slower but may result in more correct shadows.
        case doubleSided = 2 // SHADOW_CASTING_SETTING_DOUBLE_SIDED
        /// Only render the shadows from the object. The object itself will not be drawn.
        case shadowsOnly = 3 // SHADOW_CASTING_SETTING_SHADOWS_ONLY
    }
    
    public enum VisibilityRangeFadeMode: Int64 {
        /// Disable visibility range fading for the given instance.
        case disabled = 0 // VISIBILITY_RANGE_FADE_DISABLED
        /// Fade-out the given instance when it approaches its visibility range limits.
        case `self` = 1 // VISIBILITY_RANGE_FADE_SELF
        /// Fade-in the given instance's dependencies when reaching its visibility range limits.
        case dependencies = 2 // VISIBILITY_RANGE_FADE_DEPENDENCIES
    }
    
    public enum BakeChannels: Int64 {
        /// Index of ``Image`` in array of ``Image``s returned by ``bakeRenderUv2(base:materialOverrides:imageSize:)``. Image uses ``Image/Format/rgba8`` and contains albedo color in the `.rgb` channels and alpha in the `.a` channel.
        case albedoAlpha = 0 // BAKE_CHANNEL_ALBEDO_ALPHA
        /// Index of ``Image`` in array of ``Image``s returned by ``bakeRenderUv2(base:materialOverrides:imageSize:)``. Image uses ``Image/Format/rgba8`` and contains the per-pixel normal of the object in the `.rgb` channels and nothing in the `.a` channel. The per-pixel normal is encoded as `normal * 0.5 + 0.5`.
        case normal = 1 // BAKE_CHANNEL_NORMAL
        /// Index of ``Image`` in array of ``Image``s returned by ``bakeRenderUv2(base:materialOverrides:imageSize:)``. Image uses ``Image/Format/rgba8`` and contains ambient occlusion (from material and decals only) in the `.r` channel, roughness in the `.g` channel, metallic in the `.b` channel and sub surface scattering amount in the `.a` channel.
        case orm = 2 // BAKE_CHANNEL_ORM
        /// Index of ``Image`` in array of ``Image``s returned by ``bakeRenderUv2(base:materialOverrides:imageSize:)``. Image uses ``Image/Format/rgbah`` and contains emission color in the `.rgb` channels and nothing in the `.a` channel.
        case emission = 3 // BAKE_CHANNEL_EMISSION
    }
    
    public enum CanvasTextureChannel: Int64 {
        /// Diffuse canvas texture (``CanvasTexture/diffuseTexture``).
        case diffuse = 0 // CANVAS_TEXTURE_CHANNEL_DIFFUSE
        /// Normal map canvas texture (``CanvasTexture/normalTexture``).
        case normal = 1 // CANVAS_TEXTURE_CHANNEL_NORMAL
        /// Specular map canvas texture (``CanvasTexture/specularTexture``).
        case specular = 2 // CANVAS_TEXTURE_CHANNEL_SPECULAR
    }
    
    public enum NinePatchAxisMode: Int64 {
        /// The nine patch gets stretched where needed.
        case stretch = 0 // NINE_PATCH_STRETCH
        /// The nine patch gets filled with tiles where needed.
        case tile = 1 // NINE_PATCH_TILE
        /// The nine patch gets filled with tiles where needed and stretches them a bit if needed.
        case tileFit = 2 // NINE_PATCH_TILE_FIT
    }
    
    public enum CanvasItemTextureFilter: Int64 {
        /// Uses the default filter mode for this ``Viewport``.
        case `default` = 0 // CANVAS_ITEM_TEXTURE_FILTER_DEFAULT
        /// The texture filter reads from the nearest pixel only. The simplest and fastest method of filtering, but the texture will look pixelized.
        case nearest = 1 // CANVAS_ITEM_TEXTURE_FILTER_NEAREST
        /// The texture filter blends between the nearest 4 pixels. Use this when you want to avoid a pixelated style, but do not want mipmaps.
        case linear = 2 // CANVAS_ITEM_TEXTURE_FILTER_LINEAR
        /// The texture filter reads from the nearest pixel in the nearest mipmap. The fastest way to read from textures with mipmaps.
        case nearestWithMipmaps = 3 // CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS
        /// The texture filter blends between the nearest 4 pixels and between the nearest 2 mipmaps.
        case linearWithMipmaps = 4 // CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS
        /// The texture filter reads from the nearest pixel, but selects a mipmap based on the angle between the surface and the camera view. This reduces artifacts on surfaces that are almost in line with the camera.
        case nearestWithMipmapsAnisotropic = 5 // CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC
        /// The texture filter blends between the nearest 4 pixels and selects a mipmap based on the angle between the surface and the camera view. This reduces artifacts on surfaces that are almost in line with the camera. This is the slowest of the filtering options, but results in the highest quality texturing.
        case linearWithMipmapsAnisotropic = 6 // CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC
        /// Max value for ``RenderingServer/CanvasItemTextureFilter`` enum.
        case max = 7 // CANVAS_ITEM_TEXTURE_FILTER_MAX
    }
    
    public enum CanvasItemTextureRepeat: Int64 {
        /// Uses the default repeat mode for this ``Viewport``.
        case `default` = 0 // CANVAS_ITEM_TEXTURE_REPEAT_DEFAULT
        /// Disables textures repeating. Instead, when reading UVs outside the 0-1 range, the value will be clamped to the edge of the texture, resulting in a stretched out look at the borders of the texture.
        case disabled = 1 // CANVAS_ITEM_TEXTURE_REPEAT_DISABLED
        /// Enables the texture to repeat when UV coordinates are outside the 0-1 range. If using one of the linear filtering modes, this can result in artifacts at the edges of a texture when the sampler filters across the edges of the texture.
        case enabled = 2 // CANVAS_ITEM_TEXTURE_REPEAT_ENABLED
        /// Flip the texture when repeating so that the edge lines up instead of abruptly changing.
        case mirror = 3 // CANVAS_ITEM_TEXTURE_REPEAT_MIRROR
        /// Max value for ``RenderingServer/CanvasItemTextureRepeat`` enum.
        case max = 4 // CANVAS_ITEM_TEXTURE_REPEAT_MAX
    }
    
    public enum CanvasGroupMode: Int64 {
        /// Child draws over parent and is not clipped.
        case disabled = 0 // CANVAS_GROUP_MODE_DISABLED
        /// Parent is used for the purposes of clipping only. Child is clipped to the parent's visible area, parent is not drawn.
        case clipOnly = 1 // CANVAS_GROUP_MODE_CLIP_ONLY
        /// Parent is used for clipping child, but parent is also drawn underneath child as normal before clipping child to its visible area.
        case clipAndDraw = 2 // CANVAS_GROUP_MODE_CLIP_AND_DRAW
        /// 
        case transparent = 3 // CANVAS_GROUP_MODE_TRANSPARENT
    }
    
    public enum CanvasLightMode: Int64 {
        /// 2D point light (see ``PointLight2D``).
        case point = 0 // CANVAS_LIGHT_MODE_POINT
        /// 2D directional (sun/moon) light (see ``DirectionalLight2D``).
        case directional = 1 // CANVAS_LIGHT_MODE_DIRECTIONAL
    }
    
    public enum CanvasLightBlendMode: Int64 {
        /// Adds light color additive to the canvas.
        case add = 0 // CANVAS_LIGHT_BLEND_MODE_ADD
        /// Adds light color subtractive to the canvas.
        case sub = 1 // CANVAS_LIGHT_BLEND_MODE_SUB
        /// The light adds color depending on transparency.
        case mix = 2 // CANVAS_LIGHT_BLEND_MODE_MIX
    }
    
    public enum CanvasLightShadowFilter: Int64 {
        /// Do not apply a filter to canvas light shadows.
        case none = 0 // CANVAS_LIGHT_FILTER_NONE
        /// Use PCF5 filtering to filter canvas light shadows.
        case pcf5 = 1 // CANVAS_LIGHT_FILTER_PCF5
        /// Use PCF13 filtering to filter canvas light shadows.
        case pcf13 = 2 // CANVAS_LIGHT_FILTER_PCF13
        /// Max value of the ``RenderingServer/CanvasLightShadowFilter`` enum.
        case max = 3 // CANVAS_LIGHT_FILTER_MAX
    }
    
    public enum CanvasOccluderPolygonCullMode: Int64 {
        /// Culling of the canvas occluder is disabled.
        case disabled = 0 // CANVAS_OCCLUDER_POLYGON_CULL_DISABLED
        /// Culling of the canvas occluder is clockwise.
        case clockwise = 1 // CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE
        /// Culling of the canvas occluder is counterclockwise.
        case counterClockwise = 2 // CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE
    }
    
    public enum GlobalShaderParameterType: Int64 {
        /// Boolean global shader parameter (`global uniform bool ...`).
        case bool = 0 // GLOBAL_VAR_TYPE_BOOL
        /// 2-dimensional boolean vector global shader parameter (`global uniform bvec2 ...`).
        case bvec2 = 1 // GLOBAL_VAR_TYPE_BVEC2
        /// 3-dimensional boolean vector global shader parameter (`global uniform bvec3 ...`).
        case bvec3 = 2 // GLOBAL_VAR_TYPE_BVEC3
        /// 4-dimensional boolean vector global shader parameter (`global uniform bvec4 ...`).
        case bvec4 = 3 // GLOBAL_VAR_TYPE_BVEC4
        /// Integer global shader parameter (`global uniform int ...`).
        case int = 4 // GLOBAL_VAR_TYPE_INT
        /// 2-dimensional integer vector global shader parameter (`global uniform ivec2 ...`).
        case ivec2 = 5 // GLOBAL_VAR_TYPE_IVEC2
        /// 3-dimensional integer vector global shader parameter (`global uniform ivec3 ...`).
        case ivec3 = 6 // GLOBAL_VAR_TYPE_IVEC3
        /// 4-dimensional integer vector global shader parameter (`global uniform ivec4 ...`).
        case ivec4 = 7 // GLOBAL_VAR_TYPE_IVEC4
        /// 2-dimensional integer rectangle global shader parameter (`global uniform ivec4 ...`). Equivalent to .globalVarTypeIvec4 in shader code, but exposed as a ``Rect2i`` in the editor UI.
        case rect2i = 8 // GLOBAL_VAR_TYPE_RECT2I
        /// Unsigned integer global shader parameter (`global uniform uint ...`).
        case uint = 9 // GLOBAL_VAR_TYPE_UINT
        /// 2-dimensional unsigned integer vector global shader parameter (`global uniform uvec2 ...`).
        case uvec2 = 10 // GLOBAL_VAR_TYPE_UVEC2
        /// 3-dimensional unsigned integer vector global shader parameter (`global uniform uvec3 ...`).
        case uvec3 = 11 // GLOBAL_VAR_TYPE_UVEC3
        /// 4-dimensional unsigned integer vector global shader parameter (`global uniform uvec4 ...`).
        case uvec4 = 12 // GLOBAL_VAR_TYPE_UVEC4
        /// Single-precision floating-point global shader parameter (`global uniform float ...`).
        case float = 13 // GLOBAL_VAR_TYPE_FLOAT
        /// 2-dimensional floating-point vector global shader parameter (`global uniform vec2 ...`).
        case vec2 = 14 // GLOBAL_VAR_TYPE_VEC2
        /// 3-dimensional floating-point vector global shader parameter (`global uniform vec3 ...`).
        case vec3 = 15 // GLOBAL_VAR_TYPE_VEC3
        /// 4-dimensional floating-point vector global shader parameter (`global uniform vec4 ...`).
        case vec4 = 16 // GLOBAL_VAR_TYPE_VEC4
        /// Color global shader parameter (`global uniform vec4 ...`). Equivalent to .globalVarTypeVec4 in shader code, but exposed as a ``Color`` in the editor UI.
        case color = 17 // GLOBAL_VAR_TYPE_COLOR
        /// 2-dimensional floating-point rectangle global shader parameter (`global uniform vec4 ...`). Equivalent to .globalVarTypeVec4 in shader code, but exposed as a ``Rect2`` in the editor UI.
        case rect2 = 18 // GLOBAL_VAR_TYPE_RECT2
        /// 2×2 matrix global shader parameter (`global uniform mat2 ...`). Exposed as a ``PackedInt32Array`` in the editor UI.
        case mat2 = 19 // GLOBAL_VAR_TYPE_MAT2
        /// 3×3 matrix global shader parameter (`global uniform mat3 ...`). Exposed as a ``Basis`` in the editor UI.
        case mat3 = 20 // GLOBAL_VAR_TYPE_MAT3
        /// 4×4 matrix global shader parameter (`global uniform mat4 ...`). Exposed as a ``Projection`` in the editor UI.
        case mat4 = 21 // GLOBAL_VAR_TYPE_MAT4
        /// 2-dimensional transform global shader parameter (`global uniform mat2x3 ...`). Exposed as a ``Transform2D`` in the editor UI.
        case transform2d = 22 // GLOBAL_VAR_TYPE_TRANSFORM_2D
        /// 3-dimensional transform global shader parameter (`global uniform mat3x4 ...`). Exposed as a ``Transform3D`` in the editor UI.
        case transform = 23 // GLOBAL_VAR_TYPE_TRANSFORM
        /// 2D sampler global shader parameter (`global uniform sampler2D ...`). Exposed as a ``Texture2D`` in the editor UI.
        case sampler2d = 24 // GLOBAL_VAR_TYPE_SAMPLER2D
        /// 2D sampler array global shader parameter (`global uniform sampler2DArray ...`). Exposed as a ``Texture2DArray`` in the editor UI.
        case sampler2darray = 25 // GLOBAL_VAR_TYPE_SAMPLER2DARRAY
        /// 3D sampler global shader parameter (`global uniform sampler3D ...`). Exposed as a ``Texture3D`` in the editor UI.
        case sampler3d = 26 // GLOBAL_VAR_TYPE_SAMPLER3D
        /// Cubemap sampler global shader parameter (`global uniform samplerCube ...`). Exposed as a ``Cubemap`` in the editor UI.
        case samplercube = 27 // GLOBAL_VAR_TYPE_SAMPLERCUBE
        /// Represents the size of the ``RenderingServer/GlobalShaderParameterType`` enum.
        case max = 28 // GLOBAL_VAR_TYPE_MAX
    }
    
    public enum RenderingInfo: Int64 {
        /// Number of objects rendered in the current 3D scene. This varies depending on camera position and rotation.
        case totalObjectsInFrame = 0 // RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME
        /// Number of points, lines, or triangles rendered in the current 3D scene. This varies depending on camera position and rotation.
        case totalPrimitivesInFrame = 1 // RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME
        /// Number of draw calls performed to render in the current 3D scene. This varies depending on camera position and rotation.
        case totalDrawCallsInFrame = 2 // RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME
        /// Texture memory used (in bytes).
        case textureMemUsed = 3 // RENDERING_INFO_TEXTURE_MEM_USED
        /// Buffer memory used (in bytes). This includes vertex data, uniform buffers, and many miscellaneous buffer types used internally.
        case bufferMemUsed = 4 // RENDERING_INFO_BUFFER_MEM_USED
        /// Video memory used (in bytes). When using the Forward+ or mobile rendering backends, this is always greater than the sum of .textureMemUsed and .bufferMemUsed, since there is miscellaneous data not accounted for by those two metrics. When using the GL Compatibility backend, this is equal to the sum of .textureMemUsed and .bufferMemUsed.
        case videoMemUsed = 5 // RENDERING_INFO_VIDEO_MEM_USED
    }
    
    public enum Features: Int64 {
        /// Hardware supports shaders. This enum is currently unused in Godot 3.x.
        case shaders = 0 // FEATURE_SHADERS
        /// Hardware supports multithreading. This enum is currently unused in Godot 3.x.
        case multithreaded = 1 // FEATURE_MULTITHREADED
    }
    
    /* Constants */
    /// Marks an error that shows that the index array is empty.
    public static let noIndexArray = -1
    /// Number of weights/bones per vertex.
    public static let arrayWeightsSize = 4
    /// The minimum Z-layer for canvas items.
    public static let canvasItemZMin = -4096
    /// The maximum Z-layer for canvas items.
    public static let canvasItemZMax = 4096
    /// The maximum number of glow levels that can be used with the glow post-processing effect.
    public static let maxGlowLevels = 7
    /// _Deprecated._ This constant is unused internally.
    public static let maxCursors = 8
    /// The maximum number of directional lights that can be rendered at a given time in 2D.
    public static let max2dDirectionalLights = 8
    /// The minimum renderpriority of all materials.
    public static let materialRenderPriorityMin = -128
    /// The maximum renderpriority of all materials.
    public static let materialRenderPriorityMax = 127
    /// The number of custom data arrays available (.arrayCustom0, .arrayCustom1, .arrayCustom2, .arrayCustom3).
    public static let arrayCustomCount = 4
    /// 
    public static let particlesEmitFlagPosition = 1
    /// 
    public static let particlesEmitFlagRotationScale = 2
    /// 
    public static let particlesEmitFlagVelocity = 4
    /// 
    public static let particlesEmitFlagColor = 8
    /// 
    public static let particlesEmitFlagCustom = 16
    
    /* Properties */
    
    /// If `false`, disables rendering completely, but the engine logic is still being processed. You can call ``forceDraw(swapBuffers:frameStep:)`` to draw a frame even with rendering disabled.
    static public var renderLoopEnabled: Bool {
        get {
            return is_render_loop_enabled ()
        }
        
        set {
            set_render_loop_enabled (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_texture_2d_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_2d_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2010018390)!
            }
            
        }
        
    }()
    
    /// Creates a 2-dimensional texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_2d_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``Texture2D``.
    /// 
    /// > Note: Not to be confused with ``RenderingDevice/textureCreate(format:view:data:)``, which creates the graphics API's own texture type as opposed to the Godot-specific ``Texture2D`` resource.
    /// 
    public static func texture2dCreate (image: Image?)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_image_handle = image?.handle
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_2d_create, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_image_handle)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: image?.handle) { p0 in
        _args.append (image == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_texture_2d_create, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_texture_2d_layered_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_2d_layered_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 913689023)!
            }
            
        }
        
    }()
    
    /// Creates a 2-dimensional layered texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_2d_layered_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``TextureLayered``.
    /// 
    public static func texture2dLayeredCreate (layers: ObjectCollection<Image>, layeredType: RenderingServer.TextureLayeredType)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_layered_type = Int64 (layeredType.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_2d_layered_create, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &layers.array.content, &copy_layered_type)
        return _result
        #else
        
        var copy_layered_type = Int64 (layeredType.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &layers.array.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_layered_type) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_2d_layered_create, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_3d_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_3d_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4036838706)!
            }
            
        }
        
    }()
    
    /// > Note: The equivalent resource is ``Texture3D``.
    public static func texture3dCreate (format: Image.Format, width: Int32, height: Int32, depth: Int32, mipmaps: Bool, data: ObjectCollection<Image>)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_format = Int64 (format.rawValue)
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        var copy_depth: Int = Int (depth)
        var copy_mipmaps = mipmaps
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_3d_create, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_format, &copy_width, &copy_height, &copy_depth, &copy_mipmaps, &data.array.content)
        return _result
        #else
        
        var copy_format = Int64 (format.rawValue)
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        var copy_depth: Int = Int (depth)
        var copy_mipmaps = mipmaps
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_format) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_height) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_depth) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_mipmaps) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &data.array.content) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_texture_3d_create, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                                return _result
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_proxy_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_proxy_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 41030802)!
            }
            
        }
        
    }()
    
    /// _Deprecated._ ProxyTexture was removed in Godot 4, so this method does nothing when called and always returns a null ``RID``.
    public static func textureProxyCreate (base: RID)-> RID {
        let _result: RID = RID ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_proxy_create, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &base.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &base.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_texture_proxy_create, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_texture_2d_update: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_2d_update")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 999539803)!
            }
            
        }
        
    }()
    
    /// Updates the texture specified by the `texture` ``RID`` with the data in `image`. A `layer` must also be specified, which should be `0` when updating a single-layer texture (``Texture2D``).
    /// 
    /// > Note: The `image` must have the same width, height and format as the current `texture` data. Otherwise, an error will be printed and the original texture won't be modified. If you need to use different width, height or format, use ``textureReplace(texture:byTexture:)`` instead.
    /// 
    public static func texture2dUpdate (texture: RID, image: Image?, layer: Int32) {
        #if false
        
        var copy_layer: Int = Int (layer)
        var copy_image_handle = image?.handle
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_2d_update, UnsafeMutableRawPointer (mutating: shared.handle), nil, &texture.content, &copy_image_handle, &copy_layer)
        
        #else
        
        var copy_layer: Int = Int (layer)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: image?.handle) { p1 in
            _args.append (image == nil ? nil : p1)
                withUnsafePointer (to: &copy_layer) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_texture_2d_update, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_3d_update: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_3d_update")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 684822712)!
            }
            
        }
        
    }()
    
    /// Updates the texture specified by the `texture` ``RID``'s data with the data in `data`. All the texture's layers must be replaced at once.
    /// 
    /// > Note: The `texture` must have the same width, height, depth and format as the current texture data. Otherwise, an error will be printed and the original texture won't be modified. If you need to use different width, height, depth or format, use ``textureReplace(texture:byTexture:)`` instead.
    /// 
    public static func texture3dUpdate (texture: RID, data: ObjectCollection<Image>) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_3d_update, UnsafeMutableRawPointer (mutating: shared.handle), nil, &texture.content, &data.array.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &data.array.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_3d_update, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_proxy_update: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_proxy_update")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// _Deprecated._ ProxyTexture was removed in Godot 4, so this method cannot be used anymore.
    public static func textureProxyUpdate (texture: RID, proxyTo: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_proxy_update, UnsafeMutableRawPointer (mutating: shared.handle), nil, &texture.content, &proxyTo.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &proxyTo.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_proxy_update, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_2d_placeholder_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_2d_placeholder_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a placeholder for a 2-dimensional layered texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_2d_layered_*` RenderingServer functions, although it does nothing when used. See also ``texture2dLayeredPlaceholderCreate(layeredType:)``
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``PlaceholderTexture2D``.
    /// 
    public static func texture2dPlaceholderCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_texture_2d_placeholder_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_texture_2d_layered_placeholder_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_2d_layered_placeholder_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1394585590)!
            }
            
        }
        
    }()
    
    /// Creates a placeholder for a 2-dimensional layered texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_2d_layered_*` RenderingServer functions, although it does nothing when used. See also ``texture2dPlaceholderCreate()``.
    /// 
    /// > Note: The equivalent resource is ``PlaceholderTextureLayered``.
    /// 
    public static func texture2dLayeredPlaceholderCreate (layeredType: RenderingServer.TextureLayeredType)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_layered_type = Int64 (layeredType.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_2d_layered_placeholder_create, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_layered_type)
        return _result
        #else
        
        var copy_layered_type = Int64 (layeredType.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_layered_type) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_texture_2d_layered_placeholder_create, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_texture_3d_placeholder_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_3d_placeholder_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a placeholder for a 3-dimensional texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `texture_3d_*` RenderingServer functions, although it does nothing when used.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``PlaceholderTexture3D``.
    /// 
    public static func texture3dPlaceholderCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_texture_3d_placeholder_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_texture_2d_get: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_2d_get")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4206205781)!
            }
            
        }
        
    }()
    
    /// Returns an ``Image`` instance from the given `texture` ``RID``.
    /// 
    /// Example of getting the test texture from ``getTestTexture()`` and applying it to a ``Sprite2D`` node:
    /// 
    public static func texture2dGet (texture: RID)-> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_2d_get, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &texture.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_texture_2d_get, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_texture_2d_layer_get: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_2d_layer_get")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2705440895)!
            }
            
        }
        
    }()
    
    /// Returns an ``Image`` instance from the given `texture` ``RID`` and `layer`.
    public static func texture2dLayerGet (texture: RID, layer: Int32)-> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_layer: Int = Int (layer)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_2d_layer_get, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &texture.content, &copy_layer)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_layer: Int = Int (layer)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_layer) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_2d_layer_get, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_3d_get: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_3d_get")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns 3D texture data as an array of ``Image``s for the specified texture ``RID``.
    public static func texture3dGet (texture: RID)-> ObjectCollection<Image> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_3d_get, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &texture.content)
        return ObjectCollection<Image>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_texture_3d_get, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return ObjectCollection<Image>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_texture_replace: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_replace")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Replaces `texture`'s texture data by the texture specified by the `byTexture` RID, without changing `texture`'s RID.
    public static func textureReplace (texture: RID, byTexture: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_replace, UnsafeMutableRawPointer (mutating: shared.handle), nil, &texture.content, &byTexture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &byTexture.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_replace, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_set_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_set_size_override")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4288446313)!
            }
            
        }
        
    }()
    
    /// 
    public static func textureSetSizeOverride (texture: RID, width: Int32, height: Int32) {
        #if false
        
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_set_size_override, UnsafeMutableRawPointer (mutating: shared.handle), nil, &texture.content, &copy_width, &copy_height)
        
        #else
        
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_height) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_texture_set_size_override, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_set_path: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_set_path")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// 
    public static func textureSetPath (texture: RID, path: String) {
        #if false
        
        let gstr_path = GString (path)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_set_path, UnsafeMutableRawPointer (mutating: shared.handle), nil, &texture.content, &gstr_path.content)
        
        #else
        
        let gstr_path = GString (path)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_path.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_set_path, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_get_path: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_get_path")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// 
    public static func textureGetPath (texture: RID)-> String {
        let _result = GString ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_get_path, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &texture.content)
        return _result.description
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_texture_get_path, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_texture_get_format: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_get_format")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1932918979)!
            }
            
        }
        
    }()
    
    /// Returns the ``Image.Format`` for the texture.
    public static func textureGetFormat (texture: RID)-> Image.Format {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_get_format, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &texture.content)
        return Image.Format (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_texture_get_format, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return Image.Format (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_texture_set_force_redraw_if_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_set_force_redraw_if_visible")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// 
    public static func textureSetForceRedrawIfVisible (texture: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_set_force_redraw_if_visible, UnsafeMutableRawPointer (mutating: shared.handle), nil, &texture.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_set_force_redraw_if_visible, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_rd_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_rd_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1434128712)!
            }
            
        }
        
    }()
    
    /// Creates a new texture object based on a texture created directly on the ``RenderingDevice``. If the texture contains layers, `layerType` is used to define the layer type.
    public static func textureRdCreate (rdTexture: RID, layerType: RenderingServer.TextureLayeredType = .textureLayered2dArray)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_layer_type = Int64 (layerType.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_rd_create, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &rdTexture.content, &copy_layer_type)
        return _result
        #else
        
        var copy_layer_type = Int64 (layerType.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &rdTexture.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_layer_type) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_rd_create, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_get_rd_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_get_rd_texture")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2790148051)!
            }
            
        }
        
    }()
    
    /// Returns a texture ``RID`` that can be used with ``RenderingDevice``.
    public static func textureGetRdTexture (_ texture: RID, srgb: Bool = false)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_srgb = srgb
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_get_rd_texture, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &texture.content, &copy_srgb)
        return _result
        #else
        
        var copy_srgb = srgb
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_srgb) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_get_rd_texture, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_texture_get_native_handle: GDExtensionMethodBindPtr = {
        let methodName = StringName ("texture_get_native_handle")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1834114100)!
            }
            
        }
        
    }()
    
    /// Returns the internal graphics handle for this texture object. For use when communicating with third-party APIs mostly with GDExtension.
    /// 
    /// > Note: This function returns a `uint64_t` which internally maps to a `GLuint` (OpenGL) or `VkImage` (Vulkan).
    /// 
    public static func textureGetNativeHandle (texture: RID, srgb: Bool = false)-> UInt {
        var _result: UInt = 0
        #if false
        
        var copy_srgb = srgb
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_texture_get_native_handle, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &texture.content, &copy_srgb)
        return _result
        #else
        
        var copy_srgb = srgb
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &texture.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_srgb) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_texture_get_native_handle, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shader_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shader_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates an empty shader and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `shader_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``Shader``.
    /// 
    public static func shaderCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_shader_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_shader_set_code: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shader_set_code")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets the shader's source code (which triggers recompilation after being changed).
    public static func shaderSetCode (shader: RID, code: String) {
        #if false
        
        let gstr_code = GString (code)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_shader_set_code, UnsafeMutableRawPointer (mutating: shared.handle), nil, &shader.content, &gstr_code.content)
        
        #else
        
        let gstr_code = GString (code)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shader.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_code.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_shader_set_code, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shader_set_path_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shader_set_path_hint")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets the path hint for the specified shader. This should generally match the ``Shader`` resource's ``Resource/resourcePath``.
    public static func shaderSetPathHint (shader: RID, path: String) {
        #if false
        
        let gstr_path = GString (path)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_shader_set_path_hint, UnsafeMutableRawPointer (mutating: shared.handle), nil, &shader.content, &gstr_path.content)
        
        #else
        
        let gstr_path = GString (path)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shader.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_path.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_shader_set_path_hint, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shader_get_code: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shader_get_code")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns a shader's source code as a string.
    public static func shaderGetCode (shader: RID)-> String {
        let _result = GString ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_shader_get_code, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &shader.content)
        return _result.description
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shader.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_shader_get_code, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_shader_parameter_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_shader_parameter_list")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns the parameters of a shader.
    public static func getShaderParameterList (shader: RID)-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_get_shader_parameter_list, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &shader.content)
        return VariantCollection<GDictionary>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shader.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_get_shader_parameter_list, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return VariantCollection<GDictionary>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_shader_get_parameter_default: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shader_get_parameter_default")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2621281810)!
            }
            
        }
        
    }()
    
    /// Returns the default value for the specified shader uniform. This is usually the value written in the shader source code.
    public static func shaderGetParameterDefault (shader: RID, name: StringName)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_shader_get_parameter_default, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &shader.content, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shader.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &name.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_shader_get_parameter_default, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shader_set_default_texture_parameter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shader_set_default_texture_parameter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4094001817)!
            }
            
        }
        
    }()
    
    /// Sets a shader's default texture. Overwrites the texture given by name.
    /// 
    /// > Note: If the sampler array is used use `index` to access the specified texture.
    /// 
    public static func shaderSetDefaultTextureParameter (shader: RID, name: StringName, texture: RID, index: Int32 = 0) {
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_shader_set_default_texture_parameter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &shader.content, &name.content, &texture.content, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shader.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &name.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_index) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_shader_set_default_texture_parameter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shader_get_default_texture_parameter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shader_get_default_texture_parameter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1464608890)!
            }
            
        }
        
    }()
    
    /// Returns a default texture from a shader searched by name.
    /// 
    /// > Note: If the sampler array is used use `index` to access the specified texture.
    /// 
    public static func shaderGetDefaultTextureParameter (shader: RID, name: StringName, index: Int32 = 0)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_shader_get_default_texture_parameter, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &shader.content, &name.content, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shader.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &name.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_shader_get_default_texture_parameter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_material_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("material_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates an empty material and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `material_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``Material``.
    /// 
    public static func materialCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_material_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_material_set_shader: GDExtensionMethodBindPtr = {
        let methodName = StringName ("material_set_shader")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a shader material's shader.
    public static func materialSetShader (shaderMaterial: RID, shader: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_material_set_shader, UnsafeMutableRawPointer (mutating: shared.handle), nil, &shaderMaterial.content, &shader.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaderMaterial.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &shader.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_material_set_shader, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_material_set_param: GDExtensionMethodBindPtr = {
        let methodName = StringName ("material_set_param")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3477296213)!
            }
            
        }
        
    }()
    
    /// Sets a material's parameter.
    public static func materialSetParam (material: RID, parameter: StringName, value: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_material_set_param, UnsafeMutableRawPointer (mutating: shared.handle), nil, &material.content, &parameter.content, &value.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &material.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &parameter.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &value.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_material_set_param, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_material_get_param: GDExtensionMethodBindPtr = {
        let methodName = StringName ("material_get_param")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2621281810)!
            }
            
        }
        
    }()
    
    /// Returns the value of a certain material's parameter.
    public static func materialGetParam (material: RID, parameter: StringName)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_material_get_param, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &material.content, &parameter.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &material.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &parameter.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_material_get_param, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_material_set_render_priority: GDExtensionMethodBindPtr = {
        let methodName = StringName ("material_set_render_priority")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets a material's render priority.
    public static func materialSetRenderPriority (material: RID, priority: Int32) {
        #if false
        
        var copy_priority: Int = Int (priority)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_material_set_render_priority, UnsafeMutableRawPointer (mutating: shared.handle), nil, &material.content, &copy_priority)
        
        #else
        
        var copy_priority: Int = Int (priority)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &material.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_priority) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_material_set_render_priority, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_material_set_next_pass: GDExtensionMethodBindPtr = {
        let methodName = StringName ("material_set_next_pass")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets an object's next material.
    public static func materialSetNextPass (material: RID, nextMaterial: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_material_set_next_pass, UnsafeMutableRawPointer (mutating: shared.handle), nil, &material.content, &nextMaterial.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &material.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &nextMaterial.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_material_set_next_pass, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_create_from_surfaces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_create_from_surfaces")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4291747531)!
            }
            
        }
        
    }()
    
    /// 
    public static func meshCreateFromSurfaces (_ surfaces: VariantCollection<GDictionary>, blendShapeCount: Int32 = 0)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_blend_shape_count: Int = Int (blendShapeCount)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_create_from_surfaces, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &surfaces.array.content, &copy_blend_shape_count)
        return _result
        #else
        
        var copy_blend_shape_count: Int = Int (blendShapeCount)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &surfaces.array.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_blend_shape_count) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_create_from_surfaces, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new mesh and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `mesh_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach this mesh to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    /// > Note: The equivalent resource is ``Mesh``.
    /// 
    public static func meshCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_mesh_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_mesh_surface_get_format_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_get_format_offset")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2981368685)!
            }
            
        }
        
    }()
    
    /// Returns the offset of a given attribute by `arrayIndex` in the start of its respective buffer.
    public static func meshSurfaceGetFormatOffset (format: RenderingServer.ArrayFormat, vertexCount: Int32, arrayIndex: Int32)-> UInt32 {
        var _result: UInt32 = 0
        #if false
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        var copy_array_index: Int = Int (arrayIndex)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_get_format_offset, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_format, &copy_vertex_count, &copy_array_index)
        return _result
        #else
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        var copy_array_index: Int = Int (arrayIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_format) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_vertex_count) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_array_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_get_format_offset, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_get_format_vertex_stride: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_get_format_vertex_stride")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3188363337)!
            }
            
        }
        
    }()
    
    /// Returns the stride of the vertex positions for a mesh with given `format`. Note importantly that vertex positions are stored consecutively and are not interleaved with the other attributes in the vertex buffer (normals and tangents).
    public static func meshSurfaceGetFormatVertexStride (format: RenderingServer.ArrayFormat, vertexCount: Int32)-> UInt32 {
        var _result: UInt32 = 0
        #if false
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_get_format_vertex_stride, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_format, &copy_vertex_count)
        return _result
        #else
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_format) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_vertex_count) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_get_format_vertex_stride, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_get_format_normal_tangent_stride: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_get_format_normal_tangent_stride")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3188363337)!
            }
            
        }
        
    }()
    
    /// Returns the stride of the combined normals and tangents for a mesh with given `format`. Note importantly that, while normals and tangents are in the vertex buffer with vertices, they are only interleaved with each other and so have a different stride than vertex positions.
    public static func meshSurfaceGetFormatNormalTangentStride (format: RenderingServer.ArrayFormat, vertexCount: Int32)-> UInt32 {
        var _result: UInt32 = 0
        #if false
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_get_format_normal_tangent_stride, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_format, &copy_vertex_count)
        return _result
        #else
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_format) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_vertex_count) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_get_format_normal_tangent_stride, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_get_format_attribute_stride: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_get_format_attribute_stride")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3188363337)!
            }
            
        }
        
    }()
    
    /// Returns the stride of the attribute buffer for a mesh with given `format`.
    public static func meshSurfaceGetFormatAttributeStride (format: RenderingServer.ArrayFormat, vertexCount: Int32)-> UInt32 {
        var _result: UInt32 = 0
        #if false
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_get_format_attribute_stride, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_format, &copy_vertex_count)
        return _result
        #else
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_format) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_vertex_count) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_get_format_attribute_stride, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_get_format_skin_stride: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_get_format_skin_stride")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3188363337)!
            }
            
        }
        
    }()
    
    /// Returns the stride of the skin buffer for a mesh with given `format`.
    public static func meshSurfaceGetFormatSkinStride (format: RenderingServer.ArrayFormat, vertexCount: Int32)-> UInt32 {
        var _result: UInt32 = 0
        #if false
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_get_format_skin_stride, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_format, &copy_vertex_count)
        return _result
        #else
        
        var copy_format = format
        var copy_vertex_count: Int = Int (vertexCount)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_format) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_vertex_count) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_get_format_skin_stride, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_add_surface: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_add_surface")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1217542888)!
            }
            
        }
        
    }()
    
    /// 
    public static func meshAddSurface (mesh: RID, surface: GDictionary) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_add_surface, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &surface.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &surface.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_add_surface, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_add_surface_from_arrays: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_add_surface_from_arrays")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2342446560)!
            }
            
        }
        
    }()
    
    /// 
    public static func meshAddSurfaceFromArrays (mesh: RID, primitive: RenderingServer.PrimitiveType, arrays: GArray, blendShapes: GArray = GArray (), lods: GDictionary = GDictionary (), compressFormat: RenderingServer.ArrayFormat = []) {
        #if false
        
        var copy_primitive = Int64 (primitive.rawValue)
        var copy_compress_format = compressFormat
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_add_surface_from_arrays, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &copy_primitive, &arrays.content, &blendShapes.content, &lods.content, &copy_compress_format)
        
        #else
        
        var copy_primitive = Int64 (primitive.rawValue)
        var copy_compress_format = compressFormat
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_primitive) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &arrays.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &blendShapes.content) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &lods.content) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_compress_format) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_add_surface_from_arrays, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_get_blend_shape_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_get_blend_shape_count")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns a mesh's blend shape count.
    public static func meshGetBlendShapeCount (mesh: RID)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_get_blend_shape_count, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &mesh.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_mesh_get_blend_shape_count, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_set_blend_shape_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_set_blend_shape_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1294662092)!
            }
            
        }
        
    }()
    
    /// Sets a mesh's blend shape mode.
    public static func meshSetBlendShapeMode (mesh: RID, mode: RenderingServer.BlendShapeMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_set_blend_shape_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_set_blend_shape_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_get_blend_shape_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_get_blend_shape_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4282291819)!
            }
            
        }
        
    }()
    
    /// Returns a mesh's blend shape mode.
    public static func meshGetBlendShapeMode (mesh: RID)-> RenderingServer.BlendShapeMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_get_blend_shape_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &mesh.content)
        return RenderingServer.BlendShapeMode (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_mesh_get_blend_shape_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return RenderingServer.BlendShapeMode (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_set_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_set_material")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2310537182)!
            }
            
        }
        
    }()
    
    /// Sets a mesh's surface's material.
    public static func meshSurfaceSetMaterial (mesh: RID, surface: Int32, material: RID) {
        #if false
        
        var copy_surface: Int = Int (surface)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_set_material, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &copy_surface, &material.content)
        
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &material.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_set_material, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_get_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_get_material")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1066463050)!
            }
            
        }
        
    }()
    
    /// Returns a mesh's surface's material.
    public static func meshSurfaceGetMaterial (mesh: RID, surface: Int32)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_surface: Int = Int (surface)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_get_material, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &mesh.content, &copy_surface)
        return _result
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_get_material, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_get_surface: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_get_surface")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 186674697)!
            }
            
        }
        
    }()
    
    /// 
    public static func meshGetSurface (mesh: RID, surface: Int32)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        var copy_surface: Int = Int (surface)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_get_surface, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &mesh.content, &copy_surface)
        return _result
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_get_surface, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_get_arrays: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_get_arrays")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1778388067)!
            }
            
        }
        
    }()
    
    /// Returns a mesh's surface's buffer arrays.
    public static func meshSurfaceGetArrays (mesh: RID, surface: Int32)-> GArray {
        let _result: GArray = GArray ()
        #if false
        
        var copy_surface: Int = Int (surface)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_get_arrays, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &mesh.content, &copy_surface)
        return _result
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_get_arrays, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_get_blend_shape_arrays: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_get_blend_shape_arrays")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1778388067)!
            }
            
        }
        
    }()
    
    /// Returns a mesh's surface's arrays for blend shapes.
    public static func meshSurfaceGetBlendShapeArrays (mesh: RID, surface: Int32)-> VariantCollection<GArray> {
        var _result: Int64 = 0
        #if false
        
        var copy_surface: Int = Int (surface)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_get_blend_shape_arrays, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &mesh.content, &copy_surface)
        return VariantCollection<GArray>(content: _result)
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_get_blend_shape_arrays, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return VariantCollection<GArray>(content: _result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_get_surface_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_get_surface_count")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns a mesh's number of surfaces.
    public static func meshGetSurfaceCount (mesh: RID)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_get_surface_count, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &mesh.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_mesh_get_surface_count, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_set_custom_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_set_custom_aabb")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3696536120)!
            }
            
        }
        
    }()
    
    /// Sets a mesh's custom aabb.
    public static func meshSetCustomAabb (mesh: RID, aabb: AABB) {
        #if false
        
        var copy_aabb = aabb
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_set_custom_aabb, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &copy_aabb)
        
        #else
        
        var copy_aabb = aabb
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_aabb) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_set_custom_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_get_custom_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_get_custom_aabb")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 974181306)!
            }
            
        }
        
    }()
    
    /// Returns a mesh's custom aabb.
    public static func meshGetCustomAabb (mesh: RID)-> AABB {
        var _result: AABB = AABB ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_get_custom_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &mesh.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_mesh_get_custom_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_clear")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Removes all surfaces from a mesh.
    public static func meshClear (mesh: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_clear, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_mesh_clear, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_update_vertex_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_update_vertex_region")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2900195149)!
            }
            
        }
        
    }()
    
    /// 
    public static func meshSurfaceUpdateVertexRegion (mesh: RID, surface: Int32, offset: Int32, data: PackedByteArray) {
        #if false
        
        var copy_surface: Int = Int (surface)
        var copy_offset: Int = Int (offset)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_update_vertex_region, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &copy_surface, &copy_offset, &data.content)
        
        #else
        
        var copy_surface: Int = Int (surface)
        var copy_offset: Int = Int (offset)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_offset) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &data.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_update_vertex_region, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_update_attribute_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_update_attribute_region")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2900195149)!
            }
            
        }
        
    }()
    
    /// 
    public static func meshSurfaceUpdateAttributeRegion (mesh: RID, surface: Int32, offset: Int32, data: PackedByteArray) {
        #if false
        
        var copy_surface: Int = Int (surface)
        var copy_offset: Int = Int (offset)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_update_attribute_region, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &copy_surface, &copy_offset, &data.content)
        
        #else
        
        var copy_surface: Int = Int (surface)
        var copy_offset: Int = Int (offset)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_offset) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &data.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_update_attribute_region, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_surface_update_skin_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_surface_update_skin_region")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2900195149)!
            }
            
        }
        
    }()
    
    /// 
    public static func meshSurfaceUpdateSkinRegion (mesh: RID, surface: Int32, offset: Int32, data: PackedByteArray) {
        #if false
        
        var copy_surface: Int = Int (surface)
        var copy_offset: Int = Int (offset)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_surface_update_skin_region, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &copy_surface, &copy_offset, &data.content)
        
        #else
        
        var copy_surface: Int = Int (surface)
        var copy_offset: Int = Int (offset)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_offset) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &data.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_mesh_surface_update_skin_region, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mesh_set_shadow_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mesh_set_shadow_mesh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// 
    public static func meshSetShadowMesh (_ mesh: RID, shadowMesh: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_mesh_set_shadow_mesh, UnsafeMutableRawPointer (mutating: shared.handle), nil, &mesh.content, &shadowMesh.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &mesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &shadowMesh.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_mesh_set_shadow_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new multimesh on the RenderingServer and returns an ``RID`` handle. This RID will be used in all `multimesh_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach this multimesh to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    /// > Note: The equivalent resource is ``MultiMesh``.
    /// 
    public static func multimeshCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_multimesh_allocate_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_allocate_data")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 283685892)!
            }
            
        }
        
    }()
    
    /// 
    public static func multimeshAllocateData (multimesh: RID, instances: Int32, transformFormat: RenderingServer.MultimeshTransformFormat, colorFormat: Bool = false, customDataFormat: Bool = false) {
        #if false
        
        var copy_instances: Int = Int (instances)
        var copy_transform_format = Int64 (transformFormat.rawValue)
        var copy_color_format = colorFormat
        var copy_custom_data_format = customDataFormat
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_allocate_data, UnsafeMutableRawPointer (mutating: shared.handle), nil, &multimesh.content, &copy_instances, &copy_transform_format, &copy_color_format, &copy_custom_data_format)
        
        #else
        
        var copy_instances: Int = Int (instances)
        var copy_transform_format = Int64 (transformFormat.rawValue)
        var copy_color_format = colorFormat
        var copy_custom_data_format = customDataFormat
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_instances) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_transform_format) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_color_format) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_custom_data_format) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_allocate_data, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_get_instance_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_get_instance_count")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns the number of instances allocated for this multimesh.
    public static func multimeshGetInstanceCount (multimesh: RID)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_get_instance_count, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &multimesh.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_get_instance_count, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_set_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_set_mesh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the mesh to be drawn by the multimesh. Equivalent to ``MultiMesh/mesh``.
    public static func multimeshSetMesh (multimesh: RID, mesh: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_set_mesh, UnsafeMutableRawPointer (mutating: shared.handle), nil, &multimesh.content, &mesh.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &mesh.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_set_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_instance_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_instance_set_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 675327471)!
            }
            
        }
        
    }()
    
    /// Sets the ``Transform3D`` for this instance. Equivalent to ``MultiMesh/setInstanceTransform(instance:transform:)``.
    public static func multimeshInstanceSetTransform (multimesh: RID, index: Int32, transform: Transform3D) {
        #if false
        
        var copy_index: Int = Int (index)
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_instance_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &multimesh.content, &copy_index, &copy_transform)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_transform) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_instance_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_instance_set_transform_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_instance_set_transform_2d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 736082694)!
            }
            
        }
        
    }()
    
    /// Sets the ``Transform2D`` for this instance. For use when multimesh is used in 2D. Equivalent to ``MultiMesh/setInstanceTransform2d(instance:transform:)``.
    public static func multimeshInstanceSetTransform2d (multimesh: RID, index: Int32, transform: Transform2D) {
        #if false
        
        var copy_index: Int = Int (index)
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_instance_set_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), nil, &multimesh.content, &copy_index, &copy_transform)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_transform) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_instance_set_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_instance_set_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_instance_set_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 176975443)!
            }
            
        }
        
    }()
    
    /// Sets the color by which this instance will be modulated. Equivalent to ``MultiMesh/setInstanceColor(instance:color:)``.
    public static func multimeshInstanceSetColor (multimesh: RID, index: Int32, color: Color) {
        #if false
        
        var copy_index: Int = Int (index)
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_instance_set_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &multimesh.content, &copy_index, &copy_color)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_color) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_instance_set_color, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_instance_set_custom_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_instance_set_custom_data")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 176975443)!
            }
            
        }
        
    }()
    
    /// Sets the custom data for this instance. Custom data is passed as a ``Color``, but is interpreted as a `vec4` in the shader. Equivalent to ``MultiMesh/setInstanceCustomData(instance:customData:)``.
    public static func multimeshInstanceSetCustomData (multimesh: RID, index: Int32, customData: Color) {
        #if false
        
        var copy_index: Int = Int (index)
        var copy_custom_data = customData
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_instance_set_custom_data, UnsafeMutableRawPointer (mutating: shared.handle), nil, &multimesh.content, &copy_index, &copy_custom_data)
        
        #else
        
        var copy_index: Int = Int (index)
        var copy_custom_data = customData
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_custom_data) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_instance_set_custom_data, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_get_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_get_mesh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814569979)!
            }
            
        }
        
    }()
    
    /// Returns the RID of the mesh that will be used in drawing this multimesh.
    public static func multimeshGetMesh (multimesh: RID)-> RID {
        let _result: RID = RID ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_get_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &multimesh.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_get_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_get_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_get_aabb")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 974181306)!
            }
            
        }
        
    }()
    
    /// Calculates and returns the axis-aligned bounding box that encloses all instances within the multimesh.
    public static func multimeshGetAabb (multimesh: RID)-> AABB {
        var _result: AABB = AABB ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_get_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &multimesh.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_get_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_instance_get_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_instance_get_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1050775521)!
            }
            
        }
        
    }()
    
    /// Returns the ``Transform3D`` of the specified instance.
    public static func multimeshInstanceGetTransform (multimesh: RID, index: Int32)-> Transform3D {
        var _result: Transform3D = Transform3D ()
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_instance_get_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &multimesh.content, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_instance_get_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_instance_get_transform_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_instance_get_transform_2d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1324854622)!
            }
            
        }
        
    }()
    
    /// Returns the ``Transform2D`` of the specified instance. For use when the multimesh is set to use 2D transforms.
    public static func multimeshInstanceGetTransform2d (multimesh: RID, index: Int32)-> Transform2D {
        var _result: Transform2D = Transform2D ()
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_instance_get_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &multimesh.content, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_instance_get_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_instance_get_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_instance_get_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2946315076)!
            }
            
        }
        
    }()
    
    /// Returns the color by which the specified instance will be modulated.
    public static func multimeshInstanceGetColor (multimesh: RID, index: Int32)-> Color {
        var _result: Color = Color ()
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_instance_get_color, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &multimesh.content, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_instance_get_color, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_instance_get_custom_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_instance_get_custom_data")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2946315076)!
            }
            
        }
        
    }()
    
    /// Returns the custom data associated with the specified instance.
    public static func multimeshInstanceGetCustomData (multimesh: RID, index: Int32)-> Color {
        var _result: Color = Color ()
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_instance_get_custom_data, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &multimesh.content, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_instance_get_custom_data, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_set_visible_instances: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_set_visible_instances")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the number of instances visible at a given time. If -1, all instances that have been allocated are drawn. Equivalent to ``MultiMesh/visibleInstanceCount``.
    public static func multimeshSetVisibleInstances (multimesh: RID, visible: Int32) {
        #if false
        
        var copy_visible: Int = Int (visible)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_set_visible_instances, UnsafeMutableRawPointer (mutating: shared.handle), nil, &multimesh.content, &copy_visible)
        
        #else
        
        var copy_visible: Int = Int (visible)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_visible) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_set_visible_instances, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_get_visible_instances: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_get_visible_instances")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns the number of visible instances for this multimesh.
    public static func multimeshGetVisibleInstances (multimesh: RID)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_get_visible_instances, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &multimesh.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_get_visible_instances, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_set_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_set_buffer")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2960552364)!
            }
            
        }
        
    }()
    
    /// Set the entire data to use for drawing the `multimesh` at once to `buffer` (such as instance transforms and colors). `buffer`'s size must match the number of instances multiplied by the per-instance data size (which depends on the enabled MultiMesh fields). Otherwise, an error message is printed and nothing is rendered. See also ``multimeshGetBuffer(multimesh:)``.
    /// 
    /// The per-instance data size and expected data order is:
    /// 
    public static func multimeshSetBuffer (multimesh: RID, buffer: PackedFloat32Array) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_set_buffer, UnsafeMutableRawPointer (mutating: shared.handle), nil, &multimesh.content, &buffer.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &buffer.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_set_buffer, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_multimesh_get_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("multimesh_get_buffer")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3964669176)!
            }
            
        }
        
    }()
    
    /// Returns the MultiMesh data (such as instance transforms, colors, etc). See ``multimeshSetBuffer(multimesh:buffer:)`` for a description of the returned data.
    /// 
    /// > Note: If the buffer is in the engine's internal cache, it will have to be fetched from GPU memory and possibly decompressed. This means ``multimeshGetBuffer(multimesh:)`` is potentially a slow operation and should be avoided whenever possible.
    /// 
    public static func multimeshGetBuffer (multimesh: RID)-> PackedFloat32Array {
        let _result: PackedFloat32Array = PackedFloat32Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_multimesh_get_buffer, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &multimesh.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &multimesh.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_multimesh_get_buffer, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_skeleton_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("skeleton_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a skeleton and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `skeleton_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    public static func skeletonCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_skeleton_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_skeleton_allocate_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("skeleton_allocate_data")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1904426712)!
            }
            
        }
        
    }()
    
    /// 
    public static func skeletonAllocateData (skeleton: RID, bones: Int32, is2dSkeleton: Bool = false) {
        #if false
        
        var copy_bones: Int = Int (bones)
        var copy_is_2d_skeleton = is2dSkeleton
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_skeleton_allocate_data, UnsafeMutableRawPointer (mutating: shared.handle), nil, &skeleton.content, &copy_bones, &copy_is_2d_skeleton)
        
        #else
        
        var copy_bones: Int = Int (bones)
        var copy_is_2d_skeleton = is2dSkeleton
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &skeleton.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bones) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_is_2d_skeleton) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_skeleton_allocate_data, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_skeleton_get_bone_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("skeleton_get_bone_count")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns the number of bones allocated for this skeleton.
    public static func skeletonGetBoneCount (skeleton: RID)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_skeleton_get_bone_count, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &skeleton.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &skeleton.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_skeleton_get_bone_count, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_skeleton_bone_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("skeleton_bone_set_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 675327471)!
            }
            
        }
        
    }()
    
    /// Sets the ``Transform3D`` for a specific bone of this skeleton.
    public static func skeletonBoneSetTransform (skeleton: RID, bone: Int32, transform: Transform3D) {
        #if false
        
        var copy_bone: Int = Int (bone)
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_skeleton_bone_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &skeleton.content, &copy_bone, &copy_transform)
        
        #else
        
        var copy_bone: Int = Int (bone)
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &skeleton.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bone) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_transform) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_skeleton_bone_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_skeleton_bone_get_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("skeleton_bone_get_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1050775521)!
            }
            
        }
        
    }()
    
    /// Returns the ``Transform3D`` set for a specific bone of this skeleton.
    public static func skeletonBoneGetTransform (skeleton: RID, bone: Int32)-> Transform3D {
        var _result: Transform3D = Transform3D ()
        #if false
        
        var copy_bone: Int = Int (bone)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_skeleton_bone_get_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &skeleton.content, &copy_bone)
        return _result
        #else
        
        var copy_bone: Int = Int (bone)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &skeleton.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_bone) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_skeleton_bone_get_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_skeleton_bone_set_transform_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("skeleton_bone_set_transform_2d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 736082694)!
            }
            
        }
        
    }()
    
    /// Sets the ``Transform2D`` for a specific bone of this skeleton.
    public static func skeletonBoneSetTransform2d (skeleton: RID, bone: Int32, transform: Transform2D) {
        #if false
        
        var copy_bone: Int = Int (bone)
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_skeleton_bone_set_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), nil, &skeleton.content, &copy_bone, &copy_transform)
        
        #else
        
        var copy_bone: Int = Int (bone)
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &skeleton.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bone) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_transform) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_skeleton_bone_set_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_skeleton_bone_get_transform_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("skeleton_bone_get_transform_2d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1324854622)!
            }
            
        }
        
    }()
    
    /// Returns the ``Transform2D`` set for a specific bone of this skeleton.
    public static func skeletonBoneGetTransform2d (skeleton: RID, bone: Int32)-> Transform2D {
        var _result: Transform2D = Transform2D ()
        #if false
        
        var copy_bone: Int = Int (bone)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_skeleton_bone_get_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &skeleton.content, &copy_bone)
        return _result
        #else
        
        var copy_bone: Int = Int (bone)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &skeleton.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_bone) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_skeleton_bone_get_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_skeleton_set_base_transform_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("skeleton_set_base_transform_2d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1246044741)!
            }
            
        }
        
    }()
    
    /// 
    public static func skeletonSetBaseTransform2d (skeleton: RID, baseTransform: Transform2D) {
        #if false
        
        var copy_base_transform = baseTransform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_skeleton_set_base_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), nil, &skeleton.content, &copy_base_transform)
        
        #else
        
        var copy_base_transform = baseTransform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &skeleton.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_base_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_skeleton_set_base_transform_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_directional_light_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("directional_light_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a directional light and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID can be used in most `light_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach this directional light to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    /// > Note: The equivalent node is ``DirectionalLight3D``.
    /// 
    public static func directionalLightCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_directional_light_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_omni_light_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("omni_light_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new omni light and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID can be used in most `light_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach this omni light to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    /// > Note: The equivalent node is ``OmniLight3D``.
    /// 
    public static func omniLightCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_omni_light_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_spot_light_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("spot_light_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a spot light and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID can be used in most `light_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach this spot light to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    public static func spotLightCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_spot_light_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_light_set_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Sets the color of the light. Equivalent to ``Light3D/lightColor``.
    public static func lightSetColor (light: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_set_color, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_param: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_param")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501936875)!
            }
            
        }
        
    }()
    
    /// Sets the specified 3D light parameter. See ``RenderingServer/LightParam`` for options. Equivalent to ``Light3D/setParam(_:value:)``.
    public static func lightSetParam (light: RID, param: RenderingServer.LightParam, value: Double) {
        #if false
        
        var copy_param = Int64 (param.rawValue)
        var copy_value = value
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_param, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_param, &copy_value)
        
        #else
        
        var copy_param = Int64 (param.rawValue)
        var copy_value = value
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_param) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_value) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_light_set_param, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_shadow: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_shadow")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, light will cast shadows. Equivalent to ``Light3D/shadowEnabled``.
    public static func lightSetShadow (light: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_shadow, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_set_shadow, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_projector: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_projector")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the projector texture to use for the specified 3D light. Equivalent to ``Light3D/lightProjector``.
    public static func lightSetProjector (light: RID, texture: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_projector, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &texture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &texture.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_set_projector, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_negative: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_negative")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, the 3D light will subtract light instead of adding light. Equivalent to ``Light3D/lightNegative``.
    public static func lightSetNegative (light: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_negative, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_set_negative, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_cull_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the cull mask for this 3D light. Lights only affect objects in the selected layers. Equivalent to ``Light3D/lightCullMask``.
    public static func lightSetCullMask (light: RID, mask: UInt32) {
        #if false
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_distance_fade: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_distance_fade")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1622292572)!
            }
            
        }
        
    }()
    
    /// Sets the distance fade for this 3D light. This acts as a form of level of detail (LOD) and can be used to improve performance. Equivalent to ``Light3D/distanceFadeEnabled``, ``Light3D/distanceFadeBegin``, ``Light3D/distanceFadeShadow``, and ``Light3D/distanceFadeLength``.
    public static func lightSetDistanceFade (decal: RID, enabled: Bool, begin: Double, shadow: Double, length: Double) {
        #if false
        
        var copy_enabled = enabled
        var copy_begin = begin
        var copy_shadow = shadow
        var copy_length = length
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_distance_fade, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_enabled, &copy_begin, &copy_shadow, &copy_length)
        
        #else
        
        var copy_enabled = enabled
        var copy_begin = begin
        var copy_shadow = shadow
        var copy_length = length
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_begin) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_shadow) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_length) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_light_set_distance_fade, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_reverse_cull_face_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_reverse_cull_face_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, reverses the backface culling of the mesh. This can be useful when you have a flat mesh that has a light behind it. If you need to cast a shadow on both sides of the mesh, set the mesh to use double-sided shadows with ``instanceGeometrySetCastShadowsSetting(instance:shadowCastingSetting:)``. Equivalent to ``Light3D/shadowReverseCullFace``.
    public static func lightSetReverseCullFaceMode (light: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_reverse_cull_face_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_set_reverse_cull_face_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_bake_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_bake_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1048525260)!
            }
            
        }
        
    }()
    
    /// Sets the bake mode to use for the specified 3D light. Equivalent to ``Light3D/lightBakeMode``.
    public static func lightSetBakeMode (light: RID, bakeMode: RenderingServer.LightBakeMode) {
        #if false
        
        var copy_bake_mode = Int64 (bakeMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_bake_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_bake_mode)
        
        #else
        
        var copy_bake_mode = Int64 (bakeMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bake_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_set_bake_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_set_max_sdfgi_cascade: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_set_max_sdfgi_cascade")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the maximum SDFGI cascade in which the 3D light's indirect lighting is rendered. Higher values allow the light to be rendered in SDFGI further away from the camera.
    public static func lightSetMaxSdfgiCascade (light: RID, cascade: UInt32) {
        #if false
        
        var copy_cascade: Int = Int (cascade)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_set_max_sdfgi_cascade, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_cascade)
        
        #else
        
        var copy_cascade: Int = Int (cascade)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_cascade) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_set_max_sdfgi_cascade, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_omni_set_shadow_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_omni_set_shadow_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2552677200)!
            }
            
        }
        
    }()
    
    /// Sets whether to use a dual paraboloid or a cubemap for the shadow map. Dual paraboloid is faster but may suffer from artifacts. Equivalent to ``OmniLight3D/omniShadowMode``.
    public static func lightOmniSetShadowMode (light: RID, mode: RenderingServer.LightOmniShadowMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_omni_set_shadow_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_omni_set_shadow_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_directional_set_shadow_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_directional_set_shadow_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 380462970)!
            }
            
        }
        
    }()
    
    /// Sets the shadow mode for this directional light. Equivalent to ``DirectionalLight3D/directionalShadowMode``. See ``RenderingServer/LightDirectionalShadowMode`` for options.
    public static func lightDirectionalSetShadowMode (light: RID, mode: RenderingServer.LightDirectionalShadowMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_directional_set_shadow_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_directional_set_shadow_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_directional_set_blend_splits: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_directional_set_blend_splits")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, this directional light will blend between shadow map splits resulting in a smoother transition between them. Equivalent to ``DirectionalLight3D/directionalShadowBlendSplits``.
    public static func lightDirectionalSetBlendSplits (light: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_directional_set_blend_splits, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_directional_set_blend_splits, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_directional_set_sky_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_directional_set_sky_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2559740754)!
            }
            
        }
        
    }()
    
    /// If `true`, this light will not be used for anything except sky shaders. Use this for lights that impact your sky shader that you may want to hide from affecting the rest of the scene. For example, you may want to enable this when the sun in your sky shader falls below the horizon.
    public static func lightDirectionalSetSkyMode (light: RID, mode: RenderingServer.LightDirectionalSkyMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_directional_set_sky_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_light_directional_set_sky_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_light_projectors_set_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("light_projectors_set_filter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 43944325)!
            }
            
        }
        
    }()
    
    /// Sets the texture filter mode to use when rendering light projectors. This parameter is global and cannot be set on a per-light basis.
    public static func lightProjectorsSetFilter (_ filter: RenderingServer.LightProjectorFilter) {
        #if false
        
        var copy_filter = Int64 (filter.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_light_projectors_set_filter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_filter)
        
        #else
        
        var copy_filter = Int64 (filter.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_filter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_light_projectors_set_filter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_positional_soft_shadow_filter_set_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("positional_soft_shadow_filter_set_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3613045266)!
            }
            
        }
        
    }()
    
    /// Sets the filter quality for omni and spot light shadows in 3D. See also ``ProjectSettings/rendering/lightsAndShadows/positionalShadow/softShadowFilterQuality``. This parameter is global and cannot be set on a per-viewport basis.
    public static func positionalSoftShadowFilterSetQuality (_ quality: RenderingServer.ShadowQuality) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_positional_soft_shadow_filter_set_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_positional_soft_shadow_filter_set_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_directional_soft_shadow_filter_set_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("directional_soft_shadow_filter_set_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3613045266)!
            }
            
        }
        
    }()
    
    /// Sets the filter `quality` for directional light shadows in 3D. See also ``ProjectSettings/rendering/lightsAndShadows/directionalShadow/softShadowFilterQuality``. This parameter is global and cannot be set on a per-viewport basis.
    public static func directionalSoftShadowFilterSetQuality (_ quality: RenderingServer.ShadowQuality) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_directional_soft_shadow_filter_set_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_directional_soft_shadow_filter_set_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_directional_shadow_atlas_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("directional_shadow_atlas_set_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the `size` of the directional light shadows in 3D. See also ``ProjectSettings/rendering/lightsAndShadows/directionalShadow/size``. This parameter is global and cannot be set on a per-viewport basis.
    public static func directionalShadowAtlasSetSize (_ size: Int32, is16bits: Bool) {
        #if false
        
        var copy_size: Int = Int (size)
        var copy_is_16bits = is16bits
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_directional_shadow_atlas_set_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_size, &copy_is_16bits)
        
        #else
        
        var copy_size: Int = Int (size)
        var copy_is_16bits = is16bits
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_is_16bits) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_directional_shadow_atlas_set_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a reflection probe and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `reflection_probe_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach this reflection probe to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    /// > Note: The equivalent node is ``ReflectionProbe``.
    /// 
    public static func reflectionProbeCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_reflection_probe_set_update_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_update_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3853670147)!
            }
            
        }
        
    }()
    
    /// Sets how often the reflection probe updates. Can either be once or every frame. See ``RenderingServer/ReflectionProbeUpdateMode`` for options.
    public static func reflectionProbeSetUpdateMode (probe: RID, mode: RenderingServer.ReflectionProbeUpdateMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_update_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_update_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_intensity: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_intensity")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the intensity of the reflection probe. Intensity modulates the strength of the reflection. Equivalent to ``ReflectionProbe/intensity``.
    public static func reflectionProbeSetIntensity (probe: RID, intensity: Double) {
        #if false
        
        var copy_intensity = intensity
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_intensity, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_intensity)
        
        #else
        
        var copy_intensity = intensity
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_intensity) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_intensity, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_ambient_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_ambient_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 184163074)!
            }
            
        }
        
    }()
    
    /// Sets the reflection probe's ambient light mode. Equivalent to ``ReflectionProbe/ambientMode``.
    public static func reflectionProbeSetAmbientMode (probe: RID, mode: RenderingServer.ReflectionProbeAmbientMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_ambient_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_ambient_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_ambient_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_ambient_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Sets the reflection probe's custom ambient light color. Equivalent to ``ReflectionProbe/ambientColor``.
    public static func reflectionProbeSetAmbientColor (probe: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_ambient_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_ambient_color, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_ambient_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_ambient_energy")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the reflection probe's custom ambient light energy. Equivalent to ``ReflectionProbe/ambientColorEnergy``.
    public static func reflectionProbeSetAmbientEnergy (probe: RID, energy: Double) {
        #if false
        
        var copy_energy = energy
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_ambient_energy, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_energy)
        
        #else
        
        var copy_energy = energy
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_energy) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_ambient_energy, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_max_distance: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_max_distance")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the max distance away from the probe an object can be before it is culled. Equivalent to ``ReflectionProbe/maxDistance``.
    public static func reflectionProbeSetMaxDistance (probe: RID, distance: Double) {
        #if false
        
        var copy_distance = distance
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_max_distance, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_distance)
        
        #else
        
        var copy_distance = distance
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_distance) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_max_distance, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3227306858)!
            }
            
        }
        
    }()
    
    /// Sets the size of the area that the reflection probe will capture. Equivalent to ``ReflectionProbe/size``.
    public static func reflectionProbeSetSize (probe: RID, size: Vector3) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_origin_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_origin_offset")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3227306858)!
            }
            
        }
        
    }()
    
    /// Sets the origin offset to be used when this reflection probe is in box project mode. Equivalent to ``ReflectionProbe/originOffset``.
    public static func reflectionProbeSetOriginOffset (probe: RID, offset: Vector3) {
        #if false
        
        var copy_offset = offset
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_origin_offset, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_offset)
        
        #else
        
        var copy_offset = offset
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_offset) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_origin_offset, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_as_interior: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_as_interior")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, reflections will ignore sky contribution. Equivalent to ``ReflectionProbe/interior``.
    public static func reflectionProbeSetAsInterior (probe: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_as_interior, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_as_interior, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_enable_box_projection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_enable_box_projection")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, uses box projection. This can make reflections look more correct in certain situations. Equivalent to ``ReflectionProbe/boxProjection``.
    public static func reflectionProbeSetEnableBoxProjection (probe: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_enable_box_projection, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_enable_box_projection, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_enable_shadows: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_enable_shadows")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, computes shadows in the reflection probe. This makes the reflection much slower to compute. Equivalent to ``ReflectionProbe/enableShadows``.
    public static func reflectionProbeSetEnableShadows (probe: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_enable_shadows, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_enable_shadows, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_cull_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the render cull mask for this reflection probe. Only instances with a matching cull mask will be rendered by this probe. Equivalent to ``ReflectionProbe/cullMask``.
    public static func reflectionProbeSetCullMask (probe: RID, layers: UInt32) {
        #if false
        
        var copy_layers: Int = Int (layers)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_layers)
        
        #else
        
        var copy_layers: Int = Int (layers)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_layers) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_resolution: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_resolution")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the resolution to use when rendering the specified reflection probe. The `resolution` is specified for each cubemap face: for instance, specifying `512` will allocate 6 faces of 512×512 each (plus mipmaps for roughness levels).
    public static func reflectionProbeSetResolution (probe: RID, resolution: Int32) {
        #if false
        
        var copy_resolution: Int = Int (resolution)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_resolution, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_resolution)
        
        #else
        
        var copy_resolution: Int = Int (resolution)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_resolution) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_resolution, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_reflection_probe_set_mesh_lod_threshold: GDExtensionMethodBindPtr = {
        let methodName = StringName ("reflection_probe_set_mesh_lod_threshold")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the mesh level of detail to use in the reflection probe rendering. Higher values will use less detailed versions of meshes that have LOD variations generated, which can improve performance. Equivalent to ``ReflectionProbe/meshLodThreshold``.
    public static func reflectionProbeSetMeshLodThreshold (probe: RID, pixels: Double) {
        #if false
        
        var copy_pixels = pixels
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_reflection_probe_set_mesh_lod_threshold, UnsafeMutableRawPointer (mutating: shared.handle), nil, &probe.content, &copy_pixels)
        
        #else
        
        var copy_pixels = pixels
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &probe.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_pixels) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_reflection_probe_set_mesh_lod_threshold, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a decal and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `decal_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach this decal to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    /// > Note: The equivalent node is ``Decal``.
    /// 
    public static func decalCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_decal_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_decal_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3227306858)!
            }
            
        }
        
    }()
    
    /// Sets the `size` of the decal specified by the `decal` RID. Equivalent to ``Decal/size``.
    public static func decalSetSize (decal: RID, size: Vector3) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_set_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_texture")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3953344054)!
            }
            
        }
        
    }()
    
    /// Sets the `texture` in the given texture `type` slot for the specified decal. Equivalent to ``Decal/setTexture(type:texture:)``.
    public static func decalSetTexture (decal: RID, type: RenderingServer.DecalTexture, texture: RID) {
        #if false
        
        var copy_type = Int64 (type.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_texture, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_type, &texture.content)
        
        #else
        
        var copy_type = Int64 (type.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_type) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_texture, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_set_emission_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_emission_energy")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the emission `energy` in the decal specified by the `decal` RID. Equivalent to ``Decal/emissionEnergy``.
    public static func decalSetEmissionEnergy (decal: RID, energy: Double) {
        #if false
        
        var copy_energy = energy
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_emission_energy, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_energy)
        
        #else
        
        var copy_energy = energy
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_energy) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_emission_energy, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_set_albedo_mix: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_albedo_mix")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the `albedoMix` in the decal specified by the `decal` RID. Equivalent to ``Decal/albedoMix``.
    public static func decalSetAlbedoMix (decal: RID, albedoMix: Double) {
        #if false
        
        var copy_albedo_mix = albedoMix
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_albedo_mix, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_albedo_mix)
        
        #else
        
        var copy_albedo_mix = albedoMix
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_albedo_mix) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_albedo_mix, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_set_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_modulate")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Sets the color multiplier in the decal specified by the `decal` RID to `color`. Equivalent to ``Decal/modulate``.
    public static func decalSetModulate (decal: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_modulate, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_modulate, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_set_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_cull_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the cull `mask` in the decal specified by the `decal` RID. Equivalent to ``Decal/cullMask``.
    public static func decalSetCullMask (decal: RID, mask: UInt32) {
        #if false
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_set_distance_fade: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_distance_fade")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2972769666)!
            }
            
        }
        
    }()
    
    /// Sets the distance fade parameters in the decal specified by the `decal` RID. Equivalent to ``Decal/distanceFadeEnabled``, ``Decal/distanceFadeBegin`` and ``Decal/distanceFadeLength``.
    public static func decalSetDistanceFade (decal: RID, enabled: Bool, begin: Double, length: Double) {
        #if false
        
        var copy_enabled = enabled
        var copy_begin = begin
        var copy_length = length
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_distance_fade, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_enabled, &copy_begin, &copy_length)
        
        #else
        
        var copy_enabled = enabled
        var copy_begin = begin
        var copy_length = length
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_begin) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_length) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_distance_fade, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_set_fade: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_fade")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2513314492)!
            }
            
        }
        
    }()
    
    /// Sets the upper fade (`above`) and lower fade (`below`) in the decal specified by the `decal` RID. Equivalent to ``Decal/upperFade`` and ``Decal/lowerFade``.
    public static func decalSetFade (decal: RID, above: Double, below: Double) {
        #if false
        
        var copy_above = above
        var copy_below = below
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_fade, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_above, &copy_below)
        
        #else
        
        var copy_above = above
        var copy_below = below
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_above) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_below) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_fade, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decal_set_normal_fade: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decal_set_normal_fade")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the normal `fade` in the decal specified by the `decal` RID. Equivalent to ``Decal/normalFade``.
    public static func decalSetNormalFade (decal: RID, fade: Double) {
        #if false
        
        var copy_fade = fade
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decal_set_normal_fade, UnsafeMutableRawPointer (mutating: shared.handle), nil, &decal.content, &copy_fade)
        
        #else
        
        var copy_fade = fade
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &decal.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_fade) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_decal_set_normal_fade, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decals_set_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decals_set_filter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3519875702)!
            }
            
        }
        
    }()
    
    /// Sets the texture `filter` mode to use when rendering decals. This parameter is global and cannot be set on a per-decal basis.
    public static func decalsSetFilter (_ filter: RenderingServer.DecalFilter) {
        #if false
        
        var copy_filter = Int64 (filter.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_decals_set_filter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_filter)
        
        #else
        
        var copy_filter = Int64 (filter.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_filter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_decals_set_filter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_gi_set_use_half_resolution: GDExtensionMethodBindPtr = {
        let methodName = StringName ("gi_set_use_half_resolution")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `halfResolution` is `true`, renders ``VoxelGI`` and SDFGI (``Environment/sdfgiEnabled``) buffers at halved resolution on each axis (e.g. 960×540 when the viewport size is 1920×1080). This improves performance significantly when VoxelGI or SDFGI is enabled, at the cost of artifacts that may be visible on polygon edges. The loss in quality becomes less noticeable as the viewport resolution increases. ``LightmapGI`` rendering is not affected by this setting. Equivalent to ``ProjectSettings/rendering/globalIllumination/gi/useHalfResolution``.
    public static func giSetUseHalfResolution (_ halfResolution: Bool) {
        #if false
        
        var copy_half_resolution = halfResolution
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_gi_set_use_half_resolution, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_half_resolution)
        
        #else
        
        var copy_half_resolution = halfResolution
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_half_resolution) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_gi_set_use_half_resolution, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new voxel-based global illumination object and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `voxel_gi_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent node is ``VoxelGI``.
    /// 
    public static func voxelGiCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_voxel_gi_allocate_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_allocate_data")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4108223027)!
            }
            
        }
        
    }()
    
    /// 
    public static func voxelGiAllocateData (voxelGi: RID, toCellXform: Transform3D, aabb: AABB, octreeSize: Vector3i, octreeCells: PackedByteArray, dataCells: PackedByteArray, distanceField: PackedByteArray, levelCounts: PackedInt32Array) {
        #if false
        
        var copy_to_cell_xform = toCellXform
        var copy_aabb = aabb
        var copy_octree_size = octreeSize
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_allocate_data, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_to_cell_xform, &copy_aabb, &copy_octree_size, &octreeCells.content, &dataCells.content, &distanceField.content, &levelCounts.content)
        
        #else
        
        var copy_to_cell_xform = toCellXform
        var copy_aabb = aabb
        var copy_octree_size = octreeSize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to_cell_xform) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_aabb) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_octree_size) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &octreeCells.content) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &dataCells.content) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &distanceField.content) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &levelCounts.content) { p7 in
                                        _args.append (p7)
        
                                        gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_allocate_data, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_get_octree_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_get_octree_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2607699645)!
            }
            
        }
        
    }()
    
    /// 
    public static func voxelGiGetOctreeSize (voxelGi: RID)-> Vector3i {
        var _result: Vector3i = Vector3i ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_get_octree_size, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &voxelGi.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_get_octree_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_get_octree_cells: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_get_octree_cells")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3348040486)!
            }
            
        }
        
    }()
    
    /// 
    public static func voxelGiGetOctreeCells (voxelGi: RID)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_get_octree_cells, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &voxelGi.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_get_octree_cells, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_get_data_cells: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_get_data_cells")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3348040486)!
            }
            
        }
        
    }()
    
    /// 
    public static func voxelGiGetDataCells (voxelGi: RID)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_get_data_cells, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &voxelGi.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_get_data_cells, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_get_distance_field: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_get_distance_field")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3348040486)!
            }
            
        }
        
    }()
    
    /// 
    public static func voxelGiGetDistanceField (voxelGi: RID)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_get_distance_field, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &voxelGi.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_get_distance_field, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_get_level_counts: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_get_level_counts")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 788230395)!
            }
            
        }
        
    }()
    
    /// 
    public static func voxelGiGetLevelCounts (voxelGi: RID)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_get_level_counts, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &voxelGi.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_get_level_counts, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_get_to_cell_xform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_get_to_cell_xform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1128465797)!
            }
            
        }
        
    }()
    
    /// 
    public static func voxelGiGetToCellXform (voxelGi: RID)-> Transform3D {
        var _result: Transform3D = Transform3D ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_get_to_cell_xform, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &voxelGi.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_get_to_cell_xform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_dynamic_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_dynamic_range")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the ``VoxelGIData/dynamicRange`` value to use on the specified `voxelGi`'s ``RID``.
    public static func voxelGiSetDynamicRange (voxelGi: RID, range: Double) {
        #if false
        
        var copy_range = range
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_dynamic_range, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_range)
        
        #else
        
        var copy_range = range
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_range) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_dynamic_range, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_propagation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_propagation")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the ``VoxelGIData/propagation`` value to use on the specified `voxelGi`'s ``RID``.
    public static func voxelGiSetPropagation (voxelGi: RID, amount: Double) {
        #if false
        
        var copy_amount = amount
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_propagation, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_amount)
        
        #else
        
        var copy_amount = amount
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_amount) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_propagation, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_energy")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the ``VoxelGIData/energy`` value to use on the specified `voxelGi`'s ``RID``.
    public static func voxelGiSetEnergy (voxelGi: RID, energy: Double) {
        #if false
        
        var copy_energy = energy
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_energy, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_energy)
        
        #else
        
        var copy_energy = energy
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_energy) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_energy, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_baked_exposure_normalization: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_baked_exposure_normalization")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Used to inform the renderer what exposure normalization value was used while baking the voxel gi. This value will be used and modulated at run time to ensure that the voxel gi maintains a consistent level of exposure even if the scene-wide exposure normalization is changed at run time. For more information see ``cameraAttributesSetExposure(cameraAttributes:multiplier:normalization:)``.
    public static func voxelGiSetBakedExposureNormalization (voxelGi: RID, bakedExposure: Double) {
        #if false
        
        var copy_baked_exposure = bakedExposure
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_baked_exposure_normalization, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_baked_exposure)
        
        #else
        
        var copy_baked_exposure = bakedExposure
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_baked_exposure) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_baked_exposure_normalization, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_bias")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the ``VoxelGIData/bias`` value to use on the specified `voxelGi`'s ``RID``.
    public static func voxelGiSetBias (voxelGi: RID, bias: Double) {
        #if false
        
        var copy_bias = bias
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_bias, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_bias)
        
        #else
        
        var copy_bias = bias
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bias) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_bias, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_normal_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_normal_bias")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the ``VoxelGIData/normalBias`` value to use on the specified `voxelGi`'s ``RID``.
    public static func voxelGiSetNormalBias (voxelGi: RID, bias: Double) {
        #if false
        
        var copy_bias = bias
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_normal_bias, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_bias)
        
        #else
        
        var copy_bias = bias
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bias) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_normal_bias, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_interior: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_interior")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Sets the ``VoxelGIData/interior`` value to use on the specified `voxelGi`'s ``RID``.
    public static func voxelGiSetInterior (voxelGi: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_interior, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_interior, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_use_two_bounces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_use_two_bounces")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Sets the ``VoxelGIData/useTwoBounces`` value to use on the specified `voxelGi`'s ``RID``.
    public static func voxelGiSetUseTwoBounces (voxelGi: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_use_two_bounces, UnsafeMutableRawPointer (mutating: shared.handle), nil, &voxelGi.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &voxelGi.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_use_two_bounces, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_voxel_gi_set_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("voxel_gi_set_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1538689978)!
            }
            
        }
        
    }()
    
    /// Sets the ``ProjectSettings/rendering/globalIllumination/voxelGi/quality`` value to use when rendering. This parameter is global and cannot be set on a per-VoxelGI basis.
    public static func voxelGiSetQuality (_ quality: RenderingServer.VoxelGIQuality) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_voxel_gi_set_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_voxel_gi_set_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new lightmap global illumination instance and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `lightmap_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent node is ``LightmapGI``.
    /// 
    public static func lightmapCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_lightmap_set_textures: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_set_textures")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2646464759)!
            }
            
        }
        
    }()
    
    /// Set the textures on the given `lightmap` GI instance to the texture array pointed to by the `light` RID. If the lightmap texture was baked with ``LightmapGI/directional`` set to `true`, then `usesSh` must also be `true`.
    public static func lightmapSetTextures (lightmap: RID, light: RID, usesSh: Bool) {
        #if false
        
        var copy_uses_sh = usesSh
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_set_textures, UnsafeMutableRawPointer (mutating: shared.handle), nil, &lightmap.content, &light.content, &copy_uses_sh)
        
        #else
        
        var copy_uses_sh = usesSh
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &light.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_uses_sh) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_set_textures, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_set_probe_bounds: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_set_probe_bounds")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3696536120)!
            }
            
        }
        
    }()
    
    /// 
    public static func lightmapSetProbeBounds (lightmap: RID, bounds: AABB) {
        #if false
        
        var copy_bounds = bounds
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_set_probe_bounds, UnsafeMutableRawPointer (mutating: shared.handle), nil, &lightmap.content, &copy_bounds)
        
        #else
        
        var copy_bounds = bounds
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bounds) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_set_probe_bounds, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_set_probe_interior: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_set_probe_interior")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// 
    public static func lightmapSetProbeInterior (lightmap: RID, interior: Bool) {
        #if false
        
        var copy_interior = interior
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_set_probe_interior, UnsafeMutableRawPointer (mutating: shared.handle), nil, &lightmap.content, &copy_interior)
        
        #else
        
        var copy_interior = interior
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_interior) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_set_probe_interior, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_set_probe_capture_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_set_probe_capture_data")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3217845880)!
            }
            
        }
        
    }()
    
    /// 
    public static func lightmapSetProbeCaptureData (lightmap: RID, points: PackedVector3Array, pointSh: PackedColorArray, tetrahedra: PackedInt32Array, bspTree: PackedInt32Array) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_set_probe_capture_data, UnsafeMutableRawPointer (mutating: shared.handle), nil, &lightmap.content, &points.content, &pointSh.content, &tetrahedra.content, &bspTree.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &points.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &pointSh.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &tetrahedra.content) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &bspTree.content) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_set_probe_capture_data, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_get_probe_capture_points: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_get_probe_capture_points")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 808965560)!
            }
            
        }
        
    }()
    
    /// 
    public static func lightmapGetProbeCapturePoints (lightmap: RID)-> PackedVector3Array {
        let _result: PackedVector3Array = PackedVector3Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_get_probe_capture_points, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &lightmap.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_get_probe_capture_points, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_get_probe_capture_sh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_get_probe_capture_sh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1569415609)!
            }
            
        }
        
    }()
    
    /// 
    public static func lightmapGetProbeCaptureSh (lightmap: RID)-> PackedColorArray {
        let _result: PackedColorArray = PackedColorArray ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_get_probe_capture_sh, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &lightmap.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_get_probe_capture_sh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_get_probe_capture_tetrahedra: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_get_probe_capture_tetrahedra")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 788230395)!
            }
            
        }
        
    }()
    
    /// 
    public static func lightmapGetProbeCaptureTetrahedra (lightmap: RID)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_get_probe_capture_tetrahedra, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &lightmap.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_get_probe_capture_tetrahedra, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_get_probe_capture_bsp_tree: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_get_probe_capture_bsp_tree")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 788230395)!
            }
            
        }
        
    }()
    
    /// 
    public static func lightmapGetProbeCaptureBspTree (lightmap: RID)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_get_probe_capture_bsp_tree, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &lightmap.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_get_probe_capture_bsp_tree, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_set_baked_exposure_normalization: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_set_baked_exposure_normalization")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Used to inform the renderer what exposure normalization value was used while baking the lightmap. This value will be used and modulated at run time to ensure that the lightmap maintains a consistent level of exposure even if the scene-wide exposure normalization is changed at run time. For more information see ``cameraAttributesSetExposure(cameraAttributes:multiplier:normalization:)``.
    public static func lightmapSetBakedExposureNormalization (lightmap: RID, bakedExposure: Double) {
        #if false
        
        var copy_baked_exposure = bakedExposure
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_set_baked_exposure_normalization, UnsafeMutableRawPointer (mutating: shared.handle), nil, &lightmap.content, &copy_baked_exposure)
        
        #else
        
        var copy_baked_exposure = bakedExposure
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &lightmap.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_baked_exposure) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_set_baked_exposure_normalization, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_lightmap_set_probe_capture_update_speed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("lightmap_set_probe_capture_update_speed")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    /// 
    public static func lightmapSetProbeCaptureUpdateSpeed (_ speed: Double) {
        #if false
        
        var copy_speed = speed
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_lightmap_set_probe_capture_update_speed, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_speed)
        
        #else
        
        var copy_speed = speed
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_speed) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_lightmap_set_probe_capture_update_speed, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_particles_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a GPU-based particle system and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `particles_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach these particles to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    /// > Note: The equivalent nodes are ``GPUParticles2D`` and ``GPUParticles3D``.
    /// 
    /// > Note: All `particles_*` methods only apply to GPU-based particles, not CPU-based particles. ``CPUParticles2D`` and ``CPUParticles3D`` do not have equivalent RenderingServer functions available, as these use ``MultiMeshInstance2D`` and ``MultiMeshInstance3D`` under the hood (see `multimesh_*` methods).
    /// 
    public static func particlesCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_particles_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_particles_set_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3492270028)!
            }
            
        }
        
    }()
    
    /// Sets whether the GPU particles specified by the `particles` RID should be rendered in 2D or 3D according to `mode`.
    public static func particlesSetMode (particles: RID, mode: RenderingServer.ParticlesMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_emitting: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_emitting")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, particles will emit over time. Setting to false does not reset the particles, but only stops their emission. Equivalent to ``GPUParticles3D/emitting``.
    public static func particlesSetEmitting (particles: RID, emitting: Bool) {
        #if false
        
        var copy_emitting = emitting
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_emitting, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_emitting)
        
        #else
        
        var copy_emitting = emitting
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_emitting) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_emitting, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_get_emitting: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_get_emitting")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Returns `true` if particles are currently set to emitting.
    public static func particlesGetEmitting (particles: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_get_emitting, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &particles.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_particles_get_emitting, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_amount: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_amount")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the number of particles to be drawn and allocates the memory for them. Equivalent to ``GPUParticles3D/amount``.
    public static func particlesSetAmount (particles: RID, amount: Int32) {
        #if false
        
        var copy_amount: Int = Int (amount)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_amount, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_amount)
        
        #else
        
        var copy_amount: Int = Int (amount)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_amount) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_amount, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_amount_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_amount_ratio")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the amount ratio for particles to be emitted. Equivalent to ``GPUParticles3D/amountRatio``.
    public static func particlesSetAmountRatio (particles: RID, ratio: Double) {
        #if false
        
        var copy_ratio = ratio
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_amount_ratio, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_ratio)
        
        #else
        
        var copy_ratio = ratio
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_ratio) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_amount_ratio, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_lifetime: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_lifetime")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the lifetime of each particle in the system. Equivalent to ``GPUParticles3D/lifetime``.
    public static func particlesSetLifetime (particles: RID, lifetime: Double) {
        #if false
        
        var copy_lifetime = lifetime
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_lifetime, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_lifetime)
        
        #else
        
        var copy_lifetime = lifetime
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_lifetime) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_lifetime, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_one_shot: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_one_shot")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, particles will emit once and then stop. Equivalent to ``GPUParticles3D/oneShot``.
    public static func particlesSetOneShot (particles: RID, oneShot: Bool) {
        #if false
        
        var copy_one_shot = oneShot
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_one_shot, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_one_shot)
        
        #else
        
        var copy_one_shot = oneShot
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_one_shot) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_one_shot, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_pre_process_time: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_pre_process_time")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the preprocess time for the particles' animation. This lets you delay starting an animation until after the particles have begun emitting. Equivalent to ``GPUParticles3D/preprocess``.
    public static func particlesSetPreProcessTime (particles: RID, time: Double) {
        #if false
        
        var copy_time = time
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_pre_process_time, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_time)
        
        #else
        
        var copy_time = time
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_time) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_pre_process_time, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_explosiveness_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_explosiveness_ratio")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the explosiveness ratio. Equivalent to ``GPUParticles3D/explosiveness``.
    public static func particlesSetExplosivenessRatio (particles: RID, ratio: Double) {
        #if false
        
        var copy_ratio = ratio
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_explosiveness_ratio, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_ratio)
        
        #else
        
        var copy_ratio = ratio
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_ratio) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_explosiveness_ratio, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_randomness_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_randomness_ratio")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the emission randomness ratio. This randomizes the emission of particles within their phase. Equivalent to ``GPUParticles3D/randomness``.
    public static func particlesSetRandomnessRatio (particles: RID, ratio: Double) {
        #if false
        
        var copy_ratio = ratio
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_randomness_ratio, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_ratio)
        
        #else
        
        var copy_ratio = ratio
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_ratio) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_randomness_ratio, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_interp_to_end: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_interp_to_end")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the value that informs a ``ParticleProcessMaterial`` to rush all particles towards the end of their lifetime.
    public static func particlesSetInterpToEnd (particles: RID, factor: Double) {
        #if false
        
        var copy_factor = factor
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_interp_to_end, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_factor)
        
        #else
        
        var copy_factor = factor
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_factor) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_interp_to_end, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_emitter_velocity: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_emitter_velocity")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3227306858)!
            }
            
        }
        
    }()
    
    /// Sets the velocity of a particle node, that will be used by ``ParticleProcessMaterial/inheritVelocityRatio``.
    public static func particlesSetEmitterVelocity (particles: RID, velocity: Vector3) {
        #if false
        
        var copy_velocity = velocity
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_emitter_velocity, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_velocity)
        
        #else
        
        var copy_velocity = velocity
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_velocity) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_emitter_velocity, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_custom_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_custom_aabb")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3696536120)!
            }
            
        }
        
    }()
    
    /// Sets a custom axis-aligned bounding box for the particle system. Equivalent to ``GPUParticles3D/visibilityAabb``.
    public static func particlesSetCustomAabb (particles: RID, aabb: AABB) {
        #if false
        
        var copy_aabb = aabb
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_custom_aabb, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_aabb)
        
        #else
        
        var copy_aabb = aabb
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_aabb) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_custom_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_speed_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_speed_scale")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the speed scale of the particle system. Equivalent to ``GPUParticles3D/speedScale``.
    public static func particlesSetSpeedScale (particles: RID, scale: Double) {
        #if false
        
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_speed_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_scale)
        
        #else
        
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_scale) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_speed_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_use_local_coordinates: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_use_local_coordinates")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, particles use local coordinates. If `false` they use global coordinates. Equivalent to ``GPUParticles3D/localCoords``.
    public static func particlesSetUseLocalCoordinates (particles: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_use_local_coordinates, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_use_local_coordinates, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_process_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_process_material")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the material for processing the particles.
    /// 
    /// > Note: This is not the material used to draw the materials. Equivalent to ``GPUParticles3D/processMaterial``.
    /// 
    public static func particlesSetProcessMaterial (particles: RID, material: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_process_material, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &material.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &material.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_process_material, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_fixed_fps: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_fixed_fps")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the frame rate that the particle system rendering will be fixed to. Equivalent to ``GPUParticles3D/fixedFps``.
    public static func particlesSetFixedFps (particles: RID, fps: Int32) {
        #if false
        
        var copy_fps: Int = Int (fps)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_fixed_fps, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_fps)
        
        #else
        
        var copy_fps: Int = Int (fps)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_fps) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_fixed_fps, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_interpolate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_interpolate")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// 
    public static func particlesSetInterpolate (particles: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_interpolate, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_interpolate, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_fractional_delta: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_fractional_delta")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, uses fractional delta which smooths the movement of the particles. Equivalent to ``GPUParticles3D/fractDelta``.
    public static func particlesSetFractionalDelta (particles: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_fractional_delta, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_fractional_delta, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_collision_base_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_collision_base_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// 
    public static func particlesSetCollisionBaseSize (particles: RID, size: Double) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_collision_base_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_collision_base_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_transform_align: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_transform_align")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3264971368)!
            }
            
        }
        
    }()
    
    /// 
    public static func particlesSetTransformAlign (particles: RID, align: RenderingServer.ParticlesTransformAlign) {
        #if false
        
        var copy_align = Int64 (align.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_transform_align, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_align)
        
        #else
        
        var copy_align = Int64 (align.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_align) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_transform_align, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_trails: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_trails")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2010054925)!
            }
            
        }
        
    }()
    
    /// If `enable` is `true`, enables trails for the `particles` with the specified `lengthSec` in seconds. Equivalent to ``GPUParticles3D/trailEnabled`` and ``GPUParticles3D/trailLifetime``.
    public static func particlesSetTrails (particles: RID, enable: Bool, lengthSec: Double) {
        #if false
        
        var copy_enable = enable
        var copy_length_sec = lengthSec
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_trails, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_enable, &copy_length_sec)
        
        #else
        
        var copy_enable = enable
        var copy_length_sec = lengthSec
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_length_sec) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_trails, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_trail_bind_poses: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_trail_bind_poses")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 684822712)!
            }
            
        }
        
    }()
    
    /// 
    public static func particlesSetTrailBindPoses (particles: RID, bindPoses: VariantCollection<Transform3D>) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_trail_bind_poses, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &bindPoses.array.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &bindPoses.array.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_trail_bind_poses, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_is_inactive: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_is_inactive")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Returns `true` if particles are not emitting and particles are set to inactive.
    public static func particlesIsInactive (particles: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_is_inactive, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &particles.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_particles_is_inactive, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_particles_request_process: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_request_process")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Add particle system to list of particle systems that need to be updated. Update will take place on the next frame, or on the next call to ``instancesCullAabb(_:scenario:)``, ``instancesCullConvex(_:scenario:)``, or ``instancesCullRay(from:to:scenario:)``.
    public static func particlesRequestProcess (particles: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_request_process, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_particles_request_process, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_particles_restart: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_restart")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Reset the particles on the next update. Equivalent to ``GPUParticles3D/restart()``.
    public static func particlesRestart (particles: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_restart, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_particles_restart, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_subemitter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_subemitter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// 
    public static func particlesSetSubemitter (particles: RID, subemitterParticles: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_subemitter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &subemitterParticles.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &subemitterParticles.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_subemitter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_emit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_emit")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4043136117)!
            }
            
        }
        
    }()
    
    /// Manually emits particles from the `particles` instance.
    public static func particlesEmit (particles: RID, transform: Transform3D, velocity: Vector3, color: Color, custom: Color, emitFlags: UInt32) {
        #if false
        
        var copy_transform = transform
        var copy_velocity = velocity
        var copy_color = color
        var copy_custom = custom
        var copy_emit_flags: Int = Int (emitFlags)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_emit, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_transform, &copy_velocity, &copy_color, &copy_custom, &copy_emit_flags)
        
        #else
        
        var copy_transform = transform
        var copy_velocity = velocity
        var copy_color = color
        var copy_custom = custom
        var copy_emit_flags: Int = Int (emitFlags)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_velocity) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_color) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_custom) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_emit_flags) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_particles_emit, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_draw_order: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_draw_order")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 935028487)!
            }
            
        }
        
    }()
    
    /// Sets the draw order of the particles to one of the named enums from ``RenderingServer/ParticlesDrawOrder``. See ``RenderingServer/ParticlesDrawOrder`` for options. Equivalent to ``GPUParticles3D/drawOrder``.
    public static func particlesSetDrawOrder (particles: RID, order: RenderingServer.ParticlesDrawOrder) {
        #if false
        
        var copy_order = Int64 (order.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_draw_order, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_order)
        
        #else
        
        var copy_order = Int64 (order.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_order) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_draw_order, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_draw_passes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_draw_passes")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the number of draw passes to use. Equivalent to ``GPUParticles3D/drawPasses``.
    public static func particlesSetDrawPasses (particles: RID, count: Int32) {
        #if false
        
        var copy_count: Int = Int (count)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_draw_passes, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_count)
        
        #else
        
        var copy_count: Int = Int (count)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_count) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_draw_passes, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_draw_pass_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_draw_pass_mesh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2310537182)!
            }
            
        }
        
    }()
    
    /// Sets the mesh to be used for the specified draw pass. Equivalent to ``GPUParticles3D/drawPass1``, ``GPUParticles3D/drawPass2``, ``GPUParticles3D/drawPass3``, and ``GPUParticles3D/drawPass4``.
    public static func particlesSetDrawPassMesh (particles: RID, pass: Int32, mesh: RID) {
        #if false
        
        var copy_pass: Int = Int (pass)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_draw_pass_mesh, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_pass, &mesh.content)
        
        #else
        
        var copy_pass: Int = Int (pass)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_pass) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &mesh.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_draw_pass_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_get_current_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_get_current_aabb")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3952830260)!
            }
            
        }
        
    }()
    
    /// Calculates and returns the axis-aligned bounding box that contains all the particles. Equivalent to ``GPUParticles3D/captureAabb()``.
    public static func particlesGetCurrentAabb (particles: RID)-> AABB {
        var _result: AABB = AABB ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_get_current_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &particles.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_particles_get_current_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_particles_set_emission_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_set_emission_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3935195649)!
            }
            
        }
        
    }()
    
    /// Sets the ``Transform3D`` that will be used by the particles when they first emit.
    public static func particlesSetEmissionTransform (particles: RID, transform: Transform3D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_set_emission_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particles.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particles.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_set_emission_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new 3D GPU particle collision or attractor and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID can be used in most `particles_collision_*` RenderingServer functions.
    /// 
    /// > Note: The equivalent nodes are ``GPUParticlesCollision3D`` and ``GPUParticlesAttractor3D``.
    /// 
    public static func particlesCollisionCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_particles_collision_set_collision_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_collision_type")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1497044930)!
            }
            
        }
        
    }()
    
    /// Sets the collision or attractor shape `type` for the 3D GPU particles collision or attractor specified by the `particlesCollision` RID.
    public static func particlesCollisionSetCollisionType (particlesCollision: RID, type: RenderingServer.ParticlesCollisionType) {
        #if false
        
        var copy_type = Int64 (type.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_collision_type, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &copy_type)
        
        #else
        
        var copy_type = Int64 (type.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_type) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_collision_type, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_set_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_cull_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the cull `mask` for the 3D GPU particles collision or attractor specified by the `particlesCollision` RID. Equivalent to ``GPUParticlesCollision3D/cullMask`` or ``GPUParticlesAttractor3D/cullMask`` depending on the `particlesCollision` type.
    public static func particlesCollisionSetCullMask (particlesCollision: RID, mask: UInt32) {
        #if false
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_set_sphere_radius: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_sphere_radius")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the `radius` for the 3D GPU particles sphere collision or attractor specified by the `particlesCollision` RID. Equivalent to ``GPUParticlesCollisionSphere3D/radius`` or ``GPUParticlesAttractorSphere3D/radius`` depending on the `particlesCollision` type.
    public static func particlesCollisionSetSphereRadius (particlesCollision: RID, radius: Double) {
        #if false
        
        var copy_radius = radius
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_sphere_radius, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &copy_radius)
        
        #else
        
        var copy_radius = radius
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_radius) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_sphere_radius, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_set_box_extents: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_box_extents")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3227306858)!
            }
            
        }
        
    }()
    
    /// Sets the `extents` for the 3D GPU particles collision by the `particlesCollision` RID. Equivalent to ``GPUParticlesCollisionBox3D/size``, ``GPUParticlesCollisionSDF3D/size``, ``GPUParticlesCollisionHeightField3D/size``, ``GPUParticlesAttractorBox3D/size`` or ``GPUParticlesAttractorVectorField3D/size`` depending on the `particlesCollision` type.
    public static func particlesCollisionSetBoxExtents (particlesCollision: RID, extents: Vector3) {
        #if false
        
        var copy_extents = extents
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_box_extents, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &copy_extents)
        
        #else
        
        var copy_extents = extents
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_extents) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_box_extents, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_set_attractor_strength: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_attractor_strength")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the `strength` for the 3D GPU particles attractor specified by the `particlesCollision` RID. Only used for attractors, not colliders. Equivalent to ``GPUParticlesAttractor3D/strength``.
    public static func particlesCollisionSetAttractorStrength (particlesCollision: RID, strength: Double) {
        #if false
        
        var copy_strength = strength
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_attractor_strength, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &copy_strength)
        
        #else
        
        var copy_strength = strength
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_strength) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_attractor_strength, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_set_attractor_directionality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_attractor_directionality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the directionality `amount` for the 3D GPU particles attractor specified by the `particlesCollision` RID. Only used for attractors, not colliders. Equivalent to ``GPUParticlesAttractor3D/directionality``.
    public static func particlesCollisionSetAttractorDirectionality (particlesCollision: RID, amount: Double) {
        #if false
        
        var copy_amount = amount
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_attractor_directionality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &copy_amount)
        
        #else
        
        var copy_amount = amount
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_amount) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_attractor_directionality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_set_attractor_attenuation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_attractor_attenuation")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the attenuation `curve` for the 3D GPU particles attractor specified by the `particlesCollision` RID. Only used for attractors, not colliders. Equivalent to ``GPUParticlesAttractor3D/attenuation``.
    public static func particlesCollisionSetAttractorAttenuation (particlesCollision: RID, curve: Double) {
        #if false
        
        var copy_curve = curve
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_attractor_attenuation, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &copy_curve)
        
        #else
        
        var copy_curve = curve
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_curve) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_attractor_attenuation, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_set_field_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_field_texture")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the signed distance field `texture` for the 3D GPU particles collision specified by the `particlesCollision` RID. Equivalent to ``GPUParticlesCollisionSDF3D/texture`` or ``GPUParticlesAttractorVectorField3D/texture`` depending on the `particlesCollision` type.
    public static func particlesCollisionSetFieldTexture (particlesCollision: RID, texture: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_field_texture, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &texture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &texture.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_field_texture, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_height_field_update: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_height_field_update")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Requests an update for the 3D GPU particle collision heightfield. This may be automatically called by the 3D GPU particle collision heightfield depending on its ``GPUParticlesCollisionHeightField3D/updateMode``.
    public static func particlesCollisionHeightFieldUpdate (particlesCollision: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_height_field_update, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_height_field_update, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_particles_collision_set_height_field_resolution: GDExtensionMethodBindPtr = {
        let methodName = StringName ("particles_collision_set_height_field_resolution")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 962977297)!
            }
            
        }
        
    }()
    
    /// Sets the heightmap `resolution` for the 3D GPU particles heightfield collision specified by the `particlesCollision` RID. Equivalent to ``GPUParticlesCollisionHeightField3D/resolution``.
    public static func particlesCollisionSetHeightFieldResolution (particlesCollision: RID, resolution: RenderingServer.ParticlesCollisionHeightfieldResolution) {
        #if false
        
        var copy_resolution = Int64 (resolution.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_particles_collision_set_height_field_resolution, UnsafeMutableRawPointer (mutating: shared.handle), nil, &particlesCollision.content, &copy_resolution)
        
        #else
        
        var copy_resolution = Int64 (resolution.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &particlesCollision.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_resolution) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_particles_collision_set_height_field_resolution, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_fog_volume_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("fog_volume_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new fog volume and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `fog_volume_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent node is ``FogVolume``.
    /// 
    public static func fogVolumeCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_fog_volume_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_fog_volume_set_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("fog_volume_set_shape")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3818703106)!
            }
            
        }
        
    }()
    
    /// Sets the shape of the fog volume to either ``RenderingServer/FogVolumeShape/ellipsoid``, ``RenderingServer/FogVolumeShape/cone``, ``RenderingServer/FogVolumeShape/cylinder``, ``RenderingServer/FogVolumeShape/box`` or ``RenderingServer/FogVolumeShape/world``.
    public static func fogVolumeSetShape (fogVolume: RID, shape: RenderingServer.FogVolumeShape) {
        #if false
        
        var copy_shape = Int64 (shape.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_fog_volume_set_shape, UnsafeMutableRawPointer (mutating: shared.handle), nil, &fogVolume.content, &copy_shape)
        
        #else
        
        var copy_shape = Int64 (shape.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fogVolume.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_shape) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_fog_volume_set_shape, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_fog_volume_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("fog_volume_set_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3227306858)!
            }
            
        }
        
    }()
    
    /// Sets the size of the fog volume when shape is ``RenderingServer/FogVolumeShape/ellipsoid``, ``RenderingServer/FogVolumeShape/cone``, ``RenderingServer/FogVolumeShape/cylinder`` or ``RenderingServer/FogVolumeShape/box``.
    public static func fogVolumeSetSize (fogVolume: RID, size: Vector3) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_fog_volume_set_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &fogVolume.content, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fogVolume.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_fog_volume_set_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_fog_volume_set_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("fog_volume_set_material")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the ``Material`` of the fog volume. Can be either a ``FogMaterial`` or a custom ``ShaderMaterial``.
    public static func fogVolumeSetMaterial (fogVolume: RID, material: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_fog_volume_set_material, UnsafeMutableRawPointer (mutating: shared.handle), nil, &fogVolume.content, &material.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fogVolume.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &material.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_fog_volume_set_material, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_visibility_notifier_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("visibility_notifier_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new 3D visibility notifier object and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `visibility_notifier_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// To place in a scene, attach this mesh to an instance using ``instanceSetBase(instance:base:)`` using the returned RID.
    /// 
    /// > Note: The equivalent node is ``VisibleOnScreenNotifier3D``.
    /// 
    public static func visibilityNotifierCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_visibility_notifier_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_visibility_notifier_set_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("visibility_notifier_set_aabb")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3696536120)!
            }
            
        }
        
    }()
    
    /// 
    public static func visibilityNotifierSetAabb (notifier: RID, aabb: AABB) {
        #if false
        
        var copy_aabb = aabb
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_visibility_notifier_set_aabb, UnsafeMutableRawPointer (mutating: shared.handle), nil, &notifier.content, &copy_aabb)
        
        #else
        
        var copy_aabb = aabb
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &notifier.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_aabb) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_visibility_notifier_set_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_visibility_notifier_set_callbacks: GDExtensionMethodBindPtr = {
        let methodName = StringName ("visibility_notifier_set_callbacks")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2689735388)!
            }
            
        }
        
    }()
    
    /// 
    public static func visibilityNotifierSetCallbacks (notifier: RID, enterCallable: Callable, exitCallable: Callable) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_visibility_notifier_set_callbacks, UnsafeMutableRawPointer (mutating: shared.handle), nil, &notifier.content, &enterCallable.content, &exitCallable.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &notifier.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &enterCallable.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &exitCallable.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_visibility_notifier_set_callbacks, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_occluder_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("occluder_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates an occluder instance and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `occluder_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``Occluder3D`` (not to be confused with the ``OccluderInstance3D`` node).
    /// 
    public static func occluderCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_occluder_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_occluder_set_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("occluder_set_mesh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3854404263)!
            }
            
        }
        
    }()
    
    /// Sets the mesh data for the given occluder RID, which controls the shape of the occlusion culling that will be performed.
    public static func occluderSetMesh (occluder: RID, vertices: PackedVector3Array, indices: PackedInt32Array) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_occluder_set_mesh, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluder.content, &vertices.content, &indices.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluder.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &vertices.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &indices.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_occluder_set_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a 3D camera and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `camera_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent node is ``Camera3D``.
    /// 
    public static func cameraCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_camera_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_camera_set_perspective: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_set_perspective")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 157498339)!
            }
            
        }
        
    }()
    
    /// Sets camera to use perspective projection. Objects on the screen becomes smaller when they are far away.
    public static func cameraSetPerspective (camera: RID, fovyDegrees: Double, zNear: Double, zFar: Double) {
        #if false
        
        var copy_fovy_degrees = fovyDegrees
        var copy_z_near = zNear
        var copy_z_far = zFar
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_set_perspective, UnsafeMutableRawPointer (mutating: shared.handle), nil, &camera.content, &copy_fovy_degrees, &copy_z_near, &copy_z_far)
        
        #else
        
        var copy_fovy_degrees = fovyDegrees
        var copy_z_near = zNear
        var copy_z_far = zFar
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &camera.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_fovy_degrees) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_z_near) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_z_far) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_camera_set_perspective, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_set_orthogonal: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_set_orthogonal")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 157498339)!
            }
            
        }
        
    }()
    
    /// Sets camera to use orthogonal projection, also known as orthographic projection. Objects remain the same size on the screen no matter how far away they are.
    public static func cameraSetOrthogonal (camera: RID, size: Double, zNear: Double, zFar: Double) {
        #if false
        
        var copy_size = size
        var copy_z_near = zNear
        var copy_z_far = zFar
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_set_orthogonal, UnsafeMutableRawPointer (mutating: shared.handle), nil, &camera.content, &copy_size, &copy_z_near, &copy_z_far)
        
        #else
        
        var copy_size = size
        var copy_z_near = zNear
        var copy_z_far = zFar
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &camera.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_z_near) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_z_far) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_camera_set_orthogonal, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_set_frustum: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_set_frustum")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1889878953)!
            }
            
        }
        
    }()
    
    /// Sets camera to use frustum projection. This mode allows adjusting the `offset` argument to create "tilted frustum" effects.
    public static func cameraSetFrustum (camera: RID, size: Double, offset: Vector2, zNear: Double, zFar: Double) {
        #if false
        
        var copy_size = size
        var copy_offset = offset
        var copy_z_near = zNear
        var copy_z_far = zFar
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_set_frustum, UnsafeMutableRawPointer (mutating: shared.handle), nil, &camera.content, &copy_size, &copy_offset, &copy_z_near, &copy_z_far)
        
        #else
        
        var copy_size = size
        var copy_offset = offset
        var copy_z_near = zNear
        var copy_z_far = zFar
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &camera.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_offset) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_z_near) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_z_far) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_camera_set_frustum, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_set_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3935195649)!
            }
            
        }
        
    }()
    
    /// Sets ``Transform3D`` of camera.
    public static func cameraSetTransform (camera: RID, transform: Transform3D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &camera.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &camera.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_camera_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_set_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_set_cull_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the cull mask associated with this camera. The cull mask describes which 3D layers are rendered by this camera. Equivalent to ``Camera3D/cullMask``.
    public static func cameraSetCullMask (camera: RID, layers: UInt32) {
        #if false
        
        var copy_layers: Int = Int (layers)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &camera.content, &copy_layers)
        
        #else
        
        var copy_layers: Int = Int (layers)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &camera.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_layers) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_camera_set_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_set_environment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_set_environment")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the environment used by this camera. Equivalent to ``Camera3D/environment``.
    public static func cameraSetEnvironment (camera: RID, env: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_set_environment, UnsafeMutableRawPointer (mutating: shared.handle), nil, &camera.content, &env.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &camera.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &env.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_camera_set_environment, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_set_camera_attributes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_set_camera_attributes")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the camera_attributes created with ``cameraAttributesCreate()`` to the given camera.
    public static func cameraSetCameraAttributes (camera: RID, effects: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_set_camera_attributes, UnsafeMutableRawPointer (mutating: shared.handle), nil, &camera.content, &effects.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &camera.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &effects.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_camera_set_camera_attributes, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_set_use_vertical_aspect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_set_use_vertical_aspect")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, preserves the horizontal aspect ratio which is equivalent to ``Camera3D/KeepAspect/keepWidth``. If `false`, preserves the vertical aspect ratio which is equivalent to ``Camera3D/KeepAspect/keepHeight``.
    public static func cameraSetUseVerticalAspect (camera: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_set_use_vertical_aspect, UnsafeMutableRawPointer (mutating: shared.handle), nil, &camera.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &camera.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_camera_set_use_vertical_aspect, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates an empty viewport and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `viewport_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent node is ``Viewport``.
    /// 
    public static func viewportCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_viewport_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_viewport_set_use_xr: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_use_xr")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, the viewport uses augmented or virtual reality technologies. See ``XRInterface``.
    public static func viewportSetUseXr (viewport: RID, useXr: Bool) {
        #if false
        
        var copy_use_xr = useXr
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_use_xr, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_use_xr)
        
        #else
        
        var copy_use_xr = useXr
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_use_xr) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_use_xr, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4288446313)!
            }
            
        }
        
    }()
    
    /// Sets the viewport's width and height in pixels.
    public static func viewportSetSize (viewport: RID, width: Int32, height: Int32) {
        #if false
        
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_width, &copy_height)
        
        #else
        
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_height) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_active")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, sets the viewport active, else sets it inactive.
    public static func viewportSetActive (viewport: RID, active: Bool) {
        #if false
        
        var copy_active = active
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_active, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_active)
        
        #else
        
        var copy_active = active
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_active) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_active, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_parent_viewport: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_parent_viewport")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the viewport's parent to the viewport specified by the `parentViewport` RID.
    public static func viewportSetParentViewport (_ viewport: RID, parentViewport: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_parent_viewport, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &parentViewport.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &parentViewport.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_parent_viewport, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_attach_to_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_attach_to_screen")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1062245816)!
            }
            
        }
        
    }()
    
    /// Copies the viewport to a region of the screen specified by `rect`. If ``viewportSetRenderDirectToScreen(viewport:enabled:)`` is `true`, then the viewport does not use a framebuffer and the contents of the viewport are rendered directly to screen. However, note that the root viewport is drawn last, therefore it will draw over the screen. Accordingly, you must set the root viewport to an area that does not cover the area that you have attached this viewport to.
    /// 
    /// For example, you can set the root viewport to not render at all with the following code:
    /// 
    /// FIXME: The method seems to be non-existent.
    /// 
    /// Using this can result in significant optimization, especially on lower-end devices. However, it comes at the cost of having to manage your viewports manually. For further optimization, see ``viewportSetRenderDirectToScreen(viewport:enabled:)``.
    /// 
    public static func viewportAttachToScreen (viewport: RID, rect: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), screen: Int32 = 0) {
        #if false
        
        var copy_rect = rect
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_attach_to_screen, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_rect, &copy_screen)
        
        #else
        
        var copy_rect = rect
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_screen) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_viewport_attach_to_screen, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_render_direct_to_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_render_direct_to_screen")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, render the contents of the viewport directly to screen. This allows a low-level optimization where you can skip drawing a viewport to the root viewport. While this optimization can result in a significant increase in speed (especially on older devices), it comes at a cost of usability. When this is enabled, you cannot read from the viewport or from the screen_texture. You also lose the benefit of certain window settings, such as the various stretch modes. Another consequence to be aware of is that in 2D the rendering happens in window coordinates, so if you have a viewport that is double the size of the window, and you set this, then only the portion that fits within the window will be drawn, no automatic scaling is possible, even if your game scene is significantly larger than the window size.
    public static func viewportSetRenderDirectToScreen (viewport: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_render_direct_to_screen, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_render_direct_to_screen, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_canvas_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_canvas_cull_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the rendering mask associated with this ``Viewport``. Only ``CanvasItem`` nodes with a matching rendering visibility layer will be rendered by this ``Viewport``.
    public static func viewportSetCanvasCullMask (viewport: RID, canvasCullMask: UInt32) {
        #if false
        
        var copy_canvas_cull_mask: Int = Int (canvasCullMask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_canvas_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_canvas_cull_mask)
        
        #else
        
        var copy_canvas_cull_mask: Int = Int (canvasCullMask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_canvas_cull_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_canvas_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_scaling_3d_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_scaling_3d_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2386524376)!
            }
            
        }
        
    }()
    
    /// Sets the 3D resolution scaling mode. Bilinear scaling renders at different resolution to either undersample or supersample the viewport. FidelityFX Super Resolution 1.0, abbreviated to FSR, is an upscaling technology that produces high quality images at fast framerates by using a spatially aware upscaling algorithm. FSR is slightly more expensive than bilinear, but it produces significantly higher image quality. FSR should be used where possible.
    public static func viewportSetScaling3dMode (viewport: RID, scaling3dMode: RenderingServer.ViewportScaling3DMode) {
        #if false
        
        var copy_scaling_3d_mode = Int64 (scaling3dMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_scaling_3d_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_scaling_3d_mode)
        
        #else
        
        var copy_scaling_3d_mode = Int64 (scaling3dMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_scaling_3d_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_scaling_3d_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_scaling_3d_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_scaling_3d_scale")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Scales the 3D render buffer based on the viewport size uses an image filter specified in ``RenderingServer/ViewportScaling3DMode`` to scale the output image to the full viewport size. Values lower than `1.0` can be used to speed up 3D rendering at the cost of quality (undersampling). Values greater than `1.0` are only valid for bilinear mode and can be used to improve 3D rendering quality at a high performance cost (supersampling). See also ``RenderingServer/ViewportMSAA`` for multi-sample antialiasing, which is significantly cheaper but only smoothens the edges of polygons.
    /// 
    /// When using FSR upscaling, AMD recommends exposing the following values as preset options to users "Ultra Quality: 0.77", "Quality: 0.67", "Balanced: 0.59", "Performance: 0.5" instead of exposing the entire scale.
    /// 
    public static func viewportSetScaling3dScale (viewport: RID, scale: Double) {
        #if false
        
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_scaling_3d_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_scale)
        
        #else
        
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_scale) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_scaling_3d_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_fsr_sharpness: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_fsr_sharpness")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Determines how sharp the upscaled image will be when using the FSR upscaling mode. Sharpness halves with every whole number. Values go from 0.0 (sharpest) to 2.0. Values above 2.0 won't make a visible difference.
    public static func viewportSetFsrSharpness (viewport: RID, sharpness: Double) {
        #if false
        
        var copy_sharpness = sharpness
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_fsr_sharpness, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_sharpness)
        
        #else
        
        var copy_sharpness = sharpness
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_sharpness) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_fsr_sharpness, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_texture_mipmap_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_texture_mipmap_bias")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Affects the final texture sharpness by reading from a lower or higher mipmap (also called "texture LOD bias"). Negative values make mipmapped textures sharper but grainier when viewed at a distance, while positive values make mipmapped textures blurrier (even when up close). To get sharper textures at a distance without introducing too much graininess, set this between `-0.75` and `0.0`. Enabling temporal antialiasing (``ProjectSettings/rendering/antiAliasing/quality/useTaa``) can help reduce the graininess visible when using negative mipmap bias.
    /// 
    /// > Note: When the 3D scaling mode is set to FSR 1.0, this value is used to adjust the automatic mipmap bias which is calculated internally based on the scale factor. The formula for this is `-log2(1.0 / scale) + mipmap_bias`.
    /// 
    public static func viewportSetTextureMipmapBias (viewport: RID, mipmapBias: Double) {
        #if false
        
        var copy_mipmap_bias = mipmapBias
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_texture_mipmap_bias, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_mipmap_bias)
        
        #else
        
        var copy_mipmap_bias = mipmapBias
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mipmap_bias) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_texture_mipmap_bias, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_update_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_update_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3161116010)!
            }
            
        }
        
    }()
    
    /// Sets when the viewport should be updated. See ``RenderingServer/ViewportUpdateMode`` constants for options.
    public static func viewportSetUpdateMode (viewport: RID, updateMode: RenderingServer.ViewportUpdateMode) {
        #if false
        
        var copy_update_mode = Int64 (updateMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_update_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_update_mode)
        
        #else
        
        var copy_update_mode = Int64 (updateMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_update_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_update_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_clear_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_clear_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3628367896)!
            }
            
        }
        
    }()
    
    /// Sets the clear mode of a viewport. See ``RenderingServer/ViewportClearMode`` for options.
    public static func viewportSetClearMode (viewport: RID, clearMode: RenderingServer.ViewportClearMode) {
        #if false
        
        var copy_clear_mode = Int64 (clearMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_clear_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_clear_mode)
        
        #else
        
        var copy_clear_mode = Int64 (clearMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_clear_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_clear_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_get_render_target: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_get_render_target")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814569979)!
            }
            
        }
        
    }()
    
    /// Returns the render target for the viewport.
    public static func viewportGetRenderTarget (viewport: RID)-> RID {
        let _result: RID = RID ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_get_render_target, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &viewport.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_viewport_get_render_target, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_get_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_get_texture")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814569979)!
            }
            
        }
        
    }()
    
    /// Returns the viewport's last rendered frame.
    public static func viewportGetTexture (viewport: RID)-> RID {
        let _result: RID = RID ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_get_texture, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &viewport.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_viewport_get_texture, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_disable_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_disable_3d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, the viewport's 3D elements are not rendered.
    public static func viewportSetDisable3d (viewport: RID, disable: Bool) {
        #if false
        
        var copy_disable = disable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_disable_3d, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_disable)
        
        #else
        
        var copy_disable = disable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_disable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_disable_3d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_disable_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_disable_2d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, the viewport's canvas (i.e. 2D and GUI elements) is not rendered.
    public static func viewportSetDisable2d (viewport: RID, disable: Bool) {
        #if false
        
        var copy_disable = disable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_disable_2d, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_disable)
        
        #else
        
        var copy_disable = disable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_disable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_disable_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_environment_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_environment_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2196892182)!
            }
            
        }
        
    }()
    
    /// Sets the viewport's environment mode which allows enabling or disabling rendering of 3D environment over 2D canvas. When disabled, 2D will not be affected by the environment. When enabled, 2D will be affected by the environment if the environment background mode is .envBgCanvas. The default behavior is to inherit the setting from the viewport's parent. If the topmost parent is also set to .viewportEnvironmentInherit, then the behavior will be the same as if it was set to .viewportEnvironmentEnabled.
    public static func viewportSetEnvironmentMode (viewport: RID, mode: RenderingServer.ViewportEnvironmentMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_environment_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_environment_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_attach_camera: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_attach_camera")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a viewport's camera.
    public static func viewportAttachCamera (viewport: RID, camera: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_attach_camera, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &camera.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &camera.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_attach_camera, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_scenario: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_scenario")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a viewport's scenario. The scenario contains information about environment information, reflection atlas, etc.
    public static func viewportSetScenario (viewport: RID, scenario: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_scenario, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &scenario.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &scenario.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_scenario, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_attach_canvas: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_attach_canvas")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a viewport's canvas.
    public static func viewportAttachCanvas (viewport: RID, canvas: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_attach_canvas, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &canvas.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_attach_canvas, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_remove_canvas: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_remove_canvas")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Detaches a viewport from a canvas and vice versa.
    public static func viewportRemoveCanvas (viewport: RID, canvas: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_remove_canvas, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &canvas.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_remove_canvas, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_snap_2d_transforms_to_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_snap_2d_transforms_to_pixel")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, canvas item transforms (i.e. origin position) are snapped to the nearest pixel when rendering. This can lead to a crisper appearance at the cost of less smooth movement, especially when ``Camera2D`` smoothing is enabled. Equivalent to ``ProjectSettings/rendering/2d/snap/snap2dTransformsToPixel``.
    public static func viewportSetSnap2dTransformsToPixel (viewport: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_snap_2d_transforms_to_pixel, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_snap_2d_transforms_to_pixel, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_snap_2d_vertices_to_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_snap_2d_vertices_to_pixel")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, canvas item vertices (i.e. polygon points) are snapped to the nearest pixel when rendering. This can lead to a crisper appearance at the cost of less smooth movement, especially when ``Camera2D`` smoothing is enabled. Equivalent to ``ProjectSettings/rendering/2d/snap/snap2dVerticesToPixel``.
    public static func viewportSetSnap2dVerticesToPixel (viewport: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_snap_2d_vertices_to_pixel, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_snap_2d_vertices_to_pixel, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_default_canvas_item_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_default_canvas_item_texture_filter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1155129294)!
            }
            
        }
        
    }()
    
    /// Sets the default texture filtering mode for the specified `viewport` RID. See ``RenderingServer/CanvasItemTextureFilter`` for options.
    public static func viewportSetDefaultCanvasItemTextureFilter (viewport: RID, filter: RenderingServer.CanvasItemTextureFilter) {
        #if false
        
        var copy_filter = Int64 (filter.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_default_canvas_item_texture_filter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_filter)
        
        #else
        
        var copy_filter = Int64 (filter.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_filter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_default_canvas_item_texture_filter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_default_canvas_item_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_default_canvas_item_texture_repeat")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1652956681)!
            }
            
        }
        
    }()
    
    /// Sets the default texture repeat mode for the specified `viewport` RID. See ``RenderingServer/CanvasItemTextureRepeat`` for options.
    public static func viewportSetDefaultCanvasItemTextureRepeat (viewport: RID, `repeat`: RenderingServer.CanvasItemTextureRepeat) {
        #if false
        
        var copy_repeat = Int64 (`repeat`.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_default_canvas_item_texture_repeat, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_repeat)
        
        #else
        
        var copy_repeat = Int64 (`repeat`.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_repeat) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_default_canvas_item_texture_repeat, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_canvas_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3608606053)!
            }
            
        }
        
    }()
    
    /// Sets the transformation of a viewport's canvas.
    public static func viewportSetCanvasTransform (viewport: RID, canvas: RID, offset: Transform2D) {
        #if false
        
        var copy_offset = offset
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_canvas_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &canvas.content, &copy_offset)
        
        #else
        
        var copy_offset = offset
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_offset) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_canvas_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_canvas_stacking: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_canvas_stacking")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3713930247)!
            }
            
        }
        
    }()
    
    /// Sets the stacking order for a viewport's canvas.
    /// 
    /// `layer` is the actual canvas layer, while `sublayer` specifies the stacking order of the canvas among those in the same layer.
    /// 
    public static func viewportSetCanvasStacking (viewport: RID, canvas: RID, layer: Int32, sublayer: Int32) {
        #if false
        
        var copy_layer: Int = Int (layer)
        var copy_sublayer: Int = Int (sublayer)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_canvas_stacking, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &canvas.content, &copy_layer, &copy_sublayer)
        
        #else
        
        var copy_layer: Int = Int (layer)
        var copy_sublayer: Int = Int (sublayer)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_layer) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_sublayer) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_canvas_stacking, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_transparent_background: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_transparent_background")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, the viewport renders its background as transparent.
    public static func viewportSetTransparentBackground (viewport: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_transparent_background, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_transparent_background, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_global_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_global_canvas_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1246044741)!
            }
            
        }
        
    }()
    
    /// Sets the viewport's global transformation matrix.
    public static func viewportSetGlobalCanvasTransform (viewport: RID, transform: Transform2D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_global_canvas_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_global_canvas_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_sdf_oversize_and_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_sdf_oversize_and_scale")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1329198632)!
            }
            
        }
        
    }()
    
    /// Sets the viewport's 2D signed distance field ``ProjectSettings/rendering/2d/sdf/oversize`` and ``ProjectSettings/rendering/2d/sdf/scale``. This is used when sampling the signed distance field in ``CanvasItem`` shaders as well as ``GPUParticles2D`` collision. This is _not_ used by SDFGI in 3D rendering.
    public static func viewportSetSdfOversizeAndScale (viewport: RID, oversize: RenderingServer.ViewportSDFOversize, scale: RenderingServer.ViewportSDFScale) {
        #if false
        
        var copy_oversize = Int64 (oversize.rawValue)
        var copy_scale = Int64 (scale.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_sdf_oversize_and_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_oversize, &copy_scale)
        
        #else
        
        var copy_oversize = Int64 (oversize.rawValue)
        var copy_scale = Int64 (scale.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_oversize) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_scale) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_sdf_oversize_and_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_positional_shadow_atlas_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_positional_shadow_atlas_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1904426712)!
            }
            
        }
        
    }()
    
    /// Sets the `size` of the shadow atlas's images (used for omni and spot lights) on the viewport specified by the `viewport` RID. The value is rounded up to the nearest power of 2. If `use16Bits` is `true`, use 16 bits for the omni/spot shadow depth map. Enabling this results in shadows having less precision and may result in shadow acne, but can lead to performance improvements on some devices.
    /// 
    /// > Note: If this is set to `0`, no positional shadows will be visible at all. This can improve performance significantly on low-end systems by reducing both the CPU and GPU load (as fewer draw calls are needed to draw the scene without shadows).
    /// 
    public static func viewportSetPositionalShadowAtlasSize (viewport: RID, size: Int32, use16Bits: Bool = false) {
        #if false
        
        var copy_size: Int = Int (size)
        var copy_use_16_bits = use16Bits
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_positional_shadow_atlas_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_size, &copy_use_16_bits)
        
        #else
        
        var copy_size: Int = Int (size)
        var copy_use_16_bits = use16Bits
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_use_16_bits) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_positional_shadow_atlas_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_positional_shadow_atlas_quadrant_subdivision: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_positional_shadow_atlas_quadrant_subdivision")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4288446313)!
            }
            
        }
        
    }()
    
    /// Sets the number of subdivisions to use in the specified shadow atlas `quadrant` for omni and spot shadows. See also ``Viewport/setPositionalShadowAtlasQuadrantSubdiv(quadrant:subdiv:)``.
    public static func viewportSetPositionalShadowAtlasQuadrantSubdivision (viewport: RID, quadrant: Int32, subdivision: Int32) {
        #if false
        
        var copy_quadrant: Int = Int (quadrant)
        var copy_subdivision: Int = Int (subdivision)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_positional_shadow_atlas_quadrant_subdivision, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_quadrant, &copy_subdivision)
        
        #else
        
        var copy_quadrant: Int = Int (quadrant)
        var copy_subdivision: Int = Int (subdivision)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_quadrant) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_subdivision) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_positional_shadow_atlas_quadrant_subdivision, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_msaa_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_msaa_3d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3764433340)!
            }
            
        }
        
    }()
    
    /// Sets the multisample anti-aliasing mode for 3D on the specified `viewport` RID. See ``RenderingServer/ViewportMSAA`` for options.
    public static func viewportSetMsaa3d (viewport: RID, msaa: RenderingServer.ViewportMSAA) {
        #if false
        
        var copy_msaa = Int64 (msaa.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_msaa_3d, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_msaa)
        
        #else
        
        var copy_msaa = Int64 (msaa.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_msaa) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_msaa_3d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_msaa_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_msaa_2d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3764433340)!
            }
            
        }
        
    }()
    
    /// Sets the multisample anti-aliasing mode for 2D/Canvas on the specified `viewport` RID. See ``RenderingServer/ViewportMSAA`` for options.
    public static func viewportSetMsaa2d (viewport: RID, msaa: RenderingServer.ViewportMSAA) {
        #if false
        
        var copy_msaa = Int64 (msaa.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_msaa_2d, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_msaa)
        
        #else
        
        var copy_msaa = Int64 (msaa.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_msaa) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_msaa_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_use_hdr_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_use_hdr_2d")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, 2D rendering will use a high dynamic range (HDR) format framebuffer matching the bit depth of the 3D framebuffer. When using the Forward+ renderer this will be a `RGBA16` framebuffer, while when using the Mobile renderer it will be a `RGB10_A2` framebuffer. Additionally, 2D rendering will take place in linear color space and will be converted to sRGB space immediately before blitting to the screen (if the Viewport is attached to the screen). Practically speaking, this means that the end result of the Viewport will not be clamped into the `0-1` range and can be used in 3D rendering without color space adjustments. This allows 2D rendering to take advantage of effects requiring high dynamic range (e.g. 2D glow) as well as substantially improves the appearance of effects requiring highly detailed gradients. This setting has the same effect as ``Viewport/useHdr2d``.
    /// 
    /// > Note: This setting will have no effect when using the GL Compatibility renderer as the GL Compatibility renderer always renders in low dynamic range for performance reasons.
    /// 
    public static func viewportSetUseHdr2d (viewport: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_use_hdr_2d, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_use_hdr_2d, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_screen_space_aa: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_screen_space_aa")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1447279591)!
            }
            
        }
        
    }()
    
    /// Sets the viewport's screen-space antialiasing mode.
    public static func viewportSetScreenSpaceAa (viewport: RID, mode: RenderingServer.ViewportScreenSpaceAA) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_screen_space_aa, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_screen_space_aa, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_use_taa: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_use_taa")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, use Temporal Anti-Aliasing. Equivalent to ``ProjectSettings/rendering/antiAliasing/quality/useTaa``.
    public static func viewportSetUseTaa (viewport: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_use_taa, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_use_taa, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_use_debanding: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_use_debanding")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, enables debanding on the specified viewport. Equivalent to ``ProjectSettings/rendering/antiAliasing/quality/useDebanding``.
    public static func viewportSetUseDebanding (viewport: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_use_debanding, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_use_debanding, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_use_occlusion_culling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_use_occlusion_culling")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, enables occlusion culling on the specified viewport. Equivalent to ``ProjectSettings/rendering/occlusionCulling/useOcclusionCulling``.
    public static func viewportSetUseOcclusionCulling (viewport: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_use_occlusion_culling, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_use_occlusion_culling, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_occlusion_rays_per_thread: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_occlusion_rays_per_thread")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the ``ProjectSettings/rendering/occlusionCulling/occlusionRaysPerThread`` to use for occlusion culling. This parameter is global and cannot be set on a per-viewport basis.
    public static func viewportSetOcclusionRaysPerThread (_ raysPerThread: Int32) {
        #if false
        
        var copy_rays_per_thread: Int = Int (raysPerThread)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_occlusion_rays_per_thread, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_rays_per_thread)
        
        #else
        
        var copy_rays_per_thread: Int = Int (raysPerThread)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_rays_per_thread) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_occlusion_rays_per_thread, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_occlusion_culling_build_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_occlusion_culling_build_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2069725696)!
            }
            
        }
        
    }()
    
    /// Sets the ``ProjectSettings/rendering/occlusionCulling/bvhBuildQuality`` to use for occlusion culling. This parameter is global and cannot be set on a per-viewport basis.
    public static func viewportSetOcclusionCullingBuildQuality (_ quality: RenderingServer.ViewportOcclusionCullingBuildQuality) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_occlusion_culling_build_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_occlusion_culling_build_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_get_render_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_get_render_info")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2041262392)!
            }
            
        }
        
    }()
    
    /// Returns a statistic about the rendering engine which can be used for performance profiling. This is separated into render pass `type`s, each of them having the same `info`s you can query (different passes will return different values). See ``RenderingServer.ViewportRenderInfoType`` for a list of render pass types and ``RenderingServer.ViewportRenderInfo`` for a list of information that can be queried.
    /// 
    /// See also ``getRenderingInfo(_:)``, which returns global information across all viewports.
    /// 
    /// > Note: Viewport rendering information is not available until at least 2 frames have been rendered by the engine. If rendering information is not available, ``viewportGetRenderInfo(viewport:type:info:)`` returns `0`. To print rendering information in `_ready()` successfully, use the following:
    /// 
    public static func viewportGetRenderInfo (viewport: RID, type: RenderingServer.ViewportRenderInfoType, info: RenderingServer.ViewportRenderInfo)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_type = Int64 (type.rawValue)
        var copy_info = Int64 (info.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_get_render_info, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &viewport.content, &copy_type, &copy_info)
        return _result
        #else
        
        var copy_type = Int64 (type.rawValue)
        var copy_info = Int64 (info.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_type) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_info) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_viewport_get_render_info, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_debug_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_debug_draw")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2089420930)!
            }
            
        }
        
    }()
    
    /// Sets the debug draw mode of a viewport. See ``RenderingServer/ViewportDebugDraw`` for options.
    public static func viewportSetDebugDraw (viewport: RID, draw: RenderingServer.ViewportDebugDraw) {
        #if false
        
        var copy_draw = Int64 (draw.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_debug_draw, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_draw)
        
        #else
        
        var copy_draw = Int64 (draw.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_draw) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_debug_draw, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_measure_render_time: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_measure_render_time")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Sets the measurement for the given `viewport` RID (obtained using ``Viewport/getViewportRid()``). Once enabled, ``viewportGetMeasuredRenderTimeCpu(viewport:)`` and ``viewportGetMeasuredRenderTimeGpu(viewport:)`` will return values greater than `0.0` when queried with the given `viewport`.
    public static func viewportSetMeasureRenderTime (viewport: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_measure_render_time, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_measure_render_time, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_get_measured_render_time_cpu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_get_measured_render_time_cpu")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns the CPU time taken to render the last frame in milliseconds. This _only_ includes time spent in rendering-related operations; scripts' `_process` functions and other engine subsystems are not included in this readout. To get a complete readout of CPU time spent to render the scene, sum the render times of all viewports that are drawn every frame plus ``getFrameSetupTimeCpu()``. Unlike ``Engine/getFramesPerSecond()``, this method will accurately reflect CPU utilization even if framerate is capped via V-Sync or ``Engine/maxFps``. See also ``viewportGetMeasuredRenderTimeGpu(viewport:)``.
    /// 
    /// > Note: Requires measurements to be enabled on the specified `viewport` using ``viewportSetMeasureRenderTime(viewport:enable:)``. Otherwise, this method returns `0.0`.
    /// 
    public static func viewportGetMeasuredRenderTimeCpu (viewport: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_get_measured_render_time_cpu, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &viewport.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_viewport_get_measured_render_time_cpu, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_get_measured_render_time_gpu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_get_measured_render_time_gpu")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns the GPU time taken to render the last frame in milliseconds. To get a complete readout of GPU time spent to render the scene, sum the render times of all viewports that are drawn every frame. Unlike ``Engine/getFramesPerSecond()``, this method accurately reflects GPU utilization even if framerate is capped via V-Sync or ``Engine/maxFps``. See also ``viewportGetMeasuredRenderTimeGpu(viewport:)``.
    /// 
    /// > Note: Requires measurements to be enabled on the specified `viewport` using ``viewportSetMeasureRenderTime(viewport:enable:)``. Otherwise, this method returns `0.0`.
    /// 
    /// > Note: When GPU utilization is low enough during a certain period of time, GPUs will decrease their power state (which in turn decreases core and memory clock speeds). This can cause the reported GPU time to increase if GPU utilization is kept low enough by a framerate cap (compared to what it would be at the GPU's highest power state). Keep this in mind when benchmarking using ``viewportGetMeasuredRenderTimeGpu(viewport:)``. This behavior can be overridden in the graphics driver settings at the cost of higher power usage.
    /// 
    public static func viewportGetMeasuredRenderTimeGpu (viewport: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_get_measured_render_time_gpu, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &viewport.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_viewport_get_measured_render_time_gpu, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_vrs_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_vrs_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 398809874)!
            }
            
        }
        
    }()
    
    /// Sets the Variable Rate Shading (VRS) mode for the viewport. If the GPU does not support VRS, this property is ignored. Equivalent to ``ProjectSettings/rendering/vrs/mode``.
    public static func viewportSetVrsMode (viewport: RID, mode: RenderingServer.ViewportVRSMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_vrs_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_vrs_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_viewport_set_vrs_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("viewport_set_vrs_texture")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// The texture to use when the VRS mode is set to ``RenderingServer/ViewportVRSMode/viewportVrsTexture``. Equivalent to ``ProjectSettings/rendering/vrs/texture``.
    public static func viewportSetVrsTexture (viewport: RID, texture: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_viewport_set_vrs_texture, UnsafeMutableRawPointer (mutating: shared.handle), nil, &viewport.content, &texture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &viewport.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &texture.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_viewport_set_vrs_texture, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_sky_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("sky_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates an empty sky and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `sky_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    public static func skyCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_sky_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_sky_set_radiance_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("sky_set_radiance_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the `radianceSize` of the sky specified by the `sky` RID (in pixels). Equivalent to ``Sky/radianceSize``.
    public static func skySetRadianceSize (sky: RID, radianceSize: Int32) {
        #if false
        
        var copy_radiance_size: Int = Int (radianceSize)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_sky_set_radiance_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &sky.content, &copy_radiance_size)
        
        #else
        
        var copy_radiance_size: Int = Int (radianceSize)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &sky.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_radiance_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_sky_set_radiance_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_sky_set_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("sky_set_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3279019937)!
            }
            
        }
        
    }()
    
    /// Sets the process `mode` of the sky specified by the `sky` RID. Equivalent to ``Sky/processMode``.
    public static func skySetMode (sky: RID, mode: RenderingServer.SkyMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_sky_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &sky.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &sky.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_sky_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_sky_set_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("sky_set_material")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the material that the sky uses to render the background, ambient and reflection maps.
    public static func skySetMaterial (sky: RID, material: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_sky_set_material, UnsafeMutableRawPointer (mutating: shared.handle), nil, &sky.content, &material.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &sky.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &material.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_sky_set_material, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_sky_bake_panorama: GDExtensionMethodBindPtr = {
        let methodName = StringName ("sky_bake_panorama")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3875285818)!
            }
            
        }
        
    }()
    
    /// Generates and returns an ``Image`` containing the radiance map for the specified `sky` RID. This supports built-in sky material and custom sky shaders. If `bakeIrradiance` is `true`, the irradiance map is saved instead of the radiance map. The radiance map is used to render reflected light, while the irradiance map is used to render ambient light. See also ``environmentBakePanorama(environment:bakeIrradiance:size:)``.
    /// 
    /// > Note: The image is saved in linear color space without any tonemapping performed, which means it will look too dark if viewed directly in an image editor. `energy` values above `1.0` can be used to brighten the resulting image.
    /// 
    /// > Note: `size` should be a 2:1 aspect ratio for the generated panorama to have square pixels. For radiance maps, there is no point in using a height greater than ``Sky/radianceSize``, as it won't increase detail. Irradiance maps only contain low-frequency data, so there is usually no point in going past a size of 128×64 pixels when saving an irradiance map.
    /// 
    public static func skyBakePanorama (sky: RID, energy: Double, bakeIrradiance: Bool, size: Vector2i)-> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_energy = energy
        var copy_bake_irradiance = bakeIrradiance
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_sky_bake_panorama, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &sky.content, &copy_energy, &copy_bake_irradiance, &copy_size)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_energy = energy
        var copy_bake_irradiance = bakeIrradiance
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &sky.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_energy) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_bake_irradiance) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_size) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_sky_bake_panorama, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates an environment and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `environment_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``Environment``.
    /// 
    public static func environmentCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_environment_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_environment_set_background: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_background")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937328877)!
            }
            
        }
        
    }()
    
    /// Sets the environment's background mode. Equivalent to ``Environment/backgroundMode``.
    public static func environmentSetBackground (env: RID, bg: RenderingServer.EnvironmentBG) {
        #if false
        
        var copy_bg = Int64 (bg.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_background, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_bg)
        
        #else
        
        var copy_bg = Int64 (bg.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bg) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_background, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_sky: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_sky")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the ``Sky`` to be used as the environment's background when using _BGMode_ sky. Equivalent to ``Environment/sky``.
    public static func environmentSetSky (env: RID, sky: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_sky, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &sky.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &sky.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_sky, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_sky_custom_fov: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_sky_custom_fov")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets a custom field of view for the background ``Sky``. Equivalent to ``Environment/skyCustomFov``.
    public static func environmentSetSkyCustomFov (env: RID, scale: Double) {
        #if false
        
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_sky_custom_fov, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_scale)
        
        #else
        
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_scale) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_sky_custom_fov, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_sky_orientation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_sky_orientation")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1735850857)!
            }
            
        }
        
    }()
    
    /// Sets the rotation of the background ``Sky`` expressed as a ``Basis``. Equivalent to ``Environment/skyRotation``, where the rotation vector is used to construct the ``Basis``.
    public static func environmentSetSkyOrientation (env: RID, orientation: Basis) {
        #if false
        
        var copy_orientation = orientation
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_sky_orientation, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_orientation)
        
        #else
        
        var copy_orientation = orientation
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_orientation) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_sky_orientation, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_bg_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_bg_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Color displayed for clear areas of the scene. Only effective if using the .envBgColor background mode.
    public static func environmentSetBgColor (env: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_bg_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_bg_color, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_bg_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_bg_energy")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2513314492)!
            }
            
        }
        
    }()
    
    /// Sets the intensity of the background color.
    public static func environmentSetBgEnergy (env: RID, multiplier: Double, exposureValue: Double) {
        #if false
        
        var copy_multiplier = multiplier
        var copy_exposure_value = exposureValue
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_bg_energy, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_multiplier, &copy_exposure_value)
        
        #else
        
        var copy_multiplier = multiplier
        var copy_exposure_value = exposureValue
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_multiplier) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_exposure_value) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_bg_energy, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_canvas_max_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_canvas_max_layer")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the maximum layer to use if using Canvas background mode.
    public static func environmentSetCanvasMaxLayer (env: RID, maxLayer: Int32) {
        #if false
        
        var copy_max_layer: Int = Int (maxLayer)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_canvas_max_layer, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_max_layer)
        
        #else
        
        var copy_max_layer: Int = Int (maxLayer)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_max_layer) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_canvas_max_layer, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_ambient_light: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_ambient_light")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1214961493)!
            }
            
        }
        
    }()
    
    /// Sets the values to be used for ambient light rendering. See ``Environment`` for more details.
    public static func environmentSetAmbientLight (env: RID, color: Color, ambient: RenderingServer.EnvironmentAmbientSource = .bg, energy: Double = 1.0, skyContibution: Double = 0.0, reflectionSource: RenderingServer.EnvironmentReflectionSource = .bg) {
        #if false
        
        var copy_color = color
        var copy_ambient = Int64 (ambient.rawValue)
        var copy_energy = energy
        var copy_sky_contibution = skyContibution
        var copy_reflection_source = Int64 (reflectionSource.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_ambient_light, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_color, &copy_ambient, &copy_energy, &copy_sky_contibution, &copy_reflection_source)
        
        #else
        
        var copy_color = color
        var copy_ambient = Int64 (ambient.rawValue)
        var copy_energy = energy
        var copy_sky_contibution = skyContibution
        var copy_reflection_source = Int64 (reflectionSource.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_ambient) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_energy) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_sky_contibution) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_reflection_source) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_ambient_light, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_glow: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_glow")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2421724940)!
            }
            
        }
        
    }()
    
    /// Configures glow for the specified environment RID. See `glow_*` properties in ``Environment`` for more information.
    public static func environmentSetGlow (env: RID, enable: Bool, levels: PackedFloat32Array, intensity: Double, strength: Double, mix: Double, bloomThreshold: Double, blendMode: RenderingServer.EnvironmentGlowBlendMode, hdrBleedThreshold: Double, hdrBleedScale: Double, hdrLuminanceCap: Double, glowMapStrength: Double, glowMap: RID) {
        #if false
        
        var copy_enable = enable
        var copy_intensity = intensity
        var copy_strength = strength
        var copy_mix = mix
        var copy_bloom_threshold = bloomThreshold
        var copy_blend_mode = Int64 (blendMode.rawValue)
        var copy_hdr_bleed_threshold = hdrBleedThreshold
        var copy_hdr_bleed_scale = hdrBleedScale
        var copy_hdr_luminance_cap = hdrLuminanceCap
        var copy_glow_map_strength = glowMapStrength
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_glow, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_enable, &levels.content, &copy_intensity, &copy_strength, &copy_mix, &copy_bloom_threshold, &copy_blend_mode, &copy_hdr_bleed_threshold, &copy_hdr_bleed_scale, &copy_hdr_luminance_cap, &copy_glow_map_strength, &glowMap.content)
        
        #else
        
        var copy_enable = enable
        var copy_intensity = intensity
        var copy_strength = strength
        var copy_mix = mix
        var copy_bloom_threshold = bloomThreshold
        var copy_blend_mode = Int64 (blendMode.rawValue)
        var copy_hdr_bleed_threshold = hdrBleedThreshold
        var copy_hdr_bleed_scale = hdrBleedScale
        var copy_hdr_luminance_cap = hdrLuminanceCap
        var copy_glow_map_strength = glowMapStrength
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &levels.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_intensity) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_strength) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_mix) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_bloom_threshold) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_blend_mode) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_hdr_bleed_threshold) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_hdr_bleed_scale) { p9 in
                                                _args.append (p9)
                                                withUnsafePointer (to: &copy_hdr_luminance_cap) { p10 in
                                                    _args.append (p10)
                                                    withUnsafePointer (to: &copy_glow_map_strength) { p11 in
                                                        _args.append (p11)
                                                        withUnsafePointer (to: &glowMap.content) { p12 in
                                                            _args.append (p12)
        
                                                            gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_glow, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_tonemap: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_tonemap")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2914312638)!
            }
            
        }
        
    }()
    
    /// Sets the variables to be used with the "tonemap" post-process effect. See ``Environment`` for more details.
    public static func environmentSetTonemap (env: RID, toneMapper: RenderingServer.EnvironmentToneMapper, exposure: Double, white: Double) {
        #if false
        
        var copy_tone_mapper = Int64 (toneMapper.rawValue)
        var copy_exposure = exposure
        var copy_white = white
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_tonemap, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_tone_mapper, &copy_exposure, &copy_white)
        
        #else
        
        var copy_tone_mapper = Int64 (toneMapper.rawValue)
        var copy_exposure = exposure
        var copy_white = white
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_tone_mapper) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_exposure) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_white) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_tonemap, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_adjustment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_adjustment")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 876799838)!
            }
            
        }
        
    }()
    
    /// Sets the values to be used with the "adjustments" post-process effect. See ``Environment`` for more details.
    public static func environmentSetAdjustment (env: RID, enable: Bool, brightness: Double, contrast: Double, saturation: Double, use1dColorCorrection: Bool, colorCorrection: RID) {
        #if false
        
        var copy_enable = enable
        var copy_brightness = brightness
        var copy_contrast = contrast
        var copy_saturation = saturation
        var copy_use_1d_color_correction = use1dColorCorrection
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_adjustment, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_enable, &copy_brightness, &copy_contrast, &copy_saturation, &copy_use_1d_color_correction, &colorCorrection.content)
        
        #else
        
        var copy_enable = enable
        var copy_brightness = brightness
        var copy_contrast = contrast
        var copy_saturation = saturation
        var copy_use_1d_color_correction = use1dColorCorrection
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_brightness) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_contrast) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_saturation) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_use_1d_color_correction) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &colorCorrection.content) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_adjustment, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_ssr: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_ssr")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3607294374)!
            }
            
        }
        
    }()
    
    /// Sets the variables to be used with the screen-space reflections (SSR) post-process effect. See ``Environment`` for more details.
    public static func environmentSetSsr (env: RID, enable: Bool, maxSteps: Int32, fadeIn: Double, fadeOut: Double, depthTolerance: Double) {
        #if false
        
        var copy_enable = enable
        var copy_max_steps: Int = Int (maxSteps)
        var copy_fade_in = fadeIn
        var copy_fade_out = fadeOut
        var copy_depth_tolerance = depthTolerance
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_ssr, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_enable, &copy_max_steps, &copy_fade_in, &copy_fade_out, &copy_depth_tolerance)
        
        #else
        
        var copy_enable = enable
        var copy_max_steps: Int = Int (maxSteps)
        var copy_fade_in = fadeIn
        var copy_fade_out = fadeOut
        var copy_depth_tolerance = depthTolerance
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_max_steps) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_fade_in) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_fade_out) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_depth_tolerance) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_ssr, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_ssao: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_ssao")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3994732740)!
            }
            
        }
        
    }()
    
    /// Sets the variables to be used with the screen-space ambient occlusion (SSAO) post-process effect. See ``Environment`` for more details.
    public static func environmentSetSsao (env: RID, enable: Bool, radius: Double, intensity: Double, power: Double, detail: Double, horizon: Double, sharpness: Double, lightAffect: Double, aoChannelAffect: Double) {
        #if false
        
        var copy_enable = enable
        var copy_radius = radius
        var copy_intensity = intensity
        var copy_power = power
        var copy_detail = detail
        var copy_horizon = horizon
        var copy_sharpness = sharpness
        var copy_light_affect = lightAffect
        var copy_ao_channel_affect = aoChannelAffect
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_ssao, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_enable, &copy_radius, &copy_intensity, &copy_power, &copy_detail, &copy_horizon, &copy_sharpness, &copy_light_affect, &copy_ao_channel_affect)
        
        #else
        
        var copy_enable = enable
        var copy_radius = radius
        var copy_intensity = intensity
        var copy_power = power
        var copy_detail = detail
        var copy_horizon = horizon
        var copy_sharpness = sharpness
        var copy_light_affect = lightAffect
        var copy_ao_channel_affect = aoChannelAffect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_radius) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_intensity) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_power) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_detail) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_horizon) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_sharpness) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_light_affect) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_ao_channel_affect) { p9 in
                                                _args.append (p9)
        
                                                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_ssao, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_fog: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_fog")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2793577733)!
            }
            
        }
        
    }()
    
    /// Configures fog for the specified environment RID. See `fog_*` properties in ``Environment`` for more information.
    public static func environmentSetFog (env: RID, enable: Bool, lightColor: Color, lightEnergy: Double, sunScatter: Double, density: Double, height: Double, heightDensity: Double, aerialPerspective: Double, skyAffect: Double) {
        #if false
        
        var copy_enable = enable
        var copy_light_color = lightColor
        var copy_light_energy = lightEnergy
        var copy_sun_scatter = sunScatter
        var copy_density = density
        var copy_height = height
        var copy_height_density = heightDensity
        var copy_aerial_perspective = aerialPerspective
        var copy_sky_affect = skyAffect
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_fog, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_enable, &copy_light_color, &copy_light_energy, &copy_sun_scatter, &copy_density, &copy_height, &copy_height_density, &copy_aerial_perspective, &copy_sky_affect)
        
        #else
        
        var copy_enable = enable
        var copy_light_color = lightColor
        var copy_light_energy = lightEnergy
        var copy_sun_scatter = sunScatter
        var copy_density = density
        var copy_height = height
        var copy_height_density = heightDensity
        var copy_aerial_perspective = aerialPerspective
        var copy_sky_affect = skyAffect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_light_color) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_light_energy) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_sun_scatter) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_density) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_height) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_height_density) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_aerial_perspective) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_sky_affect) { p9 in
                                                _args.append (p9)
        
                                                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_fog, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_sdfgi: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_sdfgi")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3519144388)!
            }
            
        }
        
    }()
    
    /// Configures signed distance field global illumination for the specified environment RID. See `sdfgi_*` properties in ``Environment`` for more information.
    public static func environmentSetSdfgi (env: RID, enable: Bool, cascades: Int32, minCellSize: Double, yScale: RenderingServer.EnvironmentSDFGIYScale, useOcclusion: Bool, bounceFeedback: Double, readSky: Bool, energy: Double, normalBias: Double, probeBias: Double) {
        #if false
        
        var copy_enable = enable
        var copy_cascades: Int = Int (cascades)
        var copy_min_cell_size = minCellSize
        var copy_y_scale = Int64 (yScale.rawValue)
        var copy_use_occlusion = useOcclusion
        var copy_bounce_feedback = bounceFeedback
        var copy_read_sky = readSky
        var copy_energy = energy
        var copy_normal_bias = normalBias
        var copy_probe_bias = probeBias
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_sdfgi, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_enable, &copy_cascades, &copy_min_cell_size, &copy_y_scale, &copy_use_occlusion, &copy_bounce_feedback, &copy_read_sky, &copy_energy, &copy_normal_bias, &copy_probe_bias)
        
        #else
        
        var copy_enable = enable
        var copy_cascades: Int = Int (cascades)
        var copy_min_cell_size = minCellSize
        var copy_y_scale = Int64 (yScale.rawValue)
        var copy_use_occlusion = useOcclusion
        var copy_bounce_feedback = bounceFeedback
        var copy_read_sky = readSky
        var copy_energy = energy
        var copy_normal_bias = normalBias
        var copy_probe_bias = probeBias
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_cascades) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_min_cell_size) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_y_scale) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_use_occlusion) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_bounce_feedback) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_read_sky) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_energy) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_normal_bias) { p9 in
                                                _args.append (p9)
                                                withUnsafePointer (to: &copy_probe_bias) { p10 in
                                                    _args.append (p10)
        
                                                    gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_sdfgi, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_volumetric_fog: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_volumetric_fog")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1553633833)!
            }
            
        }
        
    }()
    
    /// Sets the variables to be used with the volumetric fog post-process effect. See ``Environment`` for more details.
    public static func environmentSetVolumetricFog (env: RID, enable: Bool, density: Double, albedo: Color, emission: Color, emissionEnergy: Double, anisotropy: Double, length: Double, pDetailSpread: Double, giInject: Double, temporalReprojection: Bool, temporalReprojectionAmount: Double, ambientInject: Double, skyAffect: Double) {
        #if false
        
        var copy_enable = enable
        var copy_density = density
        var copy_albedo = albedo
        var copy_emission = emission
        var copy_emission_energy = emissionEnergy
        var copy_anisotropy = anisotropy
        var copy_length = length
        var copy_p_detail_spread = pDetailSpread
        var copy_gi_inject = giInject
        var copy_temporal_reprojection = temporalReprojection
        var copy_temporal_reprojection_amount = temporalReprojectionAmount
        var copy_ambient_inject = ambientInject
        var copy_sky_affect = skyAffect
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_volumetric_fog, UnsafeMutableRawPointer (mutating: shared.handle), nil, &env.content, &copy_enable, &copy_density, &copy_albedo, &copy_emission, &copy_emission_energy, &copy_anisotropy, &copy_length, &copy_p_detail_spread, &copy_gi_inject, &copy_temporal_reprojection, &copy_temporal_reprojection_amount, &copy_ambient_inject, &copy_sky_affect)
        
        #else
        
        var copy_enable = enable
        var copy_density = density
        var copy_albedo = albedo
        var copy_emission = emission
        var copy_emission_energy = emissionEnergy
        var copy_anisotropy = anisotropy
        var copy_length = length
        var copy_p_detail_spread = pDetailSpread
        var copy_gi_inject = giInject
        var copy_temporal_reprojection = temporalReprojection
        var copy_temporal_reprojection_amount = temporalReprojectionAmount
        var copy_ambient_inject = ambientInject
        var copy_sky_affect = skyAffect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &env.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_density) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_albedo) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_emission) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_emission_energy) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_anisotropy) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_length) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_p_detail_spread) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_gi_inject) { p9 in
                                                _args.append (p9)
                                                withUnsafePointer (to: &copy_temporal_reprojection) { p10 in
                                                    _args.append (p10)
                                                    withUnsafePointer (to: &copy_temporal_reprojection_amount) { p11 in
                                                        _args.append (p11)
                                                        withUnsafePointer (to: &copy_ambient_inject) { p12 in
                                                            _args.append (p12)
                                                            withUnsafePointer (to: &copy_sky_affect) { p13 in
                                                                _args.append (p13)
        
                                                                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_volumetric_fog, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_glow_set_use_bicubic_upscale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_glow_set_use_bicubic_upscale")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `enable` is `true`, enables bicubic upscaling for glow which improves quality at the cost of performance. Equivalent to ``ProjectSettings/rendering/environment/glow/upscaleMode``.
    public static func environmentGlowSetUseBicubicUpscale (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_glow_set_use_bicubic_upscale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_environment_glow_set_use_bicubic_upscale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_ssr_roughness_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_ssr_roughness_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1190026788)!
            }
            
        }
        
    }()
    
    /// 
    public static func environmentSetSsrRoughnessQuality (_ quality: RenderingServer.EnvironmentSSRRoughnessQuality) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_ssr_roughness_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_ssr_roughness_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_ssao_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_ssao_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 189753569)!
            }
            
        }
        
    }()
    
    /// Sets the quality level of the screen-space ambient occlusion (SSAO) post-process effect. See ``Environment`` for more details.
    public static func environmentSetSsaoQuality (_ quality: RenderingServer.EnvironmentSSAOQuality, halfSize: Bool, adaptiveTarget: Double, blurPasses: Int32, fadeoutFrom: Double, fadeoutTo: Double) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        var copy_half_size = halfSize
        var copy_adaptive_target = adaptiveTarget
        var copy_blur_passes: Int = Int (blurPasses)
        var copy_fadeout_from = fadeoutFrom
        var copy_fadeout_to = fadeoutTo
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_ssao_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality, &copy_half_size, &copy_adaptive_target, &copy_blur_passes, &copy_fadeout_from, &copy_fadeout_to)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var copy_half_size = halfSize
        var copy_adaptive_target = adaptiveTarget
        var copy_blur_passes: Int = Int (blurPasses)
        var copy_fadeout_from = fadeoutFrom
        var copy_fadeout_to = fadeoutTo
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_half_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_adaptive_target) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_blur_passes) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_fadeout_from) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_fadeout_to) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_ssao_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_ssil_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_ssil_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1713836683)!
            }
            
        }
        
    }()
    
    /// Sets the quality level of the screen-space indirect lighting (SSIL) post-process effect. See ``Environment`` for more details.
    public static func environmentSetSsilQuality (_ quality: RenderingServer.EnvironmentSSILQuality, halfSize: Bool, adaptiveTarget: Double, blurPasses: Int32, fadeoutFrom: Double, fadeoutTo: Double) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        var copy_half_size = halfSize
        var copy_adaptive_target = adaptiveTarget
        var copy_blur_passes: Int = Int (blurPasses)
        var copy_fadeout_from = fadeoutFrom
        var copy_fadeout_to = fadeoutTo
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_ssil_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality, &copy_half_size, &copy_adaptive_target, &copy_blur_passes, &copy_fadeout_from, &copy_fadeout_to)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var copy_half_size = halfSize
        var copy_adaptive_target = adaptiveTarget
        var copy_blur_passes: Int = Int (blurPasses)
        var copy_fadeout_from = fadeoutFrom
        var copy_fadeout_to = fadeoutTo
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_half_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_adaptive_target) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_blur_passes) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_fadeout_from) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_fadeout_to) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_ssil_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_sdfgi_ray_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_sdfgi_ray_count")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 340137951)!
            }
            
        }
        
    }()
    
    /// Sets the number of rays to throw per frame when computing signed distance field global illumination. Equivalent to ``ProjectSettings/rendering/globalIllumination/sdfgi/probeRayCount``.
    public static func environmentSetSdfgiRayCount (_ rayCount: RenderingServer.EnvironmentSDFGIRayCount) {
        #if false
        
        var copy_ray_count = Int64 (rayCount.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_sdfgi_ray_count, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_ray_count)
        
        #else
        
        var copy_ray_count = Int64 (rayCount.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_ray_count) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_sdfgi_ray_count, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_sdfgi_frames_to_converge: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_sdfgi_frames_to_converge")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2182444374)!
            }
            
        }
        
    }()
    
    /// Sets the number of frames to use for converging signed distance field global illumination. Equivalent to ``ProjectSettings/rendering/globalIllumination/sdfgi/framesToConverge``.
    public static func environmentSetSdfgiFramesToConverge (frames: RenderingServer.EnvironmentSDFGIFramesToConverge) {
        #if false
        
        var copy_frames = Int64 (frames.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_sdfgi_frames_to_converge, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_frames)
        
        #else
        
        var copy_frames = Int64 (frames.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_frames) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_sdfgi_frames_to_converge, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_sdfgi_frames_to_update_light: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_sdfgi_frames_to_update_light")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1251144068)!
            }
            
        }
        
    }()
    
    /// Sets the update speed for dynamic lights' indirect lighting when computing signed distance field global illumination. Equivalent to ``ProjectSettings/rendering/globalIllumination/sdfgi/framesToUpdateLights``.
    public static func environmentSetSdfgiFramesToUpdateLight (frames: RenderingServer.EnvironmentSDFGIFramesToUpdateLight) {
        #if false
        
        var copy_frames = Int64 (frames.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_sdfgi_frames_to_update_light, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_frames)
        
        #else
        
        var copy_frames = Int64 (frames.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_frames) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_sdfgi_frames_to_update_light, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_volumetric_fog_volume_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_volumetric_fog_volume_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the resolution of the volumetric fog's froxel buffer. `size` is modified by the screen's aspect ratio and then used to set the width and height of the buffer. While `depth` is directly used to set the depth of the buffer.
    public static func environmentSetVolumetricFogVolumeSize (_ size: Int32, depth: Int32) {
        #if false
        
        var copy_size: Int = Int (size)
        var copy_depth: Int = Int (depth)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_volumetric_fog_volume_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_size, &copy_depth)
        
        #else
        
        var copy_size: Int = Int (size)
        var copy_depth: Int = Int (depth)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_depth) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_volumetric_fog_volume_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_environment_set_volumetric_fog_filter_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_set_volumetric_fog_filter_active")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Enables filtering of the volumetric fog scattering buffer. This results in much smoother volumes with very few under-sampling artifacts.
    public static func environmentSetVolumetricFogFilterActive (_ active: Bool) {
        #if false
        
        var copy_active = active
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_set_volumetric_fog_filter_active, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_active)
        
        #else
        
        var copy_active = active
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_active) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_environment_set_volumetric_fog_filter_active, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_environment_bake_panorama: GDExtensionMethodBindPtr = {
        let methodName = StringName ("environment_bake_panorama")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2452908646)!
            }
            
        }
        
    }()
    
    /// Generates and returns an ``Image`` containing the radiance map for the specified `environment` RID's sky. This supports built-in sky material and custom sky shaders. If `bakeIrradiance` is `true`, the irradiance map is saved instead of the radiance map. The radiance map is used to render reflected light, while the irradiance map is used to render ambient light. See also ``skyBakePanorama(sky:energy:bakeIrradiance:size:)``.
    /// 
    /// > Note: The image is saved in linear color space without any tonemapping performed, which means it will look too dark if viewed directly in an image editor.
    /// 
    /// > Note: `size` should be a 2:1 aspect ratio for the generated panorama to have square pixels. For radiance maps, there is no point in using a height greater than ``Sky/radianceSize``, as it won't increase detail. Irradiance maps only contain low-frequency data, so there is usually no point in going past a size of 128×64 pixels when saving an irradiance map.
    /// 
    public static func environmentBakePanorama (environment: RID, bakeIrradiance: Bool, size: Vector2i)-> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_bake_irradiance = bakeIrradiance
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_environment_bake_panorama, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &environment.content, &copy_bake_irradiance, &copy_size)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_bake_irradiance = bakeIrradiance
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &environment.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_bake_irradiance) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_size) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_environment_bake_panorama, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_screen_space_roughness_limiter_set_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_space_roughness_limiter_set_active")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 916716790)!
            }
            
        }
        
    }()
    
    /// Sets the screen-space roughness limiter parameters, such as whether it should be enabled and its thresholds. Equivalent to ``ProjectSettings/rendering/antiAliasing/screenSpaceRoughnessLimiter/enabled``, ``ProjectSettings/rendering/antiAliasing/screenSpaceRoughnessLimiter/amount`` and ``ProjectSettings/rendering/antiAliasing/screenSpaceRoughnessLimiter/limit``.
    public static func screenSpaceRoughnessLimiterSetActive (enable: Bool, amount: Double, limit: Double) {
        #if false
        
        var copy_enable = enable
        var copy_amount = amount
        var copy_limit = limit
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_screen_space_roughness_limiter_set_active, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_enable, &copy_amount, &copy_limit)
        
        #else
        
        var copy_enable = enable
        var copy_amount = amount
        var copy_limit = limit
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_amount) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_limit) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_screen_space_roughness_limiter_set_active, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_sub_surface_scattering_set_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("sub_surface_scattering_set_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 64571803)!
            }
            
        }
        
    }()
    
    /// Sets ``ProjectSettings/rendering/environment/subsurfaceScattering/subsurfaceScatteringQuality`` to use when rendering materials that have subsurface scattering enabled.
    public static func subSurfaceScatteringSetQuality (_ quality: RenderingServer.SubSurfaceScatteringQuality) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_sub_surface_scattering_set_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_sub_surface_scattering_set_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_sub_surface_scattering_set_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("sub_surface_scattering_set_scale")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1017552074)!
            }
            
        }
        
    }()
    
    /// Sets the ``ProjectSettings/rendering/environment/subsurfaceScattering/subsurfaceScatteringScale`` and ``ProjectSettings/rendering/environment/subsurfaceScattering/subsurfaceScatteringDepthScale`` to use when rendering materials that have subsurface scattering enabled.
    public static func subSurfaceScatteringSetScale (_ scale: Double, depthScale: Double) {
        #if false
        
        var copy_scale = scale
        var copy_depth_scale = depthScale
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_sub_surface_scattering_set_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_scale, &copy_depth_scale)
        
        #else
        
        var copy_scale = scale
        var copy_depth_scale = depthScale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_scale) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_depth_scale) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_sub_surface_scattering_set_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_attributes_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_attributes_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a camera attributes object and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `camera_attributes_` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``CameraAttributes``.
    /// 
    public static func cameraAttributesCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_camera_attributes_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_camera_attributes_set_dof_blur_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_attributes_set_dof_blur_quality")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2220136795)!
            }
            
        }
        
    }()
    
    /// Sets the quality level of the DOF blur effect to one of the options in ``RenderingServer/DOFBlurQuality``. `useJitter` can be used to jitter samples taken during the blur pass to hide artifacts at the cost of looking more fuzzy.
    public static func cameraAttributesSetDofBlurQuality (_ quality: RenderingServer.DOFBlurQuality, useJitter: Bool) {
        #if false
        
        var copy_quality = Int64 (quality.rawValue)
        var copy_use_jitter = useJitter
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_attributes_set_dof_blur_quality, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_quality, &copy_use_jitter)
        
        #else
        
        var copy_quality = Int64 (quality.rawValue)
        var copy_use_jitter = useJitter
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quality) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_use_jitter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_camera_attributes_set_dof_blur_quality, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_attributes_set_dof_blur_bokeh_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_attributes_set_dof_blur_bokeh_shape")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1205058394)!
            }
            
        }
        
    }()
    
    /// Sets the shape of the DOF bokeh pattern. Different shapes may be used to achieve artistic effect, or to meet performance targets. For more detail on available options see ``RenderingServer/DOFBokehShape``.
    public static func cameraAttributesSetDofBlurBokehShape (_ shape: RenderingServer.DOFBokehShape) {
        #if false
        
        var copy_shape = Int64 (shape.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_attributes_set_dof_blur_bokeh_shape, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_shape)
        
        #else
        
        var copy_shape = Int64 (shape.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_shape) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_camera_attributes_set_dof_blur_bokeh_shape, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_camera_attributes_set_dof_blur: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_attributes_set_dof_blur")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 316272616)!
            }
            
        }
        
    }()
    
    /// Sets the parameters to use with the DOF blur effect. These parameters take on the same meaning as their counterparts in ``CameraAttributesPractical``.
    public static func cameraAttributesSetDofBlur (cameraAttributes: RID, farEnable: Bool, farDistance: Double, farTransition: Double, nearEnable: Bool, nearDistance: Double, nearTransition: Double, amount: Double) {
        #if false
        
        var copy_far_enable = farEnable
        var copy_far_distance = farDistance
        var copy_far_transition = farTransition
        var copy_near_enable = nearEnable
        var copy_near_distance = nearDistance
        var copy_near_transition = nearTransition
        var copy_amount = amount
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_attributes_set_dof_blur, UnsafeMutableRawPointer (mutating: shared.handle), nil, &cameraAttributes.content, &copy_far_enable, &copy_far_distance, &copy_far_transition, &copy_near_enable, &copy_near_distance, &copy_near_transition, &copy_amount)
        
        #else
        
        var copy_far_enable = farEnable
        var copy_far_distance = farDistance
        var copy_far_transition = farTransition
        var copy_near_enable = nearEnable
        var copy_near_distance = nearDistance
        var copy_near_transition = nearTransition
        var copy_amount = amount
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &cameraAttributes.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_far_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_far_distance) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_far_transition) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_near_enable) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_near_distance) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_near_transition) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_amount) { p7 in
                                        _args.append (p7)
        
                                        gi.object_method_bind_ptrcall (RenderingServer.method_camera_attributes_set_dof_blur, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_attributes_set_exposure: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_attributes_set_exposure")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2513314492)!
            }
            
        }
        
    }()
    
    /// Sets the exposure values that will be used by the renderers. The normalization amount is used to bake a given Exposure Value (EV) into rendering calculations to reduce the dynamic range of the scene.
    /// 
    /// The normalization factor can be calculated from exposure value (EV100) as follows:
    /// 
    /// The exposure value can be calculated from aperture (in f-stops), shutter speed (in seconds), and sensitivity (in ISO) as follows:
    /// 
    public static func cameraAttributesSetExposure (cameraAttributes: RID, multiplier: Double, normalization: Double) {
        #if false
        
        var copy_multiplier = multiplier
        var copy_normalization = normalization
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_attributes_set_exposure, UnsafeMutableRawPointer (mutating: shared.handle), nil, &cameraAttributes.content, &copy_multiplier, &copy_normalization)
        
        #else
        
        var copy_multiplier = multiplier
        var copy_normalization = normalization
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &cameraAttributes.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_multiplier) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_normalization) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_camera_attributes_set_exposure, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_camera_attributes_set_auto_exposure: GDExtensionMethodBindPtr = {
        let methodName = StringName ("camera_attributes_set_auto_exposure")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4266986332)!
            }
            
        }
        
    }()
    
    /// Sets the parameters to use with the auto-exposure effect. These parameters take on the same meaning as their counterparts in ``CameraAttributes`` and ``CameraAttributesPractical``.
    public static func cameraAttributesSetAutoExposure (cameraAttributes: RID, enable: Bool, minSensitivity: Double, maxSensitivity: Double, speed: Double, scale: Double) {
        #if false
        
        var copy_enable = enable
        var copy_min_sensitivity = minSensitivity
        var copy_max_sensitivity = maxSensitivity
        var copy_speed = speed
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_camera_attributes_set_auto_exposure, UnsafeMutableRawPointer (mutating: shared.handle), nil, &cameraAttributes.content, &copy_enable, &copy_min_sensitivity, &copy_max_sensitivity, &copy_speed, &copy_scale)
        
        #else
        
        var copy_enable = enable
        var copy_min_sensitivity = minSensitivity
        var copy_max_sensitivity = maxSensitivity
        var copy_speed = speed
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &cameraAttributes.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_min_sensitivity) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_max_sensitivity) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_speed) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_scale) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_camera_attributes_set_auto_exposure, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_scenario_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scenario_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a scenario and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `scenario_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// The scenario is the 3D world that all the visual instances exist in.
    /// 
    public static func scenarioCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_scenario_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_scenario_set_environment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scenario_set_environment")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the environment that will be used with this scenario. See also ``Environment``.
    public static func scenarioSetEnvironment (scenario: RID, environment: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_scenario_set_environment, UnsafeMutableRawPointer (mutating: shared.handle), nil, &scenario.content, &environment.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &scenario.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &environment.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_scenario_set_environment, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_scenario_set_fallback_environment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scenario_set_fallback_environment")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the fallback environment to be used by this scenario. The fallback environment is used if no environment is set. Internally, this is used by the editor to provide a default environment.
    public static func scenarioSetFallbackEnvironment (scenario: RID, environment: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_scenario_set_fallback_environment, UnsafeMutableRawPointer (mutating: shared.handle), nil, &scenario.content, &environment.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &scenario.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &environment.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_scenario_set_fallback_environment, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_scenario_set_camera_attributes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scenario_set_camera_attributes")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the camera attributes (`effects`) that will be used with this scenario. See also ``CameraAttributes``.
    public static func scenarioSetCameraAttributes (scenario: RID, effects: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_scenario_set_camera_attributes, UnsafeMutableRawPointer (mutating: shared.handle), nil, &scenario.content, &effects.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &scenario.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &effects.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_scenario_set_camera_attributes, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_create2: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_create2")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 746547085)!
            }
            
        }
        
    }()
    
    /// Creates a visual instance, adds it to the RenderingServer, and sets both base and scenario. It can be accessed with the RID that is returned. This RID will be used in all `instance_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method. This is a shorthand for using ``instanceCreate()`` and setting the base and scenario manually.
    /// 
    public static func instanceCreate2 (base: RID, scenario: RID)-> RID {
        let _result: RID = RID ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_create2, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &base.content, &scenario.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &base.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &scenario.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_create2, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a visual instance and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `instance_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// An instance is a way of placing a 3D object in the scenario. Objects like particles, meshes, reflection probes and decals need to be associated with an instance to be visible in the scenario using ``instanceSetBase(instance:base:)``.
    /// 
    /// > Note: The equivalent node is ``VisualInstance3D``.
    /// 
    public static func instanceCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_instance_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_instance_set_base: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_base")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the base of the instance. A base can be any of the 3D objects that are created in the RenderingServer that can be displayed. For example, any of the light types, mesh, multimesh, particle system, reflection probe, decal, lightmap, voxel GI and visibility notifiers are all types that can be set as the base of an instance in order to be displayed in the scenario.
    public static func instanceSetBase (instance: RID, base: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_base, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &base.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &base.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_base, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_scenario: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_scenario")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the scenario that the instance is in. The scenario is the 3D world that the objects will be displayed in.
    public static func instanceSetScenario (instance: RID, scenario: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_scenario, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &scenario.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &scenario.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_scenario, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_layer_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_layer_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the render layers that this instance will be drawn to. Equivalent to ``VisualInstance3D/layers``.
    public static func instanceSetLayerMask (instance: RID, mask: UInt32) {
        #if false
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_layer_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_layer_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_pivot_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_pivot_data")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1280615259)!
            }
            
        }
        
    }()
    
    /// Sets the sorting offset and switches between using the bounding box or instance origin for depth sorting.
    public static func instanceSetPivotData (instance: RID, sortingOffset: Double, useAabbCenter: Bool) {
        #if false
        
        var copy_sorting_offset = sortingOffset
        var copy_use_aabb_center = useAabbCenter
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_pivot_data, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_sorting_offset, &copy_use_aabb_center)
        
        #else
        
        var copy_sorting_offset = sortingOffset
        var copy_use_aabb_center = useAabbCenter
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_sorting_offset) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_use_aabb_center) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_pivot_data, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3935195649)!
            }
            
        }
        
    }()
    
    /// Sets the world space transform of the instance. Equivalent to ``Node3D/transform``.
    public static func instanceSetTransform (instance: RID, transform: Transform3D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_attach_object_instance_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_attach_object_instance_id")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Attaches a unique Object ID to instance. Object ID must be attached to instance for proper culling with ``instancesCullAabb(_:scenario:)``, ``instancesCullConvex(_:scenario:)``, and ``instancesCullRay(from:to:scenario:)``.
    public static func instanceAttachObjectInstanceId (instance: RID, id: UInt) {
        #if false
        
        var copy_id = id
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_attach_object_instance_id, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_id)
        
        #else
        
        var copy_id = id
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_attach_object_instance_id, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_blend_shape_weight: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_blend_shape_weight")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets the weight for a given blend shape associated with this instance.
    public static func instanceSetBlendShapeWeight (instance: RID, shape: Int32, weight: Double) {
        #if false
        
        var copy_shape: Int = Int (shape)
        var copy_weight = weight
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_blend_shape_weight, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_shape, &copy_weight)
        
        #else
        
        var copy_shape: Int = Int (shape)
        var copy_weight = weight
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_shape) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_weight) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_blend_shape_weight, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_surface_override_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_surface_override_material")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2310537182)!
            }
            
        }
        
    }()
    
    /// Sets the override material of a specific surface. Equivalent to ``MeshInstance3D/setSurfaceOverrideMaterial(surface:material:)``.
    public static func instanceSetSurfaceOverrideMaterial (instance: RID, surface: Int32, material: RID) {
        #if false
        
        var copy_surface: Int = Int (surface)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_surface_override_material, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_surface, &material.content)
        
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_surface) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &material.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_surface_override_material, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_visible")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Sets whether an instance is drawn or not. Equivalent to ``Node3D/visible``.
    public static func instanceSetVisible (instance: RID, visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_visible, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_visible) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_visible, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_transparency: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_transparency")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the transparency for the given geometry instance. Equivalent to ``GeometryInstance3D/transparency``.
    /// 
    /// A transparency of `0.0` is fully opaque, while `1.0` is fully transparent. Values greater than `0.0` (exclusive) will force the geometry's materials to go through the transparent pipeline, which is slower to render and can exhibit rendering issues due to incorrect transparency sorting. However, unlike using a transparent material, setting `transparency` to a value greater than `0.0` (exclusive) will _not_ disable shadow rendering.
    /// 
    /// In spatial shaders, `1.0 - transparency` is set as the default value of the `ALPHA` built-in.
    /// 
    /// > Note: `transparency` is clamped between `0.0` and `1.0`, so this property cannot be used to make transparent materials more opaque than they originally are.
    /// 
    public static func instanceGeometrySetTransparency (instance: RID, transparency: Double) {
        #if false
        
        var copy_transparency = transparency
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_transparency, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_transparency)
        
        #else
        
        var copy_transparency = transparency
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transparency) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_transparency, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_custom_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_custom_aabb")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3696536120)!
            }
            
        }
        
    }()
    
    /// Sets a custom AABB to use when culling objects from the view frustum. Equivalent to setting ``GeometryInstance3D/customAabb``.
    public static func instanceSetCustomAabb (instance: RID, aabb: AABB) {
        #if false
        
        var copy_aabb = aabb
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_custom_aabb, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_aabb)
        
        #else
        
        var copy_aabb = aabb
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_aabb) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_custom_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_attach_skeleton: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_attach_skeleton")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Attaches a skeleton to an instance. Removes the previous skeleton from the instance.
    public static func instanceAttachSkeleton (instance: RID, skeleton: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_attach_skeleton, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &skeleton.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &skeleton.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_attach_skeleton, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_extra_visibility_margin: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_extra_visibility_margin")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets a margin to increase the size of the AABB when culling objects from the view frustum. This allows you to avoid culling objects that fall outside the view frustum. Equivalent to ``GeometryInstance3D/extraCullMargin``.
    public static func instanceSetExtraVisibilityMargin (instance: RID, margin: Double) {
        #if false
        
        var copy_margin = margin
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_extra_visibility_margin, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_margin)
        
        #else
        
        var copy_margin = margin
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_margin) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_extra_visibility_margin, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_visibility_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_visibility_parent")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the visibility parent for the given instance. Equivalent to ``Node3D/visibilityParent``.
    public static func instanceSetVisibilityParent (instance: RID, parent: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_visibility_parent, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &parent.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &parent.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_visibility_parent, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_set_ignore_culling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_set_ignore_culling")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `true`, ignores both frustum and occlusion culling on the specified 3D geometry instance. This is not the same as ``GeometryInstance3D/ignoreOcclusionCulling``, which only ignores occlusion culling and leaves frustum culling intact.
    public static func instanceSetIgnoreCulling (instance: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_set_ignore_culling, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_set_ignore_culling, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_flag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_flag")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1014989537)!
            }
            
        }
        
    }()
    
    /// Sets the flag for a given ``RenderingServer/InstanceFlags``. See ``RenderingServer/InstanceFlags`` for more details.
    public static func instanceGeometrySetFlag (instance: RID, flag: RenderingServer.InstanceFlags, enabled: Bool) {
        #if false
        
        var copy_flag = Int64 (flag.rawValue)
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_flag, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_flag, &copy_enabled)
        
        #else
        
        var copy_flag = Int64 (flag.rawValue)
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_flag) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_enabled) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_flag, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_cast_shadows_setting: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_cast_shadows_setting")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3768836020)!
            }
            
        }
        
    }()
    
    /// Sets the shadow casting setting to one of ``RenderingServer/ShadowCastingSetting``. Equivalent to ``GeometryInstance3D/castShadow``.
    public static func instanceGeometrySetCastShadowsSetting (instance: RID, shadowCastingSetting: RenderingServer.ShadowCastingSetting) {
        #if false
        
        var copy_shadow_casting_setting = Int64 (shadowCastingSetting.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_cast_shadows_setting, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_shadow_casting_setting)
        
        #else
        
        var copy_shadow_casting_setting = Int64 (shadowCastingSetting.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_shadow_casting_setting) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_cast_shadows_setting, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_material_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_material_override")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a material that will override the material for all surfaces on the mesh associated with this instance. Equivalent to ``GeometryInstance3D/materialOverride``.
    public static func instanceGeometrySetMaterialOverride (instance: RID, material: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_material_override, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &material.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &material.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_material_override, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_material_overlay: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_material_overlay")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a material that will be rendered for all surfaces on top of active materials for the mesh associated with this instance. Equivalent to ``GeometryInstance3D/materialOverlay``.
    public static func instanceGeometrySetMaterialOverlay (instance: RID, material: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_material_overlay, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &material.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &material.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_material_overlay, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_visibility_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_visibility_range")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4263925858)!
            }
            
        }
        
    }()
    
    /// Sets the visibility range values for the given geometry instance. Equivalent to ``GeometryInstance3D/visibilityRangeBegin`` and related properties.
    public static func instanceGeometrySetVisibilityRange (instance: RID, min: Double, max: Double, minMargin: Double, maxMargin: Double, fadeMode: RenderingServer.VisibilityRangeFadeMode) {
        #if false
        
        var copy_min = min
        var copy_max = max
        var copy_min_margin = minMargin
        var copy_max_margin = maxMargin
        var copy_fade_mode = Int64 (fadeMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_visibility_range, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_min, &copy_max, &copy_min_margin, &copy_max_margin, &copy_fade_mode)
        
        #else
        
        var copy_min = min
        var copy_max = max
        var copy_min_margin = minMargin
        var copy_max_margin = maxMargin
        var copy_fade_mode = Int64 (fadeMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_min) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_max) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_min_margin) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_max_margin) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_fade_mode) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_visibility_range, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_lightmap: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_lightmap")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 536974962)!
            }
            
        }
        
    }()
    
    /// Sets the lightmap GI instance to use for the specified 3D geometry instance. The lightmap UV scale for the specified instance (equivalent to ``GeometryInstance3D/giLightmapScale``) and lightmap atlas slice must also be specified.
    public static func instanceGeometrySetLightmap (instance: RID, lightmap: RID, lightmapUvScale: Rect2, lightmapSlice: Int32) {
        #if false
        
        var copy_lightmap_uv_scale = lightmapUvScale
        var copy_lightmap_slice: Int = Int (lightmapSlice)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_lightmap, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &lightmap.content, &copy_lightmap_uv_scale, &copy_lightmap_slice)
        
        #else
        
        var copy_lightmap_uv_scale = lightmapUvScale
        var copy_lightmap_slice: Int = Int (lightmapSlice)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &lightmap.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_lightmap_uv_scale) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_lightmap_slice) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_lightmap, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_lod_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_lod_bias")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the level of detail bias to use when rendering the specified 3D geometry instance. Higher values result in higher detail from further away. Equivalent to ``GeometryInstance3D/lodBias``.
    public static func instanceGeometrySetLodBias (instance: RID, lodBias: Double) {
        #if false
        
        var copy_lod_bias = lodBias
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_lod_bias, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &copy_lod_bias)
        
        #else
        
        var copy_lod_bias = lodBias
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_lod_bias) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_lod_bias, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_set_shader_parameter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_set_shader_parameter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3477296213)!
            }
            
        }
        
    }()
    
    /// Sets the per-instance shader uniform on the specified 3D geometry instance. Equivalent to ``GeometryInstance3D/setInstanceShaderParameter(name:value:)``.
    public static func instanceGeometrySetShaderParameter (instance: RID, parameter: StringName, value: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_set_shader_parameter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &instance.content, &parameter.content, &value.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &parameter.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &value.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_set_shader_parameter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_get_shader_parameter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_get_shader_parameter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2621281810)!
            }
            
        }
        
    }()
    
    /// Returns the value of the per-instance shader uniform from the specified 3D geometry instance. Equivalent to ``GeometryInstance3D/getInstanceShaderParameter(name:)``.
    /// 
    /// > Note: Per-instance shader parameter names are case-sensitive.
    /// 
    public static func instanceGeometryGetShaderParameter (instance: RID, parameter: StringName)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_get_shader_parameter, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &instance.content, &parameter.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &parameter.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_get_shader_parameter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_get_shader_parameter_default_value: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_get_shader_parameter_default_value")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2621281810)!
            }
            
        }
        
    }()
    
    /// Returns the default value of the per-instance shader uniform from the specified 3D geometry instance. Equivalent to ``GeometryInstance3D/getInstanceShaderParameter(name:)``.
    public static func instanceGeometryGetShaderParameterDefaultValue (instance: RID, parameter: StringName)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_get_shader_parameter_default_value, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &instance.content, &parameter.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &parameter.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_get_shader_parameter_default_value, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instance_geometry_get_shader_parameter_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instance_geometry_get_shader_parameter_list")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns a dictionary of per-instance shader uniform names of the per-instance shader uniform from the specified 3D geometry instance. The returned dictionary is in PropertyInfo format, with the keys `name`, `class_name`, `type`, `hint`, `hint_string` and `usage`. Equivalent to ``GeometryInstance3D/getInstanceShaderParameter(name:)``.
    public static func instanceGeometryGetShaderParameterList (instance: RID)-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instance_geometry_get_shader_parameter_list, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &instance.content)
        return VariantCollection<GDictionary>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_instance_geometry_get_shader_parameter_list, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return VariantCollection<GDictionary>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_instances_cull_aabb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instances_cull_aabb")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2570105777)!
            }
            
        }
        
    }()
    
    /// Returns an array of object IDs intersecting with the provided AABB. Only 3D nodes that inherit from ``VisualInstance3D`` are considered, such as ``MeshInstance3D`` or ``DirectionalLight3D``. Use ``@GlobalScope.instance_from_id`` to obtain the actual nodes. A scenario RID must be provided, which is available in the ``World3D`` you want to query. This forces an update for all resources queued to update.
    /// 
    /// > Warning: This function is primarily intended for editor usage. For in-game use cases, prefer physics collision.
    /// 
    public static func instancesCullAabb (_ aabb: AABB, scenario: RID = RID())-> PackedInt64Array {
        let _result: PackedInt64Array = PackedInt64Array ()
        #if false
        
        var copy_aabb = aabb
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instances_cull_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_aabb, &scenario.content)
        return _result
        #else
        
        var copy_aabb = aabb
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_aabb) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &scenario.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instances_cull_aabb, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instances_cull_ray: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instances_cull_ray")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2208759584)!
            }
            
        }
        
    }()
    
    /// Returns an array of object IDs intersecting with the provided 3D ray. Only 3D nodes that inherit from ``VisualInstance3D`` are considered, such as ``MeshInstance3D`` or ``DirectionalLight3D``. Use ``@GlobalScope.instance_from_id`` to obtain the actual nodes. A scenario RID must be provided, which is available in the ``World3D`` you want to query. This forces an update for all resources queued to update.
    /// 
    /// > Warning: This function is primarily intended for editor usage. For in-game use cases, prefer physics collision.
    /// 
    public static func instancesCullRay (from: Vector3, to: Vector3, scenario: RID = RID())-> PackedInt64Array {
        let _result: PackedInt64Array = PackedInt64Array ()
        #if false
        
        var copy_from = from
        var copy_to = to
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instances_cull_ray, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_from, &copy_to, &scenario.content)
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &scenario.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_instances_cull_ray, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_instances_cull_convex: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instances_cull_convex")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2488539944)!
            }
            
        }
        
    }()
    
    /// Returns an array of object IDs intersecting with the provided convex shape. Only 3D nodes that inherit from ``VisualInstance3D`` are considered, such as ``MeshInstance3D`` or ``DirectionalLight3D``. Use ``@GlobalScope.instance_from_id`` to obtain the actual nodes. A scenario RID must be provided, which is available in the ``World3D`` you want to query. This forces an update for all resources queued to update.
    /// 
    /// > Warning: This function is primarily intended for editor usage. For in-game use cases, prefer physics collision.
    /// 
    public static func instancesCullConvex (_ convex: VariantCollection<Plane>, scenario: RID = RID())-> PackedInt64Array {
        let _result: PackedInt64Array = PackedInt64Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_instances_cull_convex, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &convex.array.content, &scenario.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &convex.array.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &scenario.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_instances_cull_convex, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_bake_render_uv2: GDExtensionMethodBindPtr = {
        let methodName = StringName ("bake_render_uv2")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1904608558)!
            }
            
        }
        
    }()
    
    /// Bakes the material data of the Mesh passed in the `base` parameter with optional `materialOverrides` to a set of ``Image``s of size `imageSize`. Returns an array of ``Image``s containing material properties as specified in ``RenderingServer/BakeChannels``.
    public static func bakeRenderUv2 (base: RID, materialOverrides: VariantCollection<RID>, imageSize: Vector2i)-> ObjectCollection<Image> {
        var _result: Int64 = 0
        #if false
        
        var copy_image_size = imageSize
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_bake_render_uv2, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &base.content, &materialOverrides.array.content, &copy_image_size)
        return ObjectCollection<Image>(content: _result)
        #else
        
        var copy_image_size = imageSize
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &base.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &materialOverrides.array.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_image_size) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_bake_render_uv2, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    return ObjectCollection<Image>(content: _result)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a canvas and returns the assigned ``RID``. It can be accessed with the RID that is returned. This RID will be used in all `canvas_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// Canvas has no ``Resource`` or ``Node`` equivalent.
    /// 
    public static func canvasCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_canvas_set_item_mirroring: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_set_item_mirroring")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2343975398)!
            }
            
        }
        
    }()
    
    /// A copy of the canvas item will be drawn with a local offset of the mirroring ``Vector2``.
    public static func canvasSetItemMirroring (canvas: RID, item: RID, mirroring: Vector2) {
        #if false
        
        var copy_mirroring = mirroring
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_set_item_mirroring, UnsafeMutableRawPointer (mutating: shared.handle), nil, &canvas.content, &item.content, &copy_mirroring)
        
        #else
        
        var copy_mirroring = mirroring
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &canvas.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &item.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_mirroring) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_set_item_mirroring, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_set_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_set_modulate")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Modulates all colors in the given canvas.
    public static func canvasSetModulate (canvas: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_set_modulate, UnsafeMutableRawPointer (mutating: shared.handle), nil, &canvas.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &canvas.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_set_modulate, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_set_disable_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_set_disable_scale")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// 
    public static func canvasSetDisableScale (disable: Bool) {
        #if false
        
        var copy_disable = disable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_set_disable_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_disable)
        
        #else
        
        var copy_disable = disable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_disable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_set_disable_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_texture_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_texture_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a canvas texture and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `canvas_texture_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method. See also ``texture2dCreate(image:)``.
    /// 
    /// > Note: The equivalent resource is ``CanvasTexture`` and is only meant to be used in 2D rendering, not 3D.
    /// 
    public static func canvasTextureCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_texture_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_canvas_texture_set_channel: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_texture_set_channel")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3822119138)!
            }
            
        }
        
    }()
    
    /// Sets the `channel`'s `texture` for the canvas texture specified by the `canvasTexture` RID. Equivalent to ``CanvasTexture/diffuseTexture``, ``CanvasTexture/normalTexture`` and ``CanvasTexture/specularTexture``.
    public static func canvasTextureSetChannel (canvasTexture: RID, channel: RenderingServer.CanvasTextureChannel, texture: RID) {
        #if false
        
        var copy_channel = Int64 (channel.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_texture_set_channel, UnsafeMutableRawPointer (mutating: shared.handle), nil, &canvasTexture.content, &copy_channel, &texture.content)
        
        #else
        
        var copy_channel = Int64 (channel.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &canvasTexture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_channel) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_texture_set_channel, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_texture_set_shading_parameters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_texture_set_shading_parameters")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2124967469)!
            }
            
        }
        
    }()
    
    /// Sets the `baseColor` and `shininess` to use for the canvas texture specified by the `canvasTexture` RID. Equivalent to ``CanvasTexture/specularColor`` and ``CanvasTexture/specularShininess``.
    public static func canvasTextureSetShadingParameters (canvasTexture: RID, baseColor: Color, shininess: Double) {
        #if false
        
        var copy_base_color = baseColor
        var copy_shininess = shininess
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_texture_set_shading_parameters, UnsafeMutableRawPointer (mutating: shared.handle), nil, &canvasTexture.content, &copy_base_color, &copy_shininess)
        
        #else
        
        var copy_base_color = baseColor
        var copy_shininess = shininess
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &canvasTexture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_base_color) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_shininess) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_texture_set_shading_parameters, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_texture_set_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_texture_set_texture_filter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1155129294)!
            }
            
        }
        
    }()
    
    /// Sets the texture `filter` mode to use for the canvas texture specified by the `canvasTexture` RID.
    public static func canvasTextureSetTextureFilter (canvasTexture: RID, filter: RenderingServer.CanvasItemTextureFilter) {
        #if false
        
        var copy_filter = Int64 (filter.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_texture_set_texture_filter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &canvasTexture.content, &copy_filter)
        
        #else
        
        var copy_filter = Int64 (filter.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &canvasTexture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_filter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_texture_set_texture_filter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_texture_set_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_texture_set_texture_repeat")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1652956681)!
            }
            
        }
        
    }()
    
    /// Sets the texture `repeat` mode to use for the canvas texture specified by the `canvasTexture` RID.
    public static func canvasTextureSetTextureRepeat (canvasTexture: RID, `repeat`: RenderingServer.CanvasItemTextureRepeat) {
        #if false
        
        var copy_repeat = Int64 (`repeat`.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_texture_set_texture_repeat, UnsafeMutableRawPointer (mutating: shared.handle), nil, &canvasTexture.content, &copy_repeat)
        
        #else
        
        var copy_repeat = Int64 (`repeat`.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &canvasTexture.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_repeat) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_texture_set_texture_repeat, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new CanvasItem instance and returns its ``RID``. It can be accessed with the RID that is returned. This RID will be used in all `canvas_item_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent node is ``CanvasItem``.
    /// 
    public static func canvasItemCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_canvas_item_set_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_parent")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a parent ``CanvasItem`` to the ``CanvasItem``. The item will inherit transform, modulation and visibility from its parent, like ``CanvasItem`` nodes in the scene tree.
    public static func canvasItemSetParent (item: RID, parent: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_parent, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &parent.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &parent.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_parent, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_default_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_default_texture_filter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1155129294)!
            }
            
        }
        
    }()
    
    /// Sets the default texture filter mode for the canvas item specified by the `item` RID. Equivalent to ``CanvasItem/textureFilter``.
    public static func canvasItemSetDefaultTextureFilter (item: RID, filter: RenderingServer.CanvasItemTextureFilter) {
        #if false
        
        var copy_filter = Int64 (filter.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_default_texture_filter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_filter)
        
        #else
        
        var copy_filter = Int64 (filter.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_filter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_default_texture_filter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_default_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_default_texture_repeat")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1652956681)!
            }
            
        }
        
    }()
    
    /// Sets the default texture repeat mode for the canvas item specified by the `item` RID. Equivalent to ``CanvasItem/textureRepeat``.
    public static func canvasItemSetDefaultTextureRepeat (item: RID, `repeat`: RenderingServer.CanvasItemTextureRepeat) {
        #if false
        
        var copy_repeat = Int64 (`repeat`.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_default_texture_repeat, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_repeat)
        
        #else
        
        var copy_repeat = Int64 (`repeat`.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_repeat) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_default_texture_repeat, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_visible")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Sets the visibility of the ``CanvasItem``.
    public static func canvasItemSetVisible (item: RID, visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_visible, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_visible) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_visible, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_light_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_light_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the light `mask` for the canvas item specified by the `item` RID. Equivalent to ``CanvasItem/lightMask``.
    public static func canvasItemSetLightMask (item: RID, mask: Int32) {
        #if false
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_light_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_light_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_visibility_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_visibility_layer")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the rendering visibility layer associated with this ``CanvasItem``. Only ``Viewport`` nodes with a matching rendering mask will render this ``CanvasItem``.
    public static func canvasItemSetVisibilityLayer (item: RID, visibilityLayer: UInt32) {
        #if false
        
        var copy_visibility_layer: Int = Int (visibilityLayer)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_visibility_layer, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_visibility_layer)
        
        #else
        
        var copy_visibility_layer: Int = Int (visibilityLayer)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_visibility_layer) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_visibility_layer, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1246044741)!
            }
            
        }
        
    }()
    
    /// Sets the `transform` of the canvas item specified by the `item` RID. This affects where and how the item will be drawn. Child canvas items' transforms are multiplied by their parent's transform. Equivalent to ``Node2D/transform``.
    public static func canvasItemSetTransform (item: RID, transform: Transform2D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_clip: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_clip")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `clip` is `true`, makes the canvas item specified by the `item` RID not draw anything outside of its rect's coordinates. This clipping is fast, but works only with axis-aligned rectangles. This means that rotation is ignored by the clipping rectangle. For more advanced clipping shapes, use ``canvasItemSetCanvasGroupMode(item:mode:clearMargin:fitEmpty:fitMargin:blurMipmaps:)`` instead.
    /// 
    /// > Note: The equivalent node functionality is found in ``Label/clipText``, ``RichTextLabel`` (always enabled) and more.
    /// 
    public static func canvasItemSetClip (item: RID, clip: Bool) {
        #if false
        
        var copy_clip = clip
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_clip, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_clip)
        
        #else
        
        var copy_clip = clip
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_clip) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_clip, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_distance_field_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_distance_field_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `enabled` is `true`, enables multichannel signed distance field rendering mode for the canvas item specified by the `item` RID. This is meant to be used for font rendering, or with specially generated images using [url=https://github.com/Chlumsky/msdfgen]msdfgen[/url].
    public static func canvasItemSetDistanceFieldMode (item: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_distance_field_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_distance_field_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_custom_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_custom_rect")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1333997032)!
            }
            
        }
        
    }()
    
    /// If `useCustomRect` is `true`, sets the custom visibility rectangle (used for culling) to `rect` for the canvas item specified by `item`. Setting a custom visibility rect can reduce CPU load when drawing lots of 2D instances. If `useCustomRect` is `false`, automatically computes a visibility rectangle based on the canvas item's draw commands.
    public static func canvasItemSetCustomRect (item: RID, useCustomRect: Bool, rect: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0)) {
        #if false
        
        var copy_use_custom_rect = useCustomRect
        var copy_rect = rect
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_custom_rect, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_use_custom_rect, &copy_rect)
        
        #else
        
        var copy_use_custom_rect = useCustomRect
        var copy_rect = rect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_use_custom_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_rect) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_custom_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_modulate")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Multiplies the color of the canvas item specified by the `item` RID, while affecting its children. See also ``canvasItemSetSelfModulate(item:color:)``. Equivalent to ``CanvasItem/modulate``.
    public static func canvasItemSetModulate (item: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_modulate, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_modulate, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_self_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_self_modulate")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Multiplies the color of the canvas item specified by the `item` RID, without affecting its children. See also ``canvasItemSetModulate(item:color:)``. Equivalent to ``CanvasItem/selfModulate``.
    public static func canvasItemSetSelfModulate (item: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_self_modulate, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_self_modulate, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_draw_behind_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_draw_behind_parent")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `enabled` is `true`, draws the canvas item specified by the `item` RID behind its parent. Equivalent to ``CanvasItem/showBehindParent``.
    public static func canvasItemSetDrawBehindParent (item: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_draw_behind_parent, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_draw_behind_parent, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_line")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1819681853)!
            }
            
        }
        
    }()
    
    /// Draws a line on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawLine(from:to:color:width:antialiased:)``.
    public static func canvasItemAddLine (item: RID, from: Vector2, to: Vector2, color: Color, width: Double = -1.0, antialiased: Bool = false) {
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_color = color
        var copy_width = width
        var copy_antialiased = antialiased
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_line, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_from, &copy_to, &copy_color, &copy_width, &copy_antialiased)
        
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_color = color
        var copy_width = width
        var copy_antialiased = antialiased
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_from) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_to) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_color) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_width) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_antialiased) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_line, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_polyline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_polyline")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3098767073)!
            }
            
        }
        
    }()
    
    /// Draws a 2D polyline on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawPolyline(points:color:width:antialiased:)`` and ``CanvasItem/drawPolylineColors(points:colors:width:antialiased:)``.
    public static func canvasItemAddPolyline (item: RID, points: PackedVector2Array, colors: PackedColorArray, width: Double = -1.0, antialiased: Bool = false) {
        #if false
        
        var copy_width = width
        var copy_antialiased = antialiased
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_polyline, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &points.content, &colors.content, &copy_width, &copy_antialiased)
        
        #else
        
        var copy_width = width
        var copy_antialiased = antialiased
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &points.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &colors.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_width) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_antialiased) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_polyline, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_multiline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_multiline")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2088642721)!
            }
            
        }
        
    }()
    
    /// Draws a 2D multiline on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawMultiline(points:color:width:)`` and ``CanvasItem/drawMultilineColors(points:colors:width:)``.
    public static func canvasItemAddMultiline (item: RID, points: PackedVector2Array, colors: PackedColorArray, width: Double = -1.0) {
        #if false
        
        var copy_width = width
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_multiline, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &points.content, &colors.content, &copy_width)
        
        #else
        
        var copy_width = width
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &points.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &colors.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_width) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_multiline, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_rect")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 934531857)!
            }
            
        }
        
    }()
    
    /// Draws a rectangle on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawRect(_:color:filled:width:)``.
    public static func canvasItemAddRect (item: RID, rect: Rect2, color: Color) {
        #if false
        
        var copy_rect = rect
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_rect, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_rect, &copy_color)
        
        #else
        
        var copy_rect = rect
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_color) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_circle: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_circle")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2439351960)!
            }
            
        }
        
    }()
    
    /// Draws a circle on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawCircle(position:radius:color:)``.
    public static func canvasItemAddCircle (item: RID, pos: Vector2, radius: Double, color: Color) {
        #if false
        
        var copy_pos = pos
        var copy_radius = radius
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_circle, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_pos, &copy_radius, &copy_color)
        
        #else
        
        var copy_pos = pos
        var copy_radius = radius
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_radius) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_color) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_circle, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_texture_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_texture_rect")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 324864032)!
            }
            
        }
        
    }()
    
    /// Draws a 2D textured rectangle on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawTextureRect(texture:rect:tile:modulate:transpose:)`` and ``Texture2D/drawRect(canvasItem:rect:tile:modulate:transpose:)``.
    public static func canvasItemAddTextureRect (item: RID, rect: Rect2, texture: RID, tile: Bool = false, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), transpose: Bool = false) {
        #if false
        
        var copy_rect = rect
        var copy_tile = tile
        var copy_modulate = modulate
        var copy_transpose = transpose
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_texture_rect, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_rect, &texture.content, &copy_tile, &copy_modulate, &copy_transpose)
        
        #else
        
        var copy_rect = rect
        var copy_tile = tile
        var copy_modulate = modulate
        var copy_transpose = transpose
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_tile) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_modulate) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_transpose) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_texture_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_msdf_texture_rect_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_msdf_texture_rect_region")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 97408773)!
            }
            
        }
        
    }()
    
    /// See also ``CanvasItem/drawMsdfTextureRectRegion(texture:rect:srcRect:modulate:outline:pixelRange:scale:)``.
    public static func canvasItemAddMsdfTextureRectRegion (item: RID, rect: Rect2, texture: RID, srcRect: Rect2, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), outlineSize: Int32 = 0, pxRange: Double = 1.0, scale: Double = 1.0) {
        #if false
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_outline_size: Int = Int (outlineSize)
        var copy_px_range = pxRange
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_msdf_texture_rect_region, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_rect, &texture.content, &copy_src_rect, &copy_modulate, &copy_outline_size, &copy_px_range, &copy_scale)
        
        #else
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_outline_size: Int = Int (outlineSize)
        var copy_px_range = pxRange
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_src_rect) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_modulate) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_outline_size) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_px_range) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_scale) { p7 in
                                        _args.append (p7)
        
                                        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_msdf_texture_rect_region, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_lcd_texture_rect_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_lcd_texture_rect_region")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 359793297)!
            }
            
        }
        
    }()
    
    /// See also ``CanvasItem/drawLcdTextureRectRegion(texture:rect:srcRect:modulate:)``.
    public static func canvasItemAddLcdTextureRectRegion (item: RID, rect: Rect2, texture: RID, srcRect: Rect2, modulate: Color) {
        #if false
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_lcd_texture_rect_region, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_rect, &texture.content, &copy_src_rect, &copy_modulate)
        
        #else
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_src_rect) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_modulate) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_lcd_texture_rect_region, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_texture_rect_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_texture_rect_region")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 485157892)!
            }
            
        }
        
    }()
    
    /// Draws the specified region of a 2D textured rectangle on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawTextureRectRegion(texture:rect:srcRect:modulate:transpose:clipUv:)`` and ``Texture2D/drawRectRegion(canvasItem:rect:srcRect:modulate:transpose:clipUv:)``.
    public static func canvasItemAddTextureRectRegion (item: RID, rect: Rect2, texture: RID, srcRect: Rect2, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), transpose: Bool = false, clipUv: Bool = true) {
        #if false
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_transpose = transpose
        var copy_clip_uv = clipUv
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_texture_rect_region, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_rect, &texture.content, &copy_src_rect, &copy_modulate, &copy_transpose, &copy_clip_uv)
        
        #else
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_transpose = transpose
        var copy_clip_uv = clipUv
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_src_rect) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_modulate) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_transpose) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_clip_uv) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_texture_rect_region, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_nine_patch: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_nine_patch")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 389957886)!
            }
            
        }
        
    }()
    
    /// Draws a nine-patch rectangle on the ``CanvasItem`` pointed to by the `item` ``RID``.
    public static func canvasItemAddNinePatch (item: RID, rect: Rect2, source: Rect2, texture: RID, topleft: Vector2, bottomright: Vector2, xAxisMode: RenderingServer.NinePatchAxisMode = .stretch, yAxisMode: RenderingServer.NinePatchAxisMode = .stretch, drawCenter: Bool = true, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_rect = rect
        var copy_source = source
        var copy_topleft = topleft
        var copy_bottomright = bottomright
        var copy_x_axis_mode = Int64 (xAxisMode.rawValue)
        var copy_y_axis_mode = Int64 (yAxisMode.rawValue)
        var copy_draw_center = drawCenter
        var copy_modulate = modulate
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_nine_patch, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_rect, &copy_source, &texture.content, &copy_topleft, &copy_bottomright, &copy_x_axis_mode, &copy_y_axis_mode, &copy_draw_center, &copy_modulate)
        
        #else
        
        var copy_rect = rect
        var copy_source = source
        var copy_topleft = topleft
        var copy_bottomright = bottomright
        var copy_x_axis_mode = Int64 (xAxisMode.rawValue)
        var copy_y_axis_mode = Int64 (yAxisMode.rawValue)
        var copy_draw_center = drawCenter
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_source) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &texture.content) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_topleft) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_bottomright) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_x_axis_mode) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_y_axis_mode) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_draw_center) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_modulate) { p9 in
                                                _args.append (p9)
        
                                                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_nine_patch, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_primitive: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_primitive")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3731601077)!
            }
            
        }
        
    }()
    
    /// Draws a 2D primitive on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawPrimitive(points:colors:uvs:texture:)``.
    public static func canvasItemAddPrimitive (item: RID, points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array, texture: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_primitive, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &points.content, &colors.content, &uvs.content, &texture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &points.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &colors.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &uvs.content) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &texture.content) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_primitive, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_polygon")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3580000528)!
            }
            
        }
        
    }()
    
    /// Draws a 2D polygon on the ``CanvasItem`` pointed to by the `item` ``RID``. If you need more flexibility (such as being able to use bones), use ``canvasItemAddTriangleArray(item:indices:points:colors:uvs:bones:weights:texture:count:)`` instead. See also ``CanvasItem/drawPolygon(points:colors:uvs:texture:)``.
    public static func canvasItemAddPolygon (item: RID, points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array = PackedVector2Array(), texture: RID = RID()) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_polygon, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &points.content, &colors.content, &uvs.content, &texture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &points.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &colors.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &uvs.content) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &texture.content) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_triangle_array: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_triangle_array")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 660261329)!
            }
            
        }
        
    }()
    
    /// Draws a triangle array on the ``CanvasItem`` pointed to by the `item` ``RID``. This is internally used by ``Line2D`` and ``StyleBoxFlat`` for rendering. ``canvasItemAddTriangleArray(item:indices:points:colors:uvs:bones:weights:texture:count:)`` is highly flexible, but more complex to use than ``canvasItemAddPolygon(item:points:colors:uvs:texture:)``.
    /// 
    /// > Note: `count` is unused and can be left unspecified.
    /// 
    public static func canvasItemAddTriangleArray (item: RID, indices: PackedInt32Array, points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array = PackedVector2Array(), bones: PackedInt32Array = PackedInt32Array(), weights: PackedFloat32Array = PackedFloat32Array(), texture: RID = RID(), count: Int32 = -1) {
        #if false
        
        var copy_count: Int = Int (count)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_triangle_array, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &indices.content, &points.content, &colors.content, &uvs.content, &bones.content, &weights.content, &texture.content, &copy_count)
        
        #else
        
        var copy_count: Int = Int (count)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &indices.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &points.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &colors.content) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &uvs.content) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &bones.content) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &weights.content) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &texture.content) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_count) { p8 in
                                            _args.append (p8)
        
                                            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_triangle_array, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_mesh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 316450961)!
            }
            
        }
        
    }()
    
    /// Draws a mesh created with ``meshCreate()`` with given `transform`, `modulate` color, and `texture`. This is used internally by ``MeshInstance2D``.
    public static func canvasItemAddMesh (item: RID, mesh: RID, transform: Transform2D = Transform2D (xAxis: Vector2 (x: 1, y: 0), yAxis: Vector2 (x: 0, y: 1), origin: Vector2 (x: 0, y: 0)), modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), texture: RID = RID()) {
        #if false
        
        var copy_transform = transform
        var copy_modulate = modulate
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_mesh, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &mesh.content, &copy_transform, &copy_modulate, &texture.content)
        
        #else
        
        var copy_transform = transform
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &mesh.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_transform) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_modulate) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &texture.content) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_multimesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_multimesh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2131855138)!
            }
            
        }
        
    }()
    
    /// Draws a 2D ``MultiMesh`` on the ``CanvasItem`` pointed to by the `item` ``RID``. See also ``CanvasItem/drawMultimesh(_:texture:)``.
    public static func canvasItemAddMultimesh (item: RID, mesh: RID, texture: RID = RID()) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_multimesh, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &mesh.content, &texture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &mesh.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_multimesh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_particles: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_particles")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2575754278)!
            }
            
        }
        
    }()
    
    /// Draws particles on the ``CanvasItem`` pointed to by the `item` ``RID``.
    public static func canvasItemAddParticles (item: RID, particles: RID, texture: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_particles, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &particles.content, &texture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &particles.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &texture.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_particles, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_set_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1246044741)!
            }
            
        }
        
    }()
    
    /// Sets a ``Transform2D`` that will be used to transform subsequent canvas item commands.
    public static func canvasItemAddSetTransform (item: RID, transform: Transform2D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_clip_ignore: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_clip_ignore")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `ignore` is `true`, ignore clipping on items drawn with this canvas item until this is called again with `ignore` set to false.
    public static func canvasItemAddClipIgnore (item: RID, ignore: Bool) {
        #if false
        
        var copy_ignore = ignore
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_clip_ignore, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_ignore)
        
        #else
        
        var copy_ignore = ignore
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_ignore) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_clip_ignore, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_add_animation_slice: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_add_animation_slice")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2646834499)!
            }
            
        }
        
    }()
    
    /// Subsequent drawing commands will be ignored unless they fall within the specified animation slice. This is a faster way to implement animations that loop on background rather than redrawing constantly.
    public static func canvasItemAddAnimationSlice (item: RID, animationLength: Double, sliceBegin: Double, sliceEnd: Double, offset: Double = 0.0) {
        #if false
        
        var copy_animation_length = animationLength
        var copy_slice_begin = sliceBegin
        var copy_slice_end = sliceEnd
        var copy_offset = offset
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_add_animation_slice, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_animation_length, &copy_slice_begin, &copy_slice_end, &copy_offset)
        
        #else
        
        var copy_animation_length = animationLength
        var copy_slice_begin = sliceBegin
        var copy_slice_end = sliceEnd
        var copy_offset = offset
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_animation_length) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_slice_begin) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_slice_end) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_offset) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_add_animation_slice, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_sort_children_by_y: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_sort_children_by_y")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If `enabled` is `true`, child nodes with the lowest Y position are drawn before those with a higher Y position. Y-sorting only affects children that inherit from the canvas item specified by the `item` RID, not the canvas item itself. Equivalent to ``CanvasItem/ySortEnabled``.
    public static func canvasItemSetSortChildrenByY (item: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_sort_children_by_y, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_sort_children_by_y, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_z_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_z_index")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the ``CanvasItem``'s Z index, i.e. its draw order (lower indexes are drawn first).
    public static func canvasItemSetZIndex (item: RID, zIndex: Int32) {
        #if false
        
        var copy_z_index: Int = Int (zIndex)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_z_index, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_z_index)
        
        #else
        
        var copy_z_index: Int = Int (zIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_z_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_z_index, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_z_as_relative_to_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_z_as_relative_to_parent")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If this is enabled, the Z index of the parent will be added to the children's Z index.
    public static func canvasItemSetZAsRelativeToParent (item: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_z_as_relative_to_parent, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_z_as_relative_to_parent, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_copy_to_backbuffer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_copy_to_backbuffer")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2429202503)!
            }
            
        }
        
    }()
    
    /// Sets the ``CanvasItem`` to copy a rect to the backbuffer.
    public static func canvasItemSetCopyToBackbuffer (item: RID, enabled: Bool, rect: Rect2) {
        #if false
        
        var copy_enabled = enabled
        var copy_rect = rect
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_copy_to_backbuffer, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_enabled, &copy_rect)
        
        #else
        
        var copy_enabled = enabled
        var copy_rect = rect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_rect) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_copy_to_backbuffer, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_clear")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Clears the ``CanvasItem`` and removes all commands in it.
    public static func canvasItemClear (item: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_clear, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_clear, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_draw_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_draw_index")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the index for the ``CanvasItem``.
    public static func canvasItemSetDrawIndex (item: RID, index: Int32) {
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_draw_index, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_draw_index, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_material")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a new `material` to the canvas item specified by the `item` RID. Equivalent to ``CanvasItem/material``.
    public static func canvasItemSetMaterial (item: RID, material: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_material, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &material.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &material.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_material, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_use_parent_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_use_parent_material")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Sets if the ``CanvasItem`` uses its parent's material.
    public static func canvasItemSetUseParentMaterial (item: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_use_parent_material, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_use_parent_material, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_visibility_notifier: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_visibility_notifier")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3568945579)!
            }
            
        }
        
    }()
    
    /// Sets the given ``CanvasItem`` as visibility notifier. `area` defines the area of detecting visibility. `enterCallable` is called when the ``CanvasItem`` enters the screen, `exitCallable` is called when the ``CanvasItem`` exits the screen. If `enable` is `false`, the item will no longer function as notifier.
    /// 
    /// This method can be used to manually mimic ``VisibleOnScreenNotifier2D``.
    /// 
    public static func canvasItemSetVisibilityNotifier (item: RID, enable: Bool, area: Rect2, enterCallable: Callable, exitCallable: Callable) {
        #if false
        
        var copy_enable = enable
        var copy_area = area
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_visibility_notifier, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_enable, &copy_area, &enterCallable.content, &exitCallable.content)
        
        #else
        
        var copy_enable = enable
        var copy_area = area
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_area) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &enterCallable.content) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &exitCallable.content) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_visibility_notifier, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_item_set_canvas_group_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_item_set_canvas_group_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3973586316)!
            }
            
        }
        
    }()
    
    /// Sets the canvas group mode used during 2D rendering for the canvas item specified by the `item` RID. For faster but more limited clipping, use ``canvasItemSetClip(item:clip:)`` instead.
    /// 
    /// > Note: The equivalent node functionality is found in ``CanvasGroup`` and ``CanvasItem/clipChildren``.
    /// 
    public static func canvasItemSetCanvasGroupMode (item: RID, mode: RenderingServer.CanvasGroupMode, clearMargin: Double = 5.0, fitEmpty: Bool = false, fitMargin: Double = 0.0, blurMipmaps: Bool = false) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        var copy_clear_margin = clearMargin
        var copy_fit_empty = fitEmpty
        var copy_fit_margin = fitMargin
        var copy_blur_mipmaps = blurMipmaps
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_item_set_canvas_group_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &item.content, &copy_mode, &copy_clear_margin, &copy_fit_empty, &copy_fit_margin, &copy_blur_mipmaps)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var copy_clear_margin = clearMargin
        var copy_fit_empty = fitEmpty
        var copy_fit_margin = fitMargin
        var copy_blur_mipmaps = blurMipmaps
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &item.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_clear_margin) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_fit_empty) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_fit_margin) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_blur_mipmaps) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_item_set_canvas_group_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a canvas light and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `canvas_light_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent node is ``Light2D``.
    /// 
    public static func canvasLightCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_canvas_light_attach_to_canvas: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_attach_to_canvas")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Attaches the canvas light to the canvas. Removes it from its previous canvas.
    public static func canvasLightAttachToCanvas (light: RID, canvas: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_attach_to_canvas, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &canvas.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_attach_to_canvas, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_enabled")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Enables or disables a canvas light.
    public static func canvasLightSetEnabled (light: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_enabled, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_enabled, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_texture_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_texture_scale")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets the scale factor of a ``PointLight2D``'s texture. Equivalent to ``PointLight2D/textureScale``.
    public static func canvasLightSetTextureScale (light: RID, scale: Double) {
        #if false
        
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_texture_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_scale)
        
        #else
        
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_scale) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_texture_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1246044741)!
            }
            
        }
        
    }()
    
    /// Sets the canvas light's ``Transform2D``.
    public static func canvasLightSetTransform (light: RID, transform: Transform2D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_texture")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets the texture to be used by a ``PointLight2D``. Equivalent to ``PointLight2D/texture``.
    public static func canvasLightSetTexture (light: RID, texture: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_texture, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &texture.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &texture.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_texture, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_texture_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_texture_offset")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3201125042)!
            }
            
        }
        
    }()
    
    /// Sets the offset of a ``PointLight2D``'s texture. Equivalent to ``PointLight2D/offset``.
    public static func canvasLightSetTextureOffset (light: RID, offset: Vector2) {
        #if false
        
        var copy_offset = offset
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_texture_offset, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_offset)
        
        #else
        
        var copy_offset = offset
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_offset) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_texture_offset, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Sets the color for a light.
    public static func canvasLightSetColor (light: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_color, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_height: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_height")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets a canvas light's height.
    public static func canvasLightSetHeight (light: RID, height: Double) {
        #if false
        
        var copy_height = height
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_height, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_height)
        
        #else
        
        var copy_height = height
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_height) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_height, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_energy")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets a canvas light's energy.
    public static func canvasLightSetEnergy (light: RID, energy: Double) {
        #if false
        
        var copy_energy = energy
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_energy, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_energy)
        
        #else
        
        var copy_energy = energy
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_energy) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_energy, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_z_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_z_range")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4288446313)!
            }
            
        }
        
    }()
    
    /// Sets the Z range of objects that will be affected by this light. Equivalent to ``Light2D/rangeZMin`` and ``Light2D/rangeZMax``.
    public static func canvasLightSetZRange (light: RID, minZ: Int32, maxZ: Int32) {
        #if false
        
        var copy_min_z: Int = Int (minZ)
        var copy_max_z: Int = Int (maxZ)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_z_range, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_min_z, &copy_max_z)
        
        #else
        
        var copy_min_z: Int = Int (minZ)
        var copy_max_z: Int = Int (maxZ)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_min_z) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_max_z) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_z_range, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_layer_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_layer_range")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4288446313)!
            }
            
        }
        
    }()
    
    /// The layer range that gets rendered with this light.
    public static func canvasLightSetLayerRange (light: RID, minLayer: Int32, maxLayer: Int32) {
        #if false
        
        var copy_min_layer: Int = Int (minLayer)
        var copy_max_layer: Int = Int (maxLayer)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_layer_range, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_min_layer, &copy_max_layer)
        
        #else
        
        var copy_min_layer: Int = Int (minLayer)
        var copy_max_layer: Int = Int (maxLayer)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_min_layer) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_max_layer) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_layer_range, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_item_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_item_cull_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// The light mask. See ``LightOccluder2D`` for more information on light masks.
    public static func canvasLightSetItemCullMask (light: RID, mask: Int32) {
        #if false
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_item_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_item_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_item_shadow_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_item_shadow_cull_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// The binary mask used to determine which layers this canvas light's shadows affects. See ``LightOccluder2D`` for more information on light masks.
    public static func canvasLightSetItemShadowCullMask (light: RID, mask: Int32) {
        #if false
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_item_shadow_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_item_shadow_cull_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2957564891)!
            }
            
        }
        
    }()
    
    /// The mode of the light, see ``RenderingServer/CanvasLightMode`` constants.
    public static func canvasLightSetMode (light: RID, mode: RenderingServer.CanvasLightMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_shadow_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_shadow_enabled")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Enables or disables the canvas light's shadow.
    public static func canvasLightSetShadowEnabled (light: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_shadow_enabled, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_shadow_enabled, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_shadow_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_shadow_filter")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 393119659)!
            }
            
        }
        
    }()
    
    /// Sets the canvas light's shadow's filter, see ``RenderingServer/CanvasLightShadowFilter`` constants.
    public static func canvasLightSetShadowFilter (light: RID, filter: RenderingServer.CanvasLightShadowFilter) {
        #if false
        
        var copy_filter = Int64 (filter.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_shadow_filter, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_filter)
        
        #else
        
        var copy_filter = Int64 (filter.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_filter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_shadow_filter, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_shadow_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_shadow_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2948539648)!
            }
            
        }
        
    }()
    
    /// Sets the color of the canvas light's shadow.
    public static func canvasLightSetShadowColor (light: RID, color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_shadow_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_shadow_color, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_shadow_smooth: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_shadow_smooth")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Smoothens the shadow. The lower, the smoother.
    public static func canvasLightSetShadowSmooth (light: RID, smooth: Double) {
        #if false
        
        var copy_smooth = smooth
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_shadow_smooth, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_smooth)
        
        #else
        
        var copy_smooth = smooth
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_smooth) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_shadow_smooth, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_set_blend_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_set_blend_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 804895945)!
            }
            
        }
        
    }()
    
    /// Sets the blend mode for the given canvas light. See ``RenderingServer/CanvasLightBlendMode`` for options. Equivalent to ``Light2D/blendMode``.
    public static func canvasLightSetBlendMode (light: RID, mode: RenderingServer.CanvasLightBlendMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_set_blend_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &light.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &light.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_set_blend_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_occluder_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_occluder_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a light occluder and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `canvas_light_occluder_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent node is ``LightOccluder2D``.
    /// 
    public static func canvasLightOccluderCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_occluder_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_canvas_light_occluder_attach_to_canvas: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_occluder_attach_to_canvas")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Attaches a light occluder to the canvas. Removes it from its previous canvas.
    public static func canvasLightOccluderAttachToCanvas (occluder: RID, canvas: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_occluder_attach_to_canvas, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluder.content, &canvas.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluder.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_occluder_attach_to_canvas, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_occluder_set_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_occluder_set_enabled")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// Enables or disables light occluder.
    public static func canvasLightOccluderSetEnabled (occluder: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_occluder_set_enabled, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluder.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluder.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_occluder_set_enabled, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_occluder_set_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_occluder_set_polygon")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 395945892)!
            }
            
        }
        
    }()
    
    /// Sets a light occluder's polygon.
    public static func canvasLightOccluderSetPolygon (occluder: RID, polygon: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_occluder_set_polygon, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluder.content, &polygon.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluder.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &polygon.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_occluder_set_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_occluder_set_as_sdf_collision: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_occluder_set_as_sdf_collision")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// 
    public static func canvasLightOccluderSetAsSdfCollision (occluder: RID, enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_occluder_set_as_sdf_collision, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluder.content, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluder.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_occluder_set_as_sdf_collision, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_occluder_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_occluder_set_transform")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1246044741)!
            }
            
        }
        
    }()
    
    /// Sets a light occluder's ``Transform2D``.
    public static func canvasLightOccluderSetTransform (occluder: RID, transform: Transform2D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_occluder_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluder.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluder.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_occluder_set_transform, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_light_occluder_set_light_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_light_occluder_set_light_mask")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// The light mask. See ``LightOccluder2D`` for more information on light masks.
    public static func canvasLightOccluderSetLightMask (occluder: RID, mask: Int32) {
        #if false
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_light_occluder_set_light_mask, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluder.content, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluder.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_light_occluder_set_light_mask, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_occluder_polygon_create: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_occluder_polygon_create")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new light occluder polygon and adds it to the RenderingServer. It can be accessed with the RID that is returned. This RID will be used in all `canvas_occluder_polygon_*` RenderingServer functions.
    /// 
    /// Once finished with your RID, you will want to free the RID using the RenderingServer's ``freeRid(_:)`` method.
    /// 
    /// > Note: The equivalent resource is ``OccluderPolygon2D``.
    /// 
    public static func canvasOccluderPolygonCreate ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_canvas_occluder_polygon_create, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_canvas_occluder_polygon_set_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_occluder_polygon_set_shape")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2103882027)!
            }
            
        }
        
    }()
    
    /// Sets the shape of the occluder polygon.
    public static func canvasOccluderPolygonSetShape (occluderPolygon: RID, shape: PackedVector2Array, closed: Bool) {
        #if false
        
        var copy_closed = closed
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_occluder_polygon_set_shape, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluderPolygon.content, &shape.content, &copy_closed)
        
        #else
        
        var copy_closed = closed
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluderPolygon.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &shape.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_closed) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_canvas_occluder_polygon_set_shape, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_occluder_polygon_set_cull_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_occluder_polygon_set_cull_mode")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1839404663)!
            }
            
        }
        
    }()
    
    /// Sets an occluder polygons cull mode. See ``RenderingServer/CanvasOccluderPolygonCullMode`` constants.
    public static func canvasOccluderPolygonSetCullMode (occluderPolygon: RID, mode: RenderingServer.CanvasOccluderPolygonCullMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_occluder_polygon_set_cull_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &occluderPolygon.content, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &occluderPolygon.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_canvas_occluder_polygon_set_cull_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_canvas_set_shadow_texture_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("canvas_set_shadow_texture_size")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the ``ProjectSettings/rendering/2d/shadowAtlas/size`` to use for ``Light2D`` shadow rendering (in pixels). The value is rounded up to the nearest power of 2.
    public static func canvasSetShadowTextureSize (_ size: Int32) {
        #if false
        
        var copy_size: Int = Int (size)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_canvas_set_shadow_texture_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_size)
        
        #else
        
        var copy_size: Int = Int (size)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_canvas_set_shadow_texture_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_global_shader_parameter_add: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_shader_parameter_add")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 463390080)!
            }
            
        }
        
    }()
    
    /// Creates a new global shader uniform.
    /// 
    /// > Note: Global shader parameter names are case-sensitive.
    /// 
    public static func globalShaderParameterAdd (name: StringName, type: RenderingServer.GlobalShaderParameterType, defaultValue: Variant) {
        #if false
        
        var copy_type = Int64 (type.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_global_shader_parameter_add, UnsafeMutableRawPointer (mutating: shared.handle), nil, &name.content, &copy_type, &defaultValue.content)
        
        #else
        
        var copy_type = Int64 (type.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_type) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &defaultValue.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_global_shader_parameter_add, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_shader_parameter_remove: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_shader_parameter_remove")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes the global shader uniform specified by `name`.
    public static func globalShaderParameterRemove (name: StringName) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_global_shader_parameter_remove, UnsafeMutableRawPointer (mutating: shared.handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_global_shader_parameter_remove, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_global_shader_parameter_get_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_shader_parameter_get_list")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns the list of global shader uniform names.
    /// 
    /// > Note: ``globalShaderParameterGet(name:)`` has a large performance penalty as the rendering thread needs to synchronize with the calling thread, which is slow. Do not use this method during gameplay to avoid stuttering. If you need to read values in a script after setting them, consider creating an autoload where you store the values you need to query at the same time you're setting them as global parameters.
    /// 
    public static func globalShaderParameterGetList ()-> VariantCollection<StringName> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (RenderingServer.method_global_shader_parameter_get_list, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return VariantCollection<StringName>(content: _result)
    }
    
    fileprivate static var method_global_shader_parameter_set: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_shader_parameter_set")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3776071444)!
            }
            
        }
        
    }()
    
    /// Sets the global shader uniform `name` to `value`.
    public static func globalShaderParameterSet (name: StringName, value: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_global_shader_parameter_set, UnsafeMutableRawPointer (mutating: shared.handle), nil, &name.content, &value.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &value.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_global_shader_parameter_set, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_shader_parameter_set_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_shader_parameter_set_override")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3776071444)!
            }
            
        }
        
    }()
    
    /// Overrides the global shader uniform `name` with `value`. Equivalent to the ``ShaderGlobalsOverride`` node.
    public static func globalShaderParameterSetOverride (name: StringName, value: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_global_shader_parameter_set_override, UnsafeMutableRawPointer (mutating: shared.handle), nil, &name.content, &value.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &value.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_global_shader_parameter_set_override, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_shader_parameter_get: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_shader_parameter_get")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2760726917)!
            }
            
        }
        
    }()
    
    /// Returns the value of the global shader uniform specified by `name`.
    /// 
    /// > Note: ``globalShaderParameterGet(name:)`` has a large performance penalty as the rendering thread needs to synchronize with the calling thread, which is slow. Do not use this method during gameplay to avoid stuttering. If you need to read values in a script after setting them, consider creating an autoload where you store the values you need to query at the same time you're setting them as global parameters.
    /// 
    public static func globalShaderParameterGet (name: StringName)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_global_shader_parameter_get, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_global_shader_parameter_get, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_global_shader_parameter_get_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_shader_parameter_get_type")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1601414142)!
            }
            
        }
        
    }()
    
    /// Returns the type associated to the global shader uniform specified by `name`.
    /// 
    /// > Note: ``globalShaderParameterGet(name:)`` has a large performance penalty as the rendering thread needs to synchronize with the calling thread, which is slow. Do not use this method during gameplay to avoid stuttering. If you need to read values in a script after setting them, consider creating an autoload where you store the values you need to query at the same time you're setting them as global parameters.
    /// 
    public static func globalShaderParameterGetType (name: StringName)-> RenderingServer.GlobalShaderParameterType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_global_shader_parameter_get_type, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &name.content)
        return RenderingServer.GlobalShaderParameterType (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_global_shader_parameter_get_type, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return RenderingServer.GlobalShaderParameterType (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_free_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("free_rid")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Tries to free an object in the RenderingServer. To avoid memory leaks, this should be called after using an object as memory management does not occur automatically when using RenderingServer directly.
    public static func freeRid (_ rid: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_free_rid, UnsafeMutableRawPointer (mutating: shared.handle), nil, &rid.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &rid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_free_rid, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_request_frame_drawn_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("request_frame_drawn_callback")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1611583062)!
            }
            
        }
        
    }()
    
    /// Schedules a callback to the given callable after a frame has been drawn.
    public static func requestFrameDrawnCallback (callable: Callable) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_request_frame_drawn_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &callable.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callable.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_request_frame_drawn_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_has_changed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_changed")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if changes have been made to the RenderingServer's data. ``forceDraw(swapBuffers:frameStep:)`` is usually called if this happens.
    public static func hasChanged ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RenderingServer.method_has_changed, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_rendering_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_rendering_info")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3763192241)!
            }
            
        }
        
    }()
    
    /// Returns a statistic about the rendering engine which can be used for performance profiling. See ``RenderingServer.RenderingInfo`` for a list of values that can be queried. See also ``viewportGetRenderInfo(viewport:type:info:)``, which returns information specific to a viewport.
    /// 
    /// > Note: Only 3D rendering is currently taken into account by some of these values, such as the number of draw calls.
    /// 
    /// > Note: Rendering information is not available until at least 2 frames have been rendered by the engine. If rendering information is not available, ``getRenderingInfo(_:)`` returns `0`. To print rendering information in `_ready()` successfully, use the following:
    /// 
    public static func getRenderingInfo (_ info: RenderingServer.RenderingInfo)-> UInt {
        var _result: UInt = 0
        #if false
        
        var copy_info = Int64 (info.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_get_rendering_info, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_info)
        return _result
        #else
        
        var copy_info = Int64 (info.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_info) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_get_rendering_info, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_video_adapter_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_video_adapter_name")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the name of the video adapter (e.g. "GeForce GTX 1080/PCIe/SSE2").
    /// 
    /// > Note: When running a headless or server binary, this function returns an empty string.
    /// 
    /// > Note: On the web platform, some browsers such as Firefox may report a different, fixed GPU name such as "GeForce GTX 980" (regardless of the user's actual GPU model). This is done to make fingerprinting more difficult.
    /// 
    public static func getVideoAdapterName ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (RenderingServer.method_get_video_adapter_name, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_video_adapter_vendor: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_video_adapter_vendor")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the vendor of the video adapter (e.g. "NVIDIA Corporation").
    /// 
    /// > Note: When running a headless or server binary, this function returns an empty string.
    /// 
    public static func getVideoAdapterVendor ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (RenderingServer.method_get_video_adapter_vendor, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_video_adapter_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_video_adapter_type")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3099547011)!
            }
            
        }
        
    }()
    
    /// Returns the type of the video adapter. Since dedicated graphics cards from a given generation will _usually_ be significantly faster than integrated graphics made in the same generation, the device type can be used as a basis for automatic graphics settings adjustment. However, this is not always true, so make sure to provide users with a way to manually override graphics settings.
    /// 
    /// > Note: When using the OpenGL backend or when running in headless mode, this function always returns ``RenderingDevice/DeviceType/other``.
    /// 
    public static func getVideoAdapterType ()-> RenderingDevice.DeviceType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (RenderingServer.method_get_video_adapter_type, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return RenderingDevice.DeviceType (rawValue: _result)!
    }
    
    fileprivate static var method_get_video_adapter_api_version: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_video_adapter_api_version")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the version of the graphics video adapter _currently in use_ (e.g. "1.2.189" for Vulkan, "3.3.0 NVIDIA 510.60.02" for OpenGL). This version may be different from the actual latest version supported by the hardware, as Godot may not always request the latest version. See also ``OS/getVideoAdapterDriverInfo()``.
    /// 
    /// > Note: When running a headless or server binary, this function returns an empty string.
    /// 
    public static func getVideoAdapterApiVersion ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (RenderingServer.method_get_video_adapter_api_version, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_make_sphere_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("make_sphere_mesh")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2251015897)!
            }
            
        }
        
    }()
    
    /// Returns a mesh of a sphere with the given number of horizontal subdivisions, vertical subdivisions and radius. See also ``getTestCube()``.
    public static func makeSphereMesh (latitudes: Int32, longitudes: Int32, radius: Double)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_latitudes: Int = Int (latitudes)
        var copy_longitudes: Int = Int (longitudes)
        var copy_radius = radius
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_make_sphere_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_latitudes, &copy_longitudes, &copy_radius)
        return _result
        #else
        
        var copy_latitudes: Int = Int (latitudes)
        var copy_longitudes: Int = Int (longitudes)
        var copy_radius = radius
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_latitudes) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_longitudes) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_radius) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RenderingServer.method_make_sphere_mesh, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_test_cube: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_test_cube")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Returns the RID of the test cube. This mesh will be created and returned on the first call to ``getTestCube()``, then it will be cached for subsequent calls. See also ``makeSphereMesh(latitudes:longitudes:radius:)``.
    public static func getTestCube ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_get_test_cube, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_test_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_test_texture")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Returns the RID of a 256×256 texture with a testing pattern on it (in ``Image/Format/rgb8`` format). This texture will be created and returned on the first call to ``getTestTexture()``, then it will be cached for subsequent calls. See also ``getWhiteTexture()``.
    /// 
    /// Example of getting the test texture and applying it to a ``Sprite2D`` node:
    /// 
    public static func getTestTexture ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_get_test_texture, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_white_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_white_texture")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Returns the ID of a 4×4 white texture (in ``Image/Format/rgb8`` format). This texture will be created and returned on the first call to ``getWhiteTexture()``, then it will be cached for subsequent calls. See also ``getTestTexture()``.
    /// 
    /// Example of getting the white texture and applying it to a ``Sprite2D`` node:
    /// 
    public static func getWhiteTexture ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (RenderingServer.method_get_white_texture, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_boot_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_boot_image")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3759744527)!
            }
            
        }
        
    }()
    
    /// Sets a boot image. The color defines the background color. If `scale` is `true`, the image will be scaled to fit the screen size. If `useFilter` is `true`, the image will be scaled with linear interpolation. If `useFilter` is `false`, the image will be scaled with nearest-neighbor interpolation.
    public static func setBootImage (_ image: Image?, color: Color, scale: Bool, useFilter: Bool = true) {
        #if false
        
        var copy_color = color
        var copy_scale = scale
        var copy_use_filter = useFilter
        var copy_image_handle = image?.handle
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_set_boot_image, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_image_handle, &copy_color, &copy_scale, &copy_use_filter)
        
        #else
        
        var copy_color = color
        var copy_scale = scale
        var copy_use_filter = useFilter
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: image?.handle) { p0 in
        _args.append (image == nil ? nil : p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_scale) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_use_filter) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RenderingServer.method_set_boot_image, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_default_clear_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_default_clear_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3200896285)!
            }
            
        }
        
    }()
    
    /// Returns the default clear color which is used when a specific clear color has not been selected. See also ``setDefaultClearColor(_:)``.
    public static func getDefaultClearColor ()-> Color {
        var _result: Color = Color ()
        gi.object_method_bind_ptrcall (RenderingServer.method_get_default_clear_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_default_clear_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_default_clear_color")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Sets the default clear color which is used when a specific clear color has not been selected. See also ``getDefaultClearColor()``.
    public static func setDefaultClearColor (_ color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_set_default_clear_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_set_default_clear_color, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_has_feature: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_feature")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 598462696)!
            }
            
        }
        
    }()
    
    /// Not yet implemented. Always returns `false`.
    public static func hasFeature (_ feature: RenderingServer.Features)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_feature = Int64 (feature.rawValue)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_has_feature, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_feature)
        return _result
        #else
        
        var copy_feature = Int64 (feature.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_feature) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_has_feature, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_has_os_feature: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_os_feature")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the OS supports a certain `feature`. Features might be `s3tc`, `etc`, and `etc2`.
    public static func hasOsFeature (_ feature: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_feature = GString (feature)
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_has_os_feature, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_feature.content)
        return _result
        #else
        
        let gstr_feature = GString (feature)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_feature.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_has_os_feature, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_debug_generate_wireframes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_debug_generate_wireframes")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// This method is currently unimplemented and does nothing if called with `generate` set to `true`.
    public static func setDebugGenerateWireframes (generate: Bool) {
        #if false
        
        var copy_generate = generate
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_set_debug_generate_wireframes, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_generate)
        
        #else
        
        var copy_generate = generate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_generate) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_set_debug_generate_wireframes, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_render_loop_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_render_loop_enabled")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func is_render_loop_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RenderingServer.method_is_render_loop_enabled, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_render_loop_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_render_loop_enabled")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate static func set_render_loop_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_set_render_loop_enabled, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_set_render_loop_enabled, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_frame_setup_time_cpu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_frame_setup_time_cpu")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the time taken to setup rendering on the CPU in milliseconds. This value is shared across all viewports and does _not_ require ``viewportSetMeasureRenderTime(viewport:enable:)`` to be enabled on a viewport to be queried. See also ``viewportGetMeasuredRenderTimeCpu(viewport:)``.
    public static func getFrameSetupTimeCpu ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (RenderingServer.method_get_frame_setup_time_cpu, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_force_sync: GDExtensionMethodBindPtr = {
        let methodName = StringName ("force_sync")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Forces a synchronization between the CPU and GPU, which may be required in certain cases. Only call this when needed, as CPU-GPU synchronization has a performance cost.
    public static func forceSync () {
        gi.object_method_bind_ptrcall (RenderingServer.method_force_sync, UnsafeMutableRawPointer (mutating: shared.handle), nil, nil)
    }
    
    fileprivate static var method_force_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("force_draw")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1076185472)!
            }
            
        }
        
    }()
    
    /// Forces redrawing of all viewports at once.
    public static func forceDraw (swapBuffers: Bool = true, frameStep: Double = 0.0) {
        #if false
        
        var copy_swap_buffers = swapBuffers
        var copy_frame_step = frameStep
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_force_draw, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_swap_buffers, &copy_frame_step)
        
        #else
        
        var copy_swap_buffers = swapBuffers
        var copy_frame_step = frameStep
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_swap_buffers) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_frame_step) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RenderingServer.method_force_draw, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_rendering_device: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_rendering_device")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1405107940)!
            }
            
        }
        
    }()
    
    /// Returns the global RenderingDevice.
    /// 
    /// > Note: When using the OpenGL backend or when running in headless mode, this function always returns `null`.
    /// 
    public static func getRenderingDevice ()-> RenderingDevice {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (RenderingServer.method_get_rendering_device, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        guard let _result else { fatalError ("Unexpected nil return from a method that should never return nil") } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_create_local_rendering_device: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_local_rendering_device")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1405107940)!
            }
            
        }
        
    }()
    
    /// Creates a RenderingDevice that can be used to do draw and compute operations on a separate thread. Cannot draw to the screen nor share data with the global RenderingDevice.
    /// 
    /// > Note: When using the OpenGL backend or when running in headless mode, this function always returns `null`.
    /// 
    public static func createLocalRenderingDevice ()-> RenderingDevice? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (RenderingServer.method_create_local_rendering_device, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_call_on_render_thread: GDExtensionMethodBindPtr = {
        let methodName = StringName ("call_on_render_thread")
        return withUnsafePointer (to: &RenderingServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1611583062)!
            }
            
        }
        
    }()
    
    /// As the RenderingServer actual logic may run on an separate thread, accessing its internals from the main (or any other) thread will result in errors. To make it easier to run code that can safely access the rendering internals (such as ``RenderingDevice`` and similar RD classes), push a callable via this function so it will be executed on the render thread.
    public static func callOnRenderThread (callable: Callable) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RenderingServer.method_call_on_render_thread, UnsafeMutableRawPointer (mutating: shared.handle), nil, &callable.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callable.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RenderingServer.method_call_on_render_thread, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    // Signals 
    /// Emitted at the beginning of the frame, before the RenderingServer updates all the Viewports.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.framePreDraw.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var framePreDraw: SimpleSignal { SimpleSignal (target: self, signalName: "frame_pre_draw") }
    
    /// Emitted at the end of the frame, after the RenderingServer has finished updating all the Viewports.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.framePostDraw.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var framePostDraw: SimpleSignal { SimpleSignal (target: self, signalName: "frame_post_draw") }
    
}

