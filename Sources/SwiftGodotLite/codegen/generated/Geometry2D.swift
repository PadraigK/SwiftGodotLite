// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Provides methods for some common 2D geometric operations.
/// 
/// Provides a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations in 2D.
open class Geometry2D: Object {
    /// The shared instance of this class
    public static var shared: Geometry2D = {
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { ptr in
            Geometry2D (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "Geometry2D" }
    public enum PolyBooleanOperation: Int64 {
        /// Create regions where either subject or clip polygons (or both) are filled.
        case union = 0 // OPERATION_UNION
        /// Create regions where subject polygons are filled except where clip polygons are filled.
        case difference = 1 // OPERATION_DIFFERENCE
        /// Create regions where both subject and clip polygons are filled.
        case intersection = 2 // OPERATION_INTERSECTION
        /// Create regions where either subject or clip polygons are filled but not where both are filled.
        case xor = 3 // OPERATION_XOR
    }
    
    public enum PolyJoinType: Int64 {
        /// Squaring is applied uniformally at all convex edge joins at `1 * delta`.
        case square = 0 // JOIN_SQUARE
        /// While flattened paths can never perfectly trace an arc, they are approximated by a series of arc chords.
        case round = 1 // JOIN_ROUND
        /// There's a necessary limit to mitered joins since offsetting edges that join at very acute angles will produce excessively long and narrow "spikes". For any given edge join, when miter offsetting would exceed that maximum distance, "square" joining is applied.
        case miter = 2 // JOIN_MITER
    }
    
    public enum PolyEndType: Int64 {
        /// Endpoints are joined using the ``Geometry2D/PolyJoinType`` value and the path filled as a polygon.
        case polygon = 0 // END_POLYGON
        /// Endpoints are joined using the ``Geometry2D/PolyJoinType`` value and the path filled as a polyline.
        case joined = 1 // END_JOINED
        /// Endpoints are squared off with no extension.
        case butt = 2 // END_BUTT
        /// Endpoints are squared off and extended by `delta` units.
        case square = 3 // END_SQUARE
        /// Endpoints are rounded off and extended by `delta` units.
        case round = 4 // END_ROUND
    }
    
    /* Methods */
    fileprivate static var method_is_point_in_circle: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_point_in_circle")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2929491703)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `point` is inside the circle or if it's located exactly _on_ the circle's boundary, otherwise returns `false`.
    public static func isPointInCircle (point: Vector2, circlePosition: Vector2, circleRadius: Double)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_point = point
        var copy_circle_position = circlePosition
        var copy_circle_radius = circleRadius
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_is_point_in_circle, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_point, &copy_circle_position, &copy_circle_radius)
        return _result
        #else
        
        var copy_point = point
        var copy_circle_position = circlePosition
        var copy_circle_radius = circleRadius
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_point) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_circle_position) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_circle_radius) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Geometry2D.method_is_point_in_circle, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_segment_intersects_circle: GDExtensionMethodBindPtr = {
        let methodName = StringName ("segment_intersects_circle")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1356928167)!
            }
            
        }
        
    }()
    
    /// Given the 2D segment (`segmentFrom`, `segmentTo`), returns the position on the segment (as a number between 0 and 1) at which the segment hits the circle that is located at position `circlePosition` and has radius `circleRadius`. If the segment does not intersect the circle, -1 is returned (this is also the case if the line extending the segment would intersect the circle, but the segment does not).
    public static func segmentIntersectsCircle (segmentFrom: Vector2, segmentTo: Vector2, circlePosition: Vector2, circleRadius: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_segment_from = segmentFrom
        var copy_segment_to = segmentTo
        var copy_circle_position = circlePosition
        var copy_circle_radius = circleRadius
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_segment_intersects_circle, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_segment_from, &copy_segment_to, &copy_circle_position, &copy_circle_radius)
        return _result
        #else
        
        var copy_segment_from = segmentFrom
        var copy_segment_to = segmentTo
        var copy_circle_position = circlePosition
        var copy_circle_radius = circleRadius
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_segment_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_segment_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_circle_position) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_circle_radius) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Geometry2D.method_segment_intersects_circle, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_segment_intersects_segment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("segment_intersects_segment")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2058025344)!
            }
            
        }
        
    }()
    
    /// Checks if the two segments (`fromA`, `toA`) and (`fromB`, `toB`) intersect. If yes, return the point of intersection as ``Vector2``. If no intersection takes place, returns `null`.
    public static func segmentIntersectsSegment (fromA: Vector2, toA: Vector2, fromB: Vector2, toB: Vector2)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        var copy_from_a = fromA
        var copy_to_a = toA
        var copy_from_b = fromB
        var copy_to_b = toB
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_segment_intersects_segment, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_from_a, &copy_to_a, &copy_from_b, &copy_to_b)
        return _result
        #else
        
        var copy_from_a = fromA
        var copy_to_a = toA
        var copy_from_b = fromB
        var copy_to_b = toB
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from_a) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to_a) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_from_b) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_to_b) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Geometry2D.method_segment_intersects_segment, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_line_intersects_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("line_intersects_line")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2058025344)!
            }
            
        }
        
    }()
    
    /// Checks if the two lines (`fromA`, `dirA`) and (`fromB`, `dirB`) intersect. If yes, return the point of intersection as ``Vector2``. If no intersection takes place, returns `null`.
    /// 
    /// > Note: The lines are specified using direction vectors, not end points.
    /// 
    public static func lineIntersectsLine (fromA: Vector2, dirA: Vector2, fromB: Vector2, dirB: Vector2)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        var copy_from_a = fromA
        var copy_dir_a = dirA
        var copy_from_b = fromB
        var copy_dir_b = dirB
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_line_intersects_line, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_from_a, &copy_dir_a, &copy_from_b, &copy_dir_b)
        return _result
        #else
        
        var copy_from_a = fromA
        var copy_dir_a = dirA
        var copy_from_b = fromB
        var copy_dir_b = dirB
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from_a) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_dir_a) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_from_b) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_dir_b) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Geometry2D.method_line_intersects_line, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_closest_points_between_segments: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_closest_points_between_segments")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3344690961)!
            }
            
        }
        
    }()
    
    /// Given the two 2D segments (`p1`, `q1`) and (`p2`, `q2`), finds those two points on the two segments that are closest to each other. Returns a ``PackedVector2Array`` that contains this point on (`p1`, `q1`) as well the accompanying point on (`p2`, `q2`).
    public static func getClosestPointsBetweenSegments (p1: Vector2, q1: Vector2, p2: Vector2, q2: Vector2)-> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        #if false
        
        var copy_p1 = p1
        var copy_q1 = q1
        var copy_p2 = p2
        var copy_q2 = q2
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_get_closest_points_between_segments, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_p1, &copy_q1, &copy_p2, &copy_q2)
        return _result
        #else
        
        var copy_p1 = p1
        var copy_q1 = q1
        var copy_p2 = p2
        var copy_q2 = q2
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_p1) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_q1) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_p2) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_q2) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Geometry2D.method_get_closest_points_between_segments, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_closest_point_to_segment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_closest_point_to_segment")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4172901909)!
            }
            
        }
        
    }()
    
    /// Returns the 2D point on the 2D segment (`s1`, `s2`) that is closest to `point`. The returned point will always be inside the specified segment.
    public static func getClosestPointToSegment (point: Vector2, s1: Vector2, s2: Vector2)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_point = point
        var copy_s1 = s1
        var copy_s2 = s2
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_get_closest_point_to_segment, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_point, &copy_s1, &copy_s2)
        return _result
        #else
        
        var copy_point = point
        var copy_s1 = s1
        var copy_s2 = s2
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_point) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_s1) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_s2) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Geometry2D.method_get_closest_point_to_segment, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_closest_point_to_segment_uncapped: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_closest_point_to_segment_uncapped")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4172901909)!
            }
            
        }
        
    }()
    
    /// Returns the 2D point on the 2D line defined by (`s1`, `s2`) that is closest to `point`. The returned point can be inside the segment (`s1`, `s2`) or outside of it, i.e. somewhere on the line extending from the segment.
    public static func getClosestPointToSegmentUncapped (point: Vector2, s1: Vector2, s2: Vector2)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_point = point
        var copy_s1 = s1
        var copy_s2 = s2
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_get_closest_point_to_segment_uncapped, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_point, &copy_s1, &copy_s2)
        return _result
        #else
        
        var copy_point = point
        var copy_s1 = s1
        var copy_s2 = s2
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_point) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_s1) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_s2) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Geometry2D.method_get_closest_point_to_segment_uncapped, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_point_is_inside_triangle: GDExtensionMethodBindPtr = {
        let methodName = StringName ("point_is_inside_triangle")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025948137)!
            }
            
        }
        
    }()
    
    /// Returns if `point` is inside the triangle specified by `a`, `b` and `c`.
    public static func pointIsInsideTriangle (point: Vector2, a: Vector2, b: Vector2, c: Vector2)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_point = point
        var copy_a = a
        var copy_b = b
        var copy_c = c
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_point_is_inside_triangle, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_point, &copy_a, &copy_b, &copy_c)
        return _result
        #else
        
        var copy_point = point
        var copy_a = a
        var copy_b = b
        var copy_c = c
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_point) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_a) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_b) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_c) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Geometry2D.method_point_is_inside_triangle, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_polygon_clockwise: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_polygon_clockwise")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1361156557)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `polygon`'s vertices are ordered in clockwise order, otherwise returns `false`.
    public static func isPolygonClockwise (polygon: PackedVector2Array)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_is_polygon_clockwise, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polygon.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polygon.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Geometry2D.method_is_polygon_clockwise, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_point_in_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_point_in_polygon")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 738277916)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `point` is inside `polygon` or if it's located exactly _on_ polygon's boundary, otherwise returns `false`.
    public static func isPointInPolygon (point: Vector2, polygon: PackedVector2Array)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_point = point
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_is_point_in_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_point, &polygon.content)
        return _result
        #else
        
        var copy_point = point
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_point) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &polygon.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Geometry2D.method_is_point_in_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_triangulate_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("triangulate_polygon")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1389921771)!
            }
            
        }
        
    }()
    
    /// Triangulates the polygon specified by the points in `polygon`. Returns a ``PackedInt32Array`` where each triangle consists of three consecutive point indices into `polygon` (i.e. the returned array will have `n * 3` elements, with `n` being the number of found triangles). Output triangles will always be counter clockwise, and the contour will be flipped if it's clockwise. If the triangulation did not succeed, an empty ``PackedInt32Array`` is returned.
    public static func triangulatePolygon (_ polygon: PackedVector2Array)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_triangulate_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &polygon.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polygon.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Geometry2D.method_triangulate_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_triangulate_delaunay: GDExtensionMethodBindPtr = {
        let methodName = StringName ("triangulate_delaunay")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1389921771)!
            }
            
        }
        
    }()
    
    /// Triangulates the area specified by discrete set of `points` such that no point is inside the circumcircle of any resulting triangle. Returns a ``PackedInt32Array`` where each triangle consists of three consecutive point indices into `points` (i.e. the returned array will have `n * 3` elements, with `n` being the number of found triangles). If the triangulation did not succeed, an empty ``PackedInt32Array`` is returned.
    public static func triangulateDelaunay (points: PackedVector2Array)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_triangulate_delaunay, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &points.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Geometry2D.method_triangulate_delaunay, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_convex_hull: GDExtensionMethodBindPtr = {
        let methodName = StringName ("convex_hull")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2004331998)!
            }
            
        }
        
    }()
    
    /// Given an array of ``Vector2``s, returns the convex hull as a list of points in counterclockwise order. The last point is the same as the first one.
    public static func convexHull (points: PackedVector2Array)-> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_convex_hull, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &points.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Geometry2D.method_convex_hull, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_decompose_polygon_in_convex: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decompose_polygon_in_convex")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3982393695)!
            }
            
        }
        
    }()
    
    /// Decomposes the `polygon` into multiple convex hulls and returns an array of ``PackedVector2Array``.
    public static func decomposePolygonInConvex (polygon: PackedVector2Array)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_decompose_polygon_in_convex, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polygon.content)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polygon.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Geometry2D.method_decompose_polygon_in_convex, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return VariantCollection<PackedVector2Array>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_merge_polygons: GDExtensionMethodBindPtr = {
        let methodName = StringName ("merge_polygons")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3637387053)!
            }
            
        }
        
    }()
    
    /// Merges (combines) `polygonA` and `polygonB` and returns an array of merged polygons. This performs .operationUnion between polygons.
    /// 
    /// The operation may result in an outer polygon (boundary) and multiple inner polygons (holes) produced which could be distinguished by calling ``isPolygonClockwise(polygon:)``.
    /// 
    public static func mergePolygons (polygonA: PackedVector2Array, polygonB: PackedVector2Array)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_merge_polygons, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polygonA.content, &polygonB.content)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polygonA.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &polygonB.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Geometry2D.method_merge_polygons, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return VariantCollection<PackedVector2Array>(content: _result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_clip_polygons: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clip_polygons")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3637387053)!
            }
            
        }
        
    }()
    
    /// Clips `polygonA` against `polygonB` and returns an array of clipped polygons. This performs .operationDifference between polygons. Returns an empty array if `polygonB` completely overlaps `polygonA`.
    /// 
    /// If `polygonB` is enclosed by `polygonA`, returns an outer polygon (boundary) and inner polygon (hole) which could be distinguished by calling ``isPolygonClockwise(polygon:)``.
    /// 
    public static func clipPolygons (polygonA: PackedVector2Array, polygonB: PackedVector2Array)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_clip_polygons, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polygonA.content, &polygonB.content)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polygonA.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &polygonB.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Geometry2D.method_clip_polygons, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return VariantCollection<PackedVector2Array>(content: _result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_intersect_polygons: GDExtensionMethodBindPtr = {
        let methodName = StringName ("intersect_polygons")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3637387053)!
            }
            
        }
        
    }()
    
    /// Intersects `polygonA` with `polygonB` and returns an array of intersected polygons. This performs .operationIntersection between polygons. In other words, returns common area shared by polygons. Returns an empty array if no intersection occurs.
    /// 
    /// The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling ``isPolygonClockwise(polygon:)``.
    /// 
    public static func intersectPolygons (polygonA: PackedVector2Array, polygonB: PackedVector2Array)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_intersect_polygons, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polygonA.content, &polygonB.content)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polygonA.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &polygonB.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Geometry2D.method_intersect_polygons, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return VariantCollection<PackedVector2Array>(content: _result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_exclude_polygons: GDExtensionMethodBindPtr = {
        let methodName = StringName ("exclude_polygons")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3637387053)!
            }
            
        }
        
    }()
    
    /// Mutually excludes common area defined by intersection of `polygonA` and `polygonB` (see ``intersectPolygons(polygonA:polygonB:)``) and returns an array of excluded polygons. This performs .operationXor between polygons. In other words, returns all but common area between polygons.
    /// 
    /// The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling ``isPolygonClockwise(polygon:)``.
    /// 
    public static func excludePolygons (polygonA: PackedVector2Array, polygonB: PackedVector2Array)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_exclude_polygons, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polygonA.content, &polygonB.content)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polygonA.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &polygonB.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Geometry2D.method_exclude_polygons, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return VariantCollection<PackedVector2Array>(content: _result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_clip_polyline_with_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clip_polyline_with_polygon")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3637387053)!
            }
            
        }
        
    }()
    
    /// Clips `polyline` against `polygon` and returns an array of clipped polylines. This performs .operationDifference between the polyline and the polygon. This operation can be thought of as cutting a line with a closed shape.
    public static func clipPolylineWithPolygon (polyline: PackedVector2Array, polygon: PackedVector2Array)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_clip_polyline_with_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polyline.content, &polygon.content)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polyline.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &polygon.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Geometry2D.method_clip_polyline_with_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return VariantCollection<PackedVector2Array>(content: _result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_intersect_polyline_with_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("intersect_polyline_with_polygon")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3637387053)!
            }
            
        }
        
    }()
    
    /// Intersects `polyline` with `polygon` and returns an array of intersected polylines. This performs .operationIntersection between the polyline and the polygon. This operation can be thought of as chopping a line with a closed shape.
    public static func intersectPolylineWithPolygon (polyline: PackedVector2Array, polygon: PackedVector2Array)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_intersect_polyline_with_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polyline.content, &polygon.content)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polyline.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &polygon.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Geometry2D.method_intersect_polyline_with_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return VariantCollection<PackedVector2Array>(content: _result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_offset_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("offset_polygon")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1275354010)!
            }
            
        }
        
    }()
    
    /// Inflates or deflates `polygon` by `delta` units (pixels). If `delta` is positive, makes the polygon grow outward. If `delta` is negative, shrinks the polygon inward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. Returns an empty array if `delta` is negative and the absolute value of it approximately exceeds the minimum bounding rectangle dimensions of the polygon.
    /// 
    /// Each polygon's vertices will be rounded as determined by `joinType`, see ``Geometry2D/PolyJoinType``.
    /// 
    /// The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling ``isPolygonClockwise(polygon:)``.
    /// 
    /// > Note: To translate the polygon's vertices specifically, multiply them to a ``Transform2D``:
    /// 
    public static func offsetPolygon (_ polygon: PackedVector2Array, delta: Double, joinType: Geometry2D.PolyJoinType = .square)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        var copy_delta = delta
        var copy_join_type = Int64 (joinType.rawValue)
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_offset_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polygon.content, &copy_delta, &copy_join_type)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var copy_delta = delta
        var copy_join_type = Int64 (joinType.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polygon.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_delta) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_join_type) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Geometry2D.method_offset_polygon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                    return VariantCollection<PackedVector2Array>(content: _result)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_offset_polyline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("offset_polyline")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2328231778)!
            }
            
        }
        
    }()
    
    /// Inflates or deflates `polyline` by `delta` units (pixels), producing polygons. If `delta` is positive, makes the polyline grow outward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. If `delta` is negative, returns an empty array.
    /// 
    /// Each polygon's vertices will be rounded as determined by `joinType`, see ``Geometry2D/PolyJoinType``.
    /// 
    /// Each polygon's endpoints will be rounded as determined by `endType`, see ``Geometry2D/PolyEndType``.
    /// 
    /// The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling ``isPolygonClockwise(polygon:)``.
    /// 
    public static func offsetPolyline (_ polyline: PackedVector2Array, delta: Double, joinType: Geometry2D.PolyJoinType = .square, endType: Geometry2D.PolyEndType = .square)-> VariantCollection<PackedVector2Array> {
        var _result: Int64 = 0
        #if false
        
        var copy_delta = delta
        var copy_join_type = Int64 (joinType.rawValue)
        var copy_end_type = Int64 (endType.rawValue)
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_offset_polyline, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &polyline.content, &copy_delta, &copy_join_type, &copy_end_type)
        return VariantCollection<PackedVector2Array>(content: _result)
        #else
        
        var copy_delta = delta
        var copy_join_type = Int64 (joinType.rawValue)
        var copy_end_type = Int64 (endType.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &polyline.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_delta) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_join_type) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_end_type) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Geometry2D.method_offset_polyline, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                        return VariantCollection<PackedVector2Array>(content: _result)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_make_atlas: GDExtensionMethodBindPtr = {
        let methodName = StringName ("make_atlas")
        return withUnsafePointer (to: &Geometry2D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1337682371)!
            }
            
        }
        
    }()
    
    /// Given an array of ``Vector2``s representing tiles, builds an atlas. The returned dictionary has two keys: `points` is a ``PackedVector2Array`` that specifies the positions of each tile, `size` contains the overall size of the whole atlas as ``Vector2i``.
    public static func makeAtlas (sizes: PackedVector2Array)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Geometry2D.method_make_atlas, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &sizes.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &sizes.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Geometry2D.method_make_atlas, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
}

