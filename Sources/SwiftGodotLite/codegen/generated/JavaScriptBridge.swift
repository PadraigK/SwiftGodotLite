// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Singleton that connects the engine with the browser's JavaScript context in Web export.
/// 
/// The JavaScriptBridge singleton is implemented only in the Web export. It's used to access the browser's JavaScript context. This allows interaction with embedding pages or calling third-party JavaScript APIs.
/// 
/// > Note: This singleton can be disabled at build-time to improve security. By default, the JavaScriptBridge singleton is enabled. Official export templates also have the JavaScriptBridge singleton enabled. See [url=$DOCS_URL/contributing/development/compiling/compiling_for_web.html]Compiling for the Web[/url] in the documentation for more information.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``pwaUpdateAvailable``
open class JavaScriptBridge: Object {
    /// The shared instance of this class
    public static var shared: JavaScriptBridge = {
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { ptr in
            JavaScriptBridge (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "JavaScriptBridge" }
    /* Methods */
    fileprivate static var method_eval: GDExtensionMethodBindPtr = {
        let methodName = StringName ("eval")
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 218087648)!
            }
            
        }
        
    }()
    
    /// Execute the string `code` as JavaScript code within the browser window. This is a call to the actual global JavaScript function [code skip-lint]eval()`.
    /// 
    /// If `useGlobalExecutionContext` is `true`, the code will be evaluated in the global execution context. Otherwise, it is evaluated in the execution context of a function within the engine's runtime environment.
    /// 
    public static func eval (code: String, useGlobalExecutionContext: Bool = false)-> Variant {
        let _result: Variant = Variant ()
        #if true
        
        let gstr_code = GString (code)
        var copy_use_global_execution_context = useGlobalExecutionContext
        
        gi.object_method_bind_ptrcall_v (JavaScriptBridge.method_eval, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &gstr_code.content, &copy_use_global_execution_context)
        return _result
        #else
        
        let gstr_code = GString (code)
        var copy_use_global_execution_context = useGlobalExecutionContext
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_code.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_use_global_execution_context) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (JavaScriptBridge.method_eval, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_interface: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_interface")
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1355533281)!
            }
            
        }
        
    }()
    
    /// Returns an interface to a JavaScript object that can be used by scripts. The `interface` must be a valid property of the JavaScript `window`. The callback must accept a single ``GArray`` argument, which will contain the JavaScript `arguments`. See ``JavaScriptObject`` for usage.
    public static func getInterface (_ interface: String)-> JavaScriptObject? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        let gstr_interface = GString (interface)
        
        gi.object_method_bind_ptrcall_v (JavaScriptBridge.method_get_interface, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_interface.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_interface = GString (interface)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_interface.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (JavaScriptBridge.method_get_interface, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_create_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_callback")
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 422818440)!
            }
            
        }
        
    }()
    
    /// Creates a reference to a ``Callable`` that can be used as a callback by JavaScript. The reference must be kept until the callback happens, or it won't be called at all. See ``JavaScriptObject`` for usage.
    public static func createCallback (callable: Callable)-> JavaScriptObject? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        
        gi.object_method_bind_ptrcall_v (JavaScriptBridge.method_create_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &callable.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &callable.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (JavaScriptBridge.method_create_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_create_object: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_object")
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3093893586)!
            }
            
        }
        
    }()
    
    /// Creates a new JavaScript object using the `new` constructor. The `object` must a valid property of the JavaScript `window`. See ``JavaScriptObject`` for usage.
    public static func createObject (_ object: String, _ arguments: Variant...)-> Variant {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_object = Variant (object)
        
        gi.object_method_bind_call_v (JavaScriptBridge.method_create_object, UnsafeMutableRawPointer (mutating: shared.handle), &_result, nil, &copy_object.content)
        return Variant (fromContentPtr: &_result)
        #else
        
        let copy_object = Variant (object)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_object.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            gi.object_method_bind_call (JavaScriptBridge.method_create_object, UnsafeMutableRawPointer (mutating: shared.handle), &_args, Int64 (_args.count), &_result, nil)
            return Variant (fromContentPtr: &_result)
        }
        
        #endif
    }
    
    fileprivate static var method_download_buffer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("download_buffer")
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3352272093)!
            }
            
        }
        
    }()
    
    /// Prompts the user to download a file containing the specified `buffer`. The file will have the given `name` and `mime` type.
    /// 
    /// > Note: The browser may override the [url=https://en.wikipedia.org/wiki/Media_type]MIME type[/url] provided based on the file `name`'s extension.
    /// 
    /// > Note: Browsers might block the download if ``downloadBuffer(_:name:mime:)`` is not being called from a user interaction (e.g. button click).
    /// 
    /// > Note: Browsers might ask the user for permission or block the download if multiple download requests are made in a quick succession.
    /// 
    public static func downloadBuffer (_ buffer: PackedByteArray, name: String, mime: String = "application/octet-stream") {
        #if true
        
        let gstr_name = GString (name)
        let gstr_mime = GString (mime)
        
        gi.object_method_bind_ptrcall_v (JavaScriptBridge.method_download_buffer, UnsafeMutableRawPointer (mutating: shared.handle), nil, &buffer.content, &gstr_name.content, &gstr_mime.content)
        
        #else
        
        let gstr_name = GString (name)
        let gstr_mime = GString (mime)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &buffer.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_name.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_mime.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (JavaScriptBridge.method_download_buffer, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_pwa_needs_update: GDExtensionMethodBindPtr = {
        let methodName = StringName ("pwa_needs_update")
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a new version of the progressive web app is waiting to be activated.
    /// 
    /// > Note: Only relevant when exported as a Progressive Web App.
    /// 
    public static func pwaNeedsUpdate ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (JavaScriptBridge.method_pwa_needs_update, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_pwa_update: GDExtensionMethodBindPtr = {
        let methodName = StringName ("pwa_update")
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Performs the live update of the progressive web app. Forcing the new version to be installed and the page to be reloaded.
    /// 
    /// > Note: Your application will be **reloaded in all browser tabs**.
    /// 
    /// > Note: Only relevant when exported as a Progressive Web App and ``pwaNeedsUpdate()`` returns `true`.
    /// 
    public static func pwaUpdate ()-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (JavaScriptBridge.method_pwa_update, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_force_fs_sync: GDExtensionMethodBindPtr = {
        let methodName = StringName ("force_fs_sync")
        return withUnsafePointer (to: &JavaScriptBridge.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Force synchronization of the persistent file system (when enabled).
    /// 
    /// > Note: This is only useful for modules or extensions that can't use ``FileAccess`` to write files.
    /// 
    public static func forceFsSync () {
        gi.object_method_bind_ptrcall (JavaScriptBridge.method_force_fs_sync, UnsafeMutableRawPointer (mutating: shared.handle), nil, nil)
    }
    
    // Signals 
    /// Emitted when an update for this progressive web app has been detected but is waiting to be activated because a previous version is active. See ``pwaUpdate()`` to force the update to take place immediately.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.pwaUpdateAvailable.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var pwaUpdateAvailable: SimpleSignal { SimpleSignal (target: self, signalName: "pwa_update_available") }
    
}

