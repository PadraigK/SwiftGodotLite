// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Node that instances meshes into a scenario.
/// 
/// MeshInstance3D is a node that takes a ``Mesh`` resource and adds it to the current scenario by creating an instance of it. This is the class most often used render 3D geometry and can be used to instance a single ``Mesh`` in many places. This allows reusing geometry, which can save on resources. When a ``Mesh`` has to be instantiated more than thousands of times at close proximity, consider using a ``MultiMesh`` in a ``MultiMeshInstance3D`` instead.
open class MeshInstance3D: GeometryInstance3D {
    override open class var godotClassName: StringName { "MeshInstance3D" }
    
    /* Properties */
    
    /// The ``Mesh`` resource for the instance.
    final public var mesh: Mesh? {
        get {
            return get_mesh ()
        }
        
        set {
            set_mesh (newValue)
        }
        
    }
    
    /// The ``Skin`` to be used by this instance.
    final public var skin: Skin? {
        get {
            return get_skin ()
        }
        
        set {
            set_skin (newValue)
        }
        
    }
    
    /// ``NodePath`` to the ``Skeleton3D`` associated with the instance.
    final public var skeleton: NodePath {
        get {
            return get_skeleton_path ()
        }
        
        set {
            set_skeleton_path (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_mesh")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 194775623)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mesh (_ mesh: Mesh?) {
        #if true
        
        var copy_mesh_handle = mesh?.handle
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_set_mesh, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mesh_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: mesh?.handle) { p0 in
        _args.append (mesh == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (MeshInstance3D.method_set_mesh, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_mesh")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1808005922)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mesh ()-> Mesh? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (MeshInstance3D.method_get_mesh, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_skeleton_path: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_skeleton_path")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1348162250)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_skeleton_path (_ skeletonPath: NodePath) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_set_skeleton_path, UnsafeMutableRawPointer (mutating: handle), nil, &skeletonPath.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &skeletonPath.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (MeshInstance3D.method_set_skeleton_path, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_skeleton_path: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_skeleton_path")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 277076166)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_skeleton_path ()-> NodePath {
        let _result: NodePath = NodePath ()
        gi.object_method_bind_ptrcall (MeshInstance3D.method_get_skeleton_path, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_skin: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_skin")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3971435618)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_skin (_ skin: Skin?) {
        #if true
        
        var copy_skin_handle = skin?.handle
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_set_skin, UnsafeMutableRawPointer (mutating: handle), nil, &copy_skin_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: skin?.handle) { p0 in
        _args.append (skin == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (MeshInstance3D.method_set_skin, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_skin: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_skin")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2074563878)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_skin ()-> Skin? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (MeshInstance3D.method_get_skin, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_surface_override_material_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_surface_override_material_count")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of surface override materials. This is equivalent to ``Mesh/getSurfaceCount()``. See also ``getSurfaceOverrideMaterial(surface:)``.
    public final func getSurfaceOverrideMaterialCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (MeshInstance3D.method_get_surface_override_material_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_surface_override_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_surface_override_material")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3671737478)!
            }
            
        }
        
    }()
    
    /// Sets the override `material` for the specified `surface` of the ``Mesh`` resource. This material is associated with this ``MeshInstance3D`` rather than with ``mesh``.
    /// 
    /// > Note: This assigns the ``Material`` associated to the ``MeshInstance3D``'s Surface Material Override properties, not the material within the ``Mesh`` resource. To set the material within the ``Mesh`` resource, use ``Mesh/surfaceGetMaterial(surfIdx:)`` instead.
    /// 
    public final func setSurfaceOverrideMaterial (surface: Int32, material: Material?) {
        #if true
        
        var copy_surface: Int = Int (surface)
        var copy_material_handle = material?.handle
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_set_surface_override_material, UnsafeMutableRawPointer (mutating: handle), nil, &copy_surface, &copy_material_handle)
        
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_surface) { p0 in
            _args.append (p0)
            withUnsafePointer (to: material?.handle) { p1 in
            _args.append (material == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (MeshInstance3D.method_set_surface_override_material, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_surface_override_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_surface_override_material")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2897466400)!
            }
            
        }
        
    }()
    
    /// Returns the override ``Material`` for the specified `surface` of the ``Mesh`` resource. See also ``getSurfaceOverrideMaterialCount()``.
    /// 
    /// > Note: This returns the ``Material`` associated to the ``MeshInstance3D``'s Surface Material Override properties, not the material within the ``Mesh`` resource. To get the material within the ``Mesh`` resource, use ``Mesh/surfaceGetMaterial(surfIdx:)`` instead.
    /// 
    public final func getSurfaceOverrideMaterial (surface: Int32)-> Material? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_surface: Int = Int (surface)
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_get_surface_override_material, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_surface)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_surface) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (MeshInstance3D.method_get_surface_override_material, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_active_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_active_material")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2897466400)!
            }
            
        }
        
    }()
    
    /// Returns the ``Material`` that will be used by the ``Mesh`` when drawing. This can return the ``GeometryInstance3D/materialOverride``, the surface override ``Material`` defined in this ``MeshInstance3D``, or the surface ``Material`` defined in the ``mesh``. For example, if ``GeometryInstance3D/materialOverride`` is used, all surfaces will return the override material.
    /// 
    /// Returns `null` if no material is active, including when ``mesh`` is `null`.
    /// 
    public final func getActiveMaterial (surface: Int32)-> Material? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_surface: Int = Int (surface)
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_get_active_material, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_surface)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_surface: Int = Int (surface)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_surface) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (MeshInstance3D.method_get_active_material, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_create_trimesh_collision: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_trimesh_collision")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// This helper creates a ``StaticBody3D`` child node with a ``ConcavePolygonShape3D`` collision shape calculated from the mesh geometry. It's mainly used for testing.
    public final func createTrimeshCollision () {
        gi.object_method_bind_ptrcall (MeshInstance3D.method_create_trimesh_collision, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_create_convex_collision: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_convex_collision")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2751962654)!
            }
            
        }
        
    }()
    
    /// This helper creates a ``StaticBody3D`` child node with a ``ConvexPolygonShape3D`` collision shape calculated from the mesh geometry. It's mainly used for testing.
    /// 
    /// If `clean` is `true` (default), duplicate and interior vertices are removed automatically. You can set it to `false` to make the process faster if not needed.
    /// 
    /// If `simplify` is `true`, the geometry can be further simplified to reduce the number of vertices. Disabled by default.
    /// 
    public final func createConvexCollision (clean: Bool = true, simplify: Bool = false) {
        #if true
        
        var copy_clean = clean
        var copy_simplify = simplify
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_create_convex_collision, UnsafeMutableRawPointer (mutating: handle), nil, &copy_clean, &copy_simplify)
        
        #else
        
        var copy_clean = clean
        var copy_simplify = simplify
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_clean) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_simplify) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (MeshInstance3D.method_create_convex_collision, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_create_multiple_convex_collisions: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_multiple_convex_collisions")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 628789669)!
            }
            
        }
        
    }()
    
    /// This helper creates a ``StaticBody3D`` child node with multiple ``ConvexPolygonShape3D`` collision shapes calculated from the mesh geometry via convex decomposition. The convex decomposition operation can be controlled with parameters from the optional `settings`.
    public final func createMultipleConvexCollisions (settings: MeshConvexDecompositionSettings? = nil) {
        #if true
        
        var copy_settings_handle = settings?.handle
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_create_multiple_convex_collisions, UnsafeMutableRawPointer (mutating: handle), nil, &copy_settings_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: settings?.handle) { p0 in
        _args.append (settings == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (MeshInstance3D.method_create_multiple_convex_collisions, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_blend_shape_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_blend_shape_count")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of blend shapes available. Produces an error if ``mesh`` is `null`.
    public final func getBlendShapeCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (MeshInstance3D.method_get_blend_shape_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_find_blend_shape_by_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("find_blend_shape_by_name")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4150868206)!
            }
            
        }
        
    }()
    
    /// Returns the index of the blend shape with the given `name`. Returns `-1` if no blend shape with this name exists, including when ``mesh`` is `null`.
    public final func findBlendShapeByName (_ name: StringName)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_find_blend_shape_by_name, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (MeshInstance3D.method_find_blend_shape_by_name, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_blend_shape_value: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_blend_shape_value")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2339986948)!
            }
            
        }
        
    }()
    
    /// Returns the value of the blend shape at the given `blendShapeIdx`. Returns `0.0` and produces an error if ``mesh`` is `null` or doesn't have a blend shape at that index.
    public final func getBlendShapeValue (blendShapeIdx: Int32)-> Double {
        var _result: Double = 0.0
        #if true
        
        var copy_blend_shape_idx: Int = Int (blendShapeIdx)
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_get_blend_shape_value, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_blend_shape_idx)
        return _result
        #else
        
        var copy_blend_shape_idx: Int = Int (blendShapeIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_blend_shape_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (MeshInstance3D.method_get_blend_shape_value, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_blend_shape_value: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_blend_shape_value")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1602489585)!
            }
            
        }
        
    }()
    
    /// Sets the value of the blend shape at `blendShapeIdx` to `value`. Produces an error if ``mesh`` is `null` or doesn't have a blend shape at that index.
    public final func setBlendShapeValue (blendShapeIdx: Int32, value: Double) {
        #if true
        
        var copy_blend_shape_idx: Int = Int (blendShapeIdx)
        var copy_value = value
        
        gi.object_method_bind_ptrcall_v (MeshInstance3D.method_set_blend_shape_value, UnsafeMutableRawPointer (mutating: handle), nil, &copy_blend_shape_idx, &copy_value)
        
        #else
        
        var copy_blend_shape_idx: Int = Int (blendShapeIdx)
        var copy_value = value
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_blend_shape_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_value) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (MeshInstance3D.method_set_blend_shape_value, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_create_debug_tangents: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_debug_tangents")
        return withUnsafePointer (to: &MeshInstance3D.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// This helper creates a ``MeshInstance3D`` child node with gizmos at every vertex calculated from the mesh geometry. It's mainly used for testing.
    public final func createDebugTangents () {
        gi.object_method_bind_ptrcall (MeshInstance3D.method_create_debug_tangents, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
}

