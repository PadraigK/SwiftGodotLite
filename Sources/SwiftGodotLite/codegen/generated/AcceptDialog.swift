// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A base dialog used for user notification.
/// 
/// The default use of ``AcceptDialog`` is to allow it to only be accepted or closed, with the same result. However, the [signal confirmed] and [signal canceled] signals allow to make the two actions different, and the ``addButton(text:right:action:)`` method allows to add custom buttons and actions.
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``confirmed``
/// - ``canceled``
/// - ``customAction``
open class AcceptDialog: Window {
    override open class var godotClassName: StringName { "AcceptDialog" }
    
    /* Properties */
    
    /// The text displayed by the OK button (see ``getOkButton()``).
    final public var okButtonText: String {
        get {
            return get_ok_button_text ()
        }
        
        set {
            set_ok_button_text (newValue)
        }
        
    }
    
    /// The text displayed by the dialog.
    final public var dialogText: String {
        get {
            return get_text ()
        }
        
        set {
            set_text (newValue)
        }
        
    }
    
    /// If `true`, the dialog is hidden when the OK button is pressed. You can set it to `false` if you want to do e.g. input validation when receiving the [signal confirmed] signal, and handle hiding the dialog in your own logic.
    /// 
    /// > Note: Some nodes derived from this class can have a different default value, and potentially their own built-in logic overriding this setting. For example ``FileDialog`` defaults to `false`, and has its own input validation code that is called when you press OK, which eventually hides the dialog if the input is valid. As such, this property can't be used in ``FileDialog`` to disable hiding the dialog when pressing OK.
    /// 
    final public var dialogHideOnOk: Bool {
        get {
            return get_hide_on_ok ()
        }
        
        set {
            set_hide_on_ok (newValue)
        }
        
    }
    
    /// If `true`, the dialog will be hidden when the escape key (``Key/escape``) is pressed.
    final public var dialogCloseOnEscape: Bool {
        get {
            return get_close_on_escape ()
        }
        
        set {
            set_close_on_escape (newValue)
        }
        
    }
    
    /// Sets autowrapping for the text in the dialog.
    final public var dialogAutowrap: Bool {
        get {
            return has_autowrap ()
        }
        
        set {
            set_autowrap (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_ok_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_ok_button")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1856205918)!
            }
            
        }
        
    }()
    
    /// Returns the OK ``Button`` instance.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``CanvasItem/visible`` property.
    /// 
    public final func getOkButton ()-> Button? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (AcceptDialog.method_get_ok_button, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_label: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_label")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 566733104)!
            }
            
        }
        
    }()
    
    /// Returns the label used for built-in text.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``CanvasItem/visible`` property.
    /// 
    public final func getLabel ()-> Label? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (AcceptDialog.method_get_label, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_hide_on_ok: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hide_on_ok")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_on_ok (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_set_hide_on_ok, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AcceptDialog.method_set_hide_on_ok, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_hide_on_ok: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hide_on_ok")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_hide_on_ok ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (AcceptDialog.method_get_hide_on_ok, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_close_on_escape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_close_on_escape")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_close_on_escape (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_set_close_on_escape, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AcceptDialog.method_set_close_on_escape, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_close_on_escape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_close_on_escape")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_close_on_escape ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (AcceptDialog.method_get_close_on_escape, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_button")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3328440682)!
            }
            
        }
        
    }()
    
    /// Adds a button with label `text` and a custom `action` to the dialog and returns the created button. `action` will be passed to the [signal custom_action] signal when pressed.
    /// 
    /// If `true`, `right` will place the button to the right of any sibling buttons.
    /// 
    /// You can use ``removeButton(_:)`` method to remove a button created with this method from the dialog.
    /// 
    public final func addButton (text: String, right: Bool = false, action: String = "")-> Button? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        let gstr_text = GString (text)
        var copy_right = right
        let gstr_action = GString (action)
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_add_button, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_text.content, &copy_right, &gstr_action.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_text = GString (text)
        var copy_right = right
        let gstr_action = GString (action)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_right) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &gstr_action.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (AcceptDialog.method_add_button, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_cancel_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_cancel_button")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 242045556)!
            }
            
        }
        
    }()
    
    /// Adds a button with label `name` and a cancel action to the dialog and returns the created button.
    /// 
    /// You can use ``removeButton(_:)`` method to remove a button created with this method from the dialog.
    /// 
    public final func addCancelButton (name: String)-> Button? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_add_cancel_button, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_name.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AcceptDialog.method_add_cancel_button, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_remove_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_button")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1496901182)!
            }
            
        }
        
    }()
    
    /// Removes the `button` from the dialog. Does NOT free the `button`. The `button` must be a ``Button`` added with ``addButton(text:right:action:)`` or ``addCancelButton(name:)`` method. After removal, pressing the `button` will no longer emit this dialog's [signal custom_action] or [signal canceled] signals.
    public final func removeButton (_ button: Control?) {
        #if false
        
        var copy_button_handle = button?.handle
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_remove_button, UnsafeMutableRawPointer (mutating: handle), nil, &copy_button_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: button?.handle) { p0 in
        _args.append (button == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (AcceptDialog.method_remove_button, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_register_text_enter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("register_text_enter")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1496901182)!
            }
            
        }
        
    }()
    
    /// Registers a ``LineEdit`` in the dialog. When the enter key is pressed, the dialog will be accepted.
    public final func registerTextEnter (lineEdit: Control?) {
        #if false
        
        var copy_line_edit_handle = lineEdit?.handle
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_register_text_enter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line_edit_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: lineEdit?.handle) { p0 in
        _args.append (lineEdit == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (AcceptDialog.method_register_text_enter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_text")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text (_ text: String) {
        #if false
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_set_text, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AcceptDialog.method_set_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (AcceptDialog.method_get_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_autowrap: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_autowrap")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_autowrap (_ autowrap: Bool) {
        #if false
        
        var copy_autowrap = autowrap
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_set_autowrap, UnsafeMutableRawPointer (mutating: handle), nil, &copy_autowrap)
        
        #else
        
        var copy_autowrap = autowrap
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_autowrap) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AcceptDialog.method_set_autowrap, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_has_autowrap: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_autowrap")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func has_autowrap ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (AcceptDialog.method_has_autowrap, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_ok_button_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_ok_button_text")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_ok_button_text (_ text: String) {
        #if false
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (AcceptDialog.method_set_ok_button_text, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AcceptDialog.method_set_ok_button_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_ok_button_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_ok_button_text")
        return withUnsafePointer (to: &AcceptDialog.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_ok_button_text ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (AcceptDialog.method_get_ok_button_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    // Signals 
    /// Emitted when the dialog is accepted, i.e. the OK button is pressed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.confirmed.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var confirmed: SimpleSignal { SimpleSignal (target: self, signalName: "confirmed") }
    
    /// Emitted when the dialog is closed or the button created with ``addCancelButton(name:)`` is pressed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.canceled.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var canceled: SimpleSignal { SimpleSignal (target: self, signalName: "canceled") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ action: StringName) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a custom button is pressed. See ``addButton(text:right:action:)``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.customAction.connect { action in
    ///    print ("caught signal")
    /// }
    /// ```
    public var customAction: Signal1 { Signal1 (target: self, signalName: "custom_action") }
    
}

