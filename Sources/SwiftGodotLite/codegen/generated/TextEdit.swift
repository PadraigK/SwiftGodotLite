// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A multiline text editor.
/// 
/// A multiline text editor. It also has limited facilities for editing code, such as syntax highlighting support. For more advanced facilities for editing code, see ``CodeEdit``.
/// 
/// > Note: Most viewport, caret and edit methods contain a `caret_index` argument for ``caretMultiple`` support. The argument should be one of the following: `-1` for all carets, `0` for the main caret, or greater than `0` for secondary carets.
/// 
/// > Note: When holding down [kbd]Alt[/kbd], the vertical scroll wheel will scroll 5 times as fast as it would normally do. This also works in the Godot script editor.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``textSet``
/// - ``textChanged``
/// - ``linesEditedFrom``
/// - ``caretChanged``
/// - ``gutterClicked``
/// - ``gutterAdded``
/// - ``gutterRemoved``
open class TextEdit: Control {
    override open class var godotClassName: StringName { "TextEdit" }
    public enum MenuItems: Int64 {
        /// Cuts (copies and clears) the selected text.
        case cut = 0 // MENU_CUT
        /// Copies the selected text.
        case copy = 1 // MENU_COPY
        /// Pastes the clipboard text over the selected text (or at the cursor's position).
        case paste = 2 // MENU_PASTE
        /// Erases the whole ``TextEdit`` text.
        case clear = 3 // MENU_CLEAR
        /// Selects the whole ``TextEdit`` text.
        case selectAll = 4 // MENU_SELECT_ALL
        /// Undoes the previous action.
        case undo = 5 // MENU_UNDO
        /// Redoes the previous action.
        case redo = 6 // MENU_REDO
        /// ID of "Text Writing Direction" submenu.
        case submenuTextDir = 7 // MENU_SUBMENU_TEXT_DIR
        /// Sets text direction to inherited.
        case dirInherited = 8 // MENU_DIR_INHERITED
        /// Sets text direction to automatic.
        case dirAuto = 9 // MENU_DIR_AUTO
        /// Sets text direction to left-to-right.
        case dirLtr = 10 // MENU_DIR_LTR
        /// Sets text direction to right-to-left.
        case dirRtl = 11 // MENU_DIR_RTL
        /// Toggles control character display.
        case displayUcc = 12 // MENU_DISPLAY_UCC
        /// ID of "Insert Control Character" submenu.
        case submenuInsertUcc = 13 // MENU_SUBMENU_INSERT_UCC
        /// Inserts left-to-right mark (LRM) character.
        case insertLrm = 14 // MENU_INSERT_LRM
        /// Inserts right-to-left mark (RLM) character.
        case insertRlm = 15 // MENU_INSERT_RLM
        /// Inserts start of left-to-right embedding (LRE) character.
        case insertLre = 16 // MENU_INSERT_LRE
        /// Inserts start of right-to-left embedding (RLE) character.
        case insertRle = 17 // MENU_INSERT_RLE
        /// Inserts start of left-to-right override (LRO) character.
        case insertLro = 18 // MENU_INSERT_LRO
        /// Inserts start of right-to-left override (RLO) character.
        case insertRlo = 19 // MENU_INSERT_RLO
        /// Inserts pop direction formatting (PDF) character.
        case insertPdf = 20 // MENU_INSERT_PDF
        /// Inserts Arabic letter mark (ALM) character.
        case insertAlm = 21 // MENU_INSERT_ALM
        /// Inserts left-to-right isolate (LRI) character.
        case insertLri = 22 // MENU_INSERT_LRI
        /// Inserts right-to-left isolate (RLI) character.
        case insertRli = 23 // MENU_INSERT_RLI
        /// Inserts first strong isolate (FSI) character.
        case insertFsi = 24 // MENU_INSERT_FSI
        /// Inserts pop direction isolate (PDI) character.
        case insertPdi = 25 // MENU_INSERT_PDI
        /// Inserts zero width joiner (ZWJ) character.
        case insertZwj = 26 // MENU_INSERT_ZWJ
        /// Inserts zero width non-joiner (ZWNJ) character.
        case insertZwnj = 27 // MENU_INSERT_ZWNJ
        /// Inserts word joiner (WJ) character.
        case insertWj = 28 // MENU_INSERT_WJ
        /// Inserts soft hyphen (SHY) character.
        case insertShy = 29 // MENU_INSERT_SHY
        /// Represents the size of the ``TextEdit/MenuItems`` enum.
        case max = 30 // MENU_MAX
    }
    
    public enum EditAction: Int64 {
        /// No current action.
        case none = 0 // ACTION_NONE
        /// A typing action.
        case typing = 1 // ACTION_TYPING
        /// A backwards delete action.
        case backspace = 2 // ACTION_BACKSPACE
        /// A forward delete action.
        case delete = 3 // ACTION_DELETE
    }
    
    public enum SearchFlags: Int64 {
        /// Match case when searching.
        case matchCase = 1 // SEARCH_MATCH_CASE
        /// Match whole words when searching.
        case wholeWords = 2 // SEARCH_WHOLE_WORDS
        /// Search from end to beginning.
        case backwards = 4 // SEARCH_BACKWARDS
    }
    
    public enum CaretType: Int64 {
        /// Vertical line caret.
        case line = 0 // CARET_TYPE_LINE
        /// Block caret.
        case block = 1 // CARET_TYPE_BLOCK
    }
    
    public enum SelectionMode: Int64 {
        /// Not selecting.
        case none = 0 // SELECTION_MODE_NONE
        /// Select as if `shift` is pressed.
        case shift = 1 // SELECTION_MODE_SHIFT
        /// Select single characters as if the user single clicked.
        case pointer = 2 // SELECTION_MODE_POINTER
        /// Select whole words as if the user double clicked.
        case word = 3 // SELECTION_MODE_WORD
        /// Select whole lines as if the user triple clicked.
        case line = 4 // SELECTION_MODE_LINE
    }
    
    public enum LineWrappingMode: Int64 {
        /// Line wrapping is disabled.
        case none = 0 // LINE_WRAPPING_NONE
        /// Line wrapping occurs at the control boundary, beyond what would normally be visible.
        case boundary = 1 // LINE_WRAPPING_BOUNDARY
    }
    
    public enum GutterType: Int64 {
        /// Draw a string.
        case string = 0 // GUTTER_TYPE_STRING
        /// Draw an icon.
        case icon = 1 // GUTTER_TYPE_ICON
        /// Custom draw.
        case custom = 2 // GUTTER_TYPE_CUSTOM
    }
    
    
    /* Properties */
    
    /// String value of the ``TextEdit``.
    final public var text: String {
        get {
            return get_text ()
        }
        
        set {
            set_text (newValue)
        }
        
    }
    
    /// Text shown when the ``TextEdit`` is empty. It is **not** the ``TextEdit``'s default value (see ``text``).
    final public var placeholderText: String {
        get {
            return get_placeholder ()
        }
        
        set {
            set_placeholder (newValue)
        }
        
    }
    
    /// If `false`, existing text cannot be modified and new text cannot be added.
    final public var editable: Bool {
        get {
            return is_editable ()
        }
        
        set {
            set_editable (newValue)
        }
        
    }
    
    /// If `true`, a right-click displays the context menu.
    final public var contextMenuEnabled: Bool {
        get {
            return is_context_menu_enabled ()
        }
        
        set {
            set_context_menu_enabled (newValue)
        }
        
    }
    
    /// If `true`, shortcut keys for context menu items are enabled, even if the context menu is disabled.
    final public var shortcutKeysEnabled: Bool {
        get {
            return is_shortcut_keys_enabled ()
        }
        
        set {
            set_shortcut_keys_enabled (newValue)
        }
        
    }
    
    /// If `true`, text can be selected.
    /// 
    /// If `false`, text can not be selected by the user or by the ``select(fromLine:fromColumn:toLine:toColumn:caretIndex:)`` or ``selectAll()`` methods.
    /// 
    final public var selectingEnabled: Bool {
        get {
            return is_selecting_enabled ()
        }
        
        set {
            set_selecting_enabled (newValue)
        }
        
    }
    
    /// If `true`, the selected text will be deselected when focus is lost.
    final public var deselectOnFocusLossEnabled: Bool {
        get {
            return is_deselect_on_focus_loss_enabled ()
        }
        
        set {
            set_deselect_on_focus_loss_enabled (newValue)
        }
        
    }
    
    /// If `true`, allow drag and drop of selected text.
    final public var dragAndDropSelectionEnabled: Bool {
        get {
            return is_drag_and_drop_selection_enabled ()
        }
        
        set {
            set_drag_and_drop_selection_enabled (newValue)
        }
        
    }
    
    /// If `true`, the native virtual keyboard is shown when focused on platforms that support it.
    final public var virtualKeyboardEnabled: Bool {
        get {
            return is_virtual_keyboard_enabled ()
        }
        
        set {
            set_virtual_keyboard_enabled (newValue)
        }
        
    }
    
    /// If `false`, using middle mouse button to paste clipboard will be disabled.
    /// 
    /// > Note: This method is only implemented on Linux.
    /// 
    final public var middleMousePasteEnabled: Bool {
        get {
            return is_middle_mouse_paste_enabled ()
        }
        
        set {
            set_middle_mouse_paste_enabled (newValue)
        }
        
    }
    
    /// Sets the line wrapping mode to use.
    final public var wrapMode: TextEdit.LineWrappingMode {
        get {
            return get_line_wrapping_mode ()
        }
        
        set {
            set_line_wrapping_mode (newValue)
        }
        
    }
    
    /// If ``wrapMode`` is set to .lineWrappingBoundary, sets text wrapping mode. To see how each mode behaves, see ``TextServer.AutowrapMode``.
    final public var autowrapMode: TextServer.AutowrapMode {
        get {
            return get_autowrap_mode ()
        }
        
        set {
            set_autowrap_mode (newValue)
        }
        
    }
    
    /// Scroll smoothly over the text rather than jumping to the next location.
    final public var scrollSmooth: Bool {
        get {
            return is_smooth_scroll_enabled ()
        }
        
        set {
            set_smooth_scroll_enabled (newValue)
        }
        
    }
    
    /// Sets the scroll speed with the minimap or when ``scrollSmooth`` is enabled.
    final public var scrollVScrollSpeed: Double {
        get {
            return get_v_scroll_speed ()
        }
        
        set {
            set_v_scroll_speed (newValue)
        }
        
    }
    
    /// Allow scrolling past the last line into "virtual" space.
    final public var scrollPastEndOfFile: Bool {
        get {
            return is_scroll_past_end_of_file_enabled ()
        }
        
        set {
            set_scroll_past_end_of_file_enabled (newValue)
        }
        
    }
    
    /// If there is a vertical scrollbar, this determines the current vertical scroll value in line numbers, starting at 0 for the top line.
    final public var scrollVertical: Double {
        get {
            return get_v_scroll ()
        }
        
        set {
            set_v_scroll (newValue)
        }
        
    }
    
    /// If there is a horizontal scrollbar, this determines the current horizontal scroll value in pixels.
    final public var scrollHorizontal: Int32 {
        get {
            return get_h_scroll ()
        }
        
        set {
            set_h_scroll (newValue)
        }
        
    }
    
    /// If `true`, ``TextEdit`` will disable vertical scroll and fit minimum height to the number of visible lines.
    final public var scrollFitContentHeight: Bool {
        get {
            return is_fit_content_height_enabled ()
        }
        
        set {
            set_fit_content_height_enabled (newValue)
        }
        
    }
    
    /// If `true`, a minimap is shown, providing an outline of your source code.
    final public var minimapDraw: Bool {
        get {
            return is_drawing_minimap ()
        }
        
        set {
            set_draw_minimap (newValue)
        }
        
    }
    
    /// The width, in pixels, of the minimap.
    final public var minimapWidth: Int32 {
        get {
            return get_minimap_width ()
        }
        
        set {
            set_minimap_width (newValue)
        }
        
    }
    
    /// Set the type of caret to draw.
    final public var caretType: TextEdit.CaretType {
        get {
            return get_caret_type ()
        }
        
        set {
            set_caret_type (newValue)
        }
        
    }
    
    /// If `true`, makes the caret blink.
    final public var caretBlink: Bool {
        get {
            return is_caret_blink_enabled ()
        }
        
        set {
            set_caret_blink_enabled (newValue)
        }
        
    }
    
    /// The interval at which the caret blinks (in seconds).
    final public var caretBlinkInterval: Double {
        get {
            return get_caret_blink_interval ()
        }
        
        set {
            set_caret_blink_interval (newValue)
        }
        
    }
    
    /// If `true`, caret will be visible when ``editable`` is disabled.
    final public var caretDrawWhenEditableDisabled: Bool {
        get {
            return is_drawing_caret_when_editable_disabled ()
        }
        
        set {
            set_draw_caret_when_editable_disabled (newValue)
        }
        
    }
    
    /// If `true`, a right-click moves the caret at the mouse position before displaying the context menu.
    /// 
    /// If `false`, the context menu disregards mouse location.
    /// 
    final public var caretMoveOnRightClick: Bool {
        get {
            return is_move_caret_on_right_click_enabled ()
        }
        
        set {
            set_move_caret_on_right_click_enabled (newValue)
        }
        
    }
    
    /// Allow moving caret, selecting and removing the individual composite character components.
    /// 
    /// > Note: [kbd]Backspace[/kbd] is always removing individual composite character components.
    /// 
    final public var caretMidGrapheme: Bool {
        get {
            return is_caret_mid_grapheme_enabled ()
        }
        
        set {
            set_caret_mid_grapheme_enabled (newValue)
        }
        
    }
    
    /// Sets if multiple carets are allowed.
    final public var caretMultiple: Bool {
        get {
            return is_multiple_carets_enabled ()
        }
        
        set {
            set_multiple_carets_enabled (newValue)
        }
        
    }
    
    /// Sets the ``SyntaxHighlighter`` to use.
    final public var syntaxHighlighter: SyntaxHighlighter? {
        get {
            return get_syntax_highlighter ()
        }
        
        set {
            set_syntax_highlighter (newValue)
        }
        
    }
    
    /// If `true`, all occurrences of the selected text will be highlighted.
    final public var highlightAllOccurrences: Bool {
        get {
            return is_highlight_all_occurrences_enabled ()
        }
        
        set {
            set_highlight_all_occurrences (newValue)
        }
        
    }
    
    /// If `true`, the line containing the cursor is highlighted.
    final public var highlightCurrentLine: Bool {
        get {
            return is_highlight_current_line_enabled ()
        }
        
        set {
            set_highlight_current_line (newValue)
        }
        
    }
    
    /// If `true`, control characters are displayed.
    final public var drawControlChars: Bool {
        get {
            return get_draw_control_chars ()
        }
        
        set {
            set_draw_control_chars (newValue)
        }
        
    }
    
    /// If `true`, the "tab" character will have a visible representation.
    final public var drawTabs: Bool {
        get {
            return is_drawing_tabs ()
        }
        
        set {
            set_draw_tabs (newValue)
        }
        
    }
    
    /// If `true`, the "space" character will have a visible representation.
    final public var drawSpaces: Bool {
        get {
            return is_drawing_spaces ()
        }
        
        set {
            set_draw_spaces (newValue)
        }
        
    }
    
    /// Base text writing direction.
    final public var textDirection: Control.TextDirection {
        get {
            return get_text_direction ()
        }
        
        set {
            set_text_direction (newValue)
        }
        
    }
    
    /// Language code used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    final public var language: String {
        get {
            return get_language ()
        }
        
        set {
            set_language (newValue)
        }
        
    }
    
    /// Set BiDi algorithm override for the structured text.
    final public var structuredTextBidiOverride: TextServer.StructuredTextParser {
        get {
            return get_structured_text_bidi_override ()
        }
        
        set {
            set_structured_text_bidi_override (newValue)
        }
        
    }
    
    /// Set additional options for BiDi override.
    final public var structuredTextBidiOverrideOptions: GArray {
        get {
            return get_structured_text_bidi_override_options ()
        }
        
        set {
            set_structured_text_bidi_override_options (newValue)
        }
        
    }
    
    /* Methods */
    /// Override this method to define what happens when the user types in the provided key `unicodeChar`.
    @_documentation(visibility: public)
    open func _handleUnicodeInput (unicodeChar: Int32, caretIndex: Int32) {
    }
    
    /// Override this method to define what happens when the user presses the backspace key.
    @_documentation(visibility: public)
    open func _backspace (caretIndex: Int32) {
    }
    
    /// Override this method to define what happens when the user performs a cut operation.
    @_documentation(visibility: public)
    open func _cut (caretIndex: Int32) {
    }
    
    /// Override this method to define what happens when the user performs a copy operation.
    @_documentation(visibility: public)
    open func _copy (caretIndex: Int32) {
    }
    
    /// Override this method to define what happens when the user performs a paste operation.
    @_documentation(visibility: public)
    open func _paste (caretIndex: Int32) {
    }
    
    /// Override this method to define what happens when the user performs a paste operation with middle mouse button.
    /// 
    /// > Note: This method is only implemented on Linux.
    /// 
    @_documentation(visibility: public)
    open func _pastePrimaryClipboard (caretIndex: Int32) {
    }
    
    fileprivate static var method_has_ime_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_ime_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns if the user has IME text.
    public final func hasImeText ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_has_ime_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_editable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_editable")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_editable (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_editable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_editable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_editable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_editable")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_editable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_editable, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_text_direction")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 119160795)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text_direction (_ direction: Control.TextDirection) {
        #if true
        
        var copy_direction = Int64 (direction.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_text_direction, UnsafeMutableRawPointer (mutating: handle), nil, &copy_direction)
        
        #else
        
        var copy_direction = Int64 (direction.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_direction) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_text_direction, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text_direction")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 797257663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text_direction ()-> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TextEdit.method_get_text_direction, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Control.TextDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_language")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_language (_ language: String) {
        #if true
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_language, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_language.content)
        
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_language.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_language, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_language")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_language ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (TextEdit.method_get_language, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_structured_text_bidi_override")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 55961453)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override (_ parser: TextServer.StructuredTextParser) {
        #if true
        
        var copy_parser = Int64 (parser.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), nil, &copy_parser)
        
        #else
        
        var copy_parser = Int64 (parser.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_parser) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_structured_text_bidi_override")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3385126229)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override ()-> TextServer.StructuredTextParser {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TextEdit.method_get_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextServer.StructuredTextParser (rawValue: _result)!
    }
    
    fileprivate static var method_set_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_structured_text_bidi_override_options")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override_options (_ args: GArray) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), nil, &args.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &args.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_structured_text_bidi_override_options")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override_options ()-> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall (TextEdit.method_get_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_tab_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_size")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the tab size for the ``TextEdit`` to use.
    public final func setTabSize (_ size: Int32) {
        #if true
        
        var copy_size: Int = Int (size)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_tab_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_size)
        
        #else
        
        var copy_size: Int = Int (size)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_tab_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_size")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the ``TextEdit``'s' tab size.
    public final func getTabSize ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_tab_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_overtype_mode_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_overtype_mode_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `true`, sets the user into overtype mode. When the user types in this mode, it will override existing text.
    public final func setOvertypeModeEnabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_overtype_mode_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_overtype_mode_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_overtype_mode_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_overtype_mode_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the user is in overtype mode.
    public final func isOvertypeModeEnabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_overtype_mode_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_context_menu_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_context_menu_enabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_context_menu_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_context_menu_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_shortcut_keys_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_shortcut_keys_enabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_shortcut_keys_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_shortcut_keys_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_virtual_keyboard_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_virtual_keyboard_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_virtual_keyboard_enabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_virtual_keyboard_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_virtual_keyboard_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_virtual_keyboard_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_virtual_keyboard_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_virtual_keyboard_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_virtual_keyboard_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_middle_mouse_paste_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_middle_mouse_paste_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_middle_mouse_paste_enabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_middle_mouse_paste_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_middle_mouse_paste_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_middle_mouse_paste_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_middle_mouse_paste_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_middle_mouse_paste_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_middle_mouse_paste_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Performs a full reset of ``TextEdit``, including undo history.
    public final func clear () {
        gi.object_method_bind_ptrcall (TextEdit.method_clear, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text (_ text: String) {
        #if true
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_text, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (TextEdit.method_get_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_line_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_count")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of lines in the text.
    public final func getLineCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_line_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_placeholder")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_placeholder (_ text: String) {
        #if true
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_placeholder, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_placeholder, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_placeholder: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_placeholder")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_placeholder ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (TextEdit.method_get_placeholder, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the text for a specific line.
    public final func setLine (_ line: Int32, newText: String) {
        #if true
        
        var copy_line: Int = Int (line)
        let gstr_new_text = GString (newText)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &gstr_new_text.content)
        
        #else
        
        var copy_line: Int = Int (line)
        let gstr_new_text = GString (newText)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_new_text.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the text of a specific line.
    public final func getLine (_ line: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_line)
        return _result.description
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_width")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 688195400)!
            }
            
        }
        
    }()
    
    /// Returns the width in pixels of the `wrapIndex` on `line`.
    public final func getLineWidth (line: Int32, wrapIndex: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_width, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_wrap_index)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_wrap_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_line_width, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_height: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_height")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the maximum value of the line height among all lines.
    /// 
    /// > Note: The return value is influenced by [theme_item line_spacing] and [theme_item font_size]. And it will not be less than `1`.
    /// 
    public final func getLineHeight ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_line_height, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_indent_level: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_indent_level")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the number of spaces and `tab * tab_size` before the first char.
    public final func getIndentLevel (line: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_indent_level, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_indent_level, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_first_non_whitespace_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_first_non_whitespace_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the first column containing a non-whitespace character.
    public final func getFirstNonWhitespaceColumn (line: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_first_non_whitespace_column, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_first_non_whitespace_column, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_swap_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("swap_lines")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Swaps the two lines.
    public final func swapLines (fromLine: Int32, toLine: Int32) {
        #if true
        
        var copy_from_line: Int = Int (fromLine)
        var copy_to_line: Int = Int (toLine)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_swap_lines, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_line, &copy_to_line)
        
        #else
        
        var copy_from_line: Int = Int (fromLine)
        var copy_to_line: Int = Int (toLine)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to_line) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_swap_lines, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_insert_line_at: GDExtensionMethodBindPtr = {
        let methodName = StringName ("insert_line_at")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Inserts a new line with `text` at `line`.
    public final func insertLineAt (line: Int32, text: String) {
        #if true
        
        var copy_line: Int = Int (line)
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_insert_line_at, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &gstr_text.content)
        
        #else
        
        var copy_line: Int = Int (line)
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_text.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_insert_line_at, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_insert_text_at_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("insert_text_at_caret")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2697778442)!
            }
            
        }
        
    }()
    
    /// Insert the specified text at the caret position.
    public final func insertTextAtCaret (text: String, caretIndex: Int32 = -1) {
        #if true
        
        let gstr_text = GString (text)
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_insert_text_at_caret, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content, &copy_caret_index)
        
        #else
        
        let gstr_text = GString (text)
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_caret_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_insert_text_at_caret, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4275841770)!
            }
            
        }
        
    }()
    
    /// Removes text between the given positions.
    /// 
    /// > Note: This does not adjust the caret or selection, which as a result it can end up in an invalid position.
    /// 
    public final func removeText (fromLine: Int32, fromColumn: Int32, toLine: Int32, toColumn: Int32) {
        #if true
        
        var copy_from_line: Int = Int (fromLine)
        var copy_from_column: Int = Int (fromColumn)
        var copy_to_line: Int = Int (toLine)
        var copy_to_column: Int = Int (toColumn)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_remove_text, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_line, &copy_from_column, &copy_to_line, &copy_to_column)
        
        #else
        
        var copy_from_line: Int = Int (fromLine)
        var copy_from_column: Int = Int (fromColumn)
        var copy_to_line: Int = Int (toLine)
        var copy_to_column: Int = Int (toColumn)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_from_column) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_to_line) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_to_column) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextEdit.method_remove_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_last_unhidden_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_last_unhidden_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the last unhidden line in the entire ``TextEdit``.
    public final func getLastUnhiddenLine ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_last_unhidden_line, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_next_visible_line_offset_from: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_next_visible_line_offset_from")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3175239445)!
            }
            
        }
        
    }()
    
    /// Returns the count to the next visible line from `line` to `line + visible_amount`. Can also count backwards. For example if a ``TextEdit`` has 5 lines with lines 2 and 3 hidden, calling this with `line = 1, visible_amount = 1` would return 3.
    public final func getNextVisibleLineOffsetFrom (line: Int32, visibleAmount: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_line: Int = Int (line)
        var copy_visible_amount: Int = Int (visibleAmount)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_next_visible_line_offset_from, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_visible_amount)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_visible_amount: Int = Int (visibleAmount)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_visible_amount) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_next_visible_line_offset_from, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_next_visible_line_index_offset_from: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_next_visible_line_index_offset_from")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3386475622)!
            }
            
        }
        
    }()
    
    /// Similar to ``getNextVisibleLineOffsetFrom(line:visibleAmount:)``, but takes into account the line wrap indexes. In the returned vector, `x` is the line, `y` is the wrap index.
    public final func getNextVisibleLineIndexOffsetFrom (line: Int32, wrapIndex: Int32, visibleAmount: Int32)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if true
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        var copy_visible_amount: Int = Int (visibleAmount)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_next_visible_line_index_offset_from, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_wrap_index, &copy_visible_amount)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        var copy_visible_amount: Int = Int (visibleAmount)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_wrap_index) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_visible_amount) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextEdit.method_get_next_visible_line_index_offset_from, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_backspace: GDExtensionMethodBindPtr = {
        let methodName = StringName ("backspace")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Called when the user presses the backspace key. Can be overridden with ``_backspace(caretIndex:)``.
    public final func backspace (caretIndex: Int32 = -1) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_backspace, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_backspace, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_cut: GDExtensionMethodBindPtr = {
        let methodName = StringName ("cut")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Cut's the current selection. Can be overridden with ``_cut(caretIndex:)``.
    public final func cut (caretIndex: Int32 = -1) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_cut, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_cut, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_copy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("copy")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Copies the current text selection. Can be overridden with ``_copy(caretIndex:)``.
    public final func copy (caretIndex: Int32 = -1) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_copy, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_copy, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_paste: GDExtensionMethodBindPtr = {
        let methodName = StringName ("paste")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Paste at the current location. Can be overridden with ``_paste(caretIndex:)``.
    public final func paste (caretIndex: Int32 = -1) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_paste, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_paste, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_paste_primary_clipboard: GDExtensionMethodBindPtr = {
        let methodName = StringName ("paste_primary_clipboard")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Pastes the primary clipboard.
    public final func pastePrimaryClipboard (caretIndex: Int32 = -1) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_paste_primary_clipboard, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_paste_primary_clipboard, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_start_action: GDExtensionMethodBindPtr = {
        let methodName = StringName ("start_action")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2834827583)!
            }
            
        }
        
    }()
    
    /// Starts an action, will end the current action if `action` is different.
    /// 
    /// An action will also end after a call to ``endAction()``, after ``ProjectSettings/gui/timers/textEditIdleDetectSec`` is triggered or a new undoable step outside the ``startAction(_:)`` and ``endAction()`` calls.
    /// 
    public final func startAction (_ action: TextEdit.EditAction) {
        #if true
        
        var copy_action = Int64 (action.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_start_action, UnsafeMutableRawPointer (mutating: handle), nil, &copy_action)
        
        #else
        
        var copy_action = Int64 (action.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_action) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_start_action, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_end_action: GDExtensionMethodBindPtr = {
        let methodName = StringName ("end_action")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Marks the end of steps in the current action started with ``startAction(_:)``.
    public final func endAction () {
        gi.object_method_bind_ptrcall (TextEdit.method_end_action, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_begin_complex_operation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("begin_complex_operation")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Starts a multipart edit. All edits will be treated as one action until ``endComplexOperation()`` is called.
    public final func beginComplexOperation () {
        gi.object_method_bind_ptrcall (TextEdit.method_begin_complex_operation, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_end_complex_operation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("end_complex_operation")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Ends a multipart edit, started with ``beginComplexOperation()``. If called outside a complex operation, the current operation is pushed onto the undo/redo stack.
    public final func endComplexOperation () {
        gi.object_method_bind_ptrcall (TextEdit.method_end_complex_operation, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_has_undo: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_undo")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if an "undo" action is available.
    public final func hasUndo ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_has_undo, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_has_redo: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_redo")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a "redo" action is available.
    public final func hasRedo ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_has_redo, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_undo: GDExtensionMethodBindPtr = {
        let methodName = StringName ("undo")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Perform undo operation.
    public final func undo () {
        gi.object_method_bind_ptrcall (TextEdit.method_undo, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_redo: GDExtensionMethodBindPtr = {
        let methodName = StringName ("redo")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Perform redo operation.
    public final func redo () {
        gi.object_method_bind_ptrcall (TextEdit.method_redo, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_clear_undo_history: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_undo_history")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the undo history.
    public final func clearUndoHistory () {
        gi.object_method_bind_ptrcall (TextEdit.method_clear_undo_history, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_tag_saved_version: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tag_saved_version")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Tag the current version as saved.
    public final func tagSavedVersion () {
        gi.object_method_bind_ptrcall (TextEdit.method_tag_saved_version, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_version: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_version")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the current version of the ``TextEdit``. The version is a count of recorded operations by the undo/redo history.
    public final func getVersion ()-> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_version, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_saved_version: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_saved_version")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the last tagged saved version from ``tagSavedVersion()``.
    public final func getSavedVersion ()-> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_saved_version, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_search_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_search_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Sets the search text. See ``setSearchFlags(_:)``.
    public final func setSearchText (_ searchText: String) {
        #if true
        
        let gstr_search_text = GString (searchText)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_search_text, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_search_text.content)
        
        #else
        
        let gstr_search_text = GString (searchText)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_search_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_search_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_search_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_search_flags")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the search `flags`. This is used with ``setSearchText(_:)`` to highlight occurrences of the searched text. Search flags can be specified from the ``TextEdit/SearchFlags`` enum.
    public final func setSearchFlags (_ flags: UInt32) {
        #if true
        
        var copy_flags: Int = Int (flags)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_search_flags, UnsafeMutableRawPointer (mutating: handle), nil, &copy_flags)
        
        #else
        
        var copy_flags: Int = Int (flags)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_flags) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_search_flags, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_search: GDExtensionMethodBindPtr = {
        let methodName = StringName ("search")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1203739136)!
            }
            
        }
        
    }()
    
    /// Perform a search inside the text. Search flags can be specified in the ``TextEdit/SearchFlags`` enum.
    /// 
    /// In the returned vector, `x` is the column, `y` is the line. If no results are found, both are equal to `-1`.
    /// 
    public final func search (text: String, flags: UInt32, fromLine: Int32, fromColum: Int32)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if true
        
        let gstr_text = GString (text)
        var copy_flags: Int = Int (flags)
        var copy_from_line: Int = Int (fromLine)
        var copy_from_colum: Int = Int (fromColum)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_search, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_text.content, &copy_flags, &copy_from_line, &copy_from_colum)
        return _result
        #else
        
        let gstr_text = GString (text)
        var copy_flags: Int = Int (flags)
        var copy_from_line: Int = Int (fromLine)
        var copy_from_colum: Int = Int (fromColum)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_flags) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_from_line) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_from_colum) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextEdit.method_search, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_tooltip_request_func: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tooltip_request_func")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1611583062)!
            }
            
        }
        
    }()
    
    /// Provide custom tooltip text. The callback method must take the following args: `hovered_word: String`.
    public final func setTooltipRequestFunc (callback: Callable) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_tooltip_request_func, UnsafeMutableRawPointer (mutating: handle), nil, &callback.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callback.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_tooltip_request_func, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_local_mouse_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_local_mouse_pos")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the local mouse position adjusted for the text direction.
    public final func getLocalMousePos ()-> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall (TextEdit.method_get_local_mouse_pos, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_word_at_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_word_at_pos")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3674420000)!
            }
            
        }
        
    }()
    
    /// Returns the word at `position`.
    public final func getWordAtPos (position: Vector2)-> String {
        let _result = GString ()
        #if true
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_word_at_pos, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_position)
        return _result.description
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_word_at_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_column_at_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_column_at_pos")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 239517838)!
            }
            
        }
        
    }()
    
    /// Returns the line and column at the given position. In the returned vector, `x` is the column, `y` is the line. If `allowOutOfBounds` is `false` and the position is not over the text, both vector values will be set to `-1`.
    public final func getLineColumnAtPos (position: Vector2i, allowOutOfBounds: Bool = true)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if true
        
        var copy_position = position
        var copy_allow_out_of_bounds = allowOutOfBounds
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_column_at_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_position, &copy_allow_out_of_bounds)
        return _result
        #else
        
        var copy_position = position
        var copy_allow_out_of_bounds = allowOutOfBounds
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_allow_out_of_bounds) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_line_column_at_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_pos_at_line_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_pos_at_line_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 410388347)!
            }
            
        }
        
    }()
    
    /// Returns the local position for the given `line` and `column`. If `x` or `y` of the returned vector equal `-1`, the position is outside of the viewable area of the control.
    /// 
    /// > Note: The Y position corresponds to the bottom side of the line. Use ``getRectAtLineColumn(line:column:)`` to get the top side position.
    /// 
    public final func getPosAtLineColumn (line: Int32, column: Int32)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if true
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_pos_at_line_column, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_column)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_pos_at_line_column, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_rect_at_line_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_rect_at_line_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3256618057)!
            }
            
        }
        
    }()
    
    /// Returns the local position and size for the grapheme at the given `line` and `column`. If `x` or `y` position of the returned rect equal `-1`, the position is outside of the viewable area of the control.
    /// 
    /// > Note: The Y position of the returned rect corresponds to the top side of the line, unlike ``getPosAtLineColumn(line:column:)`` which returns the bottom side.
    /// 
    public final func getRectAtLineColumn (line: Int32, column: Int32)-> Rect2i {
        var _result: Rect2i = Rect2i ()
        #if true
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_rect_at_line_column, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_column)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_rect_at_line_column, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_minimap_line_at_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_minimap_line_at_pos")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2485466453)!
            }
            
        }
        
    }()
    
    /// Returns the equivalent minimap line at `position`.
    public final func getMinimapLineAtPos (position: Vector2i)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_minimap_line_at_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_position)
        return _result
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_minimap_line_at_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_dragging_cursor: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_dragging_cursor")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the user is dragging their mouse for scrolling or selecting.
    public final func isDraggingCursor ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_dragging_cursor, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_mouse_over_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_mouse_over_selection")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1840282309)!
            }
            
        }
        
    }()
    
    /// Returns whether the mouse is over selection. If `edges` is `true`, the edges are considered part of the selection.
    public final func isMouseOverSelection (edges: Bool, caretIndex: Int32 = -1)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_edges = edges
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_is_mouse_over_selection, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_edges, &copy_caret_index)
        return _result
        #else
        
        var copy_edges = edges
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_edges) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_caret_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_is_mouse_over_selection, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_caret_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_type")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1211596914)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_type (_ type: TextEdit.CaretType) {
        #if true
        
        var copy_type = Int64 (type.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_caret_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_type)
        
        #else
        
        var copy_type = Int64 (type.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_caret_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_type")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2830252959)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_caret_type ()-> TextEdit.CaretType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TextEdit.method_get_caret_type, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextEdit.CaretType (rawValue: _result)!
    }
    
    fileprivate static var method_set_caret_blink_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_blink_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_blink_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_caret_blink_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_caret_blink_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_caret_blink_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_caret_blink_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_caret_blink_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_caret_blink_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_blink_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_blink_interval")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_blink_interval (_ interval: Double) {
        #if true
        
        var copy_interval = interval
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_caret_blink_interval, UnsafeMutableRawPointer (mutating: handle), nil, &copy_interval)
        
        #else
        
        var copy_interval = interval
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_interval) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_caret_blink_interval, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_blink_interval: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_blink_interval")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_caret_blink_interval ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (TextEdit.method_get_caret_blink_interval, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_caret_when_editable_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_caret_when_editable_disabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_caret_when_editable_disabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_draw_caret_when_editable_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_draw_caret_when_editable_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drawing_caret_when_editable_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drawing_caret_when_editable_disabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_caret_when_editable_disabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_drawing_caret_when_editable_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_move_caret_on_right_click_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_move_caret_on_right_click_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_move_caret_on_right_click_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_move_caret_on_right_click_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_move_caret_on_right_click_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_move_caret_on_right_click_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_move_caret_on_right_click_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_move_caret_on_right_click_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_move_caret_on_right_click_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_caret_mid_grapheme_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_mid_grapheme_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_caret_mid_grapheme_enabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_caret_mid_grapheme_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_caret_mid_grapheme_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_caret_mid_grapheme_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_caret_mid_grapheme_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_caret_mid_grapheme_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_caret_mid_grapheme_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_multiple_carets_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_multiple_carets_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_multiple_carets_enabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_multiple_carets_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_multiple_carets_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_multiple_carets_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_multiple_carets_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_multiple_carets_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_multiple_carets_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_caret")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 50157827)!
            }
            
        }
        
    }()
    
    /// Adds a new caret at the given location. Returns the index of the new caret, or `-1` if the location is invalid.
    public final func addCaret (line: Int32, col: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_line: Int = Int (line)
        var copy_col: Int = Int (col)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_add_caret, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_col)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_col: Int = Int (col)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_col) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_add_caret, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_caret")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the given caret index.
    /// 
    /// > Note: This can result in adjustment of all other caret indices.
    /// 
    public final func removeCaret (_ caret: Int32) {
        #if true
        
        var copy_caret: Int = Int (caret)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_remove_caret, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret)
        
        #else
        
        var copy_caret: Int = Int (caret)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_remove_caret, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_secondary_carets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_secondary_carets")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all additional carets.
    public final func removeSecondaryCarets () {
        gi.object_method_bind_ptrcall (TextEdit.method_remove_secondary_carets, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_merge_overlapping_carets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("merge_overlapping_carets")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Merges any overlapping carets. Will favor the newest caret, or the caret with a selection.
    /// 
    /// > Note: This is not called when a caret changes position but after certain actions, so it is possible to get into a state where carets overlap.
    /// 
    public final func mergeOverlappingCarets () {
        gi.object_method_bind_ptrcall (TextEdit.method_merge_overlapping_carets, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_caret_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_count")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of carets in this ``TextEdit``.
    public final func getCaretCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_caret_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_caret_at_carets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_caret_at_carets")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Adds an additional caret above or below every caret. If `below` is true the new caret will be added below and above otherwise.
    public final func addCaretAtCarets (below: Bool) {
        #if true
        
        var copy_below = below
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_add_caret_at_carets, UnsafeMutableRawPointer (mutating: handle), nil, &copy_below)
        
        #else
        
        var copy_below = below
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_below) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_add_caret_at_carets, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_index_edit_order: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_index_edit_order")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 969006518)!
            }
            
        }
        
    }()
    
    /// Returns a list of caret indexes in their edit order, this done from bottom to top. Edit order refers to the way actions such as ``insertTextAtCaret(text:caretIndex:)`` are applied.
    public final func getCaretIndexEditOrder ()-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall (TextEdit.method_get_caret_index_edit_order, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_adjust_carets_after_edit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("adjust_carets_after_edit")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1770277138)!
            }
            
        }
        
    }()
    
    /// Reposition the carets affected by the edit. This assumes edits are applied in edit order, see ``getCaretIndexEditOrder()``.
    public final func adjustCaretsAfterEdit (caret: Int32, fromLine: Int32, fromCol: Int32, toLine: Int32, toCol: Int32) {
        #if true
        
        var copy_caret: Int = Int (caret)
        var copy_from_line: Int = Int (fromLine)
        var copy_from_col: Int = Int (fromCol)
        var copy_to_line: Int = Int (toLine)
        var copy_to_col: Int = Int (toCol)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_adjust_carets_after_edit, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret, &copy_from_line, &copy_from_col, &copy_to_line, &copy_to_col)
        
        #else
        
        var copy_caret: Int = Int (caret)
        var copy_from_line: Int = Int (fromLine)
        var copy_from_col: Int = Int (fromCol)
        var copy_to_line: Int = Int (toLine)
        var copy_to_col: Int = Int (toCol)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_from_line) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_from_col) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_to_line) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_to_col) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (TextEdit.method_adjust_carets_after_edit, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_caret_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_caret_visible")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1051549951)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the caret is visible on the screen.
    public final func isCaretVisible (caretIndex: Int32 = 0)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_is_caret_visible, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_is_caret_visible, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_draw_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_draw_pos")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 478253731)!
            }
            
        }
        
    }()
    
    /// Returns the caret pixel draw position.
    public final func getCaretDrawPos (caretIndex: Int32 = 0)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_caret_draw_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_caret_draw_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_caret_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1302582944)!
            }
            
        }
        
    }()
    
    /// Moves the caret to the specified `line` index.
    /// 
    /// If `adjustViewport` is `true`, the viewport will center at the caret position after the move occurs.
    /// 
    /// If `canBeHidden` is `true`, the specified `line` can be hidden.
    /// 
    /// > Note: If supporting multiple carets this will not check for any overlap. See ``mergeOverlappingCarets()``.
    /// 
    public final func setCaretLine (_ line: Int32, adjustViewport: Bool = true, canBeHidden: Bool = true, wrapIndex: Int32 = 0, caretIndex: Int32 = 0) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_adjust_viewport = adjustViewport
        var copy_can_be_hidden = canBeHidden
        var copy_wrap_index: Int = Int (wrapIndex)
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_caret_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_adjust_viewport, &copy_can_be_hidden, &copy_wrap_index, &copy_caret_index)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_adjust_viewport = adjustViewport
        var copy_can_be_hidden = canBeHidden
        var copy_wrap_index: Int = Int (wrapIndex)
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_adjust_viewport) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_can_be_hidden) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_wrap_index) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_caret_index) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (TextEdit.method_set_caret_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the line the editing caret is on.
    public final func getCaretLine (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_caret_line, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_caret_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_caret_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_caret_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3796796178)!
            }
            
        }
        
    }()
    
    /// Moves the caret to the specified `column` index.
    /// 
    /// If `adjustViewport` is `true`, the viewport will center at the caret position after the move occurs.
    /// 
    /// > Note: If supporting multiple carets this will not check for any overlap. See ``mergeOverlappingCarets()``.
    /// 
    public final func setCaretColumn (_ column: Int32, adjustViewport: Bool = true, caretIndex: Int32 = 0) {
        #if true
        
        var copy_column: Int = Int (column)
        var copy_adjust_viewport = adjustViewport
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_caret_column, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &copy_adjust_viewport, &copy_caret_index)
        
        #else
        
        var copy_column: Int = Int (column)
        var copy_adjust_viewport = adjustViewport
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_adjust_viewport) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_caret_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextEdit.method_set_caret_column, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the column the editing caret is at.
    public final func getCaretColumn (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_caret_column, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_caret_column, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_caret_wrap_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_caret_wrap_index")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the wrap index the editing caret is on.
    public final func getCaretWrapIndex (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_caret_wrap_index, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_caret_wrap_index, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_word_under_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_word_under_caret")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3929349208)!
            }
            
        }
        
    }()
    
    /// Returns a ``String`` text with the word under the caret's location.
    public final func getWordUnderCaret (caretIndex: Int32 = -1)-> String {
        let _result = GString ()
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_word_under_caret, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_caret_index)
        return _result.description
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_word_under_caret, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_set_selecting_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_selecting_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_selecting_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_selecting_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_selecting_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_selecting_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_selecting_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_selecting_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_selecting_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_deselect_on_focus_loss_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_deselect_on_focus_loss_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_deselect_on_focus_loss_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_deselect_on_focus_loss_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_drag_and_drop_selection_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drag_and_drop_selection_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drag_and_drop_selection_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drag_and_drop_selection_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_selection_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_selection_mode")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1443345937)!
            }
            
        }
        
    }()
    
    /// Sets the current selection mode.
    public final func setSelectionMode (_ mode: TextEdit.SelectionMode, line: Int32 = -1, column: Int32 = -1, caretIndex: Int32 = 0) {
        #if true
        
        var copy_mode = Int64 (mode.rawValue)
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_selection_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode, &copy_line, &copy_column, &copy_caret_index)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_line) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_column) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_caret_index) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextEdit.method_set_selection_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_selection_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_mode")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3750106938)!
            }
            
        }
        
    }()
    
    /// Returns the current selection mode.
    public final func getSelectionMode ()-> TextEdit.SelectionMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TextEdit.method_get_selection_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextEdit.SelectionMode (rawValue: _result)!
    }
    
    fileprivate static var method_select_all: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select_all")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Select all the text.
    /// 
    /// If ``selectingEnabled`` is `false`, no selection will occur.
    /// 
    public final func selectAll () {
        gi.object_method_bind_ptrcall (TextEdit.method_select_all, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_select_word_under_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select_word_under_caret")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Selects the word under the caret.
    public final func selectWordUnderCaret (caretIndex: Int32 = -1) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_select_word_under_caret, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_select_word_under_caret, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_selection_for_next_occurrence: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_selection_for_next_occurrence")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a selection and a caret for the next occurrence of the current selection. If there is no active selection, selects word under caret.
    public final func addSelectionForNextOccurrence () {
        gi.object_method_bind_ptrcall (TextEdit.method_add_selection_for_next_occurrence, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_select: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2560984452)!
            }
            
        }
        
    }()
    
    /// Perform selection, from line/column to line/column.
    /// 
    /// If ``selectingEnabled`` is `false`, no selection will occur.
    /// 
    public final func select (fromLine: Int32, fromColumn: Int32, toLine: Int32, toColumn: Int32, caretIndex: Int32 = 0) {
        #if true
        
        var copy_from_line: Int = Int (fromLine)
        var copy_from_column: Int = Int (fromColumn)
        var copy_to_line: Int = Int (toLine)
        var copy_to_column: Int = Int (toColumn)
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_select, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_line, &copy_from_column, &copy_to_line, &copy_to_column, &copy_caret_index)
        
        #else
        
        var copy_from_line: Int = Int (fromLine)
        var copy_from_column: Int = Int (fromColumn)
        var copy_to_line: Int = Int (toLine)
        var copy_to_column: Int = Int (toColumn)
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_from_column) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_to_line) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_to_column) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_caret_index) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (TextEdit.method_select, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_selection")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2824505868)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the user has selected text.
    public final func hasSelection (caretIndex: Int32 = -1)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_has_selection, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_has_selection, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_selected_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selected_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2309358862)!
            }
            
        }
        
    }()
    
    /// Returns the text inside the selection of a caret, or all the carets if `caretIndex` is its default value `-1`.
    public final func getSelectedText (caretIndex: Int32 = -1)-> String {
        let _result = GString ()
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_selected_text, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_caret_index)
        return _result.description
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_selected_text, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_selection_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the original start line of the selection.
    public final func getSelectionLine (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_selection_line, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_selection_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_selection_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the original start column of the selection.
    public final func getSelectionColumn (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_selection_column, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_selection_column, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_selection_from_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_from_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the selection begin line.
    public final func getSelectionFromLine (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_selection_from_line, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_selection_from_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_selection_from_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_from_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the selection begin column.
    public final func getSelectionFromColumn (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_selection_from_column, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_selection_from_column, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_selection_to_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_to_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the selection end line.
    public final func getSelectionToLine (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_selection_to_line, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_selection_to_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_selection_to_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_to_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the selection end column.
    public final func getSelectionToColumn (caretIndex: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_selection_to_column, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_caret_index)
        return _result
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_selection_to_column, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_deselect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("deselect")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Deselects the current selection.
    public final func deselect (caretIndex: Int32 = -1) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_deselect, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_deselect, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_delete_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("delete_selection")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Deletes the selected text.
    public final func deleteSelection (caretIndex: Int32 = -1) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_delete_selection, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_delete_selection, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_line_wrapping_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_wrapping_mode")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2525115309)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_line_wrapping_mode (_ mode: TextEdit.LineWrappingMode) {
        #if true
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_wrapping_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_line_wrapping_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_wrapping_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_wrapping_mode")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3562716114)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_line_wrapping_mode ()-> TextEdit.LineWrappingMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TextEdit.method_get_line_wrapping_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextEdit.LineWrappingMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_autowrap_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_autowrap_mode")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3289138044)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_autowrap_mode (_ autowrapMode: TextServer.AutowrapMode) {
        #if true
        
        var copy_autowrap_mode = Int64 (autowrapMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_autowrap_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_autowrap_mode)
        
        #else
        
        var copy_autowrap_mode = Int64 (autowrapMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_autowrap_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_autowrap_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_autowrap_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_autowrap_mode")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1549071663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_autowrap_mode ()-> TextServer.AutowrapMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TextEdit.method_get_autowrap_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextServer.AutowrapMode (rawValue: _result)!
    }
    
    fileprivate static var method_is_line_wrapped: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_wrapped")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns if the given line is wrapped.
    public final func isLineWrapped (line: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_is_line_wrapped, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_is_line_wrapped, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_wrap_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_wrap_count")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the number of times the given line is wrapped.
    public final func getLineWrapCount (line: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_wrap_count, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_line_wrap_count, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_wrap_index_at_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_wrap_index_at_column")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3175239445)!
            }
            
        }
        
    }()
    
    /// Returns the wrap index of the given line column.
    public final func getLineWrapIndexAtColumn (line: Int32, column: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_wrap_index_at_column, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_column)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_line_wrap_index_at_column, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_wrapped_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_wrapped_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 647634434)!
            }
            
        }
        
    }()
    
    /// Returns an array of ``String``s representing each wrapped index.
    public final func getLineWrappedText (line: Int32)-> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        #if true
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_wrapped_text, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_line_wrapped_text, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_smooth_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_smooth_scroll_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_smooth_scroll_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_smooth_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_smooth_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_smooth_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_smooth_scroll_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_smooth_scroll_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_smooth_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_v_scroll_bar: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_v_scroll_bar")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3226026593)!
            }
            
        }
        
    }()
    
    /// Returns the ``VScrollBar`` of the ``TextEdit``.
    public final func getVScrollBar ()-> VScrollBar? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TextEdit.method_get_v_scroll_bar, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_h_scroll_bar: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_h_scroll_bar")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3774687988)!
            }
            
        }
        
    }()
    
    /// Returns the ``HScrollBar`` used by ``TextEdit``.
    public final func getHScrollBar ()-> HScrollBar? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TextEdit.method_get_h_scroll_bar, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_v_scroll: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_v_scroll")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_v_scroll (_ value: Double) {
        #if true
        
        var copy_value = value
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_v_scroll, UnsafeMutableRawPointer (mutating: handle), nil, &copy_value)
        
        #else
        
        var copy_value = value
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_v_scroll, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_v_scroll: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_v_scroll")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_v_scroll ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (TextEdit.method_get_v_scroll, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_h_scroll: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_h_scroll")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_h_scroll (_ value: Int32) {
        #if true
        
        var copy_value: Int = Int (value)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_h_scroll, UnsafeMutableRawPointer (mutating: handle), nil, &copy_value)
        
        #else
        
        var copy_value: Int = Int (value)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_h_scroll, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_h_scroll: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_h_scroll")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_h_scroll ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_h_scroll, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scroll_past_end_of_file_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scroll_past_end_of_file_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scroll_past_end_of_file_enabled (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_scroll_past_end_of_file_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_scroll_past_end_of_file_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_scroll_past_end_of_file_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_scroll_past_end_of_file_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_scroll_past_end_of_file_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_scroll_past_end_of_file_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_v_scroll_speed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_v_scroll_speed")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_v_scroll_speed (_ speed: Double) {
        #if true
        
        var copy_speed = speed
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_v_scroll_speed, UnsafeMutableRawPointer (mutating: handle), nil, &copy_speed)
        
        #else
        
        var copy_speed = speed
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_speed) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_v_scroll_speed, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_v_scroll_speed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_v_scroll_speed")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_v_scroll_speed ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (TextEdit.method_get_v_scroll_speed, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_fit_content_height_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_fit_content_height_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_fit_content_height_enabled (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_fit_content_height_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_fit_content_height_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_fit_content_height_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_fit_content_height_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_fit_content_height_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_fit_content_height_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_scroll_pos_for_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scroll_pos_for_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3929084198)!
            }
            
        }
        
    }()
    
    /// Returns the scroll position for `wrapIndex` of `line`.
    public final func getScrollPosForLine (_ line: Int32, wrapIndex: Int32 = 0)-> Double {
        var _result: Double = 0.0
        #if true
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_scroll_pos_for_line, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_wrap_index)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_wrap_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_scroll_pos_for_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_line_as_first_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_as_first_visible")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2230941749)!
            }
            
        }
        
    }()
    
    /// Positions the `wrapIndex` of `line` at the top of the viewport.
    public final func setLineAsFirstVisible (line: Int32, wrapIndex: Int32 = 0) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_as_first_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_wrap_index)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_wrap_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_line_as_first_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_first_visible_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_first_visible_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the first visible line.
    public final func getFirstVisibleLine ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_first_visible_line, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_line_as_center_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_as_center_visible")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2230941749)!
            }
            
        }
        
    }()
    
    /// Positions the `wrapIndex` of `line` at the center of the viewport.
    public final func setLineAsCenterVisible (line: Int32, wrapIndex: Int32 = 0) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_as_center_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_wrap_index)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_wrap_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_line_as_center_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_line_as_last_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_as_last_visible")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2230941749)!
            }
            
        }
        
    }()
    
    /// Positions the `wrapIndex` of `line` at the bottom of the viewport.
    public final func setLineAsLastVisible (line: Int32, wrapIndex: Int32 = 0) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_as_last_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_wrap_index)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_wrap_index: Int = Int (wrapIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_wrap_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_line_as_last_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_last_full_visible_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_last_full_visible_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the last visible line. Use ``getLastFullVisibleLineWrapIndex()`` for the wrap index.
    public final func getLastFullVisibleLine ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_last_full_visible_line, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_last_full_visible_line_wrap_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_last_full_visible_line_wrap_index")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the last visible wrap index of the last visible line.
    public final func getLastFullVisibleLineWrapIndex ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_last_full_visible_line_wrap_index, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_line_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visible_line_count")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of visible lines, including wrapped text.
    public final func getVisibleLineCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_visible_line_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_line_count_in_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visible_line_count_in_range")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3175239445)!
            }
            
        }
        
    }()
    
    /// Returns the total number of visible + wrapped lines between the two lines.
    public final func getVisibleLineCountInRange (fromLine: Int32, toLine: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_from_line: Int = Int (fromLine)
        var copy_to_line: Int = Int (toLine)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_visible_line_count_in_range, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_from_line, &copy_to_line)
        return _result
        #else
        
        var copy_from_line: Int = Int (fromLine)
        var copy_to_line: Int = Int (toLine)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to_line) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_visible_line_count_in_range, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_total_visible_line_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_total_visible_line_count")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of lines that may be drawn.
    public final func getTotalVisibleLineCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_total_visible_line_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_adjust_viewport_to_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("adjust_viewport_to_caret")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1995695955)!
            }
            
        }
        
    }()
    
    /// Adjust the viewport so the caret is visible.
    public final func adjustViewportToCaret (caretIndex: Int32 = 0) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_adjust_viewport_to_caret, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_adjust_viewport_to_caret, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_center_viewport_to_caret: GDExtensionMethodBindPtr = {
        let methodName = StringName ("center_viewport_to_caret")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1995695955)!
            }
            
        }
        
    }()
    
    /// Centers the viewport on the line the editing caret is at. This also resets the ``scrollHorizontal`` value to `0`.
    public final func centerViewportToCaret (caretIndex: Int32 = 0) {
        #if true
        
        var copy_caret_index: Int = Int (caretIndex)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_center_viewport_to_caret, UnsafeMutableRawPointer (mutating: handle), nil, &copy_caret_index)
        
        #else
        
        var copy_caret_index: Int = Int (caretIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_caret_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_center_viewport_to_caret, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_draw_minimap: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_minimap")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_minimap (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_draw_minimap, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_draw_minimap, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drawing_minimap: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drawing_minimap")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_minimap ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_drawing_minimap, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_minimap_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_minimap_width")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_minimap_width (_ width: Int32) {
        #if true
        
        var copy_width: Int = Int (width)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_minimap_width, UnsafeMutableRawPointer (mutating: handle), nil, &copy_width)
        
        #else
        
        var copy_width: Int = Int (width)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_width) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_minimap_width, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_minimap_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_minimap_width")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_minimap_width ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_minimap_width, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_minimap_visible_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_minimap_visible_lines")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of lines that may be drawn on the minimap.
    public final func getMinimapVisibleLines ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_minimap_visible_lines, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_gutter")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1025054187)!
            }
            
        }
        
    }()
    
    /// Register a new gutter to this ``TextEdit``. Use `at` to have a specific gutter order. A value of `-1` appends the gutter to the right.
    public final func addGutter (at: Int32 = -1) {
        #if true
        
        var copy_at: Int = Int (at)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_add_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_at)
        
        #else
        
        var copy_at: Int = Int (at)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_at) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_add_gutter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_remove_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_gutter")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the gutter from this ``TextEdit``.
    public final func removeGutter (_ gutter: Int32) {
        #if true
        
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_remove_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_gutter)
        
        #else
        
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_remove_gutter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_gutter_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_gutter_count")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of gutters registered.
    public final func getGutterCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_gutter_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_gutter_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_gutter_name")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the name of the gutter.
    public final func setGutterName (gutter: Int32, name: String) {
        #if true
        
        var copy_gutter: Int = Int (gutter)
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_gutter_name, UnsafeMutableRawPointer (mutating: handle), nil, &copy_gutter, &gstr_name.content)
        
        #else
        
        var copy_gutter: Int = Int (gutter)
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_name.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_gutter_name, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_gutter_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_gutter_name")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the name of the gutter at the given index.
    public final func getGutterName (gutter: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_gutter_name, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_gutter)
        return _result.description
        #else
        
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_gutter_name, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_set_gutter_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_gutter_type")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1088959071)!
            }
            
        }
        
    }()
    
    /// Sets the type of gutter.
    public final func setGutterType (gutter: Int32, type: TextEdit.GutterType) {
        #if true
        
        var copy_gutter: Int = Int (gutter)
        var copy_type = Int64 (type.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_gutter_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_gutter, &copy_type)
        
        #else
        
        var copy_gutter: Int = Int (gutter)
        var copy_type = Int64 (type.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_type) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_gutter_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_gutter_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_gutter_type")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1159699127)!
            }
            
        }
        
    }()
    
    /// Returns the type of the gutter at the given index.
    public final func getGutterType (gutter: Int32)-> TextEdit.GutterType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_gutter_type, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_gutter)
        return TextEdit.GutterType (rawValue: _result)!
        #else
        
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_gutter_type, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return TextEdit.GutterType (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_gutter_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_gutter_width")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Set the width of the gutter.
    public final func setGutterWidth (gutter: Int32, width: Int32) {
        #if true
        
        var copy_gutter: Int = Int (gutter)
        var copy_width: Int = Int (width)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_gutter_width, UnsafeMutableRawPointer (mutating: handle), nil, &copy_gutter, &copy_width)
        
        #else
        
        var copy_gutter: Int = Int (gutter)
        var copy_width: Int = Int (width)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_gutter_width, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_gutter_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_gutter_width")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the width of the gutter at the given index.
    public final func getGutterWidth (gutter: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_gutter_width, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_gutter)
        return _result
        #else
        
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_gutter_width, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_gutter_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_gutter_draw")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets whether the gutter should be drawn.
    public final func setGutterDraw (gutter: Int32, draw: Bool) {
        #if true
        
        var copy_gutter: Int = Int (gutter)
        var copy_draw = draw
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_gutter_draw, UnsafeMutableRawPointer (mutating: handle), nil, &copy_gutter, &copy_draw)
        
        #else
        
        var copy_gutter: Int = Int (gutter)
        var copy_draw = draw
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_draw) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_gutter_draw, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_gutter_drawn: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_gutter_drawn")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the gutter is currently drawn.
    public final func isGutterDrawn (gutter: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_is_gutter_drawn, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_gutter)
        return _result
        #else
        
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_is_gutter_drawn, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_gutter_clickable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_gutter_clickable")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the gutter as clickable. This will change the mouse cursor to a pointing hand when hovering over the gutter.
    public final func setGutterClickable (gutter: Int32, clickable: Bool) {
        #if true
        
        var copy_gutter: Int = Int (gutter)
        var copy_clickable = clickable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_gutter_clickable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_gutter, &copy_clickable)
        
        #else
        
        var copy_gutter: Int = Int (gutter)
        var copy_clickable = clickable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_clickable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_gutter_clickable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_gutter_clickable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_gutter_clickable")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the gutter is clickable.
    public final func isGutterClickable (gutter: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_is_gutter_clickable, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_gutter)
        return _result
        #else
        
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_is_gutter_clickable, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_gutter_overwritable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_gutter_overwritable")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the gutter to overwritable. See ``mergeGutters(fromLine:toLine:)``.
    public final func setGutterOverwritable (gutter: Int32, overwritable: Bool) {
        #if true
        
        var copy_gutter: Int = Int (gutter)
        var copy_overwritable = overwritable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_gutter_overwritable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_gutter, &copy_overwritable)
        
        #else
        
        var copy_gutter: Int = Int (gutter)
        var copy_overwritable = overwritable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_overwritable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_gutter_overwritable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_gutter_overwritable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_gutter_overwritable")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the gutter is overwritable.
    public final func isGutterOverwritable (gutter: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_is_gutter_overwritable, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_gutter)
        return _result
        #else
        
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_gutter) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_is_gutter_overwritable, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_merge_gutters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("merge_gutters")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Merge the gutters from `fromLine` into `toLine`. Only overwritable gutters will be copied.
    public final func mergeGutters (fromLine: Int32, toLine: Int32) {
        #if true
        
        var copy_from_line: Int = Int (fromLine)
        var copy_to_line: Int = Int (toLine)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_merge_gutters, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_line, &copy_to_line)
        
        #else
        
        var copy_from_line: Int = Int (fromLine)
        var copy_to_line: Int = Int (toLine)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to_line) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_merge_gutters, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_gutter_custom_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_gutter_custom_draw")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 957362965)!
            }
            
        }
        
    }()
    
    /// Set a custom draw method for the gutter. The callback method must take the following args: `line: int, gutter: int, Area: Rect2`.
    public final func setGutterCustomDraw (column: Int32, drawCallback: Callable) {
        #if true
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_gutter_custom_draw, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &drawCallback.content)
        
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &drawCallback.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_gutter_custom_draw, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_total_gutter_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_total_gutter_width")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total width of all gutters and internal padding.
    public final func getTotalGutterWidth ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TextEdit.method_get_total_gutter_width, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_line_gutter_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_gutter_metadata")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2060538656)!
            }
            
        }
        
    }()
    
    /// Sets the metadata for `gutter` on `line` to `metadata`.
    public final func setLineGutterMetadata (line: Int32, gutter: Int32, metadata: Variant) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_gutter_metadata, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_gutter, &metadata.content)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &metadata.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextEdit.method_set_line_gutter_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_gutter_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_gutter_metadata")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 678354945)!
            }
            
        }
        
    }()
    
    /// Returns the metadata currently in `gutter` at `line`.
    public final func getLineGutterMetadata (line: Int32, gutter: Int32)-> Variant {
        let _result: Variant = Variant ()
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_gutter_metadata, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_line, &copy_gutter)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_line_gutter_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_line_gutter_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_gutter_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2285447957)!
            }
            
        }
        
    }()
    
    /// Sets the text for `gutter` on `line` to `text`.
    public final func setLineGutterText (line: Int32, gutter: Int32, text: String) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_gutter_text, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_gutter, &gstr_text.content)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_text.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextEdit.method_set_line_gutter_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_gutter_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_gutter_text")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1391810591)!
            }
            
        }
        
    }()
    
    /// Returns the text currently in `gutter` at `line`.
    public final func getLineGutterText (line: Int32, gutter: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_gutter_text, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_line, &copy_gutter)
        return _result.description
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_line_gutter_text, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_line_gutter_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_gutter_icon")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 176101966)!
            }
            
        }
        
    }()
    
    /// Sets the icon for `gutter` on `line` to `icon`.
    public final func setLineGutterIcon (line: Int32, gutter: Int32, icon: Texture2D?) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_gutter_icon, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_gutter, &copy_icon_handle)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
                withUnsafePointer (to: icon?.handle) { p2 in
                _args.append (icon == nil ? nil : p2)
        
                    gi.object_method_bind_ptrcall (TextEdit.method_set_line_gutter_icon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_gutter_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_gutter_icon")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2584904275)!
            }
            
        }
        
    }()
    
    /// Returns the icon currently in `gutter` at `line`.
    public final func getLineGutterIcon (line: Int32, gutter: Int32)-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_gutter_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_gutter)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_line_gutter_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_line_gutter_item_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_gutter_item_color")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3733378741)!
            }
            
        }
        
    }()
    
    /// Sets the color for `gutter` on `line` to `color`.
    public final func setLineGutterItemColor (line: Int32, gutter: Int32, color: Color) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_gutter_item_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_gutter, &copy_color)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_color) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextEdit.method_set_line_gutter_item_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_gutter_item_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_gutter_item_color")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2165839948)!
            }
            
        }
        
    }()
    
    /// Returns the color currently in `gutter` at `line`.
    public final func getLineGutterItemColor (line: Int32, gutter: Int32)-> Color {
        var _result: Color = Color ()
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_gutter_item_color, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_gutter)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_get_line_gutter_item_color, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_line_gutter_clickable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_gutter_clickable")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1383440665)!
            }
            
        }
        
    }()
    
    /// If `clickable` is `true`, makes the `gutter` on `line` clickable. See [signal gutter_clicked].
    public final func setLineGutterClickable (line: Int32, gutter: Int32, clickable: Bool) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var copy_clickable = clickable
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_gutter_clickable, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_gutter, &copy_clickable)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var copy_clickable = clickable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_clickable) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextEdit.method_set_line_gutter_clickable, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_gutter_clickable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_gutter_clickable")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2522259332)!
            }
            
        }
        
    }()
    
    /// Returns whether the gutter on the given line is clickable.
    public final func isLineGutterClickable (line: Int32, gutter: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_is_line_gutter_clickable, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_gutter)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_gutter: Int = Int (gutter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_gutter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_is_line_gutter_clickable, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_line_background_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_background_color")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2878471219)!
            }
            
        }
        
    }()
    
    /// Sets the current background color of the line. Set to `Color(0, 0, 0, 0)` for no color.
    public final func setLineBackgroundColor (line: Int32, color: Color) {
        #if true
        
        var copy_line: Int = Int (line)
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_line_background_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_color)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextEdit.method_set_line_background_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_background_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_background_color")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3457211756)!
            }
            
        }
        
    }()
    
    /// Returns the current background color of the line. `Color(0, 0, 0, 0)` is returned if no color is set.
    public final func getLineBackgroundColor (line: Int32)-> Color {
        var _result: Color = Color ()
        #if true
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_get_line_background_color, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_get_line_background_color, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_syntax_highlighter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_syntax_highlighter")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2765644541)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_syntax_highlighter (_ syntaxHighlighter: SyntaxHighlighter?) {
        #if true
        
        var copy_syntax_highlighter_handle = syntaxHighlighter?.handle
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_syntax_highlighter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_syntax_highlighter_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: syntaxHighlighter?.handle) { p0 in
        _args.append (syntaxHighlighter == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_syntax_highlighter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_syntax_highlighter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_syntax_highlighter")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2721131626)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_syntax_highlighter ()-> SyntaxHighlighter? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TextEdit.method_get_syntax_highlighter, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_highlight_current_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_highlight_current_line")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_highlight_current_line (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_highlight_current_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_highlight_current_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_highlight_current_line_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_highlight_current_line_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_highlight_current_line_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_highlight_current_line_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_highlight_all_occurrences: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_highlight_all_occurrences")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_highlight_all_occurrences (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_highlight_all_occurrences, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_highlight_all_occurrences, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_highlight_all_occurrences_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_highlight_all_occurrences_enabled")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_highlight_all_occurrences_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_highlight_all_occurrences_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_draw_control_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_draw_control_chars")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_draw_control_chars ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_get_draw_control_chars, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_control_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_control_chars")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_control_chars (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_draw_control_chars, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_draw_control_chars, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_draw_tabs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_tabs")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_tabs (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_draw_tabs, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_draw_tabs, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drawing_tabs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drawing_tabs")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_tabs ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_drawing_tabs, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_spaces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_spaces")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_spaces (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_set_draw_spaces, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_set_draw_spaces, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drawing_spaces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drawing_spaces")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_spaces ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_drawing_spaces, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_menu")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 229722558)!
            }
            
        }
        
    }()
    
    /// Returns the ``PopupMenu`` of this ``TextEdit``. By default, this menu is displayed when right-clicking on the ``TextEdit``.
    /// 
    /// You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see ``TextEdit/MenuItems``). For example:
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``Window/visible`` property.
    /// 
    public final func getMenu ()-> PopupMenu? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TextEdit.method_get_menu, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_is_menu_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_menu_visible")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the menu is visible. Use this instead of `get_menu().visible` to improve performance (so the creation of the menu is avoided).
    public final func isMenuVisible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TextEdit.method_is_menu_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_menu_option: GDExtensionMethodBindPtr = {
        let methodName = StringName ("menu_option")
        return withUnsafePointer (to: &TextEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Executes a given action as defined in the ``TextEdit/MenuItems`` enum.
    public final func menuOption (_ option: Int32) {
        #if true
        
        var copy_option: Int = Int (option)
        
        gi.object_method_bind_ptrcall_v (TextEdit.method_menu_option, UnsafeMutableRawPointer (mutating: handle), nil, &copy_option)
        
        #else
        
        var copy_option: Int = Int (option)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_option) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextEdit.method_menu_option, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_backspace":
                return _TextEdit_proxy_backspace
            case "_copy":
                return _TextEdit_proxy_copy
            case "_cut":
                return _TextEdit_proxy_cut
            case "_handle_unicode_input":
                return _TextEdit_proxy_handle_unicode_input
            case "_paste":
                return _TextEdit_proxy_paste
            case "_paste_primary_clipboard":
                return _TextEdit_proxy_paste_primary_clipboard
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Emitted when ``clear()`` is called or ``text`` is set.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.textSet.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var textSet: SimpleSignal { SimpleSignal (target: self, signalName: "text_set") }
    
    /// Emitted when the text changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.textChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var textChanged: SimpleSignal { SimpleSignal (target: self, signalName: "text_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ fromLine: Int64, _ toLine: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                let arg_1 = Int64 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted immediately when the text changes.
    /// 
    /// When text is added `fromLine` will be less than `toLine`. On a remove `toLine` will be less than `fromLine`.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.linesEditedFrom.connect { fromLine, toLine in
    ///    print ("caught signal")
    /// }
    /// ```
    public var linesEditedFrom: Signal1 { Signal1 (target: self, signalName: "lines_edited_from") }
    
    /// Emitted when the caret changes position.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.caretChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var caretChanged: SimpleSignal { SimpleSignal (target: self, signalName: "caret_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ line: Int64, _ gutter: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                let arg_1 = Int64 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a gutter is clicked.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.gutterClicked.connect { line, gutter in
    ///    print ("caught signal")
    /// }
    /// ```
    public var gutterClicked: Signal2 { Signal2 (target: self, signalName: "gutter_clicked") }
    
    /// Emitted when a gutter is added.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.gutterAdded.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var gutterAdded: SimpleSignal { SimpleSignal (target: self, signalName: "gutter_added") }
    
    /// Emitted when a gutter is removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.gutterRemoved.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var gutterRemoved: SimpleSignal { SimpleSignal (target: self, signalName: "gutter_removed") }
    
}

// Support methods for proxies
func _TextEdit_proxy_backspace (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TextEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._backspace (caretIndex: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
}

func _TextEdit_proxy_copy (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TextEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._copy (caretIndex: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
}

func _TextEdit_proxy_cut (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TextEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._cut (caretIndex: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
}

func _TextEdit_proxy_handle_unicode_input (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TextEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._handleUnicodeInput (unicodeChar: args [0]!.assumingMemoryBound (to: Int32.self).pointee, caretIndex: args [1]!.assumingMemoryBound (to: Int32.self).pointee)
}

func _TextEdit_proxy_paste (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TextEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._paste (caretIndex: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
}

func _TextEdit_proxy_paste_primary_clipboard (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<TextEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._pastePrimaryClipboard (caretIndex: args [0]!.assumingMemoryBound (to: Int32.self).pointee)
}

