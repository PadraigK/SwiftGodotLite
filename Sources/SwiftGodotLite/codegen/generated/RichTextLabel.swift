// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A control for displaying text that can contain different font styles, images, and basic formatting.
/// 
/// A control for displaying text that can contain custom fonts, images, and basic formatting. ``RichTextLabel`` manages these as an internal tag stack. It also adapts itself to given width/heights.
/// 
/// > Note: Assignments to ``text`` clear the tag stack and reconstruct it from the property's contents. Any edits made to ``text`` will erase previous edits made from other manual sources such as ``appendText(bbcode:)`` and the `push_*` / ``pop()`` methods.
/// 
/// > Note: RichTextLabel doesn't support entangled BBCode tags. For example, instead of using [code skip-lint]**bold_bold italic**italic_`, use [code skip-lint]**bold_bold italic_**_italic_`.
/// 
/// > Note: `push_*/pop_*` functions won't affect BBCode.
/// 
/// > Note: Unlike ``Label``, ``RichTextLabel`` doesn't have a _property_ to horizontally align text to the center. Instead, enable ``bbcodeEnabled`` and surround the text in a [code skip-lint][center]` tag as follows: [code skip-lint][center]Example[/center]`. There is currently no built-in way to vertically align text either, but this can be emulated by relying on anchors/containers and the ``fitContent`` property.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``metaClicked``
/// - ``metaHoverStarted``
/// - ``metaHoverEnded``
/// - ``finished``
open class RichTextLabel: Control {
    override open class var godotClassName: StringName { "RichTextLabel" }
    public enum ListType: Int64 {
        /// Each list item has a number marker.
        case numbers = 0 // LIST_NUMBERS
        /// Each list item has a letter marker.
        case letters = 1 // LIST_LETTERS
        /// Each list item has a roman number marker.
        case roman = 2 // LIST_ROMAN
        /// Each list item has a filled circle marker.
        case dots = 3 // LIST_DOTS
    }
    
    public enum MenuItems: Int64 {
        /// Copies the selected text.
        case copy = 0 // MENU_COPY
        /// Selects the whole ``RichTextLabel`` text.
        case selectAll = 1 // MENU_SELECT_ALL
        /// Represents the size of the ``RichTextLabel/MenuItems`` enum.
        case max = 2 // MENU_MAX
    }
    
    public struct ImageUpdateMask: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int64
        public init (rawValue: Int64) {
            self.rawValue = rawValue
        }
        
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image texture.
        public static let texture = ImageUpdateMask (rawValue: 1)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image size.
        public static let size = ImageUpdateMask (rawValue: 2)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image color.
        public static let color = ImageUpdateMask (rawValue: 4)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image inline alignment.
        public static let alignment = ImageUpdateMask (rawValue: 8)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image texture region.
        public static let region = ImageUpdateMask (rawValue: 16)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image padding.
        public static let pad = ImageUpdateMask (rawValue: 32)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image tooltip.
        public static let tooltip = ImageUpdateMask (rawValue: 64)
        /// If this bit is set, ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)`` changes image width from/to percents.
        public static let widthInPercent = ImageUpdateMask (rawValue: 128)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.texture) { result += "texture, " }
            if self.contains (.size) { result += "size, " }
            if self.contains (.color) { result += "color, " }
            if self.contains (.alignment) { result += "alignment, " }
            if self.contains (.region) { result += "region, " }
            if self.contains (.pad) { result += "pad, " }
            if self.contains (.tooltip) { result += "tooltip, " }
            if self.contains (.widthInPercent) { result += "widthInPercent, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    
    /* Properties */
    
    /// If `true`, the label uses BBCode formatting.
    final public var bbcodeEnabled: Bool {
        get {
            return is_using_bbcode ()
        }
        
        set {
            set_use_bbcode (newValue)
        }
        
    }
    
    /// The label's text in BBCode format. Is not representative of manual modifications to the internal tag stack. Erases changes made by other methods when edited.
    /// 
    /// > Note: If ``bbcodeEnabled`` is `true`, it is unadvised to use the `+=` operator with ``text`` (e.g. `text += "some string"`) as it replaces the whole text and can cause slowdowns. It will also erase all BBCode that was added to stack using `push_*` methods. Use ``appendText(bbcode:)`` for adding text instead, unless you absolutely need to close a tag that was opened in an earlier method call.
    /// 
    final public var text: String {
        get {
            return get_text ()
        }
        
        set {
            set_text (newValue)
        }
        
    }
    
    /// If `true`, the label's minimum size will be automatically updated to fit its content, matching the behavior of ``Label``.
    final public var fitContent: Bool {
        get {
            return is_fit_content_enabled ()
        }
        
        set {
            set_fit_content (newValue)
        }
        
    }
    
    /// If `true`, the scrollbar is visible. Setting this to `false` does not block scrolling completely. See ``scrollToLine(_:)``.
    final public var scrollActive: Bool {
        get {
            return is_scroll_active ()
        }
        
        set {
            set_scroll_active (newValue)
        }
        
    }
    
    /// If `true`, the window scrolls down to display new content automatically.
    final public var scrollFollowing: Bool {
        get {
            return is_scroll_following ()
        }
        
        set {
            set_scroll_follow (newValue)
        }
        
    }
    
    /// If set to something other than ``TextServer/AutowrapMode/autowrapOff``, the text gets wrapped inside the node's bounding rectangle. To see how each mode behaves, see ``TextServer.AutowrapMode``.
    final public var autowrapMode: TextServer.AutowrapMode {
        get {
            return get_autowrap_mode ()
        }
        
        set {
            set_autowrap_mode (newValue)
        }
        
    }
    
    /// The number of spaces associated with a single tab length. Does not affect `\t` in text tags, only indent tags.
    final public var tabSize: Int32 {
        get {
            return get_tab_size ()
        }
        
        set {
            set_tab_size (newValue)
        }
        
    }
    
    /// If `true`, a right-click displays the context menu.
    final public var contextMenuEnabled: Bool {
        get {
            return is_context_menu_enabled ()
        }
        
        set {
            set_context_menu_enabled (newValue)
        }
        
    }
    
    /// If `true`, shortcut keys for context menu items are enabled, even if the context menu is disabled.
    final public var shortcutKeysEnabled: Bool {
        get {
            return is_shortcut_keys_enabled ()
        }
        
        set {
            set_shortcut_keys_enabled (newValue)
        }
        
    }
    
    /// The currently installed custom effects. This is an array of ``RichTextEffect``s.
    /// 
    /// To add a custom effect, it's more convenient to use ``installEffect(_:)``.
    /// 
    final public var customEffects: GArray {
        get {
            return get_effects ()
        }
        
        set {
            set_effects (newValue)
        }
        
    }
    
    /// If `true`, the label underlines meta tags such as [code skip-lint][url]{text}[/url]`.
    final public var metaUnderlined: Bool {
        get {
            return is_meta_underlined ()
        }
        
        set {
            set_meta_underline (newValue)
        }
        
    }
    
    /// If `true`, the label underlines hint tags such as [code skip-lint][hint=description]{text}[/hint]`.
    final public var hintUnderlined: Bool {
        get {
            return is_hint_underlined ()
        }
        
        set {
            set_hint_underline (newValue)
        }
        
    }
    
    /// If `true`, text processing is done in a background thread.
    final public var threaded: Bool {
        get {
            return is_threaded ()
        }
        
        set {
            set_threaded (newValue)
        }
        
    }
    
    /// The delay after which the loading progress bar is displayed, in milliseconds. Set to `-1` to disable progress bar entirely.
    /// 
    /// > Note: Progress bar is displayed only if ``threaded`` is enabled.
    /// 
    final public var progressBarDelay: Int32 {
        get {
            return get_progress_bar_delay ()
        }
        
        set {
            set_progress_bar_delay (newValue)
        }
        
    }
    
    /// If `true`, the label allows text selection.
    final public var selectionEnabled: Bool {
        get {
            return is_selection_enabled ()
        }
        
        set {
            set_selection_enabled (newValue)
        }
        
    }
    
    /// If `true`, the selected text will be deselected when focus is lost.
    final public var deselectOnFocusLossEnabled: Bool {
        get {
            return is_deselect_on_focus_loss_enabled ()
        }
        
        set {
            set_deselect_on_focus_loss_enabled (newValue)
        }
        
    }
    
    /// If `true`, allow drag and drop of selected text.
    final public var dragAndDropSelectionEnabled: Bool {
        get {
            return is_drag_and_drop_selection_enabled ()
        }
        
        set {
            set_drag_and_drop_selection_enabled (newValue)
        }
        
    }
    
    /// The number of characters to display. If set to `-1`, all characters are displayed. This can be useful when animating the text appearing in a dialog box.
    /// 
    /// > Note: Setting this property updates ``visibleRatio`` accordingly.
    /// 
    final public var visibleCharacters: Int32 {
        get {
            return get_visible_characters ()
        }
        
        set {
            set_visible_characters (newValue)
        }
        
    }
    
    /// Sets the clipping behavior when ``visibleCharacters`` or ``visibleRatio`` is set. See ``TextServer.VisibleCharactersBehavior`` for more info.
    final public var visibleCharactersBehavior: TextServer.VisibleCharactersBehavior {
        get {
            return get_visible_characters_behavior ()
        }
        
        set {
            set_visible_characters_behavior (newValue)
        }
        
    }
    
    /// The fraction of characters to display, relative to the total number of characters (see ``getTotalCharacterCount()``). If set to `1.0`, all characters are displayed. If set to `0.5`, only half of the characters will be displayed. This can be useful when animating the text appearing in a dialog box.
    /// 
    /// > Note: Setting this property updates ``visibleCharacters`` accordingly.
    /// 
    final public var visibleRatio: Double {
        get {
            return get_visible_ratio ()
        }
        
        set {
            set_visible_ratio (newValue)
        }
        
    }
    
    /// Base text writing direction.
    final public var textDirection: Control.TextDirection {
        get {
            return get_text_direction ()
        }
        
        set {
            set_text_direction (newValue)
        }
        
    }
    
    /// Language code used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    final public var language: String {
        get {
            return get_language ()
        }
        
        set {
            set_language (newValue)
        }
        
    }
    
    /// Set BiDi algorithm override for the structured text.
    final public var structuredTextBidiOverride: TextServer.StructuredTextParser {
        get {
            return get_structured_text_bidi_override ()
        }
        
        set {
            set_structured_text_bidi_override (newValue)
        }
        
    }
    
    /// Set additional options for BiDi override.
    final public var structuredTextBidiOverrideOptions: GArray {
        get {
            return get_structured_text_bidi_override_options ()
        }
        
        set {
            set_structured_text_bidi_override_options (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_parsed_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_parsed_text")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the text without BBCode mark-up.
    public final func getParsedText ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_parsed_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_add_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_text")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds raw non-BBCode-parsed text to the tag stack.
    public final func addText (_ text: String) {
        #if false
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_add_text, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_add_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_text")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text (_ text: String) {
        #if false
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_text, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_image")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3017663154)!
            }
            
        }
        
    }()
    
    /// Adds an image's opening and closing tags to the tag stack, optionally providing a `width` and `height` to resize the image, a `color` to tint the image and a `region` to only use parts of the image.
    /// 
    /// If `width` or `height` is set to 0, the image size will be adjusted in order to keep the original aspect ratio.
    /// 
    /// If `width` and `height` are not set, but `region` is, the region's rect will be used.
    /// 
    /// `key` is an optional identifier, that can be used to modify the image via ``updateImage(key:mask:image:width:height:color:inlineAlign:region:pad:tooltip:sizeInPercent:)``.
    /// 
    /// If `pad` is set, and the image is smaller than the size specified by `width` and `height`, the image padding is added to match the size instead of upscaling.
    /// 
    /// If `sizeInPercent` is set, `width` and `height` values are percentages of the control width instead of pixels.
    /// 
    public final func addImage (_ image: Texture2D?, width: Int32 = 0, height: Int32 = 0, color: Color = Color (r: 1, g: 1, b: 1, a: 1), inlineAlign: InlineAlignment = .center, region: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), key: Variant, pad: Bool = false, tooltip: String = "", sizeInPercent: Bool = false) {
        #if false
        
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        var copy_color = color
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_region = region
        var copy_pad = pad
        let gstr_tooltip = GString (tooltip)
        var copy_size_in_percent = sizeInPercent
        var copy_image_handle = image?.handle
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_add_image, UnsafeMutableRawPointer (mutating: handle), nil, &copy_image_handle, &copy_width, &copy_height, &copy_color, &copy_inline_align, &copy_region, &key.content, &copy_pad, &gstr_tooltip.content, &copy_size_in_percent)
        
        #else
        
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        var copy_color = color
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_region = region
        var copy_pad = pad
        let gstr_tooltip = GString (tooltip)
        var copy_size_in_percent = sizeInPercent
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: image?.handle) { p0 in
        _args.append (image == nil ? nil : p0)
            withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_height) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_color) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_inline_align) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_region) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &key.content) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_pad) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &gstr_tooltip.content) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_size_in_percent) { p9 in
                                                _args.append (p9)
        
                                                gi.object_method_bind_ptrcall (RichTextLabel.method_add_image, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_update_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("update_image")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 815048486)!
            }
            
        }
        
    }()
    
    /// Updates the existing images with the key `key`. Only properties specified by `mask` bits are updated. See ``addImage(_:width:height:color:inlineAlign:region:key:pad:tooltip:sizeInPercent:)``.
    public final func updateImage (key: Variant, mask: RichTextLabel.ImageUpdateMask, image: Texture2D?, width: Int32 = 0, height: Int32 = 0, color: Color = Color (r: 1, g: 1, b: 1, a: 1), inlineAlign: InlineAlignment = .center, region: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), pad: Bool = false, tooltip: String = "", sizeInPercent: Bool = false) {
        #if false
        
        var copy_mask = mask
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        var copy_color = color
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_region = region
        var copy_pad = pad
        let gstr_tooltip = GString (tooltip)
        var copy_size_in_percent = sizeInPercent
        var copy_image_handle = image?.handle
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_update_image, UnsafeMutableRawPointer (mutating: handle), nil, &key.content, &copy_mask, &copy_image_handle, &copy_width, &copy_height, &copy_color, &copy_inline_align, &copy_region, &copy_pad, &gstr_tooltip.content, &copy_size_in_percent)
        
        #else
        
        var copy_mask = mask
        var copy_width: Int = Int (width)
        var copy_height: Int = Int (height)
        var copy_color = color
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_region = region
        var copy_pad = pad
        let gstr_tooltip = GString (tooltip)
        var copy_size_in_percent = sizeInPercent
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &key.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_mask) { p1 in
                _args.append (p1)
                withUnsafePointer (to: image?.handle) { p2 in
                _args.append (image == nil ? nil : p2)
                    withUnsafePointer (to: &copy_width) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_height) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_color) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_inline_align) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_region) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_pad) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &gstr_tooltip.content) { p9 in
                                                _args.append (p9)
                                                withUnsafePointer (to: &copy_size_in_percent) { p10 in
                                                    _args.append (p10)
        
                                                    gi.object_method_bind_ptrcall (RichTextLabel.method_update_image, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_newline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("newline")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a newline tag to the tag stack.
    public final func newline () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_newline, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_remove_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_paragraph")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3067735520)!
            }
            
        }
        
    }()
    
    /// Removes a paragraph of content from the label. Returns `true` if the paragraph exists.
    /// 
    /// The `paragraph` argument is the index of the paragraph to remove, it can take values in the interval `[0, get_paragraph_count() - 1]`.
    /// 
    public final func removeParagraph (_ paragraph: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_paragraph: Int = Int (paragraph)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_remove_paragraph, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_paragraph)
        return _result
        #else
        
        var copy_paragraph: Int = Int (paragraph)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_paragraph) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_remove_paragraph, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_push_font: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_font")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2347424842)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag to the tag stack. Overrides default fonts for its duration.
    /// 
    /// Passing `0` to `fontSize` will use the existing default font size.
    /// 
    public final func pushFont (_ font: Font?, fontSize: Int32 = 0) {
        #if false
        
        var copy_font_size: Int = Int (fontSize)
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_font, UnsafeMutableRawPointer (mutating: handle), nil, &copy_font_handle, &copy_font_size)
        
        #else
        
        var copy_font_size: Int = Int (fontSize)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: font?.handle) { p0 in
        _args.append (font == nil ? nil : p0)
            withUnsafePointer (to: &copy_font_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RichTextLabel.method_push_font, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_push_font_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_font_size")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font_size]` tag to the tag stack. Overrides default font size for its duration.
    public final func pushFontSize (_ fontSize: Int32) {
        #if false
        
        var copy_font_size: Int = Int (fontSize)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_font_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_font_size)
        
        #else
        
        var copy_font_size: Int = Int (fontSize)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_font_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_font_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_normal: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_normal")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with a normal font to the tag stack.
    public final func pushNormal () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_normal, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_push_bold: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_bold")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with a bold font to the tag stack. This is the same as adding a [code skip-lint]**` tag if not currently in a [code skip-lint]_` tag.
    public final func pushBold () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_bold, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_push_bold_italics: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_bold_italics")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with a bold italics font to the tag stack.
    public final func pushBoldItalics () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_bold_italics, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_push_italics: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_italics")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with an italics font to the tag stack. This is the same as adding an [code skip-lint]_` tag if not currently in a [code skip-lint]**` tag.
    public final func pushItalics () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_italics, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_push_mono: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_mono")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][font]` tag with a monospace font to the tag stack.
    public final func pushMono () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_mono, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_push_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_color")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][color]` tag to the tag stack.
    public final func pushColor (_ color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_outline_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_outline_size")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][outline_size]` tag to the tag stack. Overrides default text outline size for its duration.
    public final func pushOutlineSize (_ outlineSize: Int32) {
        #if false
        
        var copy_outline_size: Int = Int (outlineSize)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_outline_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_outline_size)
        
        #else
        
        var copy_outline_size: Int = Int (outlineSize)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_outline_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_outline_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_outline_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_outline_color")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][outline_color]` tag to the tag stack. Adds text outline for its duration.
    public final func pushOutlineColor (_ color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_outline_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_outline_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_paragraph")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3089306873)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][p]` tag to the tag stack.
    public final func pushParagraph (alignment: HorizontalAlignment, baseDirection: Control.TextDirection = .auto, language: String = "", stParser: TextServer.StructuredTextParser = .`default`, justificationFlags: TextServer.JustificationFlag = [.kashida, .wordBound, .skipLastLine, .doNotSkipSingleLine], tabStops: PackedFloat32Array = PackedFloat32Array()) {
        #if false
        
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_base_direction = Int64 (baseDirection.rawValue)
        let gstr_language = GString (language)
        var copy_st_parser = Int64 (stParser.rawValue)
        var copy_justification_flags = justificationFlags
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_paragraph, UnsafeMutableRawPointer (mutating: handle), nil, &copy_alignment, &copy_base_direction, &gstr_language.content, &copy_st_parser, &copy_justification_flags, &tabStops.content)
        
        #else
        
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_base_direction = Int64 (baseDirection.rawValue)
        let gstr_language = GString (language)
        var copy_st_parser = Int64 (stParser.rawValue)
        var copy_justification_flags = justificationFlags
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_alignment) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_base_direction) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_language.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_st_parser) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_justification_flags) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &tabStops.content) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (RichTextLabel.method_push_paragraph, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_push_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_indent")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Adds an [code skip-lint][indent]` tag to the tag stack. Multiplies `level` by current ``tabSize`` to determine new margin length.
    public final func pushIndent (level: Int32) {
        #if false
        
        var copy_level: Int = Int (level)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_indent, UnsafeMutableRawPointer (mutating: handle), nil, &copy_level)
        
        #else
        
        var copy_level: Int = Int (level)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_level) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_indent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_list")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3017143144)!
            }
            
        }
        
    }()
    
    /// Adds [code skip-lint][ol]` or [code skip-lint][ul]` tag to the tag stack. Multiplies `level` by current ``tabSize`` to determine new margin length.
    public final func pushList (level: Int32, type: RichTextLabel.ListType, capitalize: Bool, bullet: String = "•") {
        #if false
        
        var copy_level: Int = Int (level)
        var copy_type = Int64 (type.rawValue)
        var copy_capitalize = capitalize
        let gstr_bullet = GString (bullet)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_list, UnsafeMutableRawPointer (mutating: handle), nil, &copy_level, &copy_type, &copy_capitalize, &gstr_bullet.content)
        
        #else
        
        var copy_level: Int = Int (level)
        var copy_type = Int64 (type.rawValue)
        var copy_capitalize = capitalize
        let gstr_bullet = GString (bullet)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_level) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_type) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_capitalize) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &gstr_bullet.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (RichTextLabel.method_push_list, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_push_meta: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_meta")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1114965689)!
            }
            
        }
        
    }()
    
    /// Adds a meta tag to the tag stack. Similar to the BBCode [code skip-lint][url=something]{text}[/url]`, but supports non-``String`` metadata types.
    public final func pushMeta (data: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_meta, UnsafeMutableRawPointer (mutating: handle), nil, &data.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &data.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_meta, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_hint")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][hint]` tag to the tag stack. Same as BBCode [code skip-lint][hint=something]{text}[/hint]`.
    public final func pushHint (description: String) {
        #if false
        
        let gstr_description = GString (description)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_hint, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_description.content)
        
        #else
        
        let gstr_description = GString (description)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_description.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_hint, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_language")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Adds language code used for text shaping algorithm and Open-Type font features.
    public final func pushLanguage (_ language: String) {
        #if false
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_language, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_language.content)
        
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_language.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_language, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_underline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_underline")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][u]` tag to the tag stack.
    public final func pushUnderline () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_underline, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_push_strikethrough: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_strikethrough")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][s]` tag to the tag stack.
    public final func pushStrikethrough () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_strikethrough, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_push_table: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_table")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2623499273)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][table=columns,inline_align]` tag to the tag stack.
    public final func pushTable (columns: Int32, inlineAlign: InlineAlignment = .top, alignToRow: Int32 = -1) {
        #if false
        
        var copy_columns: Int = Int (columns)
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_align_to_row: Int = Int (alignToRow)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_table, UnsafeMutableRawPointer (mutating: handle), nil, &copy_columns, &copy_inline_align, &copy_align_to_row)
        
        #else
        
        var copy_columns: Int = Int (columns)
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_align_to_row: Int = Int (alignToRow)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_columns) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_inline_align) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_align_to_row) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RichTextLabel.method_push_table, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_push_dropcap: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_dropcap")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4061635501)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][dropcap]` tag to the tag stack. Drop cap (dropped capital) is a decorative element at the beginning of a paragraph that is larger than the rest of the text.
    public final func pushDropcap (string: String, font: Font?, size: Int32, dropcapMargins: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), color: Color = Color (r: 1, g: 1, b: 1, a: 1), outlineSize: Int32 = 0, outlineColor: Color = Color (r: 0, g: 0, b: 0, a: 0)) {
        #if false
        
        let gstr_string = GString (string)
        var copy_size: Int = Int (size)
        var copy_dropcap_margins = dropcapMargins
        var copy_color = color
        var copy_outline_size: Int = Int (outlineSize)
        var copy_outline_color = outlineColor
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_dropcap, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_string.content, &copy_font_handle, &copy_size, &copy_dropcap_margins, &copy_color, &copy_outline_size, &copy_outline_color)
        
        #else
        
        let gstr_string = GString (string)
        var copy_size: Int = Int (size)
        var copy_dropcap_margins = dropcapMargins
        var copy_color = color
        var copy_outline_size: Int = Int (outlineSize)
        var copy_outline_color = outlineColor
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: font?.handle) { p1 in
            _args.append (font == nil ? nil : p1)
                withUnsafePointer (to: &copy_size) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_dropcap_margins) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_color) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_outline_size) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_outline_color) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (RichTextLabel.method_push_dropcap, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_table_column_expand: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_table_column_expand")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2185176273)!
            }
            
        }
        
    }()
    
    /// Edits the selected column's expansion options. If `expand` is `true`, the column expands in proportion to its expansion ratio versus the other columns' ratios.
    /// 
    /// For example, 2 columns with ratios 3 and 4 plus 70 pixels in available width would expand 30 and 40 pixels, respectively.
    /// 
    /// If `expand` is `false`, the column will not contribute to the total ratio.
    /// 
    public final func setTableColumnExpand (column: Int32, expand: Bool, ratio: Int32 = 1) {
        #if false
        
        var copy_column: Int = Int (column)
        var copy_expand = expand
        var copy_ratio: Int = Int (ratio)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_table_column_expand, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &copy_expand, &copy_ratio)
        
        #else
        
        var copy_column: Int = Int (column)
        var copy_expand = expand
        var copy_ratio: Int = Int (ratio)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_expand) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_ratio) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (RichTextLabel.method_set_table_column_expand, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_cell_row_background_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_cell_row_background_color")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3465483165)!
            }
            
        }
        
    }()
    
    /// Sets color of a table cell. Separate colors for alternating rows can be specified.
    public final func setCellRowBackgroundColor (oddRowBg: Color, evenRowBg: Color) {
        #if false
        
        var copy_odd_row_bg = oddRowBg
        var copy_even_row_bg = evenRowBg
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_cell_row_background_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_odd_row_bg, &copy_even_row_bg)
        
        #else
        
        var copy_odd_row_bg = oddRowBg
        var copy_even_row_bg = evenRowBg
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_odd_row_bg) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_even_row_bg) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RichTextLabel.method_set_cell_row_background_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_cell_border_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_cell_border_color")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Sets color of a table cell border.
    public final func setCellBorderColor (_ color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_cell_border_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_cell_border_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_cell_size_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_cell_size_override")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3108078480)!
            }
            
        }
        
    }()
    
    /// Sets minimum and maximum size overrides for a table cell.
    public final func setCellSizeOverride (minSize: Vector2, maxSize: Vector2) {
        #if false
        
        var copy_min_size = minSize
        var copy_max_size = maxSize
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_cell_size_override, UnsafeMutableRawPointer (mutating: handle), nil, &copy_min_size, &copy_max_size)
        
        #else
        
        var copy_min_size = minSize
        var copy_max_size = maxSize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_min_size) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_max_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RichTextLabel.method_set_cell_size_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_cell_padding: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_cell_padding")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2046264180)!
            }
            
        }
        
    }()
    
    /// Sets inner padding of a table cell.
    public final func setCellPadding (_ padding: Rect2) {
        #if false
        
        var copy_padding = padding
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_cell_padding, UnsafeMutableRawPointer (mutating: handle), nil, &copy_padding)
        
        #else
        
        var copy_padding = padding
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_padding) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_cell_padding, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_cell: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_cell")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][cell]` tag to the tag stack. Must be inside a [code skip-lint][table]` tag. See ``pushTable(columns:inlineAlign:alignToRow:)`` for details.
    public final func pushCell () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_cell, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_push_fgcolor: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_fgcolor")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][fgcolor]` tag to the tag stack.
    public final func pushFgcolor (_ fgcolor: Color) {
        #if false
        
        var copy_fgcolor = fgcolor
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_fgcolor, UnsafeMutableRawPointer (mutating: handle), nil, &copy_fgcolor)
        
        #else
        
        var copy_fgcolor = fgcolor
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_fgcolor) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_fgcolor, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_bgcolor: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_bgcolor")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds a [code skip-lint][bgcolor]` tag to the tag stack.
    public final func pushBgcolor (_ bgcolor: Color) {
        #if false
        
        var copy_bgcolor = bgcolor
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_bgcolor, UnsafeMutableRawPointer (mutating: handle), nil, &copy_bgcolor)
        
        #else
        
        var copy_bgcolor = bgcolor
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_bgcolor) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_push_bgcolor, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_customfx: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_customfx")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2337942958)!
            }
            
        }
        
    }()
    
    /// Adds a custom effect tag to the tag stack. The effect does not need to be in ``customEffects``. The environment is directly passed to the effect.
    public final func pushCustomfx (effect: RichTextEffect?, env: GDictionary) {
        #if false
        
        var copy_effect_handle = effect?.handle
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_push_customfx, UnsafeMutableRawPointer (mutating: handle), nil, &copy_effect_handle, &env.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: effect?.handle) { p0 in
        _args.append (effect == nil ? nil : p0)
            withUnsafePointer (to: &env.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (RichTextLabel.method_push_customfx, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_push_context: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_context")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adds a context marker to the tag stack. See ``popContext()``.
    public final func pushContext () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_push_context, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_pop_context: GDExtensionMethodBindPtr = {
        let methodName = StringName ("pop_context")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Terminates tags opened after the last ``pushContext()`` call (including context marker), or all tags if there's no context marker on the stack.
    public final func popContext () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_pop_context, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_pop: GDExtensionMethodBindPtr = {
        let methodName = StringName ("pop")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Terminates the current tag. Use after `push_*` methods to close BBCodes manually. Does not need to follow `add_*` methods.
    public final func pop () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_pop, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_pop_all: GDExtensionMethodBindPtr = {
        let methodName = StringName ("pop_all")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Terminates all tags opened by `push_*` methods.
    public final func popAll () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_pop_all, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the tag stack.
    /// 
    /// > Note: This method will not modify ``text``, but setting ``text`` to an empty string also clears the stack.
    /// 
    public final func clear () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_clear, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_structured_text_bidi_override")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 55961453)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override (_ parser: TextServer.StructuredTextParser) {
        #if false
        
        var copy_parser = Int64 (parser.rawValue)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), nil, &copy_parser)
        
        #else
        
        var copy_parser = Int64 (parser.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_parser) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_structured_text_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_structured_text_bidi_override")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3385126229)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override ()-> TextServer.StructuredTextParser {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_structured_text_bidi_override, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextServer.StructuredTextParser (rawValue: _result)!
    }
    
    fileprivate static var method_set_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_structured_text_bidi_override_options")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_structured_text_bidi_override_options (_ args: GArray) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), nil, &args.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &args.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_structured_text_bidi_override_options: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_structured_text_bidi_override_options")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_structured_text_bidi_override_options ()-> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_structured_text_bidi_override_options, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_text_direction")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 119160795)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_text_direction (_ direction: Control.TextDirection) {
        #if false
        
        var copy_direction = Int64 (direction.rawValue)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_text_direction, UnsafeMutableRawPointer (mutating: handle), nil, &copy_direction)
        
        #else
        
        var copy_direction = Int64 (direction.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_direction) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_text_direction, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text_direction")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 797257663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text_direction ()-> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_text_direction, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Control.TextDirection (rawValue: _result)!
    }
    
    fileprivate static var method_set_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_language")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_language (_ language: String) {
        #if false
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_language, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_language.content)
        
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_language.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_language, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_language")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_language ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_language, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_autowrap_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_autowrap_mode")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3289138044)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_autowrap_mode (_ autowrapMode: TextServer.AutowrapMode) {
        #if false
        
        var copy_autowrap_mode = Int64 (autowrapMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_autowrap_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_autowrap_mode)
        
        #else
        
        var copy_autowrap_mode = Int64 (autowrapMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_autowrap_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_autowrap_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_autowrap_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_autowrap_mode")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1549071663)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_autowrap_mode ()-> TextServer.AutowrapMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_autowrap_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextServer.AutowrapMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_meta_underline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_meta_underline")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_meta_underline (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_meta_underline, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_meta_underline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_meta_underlined: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_meta_underlined")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_meta_underlined ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_meta_underlined, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hint_underline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hint_underline")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hint_underline (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_hint_underline, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_hint_underline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_hint_underlined: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_hint_underlined")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hint_underlined ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_hint_underlined, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scroll_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scroll_active")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scroll_active (_ active: Bool) {
        #if false
        
        var copy_active = active
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_scroll_active, UnsafeMutableRawPointer (mutating: handle), nil, &copy_active)
        
        #else
        
        var copy_active = active
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_active) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_scroll_active, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_scroll_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_scroll_active")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_scroll_active ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_scroll_active, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scroll_follow: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scroll_follow")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scroll_follow (_ follow: Bool) {
        #if false
        
        var copy_follow = follow
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_scroll_follow, UnsafeMutableRawPointer (mutating: handle), nil, &copy_follow)
        
        #else
        
        var copy_follow = follow
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_follow) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_scroll_follow, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_scroll_following: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_scroll_following")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_scroll_following ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_scroll_following, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_v_scroll_bar: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_v_scroll_bar")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2630340773)!
            }
            
        }
        
    }()
    
    /// Returns the vertical scrollbar.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``CanvasItem/visible`` property.
    /// 
    public final func getVScrollBar ()-> VScrollBar? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_v_scroll_bar, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_scroll_to_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scroll_to_line")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Scrolls the window's top line to match `line`.
    public final func scrollToLine (_ line: Int32) {
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_scroll_to_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line)
        
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_scroll_to_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_scroll_to_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scroll_to_paragraph")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Scrolls the window's top line to match first line of the `paragraph`.
    public final func scrollToParagraph (_ paragraph: Int32) {
        #if false
        
        var copy_paragraph: Int = Int (paragraph)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_scroll_to_paragraph, UnsafeMutableRawPointer (mutating: handle), nil, &copy_paragraph)
        
        #else
        
        var copy_paragraph: Int = Int (paragraph)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_paragraph) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_scroll_to_paragraph, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_scroll_to_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scroll_to_selection")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Scrolls to the beginning of the current selection.
    public final func scrollToSelection () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_scroll_to_selection, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_tab_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_size")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tab_size (_ spaces: Int32) {
        #if false
        
        var copy_spaces: Int = Int (spaces)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_tab_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_spaces)
        
        #else
        
        var copy_spaces: Int = Int (spaces)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_spaces) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_tab_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_size")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tab_size ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_tab_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_fit_content: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_fit_content")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_fit_content (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_fit_content, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_fit_content, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_fit_content_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_fit_content_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_fit_content_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_fit_content_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_selection_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_selection_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_selection_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_selection_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_selection_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_selection_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_selection_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_context_menu_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_context_menu_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_context_menu_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_context_menu_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_context_menu_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_context_menu_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_shortcut_keys_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_shortcut_keys_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_shortcut_keys_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_shortcut_keys_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_shortcut_keys_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_shortcut_keys_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_deselect_on_focus_loss_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_deselect_on_focus_loss_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_deselect_on_focus_loss_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_deselect_on_focus_loss_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_deselect_on_focus_loss_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_deselect_on_focus_loss_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_drag_and_drop_selection_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drag_and_drop_selection_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drag_and_drop_selection_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drag_and_drop_selection_enabled")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drag_and_drop_selection_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_drag_and_drop_selection_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selection_from: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_from")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the current selection first character index if a selection is active, `-1` otherwise. Does not include BBCodes.
    public final func getSelectionFrom ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_selection_from, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selection_to: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selection_to")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the current selection last character index if a selection is active, `-1` otherwise. Does not include BBCodes.
    public final func getSelectionTo ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_selection_to, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_select_all: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select_all")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Select all the text.
    /// 
    /// If ``selectionEnabled`` is `false`, no selection will occur.
    /// 
    public final func selectAll () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_select_all, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_selected_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selected_text")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the current selection text. Does not include BBCodes.
    public final func getSelectedText ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_selected_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_deselect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("deselect")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the current selection.
    public final func deselect () {
        gi.object_method_bind_ptrcall (RichTextLabel.method_deselect, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_parse_bbcode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("parse_bbcode")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// The assignment version of ``appendText(bbcode:)``. Clears the tag stack and inserts the new content.
    public final func parseBbcode (_ bbcode: String) {
        #if false
        
        let gstr_bbcode = GString (bbcode)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_parse_bbcode, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_bbcode.content)
        
        #else
        
        let gstr_bbcode = GString (bbcode)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_bbcode.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_parse_bbcode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_append_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("append_text")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Parses `bbcode` and adds tags to the tag stack as needed.
    /// 
    /// > Note: Using this method, you can't close a tag that was opened in a previous ``appendText(bbcode:)`` call. This is done to improve performance, especially when updating large RichTextLabels since rebuilding the whole BBCode every time would be slower. If you absolutely need to close a tag in a future method call, append the ``text`` instead of using ``appendText(bbcode:)``.
    /// 
    public final func appendText (bbcode: String) {
        #if false
        
        let gstr_bbcode = GString (bbcode)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_append_text, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_bbcode.content)
        
        #else
        
        let gstr_bbcode = GString (bbcode)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_bbcode.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_append_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_text ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_is_ready: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_ready")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// If ``threaded`` is enabled, returns `true` if the background thread has finished text processing, otherwise always return `true`.
    public final func isReady ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_ready, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_threaded: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_threaded")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_threaded (_ threaded: Bool) {
        #if false
        
        var copy_threaded = threaded
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_threaded, UnsafeMutableRawPointer (mutating: handle), nil, &copy_threaded)
        
        #else
        
        var copy_threaded = threaded
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_threaded) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_threaded, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_threaded: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_threaded")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_threaded ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_threaded, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_progress_bar_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_progress_bar_delay")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_progress_bar_delay (_ delayMs: Int32) {
        #if false
        
        var copy_delay_ms: Int = Int (delayMs)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_progress_bar_delay, UnsafeMutableRawPointer (mutating: handle), nil, &copy_delay_ms)
        
        #else
        
        var copy_delay_ms: Int = Int (delayMs)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_delay_ms) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_progress_bar_delay, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_progress_bar_delay: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_progress_bar_delay")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_progress_bar_delay ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_progress_bar_delay, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_visible_characters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_visible_characters")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible_characters (_ amount: Int32) {
        #if false
        
        var copy_amount: Int = Int (amount)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_visible_characters, UnsafeMutableRawPointer (mutating: handle), nil, &copy_amount)
        
        #else
        
        var copy_amount: Int = Int (amount)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_amount) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_visible_characters, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_visible_characters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visible_characters")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visible_characters ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_visible_characters, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_characters_behavior: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visible_characters_behavior")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 258789322)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visible_characters_behavior ()-> TextServer.VisibleCharactersBehavior {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_visible_characters_behavior, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TextServer.VisibleCharactersBehavior (rawValue: _result)!
    }
    
    fileprivate static var method_set_visible_characters_behavior: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_visible_characters_behavior")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3383839701)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible_characters_behavior (_ behavior: TextServer.VisibleCharactersBehavior) {
        #if false
        
        var copy_behavior = Int64 (behavior.rawValue)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_visible_characters_behavior, UnsafeMutableRawPointer (mutating: handle), nil, &copy_behavior)
        
        #else
        
        var copy_behavior = Int64 (behavior.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_behavior) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_visible_characters_behavior, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_visible_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_visible_ratio")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible_ratio (_ ratio: Double) {
        #if false
        
        var copy_ratio = ratio
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_visible_ratio, UnsafeMutableRawPointer (mutating: handle), nil, &copy_ratio)
        
        #else
        
        var copy_ratio = ratio
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_ratio) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_visible_ratio, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_visible_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visible_ratio")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visible_ratio ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_visible_ratio, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_character_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_character_line")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3744713108)!
            }
            
        }
        
    }()
    
    /// Returns the line number of the character position provided.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getCharacterLine (character: Int32)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_character: Int = Int (character)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_get_character_line, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_character)
        return _result
        #else
        
        var copy_character: Int = Int (character)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_character) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_get_character_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_character_paragraph: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_character_paragraph")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3744713108)!
            }
            
        }
        
    }()
    
    /// Returns the paragraph number of the character position provided.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getCharacterParagraph (character: Int32)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_character: Int = Int (character)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_get_character_paragraph, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_character)
        return _result
        #else
        
        var copy_character: Int = Int (character)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_character) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_get_character_paragraph, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_total_character_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_total_character_count")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of characters from text tags. Does not include BBCodes.
    public final func getTotalCharacterCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_total_character_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_bbcode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_bbcode")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_bbcode (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_use_bbcode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_use_bbcode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_bbcode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_bbcode")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_bbcode ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_using_bbcode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_line_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_count")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of lines in the text. Wrapped text is counted as multiple lines.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getLineCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_line_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_line_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visible_line_count")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of visible lines.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getVisibleLineCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_visible_line_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_paragraph_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_paragraph_count")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of paragraphs (newlines or `p` tags in the tag stack's text tags). Considers wrapped text as one paragraph.
    public final func getParagraphCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_paragraph_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_paragraph_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visible_paragraph_count")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of visible paragraphs. A paragraph is considered visible if at least one of its lines is visible.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getVisibleParagraphCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_visible_paragraph_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_content_height: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_content_height")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the height of the content.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getContentHeight ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_content_height, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_content_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_content_width")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the width of the content.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getContentWidth ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_content_width, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_line_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_offset")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4025615559)!
            }
            
        }
        
    }()
    
    /// Returns the vertical offset of the line found at the provided index.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getLineOffset (line: Int32)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_get_line_offset, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_get_line_offset, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_paragraph_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_paragraph_offset")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4025615559)!
            }
            
        }
        
    }()
    
    /// Returns the vertical offset of the paragraph found at the provided index.
    /// 
    /// > Note: If ``threaded`` is enabled, this method returns a value for the loaded part of the document. Use ``isReady()`` or [signal finished] to determine whether document is fully loaded.
    /// 
    public final func getParagraphOffset (paragraph: Int32)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_paragraph: Int = Int (paragraph)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_get_paragraph_offset, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_paragraph)
        return _result
        #else
        
        var copy_paragraph: Int = Int (paragraph)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_paragraph) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_get_paragraph_offset, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_parse_expressions_for_values: GDExtensionMethodBindPtr = {
        let methodName = StringName ("parse_expressions_for_values")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1522900837)!
            }
            
        }
        
    }()
    
    /// Parses BBCode parameter `expressions` into a dictionary.
    public final func parseExpressionsForValues (expressions: PackedStringArray)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_parse_expressions_for_values, UnsafeMutableRawPointer (mutating: handle), &_result.content, &expressions.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &expressions.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_parse_expressions_for_values, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_effects: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_effects")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_effects (_ effects: GArray) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_set_effects, UnsafeMutableRawPointer (mutating: handle), nil, &effects.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &effects.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_set_effects, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_effects: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_effects")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2915620761)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_effects ()-> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_effects, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_install_effect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("install_effect")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1114965689)!
            }
            
        }
        
    }()
    
    /// Installs a custom effect. `effect` should be a valid ``RichTextEffect``.
    public final func installEffect (_ effect: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_install_effect, UnsafeMutableRawPointer (mutating: handle), nil, &effect.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &effect.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_install_effect, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_menu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_menu")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 229722558)!
            }
            
        }
        
    }()
    
    /// Returns the ``PopupMenu`` of this ``RichTextLabel``. By default, this menu is displayed when right-clicking on the ``RichTextLabel``.
    /// 
    /// You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see ``RichTextLabel/MenuItems``). For example:
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``Window/visible`` property.
    /// 
    public final func getMenu ()-> PopupMenu? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (RichTextLabel.method_get_menu, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_is_menu_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_menu_visible")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the menu is visible. Use this instead of `get_menu().visible` to improve performance (so the creation of the menu is avoided).
    public final func isMenuVisible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (RichTextLabel.method_is_menu_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_menu_option: GDExtensionMethodBindPtr = {
        let methodName = StringName ("menu_option")
        return withUnsafePointer (to: &RichTextLabel.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Executes a given action as defined in the ``RichTextLabel/MenuItems`` enum.
    public final func menuOption (_ option: Int32) {
        #if false
        
        var copy_option: Int = Int (option)
        
        gi.object_method_bind_ptrcall_v (RichTextLabel.method_menu_option, UnsafeMutableRawPointer (mutating: handle), nil, &copy_option)
        
        #else
        
        var copy_option: Int = Int (option)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_option) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (RichTextLabel.method_menu_option, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ meta: Variant) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = args [0]
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Triggered when the user clicks on content between meta tags. If the meta is defined in text, e.g. [code skip-lint][url={"data"="hi"}]hi[/url]`, then the parameter for this signal will be a ``String`` type. If a particular type or an object is desired, the ``pushMeta(data:)`` method must be used to manually insert the data into the tag stack.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.metaClicked.connect { meta in
    ///    print ("caught signal")
    /// }
    /// ```
    public var metaClicked: Signal1 { Signal1 (target: self, signalName: "meta_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ meta: Variant) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = args [0]
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Triggers when the mouse enters a meta tag.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.metaHoverStarted.connect { meta in
    ///    print ("caught signal")
    /// }
    /// ```
    public var metaHoverStarted: Signal2 { Signal2 (target: self, signalName: "meta_hover_started") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ meta: Variant) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = args [0]
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Triggers when the mouse exits a meta tag.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.metaHoverEnded.connect { meta in
    ///    print ("caught signal")
    /// }
    /// ```
    public var metaHoverEnded: Signal3 { Signal3 (target: self, signalName: "meta_hover_ended") }
    
    /// Triggered when the document is fully loaded.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.finished.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var finished: SimpleSignal { SimpleSignal (target: self, signalName: "finished") }
    
}

