// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for ``AnimationPlayer`` and ``AnimationTree``.
/// 
/// Base class for ``AnimationPlayer`` and ``AnimationTree`` to manage animation lists. It also has general properties and methods for playback and blending.
/// 
/// After instantiating the playback information data within the extended class, the blending is processed by the ``AnimationMixer``.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``mixerUpdated``
/// - ``animationListChanged``
/// - ``animationLibrariesUpdated``
/// - ``animationFinished``
/// - ``animationStarted``
/// - ``cachesCleared``
open class AnimationMixer: Node {
    override open class var godotClassName: StringName { "AnimationMixer" }
    public enum AnimationCallbackModeProcess: Int64 {
        /// Process animation during physics frames (see ``Node/``notificationInternalPhysicsProcess````). This is especially useful when animating physics bodies.
        case physics = 0 // ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS
        /// Process animation during process frames (see ``Node/``notificationInternalProcess````).
        case idle = 1 // ANIMATION_CALLBACK_MODE_PROCESS_IDLE
        /// Do not process animation. Use ``advance(delta:)`` to process the animation manually.
        case manual = 2 // ANIMATION_CALLBACK_MODE_PROCESS_MANUAL
    }
    
    public enum AnimationCallbackModeMethod: Int64 {
        /// Batch method calls during the animation process, then do the calls after events are processed. This avoids bugs involving deleting nodes or modifying the AnimationPlayer while playing.
        case deferred = 0 // ANIMATION_CALLBACK_MODE_METHOD_DEFERRED
        /// Make method calls immediately when reached in the animation.
        case immediate = 1 // ANIMATION_CALLBACK_MODE_METHOD_IMMEDIATE
    }
    
    
    /* Properties */
    
    /// If `true`, the ``AnimationMixer`` will be processing.
    final public var active: Bool {
        get {
            return is_active ()
        }
        
        set {
            set_active (newValue)
        }
        
    }
    
    /// If `true`, the blending uses the deterministic algorithm. The total weight is not normalized and the result is accumulated with an initial value (`0` or a `"RESET"` animation if present).
    /// 
    /// This means that if the total amount of blending is `0.0`, the result is equal to the `"RESET"` animation.
    /// 
    /// If the number of tracks between the blended animations is different, the animation with the missing track is treated as if it had the initial value.
    /// 
    /// If `false`, The blend does not use the deterministic algorithm. The total weight is normalized and always `1.0`. If the number of tracks between the blended animations is different, nothing is done about the animation that is missing a track.
    /// 
    /// > Note: In ``AnimationTree``, the blending with ``AnimationNodeAdd2``, ``AnimationNodeAdd3``, ``AnimationNodeSub2`` or the weight greater than `1.0` may produce unexpected results.
    /// 
    /// For example, if ``AnimationNodeAdd2`` blends two nodes with the amount `1.0`, then total weight is `2.0` but it will be normalized to make the total amount `1.0` and the result will be equal to ``AnimationNodeBlend2`` with the amount `0.5`.
    /// 
    final public var deterministic: Bool {
        get {
            return is_deterministic ()
        }
        
        set {
            set_deterministic (newValue)
        }
        
    }
    
    /// This is used by the editor. If set to `true`, the scene will be saved with the effects of the reset animation (the animation with the key `"RESET"`) applied as if it had been seeked to time 0, with the editor keeping the values that the scene had before saving.
    /// 
    /// This makes it more convenient to preview and edit animations in the editor, as changes to the scene will not be saved as long as they are set in the reset animation.
    /// 
    final public var resetOnSave: Bool {
        get {
            return is_reset_on_save_enabled ()
        }
        
        set {
            set_reset_on_save_enabled (newValue)
        }
        
    }
    
    /// The node from which node path references will travel.
    final public var rootNode: NodePath {
        get {
            return get_root_node ()
        }
        
        set {
            set_root_node (newValue)
        }
        
    }
    
    /// The path to the Animation track used for root motion. Paths must be valid scene-tree paths to a node, and must be specified starting from the parent node of the node that will reproduce the animation. To specify a track that controls properties or bones, append its name after the path, separated by `":"`. For example, `"character/skeleton:ankle"` or `"character/mesh:transform/local"`.
    /// 
    /// If the track has type ``Animation/TrackType/typePosition3d``, ``Animation/TrackType/typeRotation3d`` or ``Animation/TrackType/typeScale3d`` the transformation will be canceled visually, and the animation will appear to stay in place. See also ``getRootMotionPosition()``, ``getRootMotionRotation()``, ``getRootMotionScale()`` and ``RootMotionView``.
    /// 
    final public var rootMotionTrack: NodePath {
        get {
            return get_root_motion_track ()
        }
        
        set {
            set_root_motion_track (newValue)
        }
        
    }
    
    /// The number of possible simultaneous sounds for each of the assigned AudioStreamPlayers.
    /// 
    /// For example, if this value is `32` and the animation has two audio tracks, the two ``AudioStreamPlayer``s assigned can play simultaneously up to `32` voices each.
    /// 
    final public var audioMaxPolyphony: Int32 {
        get {
            return get_audio_max_polyphony ()
        }
        
        set {
            set_audio_max_polyphony (newValue)
        }
        
    }
    
    /// The process notification in which to update animations.
    final public var callbackModeProcess: AnimationMixer.AnimationCallbackModeProcess {
        get {
            return get_callback_mode_process ()
        }
        
        set {
            set_callback_mode_process (newValue)
        }
        
    }
    
    /// The call mode to use for Call Method tracks.
    final public var callbackModeMethod: AnimationMixer.AnimationCallbackModeMethod {
        get {
            return get_callback_mode_method ()
        }
        
        set {
            set_callback_mode_method (newValue)
        }
        
    }
    
    /* Methods */
    /// A virtual function for processing after key getting during playback.
    @_documentation(visibility: public)
    open func _postProcessKeyValue (animation: Animation?, track: Int32, value: Variant, object: Object?, objectIdx: Int32)-> Variant {
        return Variant ()
    }
    
    fileprivate static var method_add_animation_library: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_animation_library")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 618909818)!
            }
            
        }
        
    }()
    
    /// Adds `library` to the animation player, under the key `name`.
    public final func addAnimationLibrary (name: StringName, library: AnimationLibrary?)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_library_handle = library?.handle
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_add_animation_library, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content, &copy_library_handle)
        return GodotError (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: library?.handle) { p1 in
            _args.append (library == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (AnimationMixer.method_add_animation_library, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_animation_library: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_animation_library")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Removes the ``AnimationLibrary`` associated with the key `name`.
    public final func removeAnimationLibrary (name: StringName) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_remove_animation_library, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_remove_animation_library, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_rename_animation_library: GDExtensionMethodBindPtr = {
        let methodName = StringName ("rename_animation_library")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3740211285)!
            }
            
        }
        
    }()
    
    /// Moves the ``AnimationLibrary`` associated with the key `name` to the key `newname`.
    public final func renameAnimationLibrary (name: StringName, newname: StringName) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_rename_animation_library, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &newname.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &newname.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (AnimationMixer.method_rename_animation_library, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_animation_library: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_animation_library")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the ``AnimationPlayer`` stores an ``AnimationLibrary`` with key `name`.
    public final func hasAnimationLibrary (name: StringName)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_has_animation_library, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_has_animation_library, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_animation_library: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_animation_library")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 147342321)!
            }
            
        }
        
    }()
    
    /// Returns the first ``AnimationLibrary`` with key `name` or `null` if not found.
    /// 
    /// To get the ``AnimationPlayer``'s global animation library, use `get_animation_library("")`.
    /// 
    public final func getAnimationLibrary (name: StringName)-> AnimationLibrary? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_get_animation_library, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_get_animation_library, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_animation_library_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_animation_library_list")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns the list of stored library keys.
    public final func getAnimationLibraryList ()-> VariantCollection<StringName> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_animation_library_list, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<StringName>(content: _result)
    }
    
    fileprivate static var method_has_animation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_animation")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the ``AnimationPlayer`` stores an ``Animation`` with key `name`.
    public final func hasAnimation (name: StringName)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_has_animation, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_has_animation, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_animation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_animation")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2933122410)!
            }
            
        }
        
    }()
    
    /// Returns the ``Animation`` with the key `name`. If the animation does not exist, `null` is returned and an error is logged.
    public final func getAnimation (name: StringName)-> Animation? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_get_animation, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_get_animation, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_animation_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_animation_list")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1139954409)!
            }
            
        }
        
    }()
    
    /// Returns the list of stored animation keys.
    public final func getAnimationList ()-> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_animation_list, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_active")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_active (_ active: Bool) {
        #if false
        
        var copy_active = active
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_set_active, UnsafeMutableRawPointer (mutating: handle), nil, &copy_active)
        
        #else
        
        var copy_active = active
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_active) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_set_active, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_active")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_active ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (AnimationMixer.method_is_active, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_deterministic: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_deterministic")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_deterministic (_ deterministic: Bool) {
        #if false
        
        var copy_deterministic = deterministic
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_set_deterministic, UnsafeMutableRawPointer (mutating: handle), nil, &copy_deterministic)
        
        #else
        
        var copy_deterministic = deterministic
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_deterministic) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_set_deterministic, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_deterministic: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_deterministic")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_deterministic ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (AnimationMixer.method_is_deterministic, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_root_node: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_root_node")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1348162250)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_root_node (_ path: NodePath) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_set_root_node, UnsafeMutableRawPointer (mutating: handle), nil, &path.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_set_root_node, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_root_node: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_node")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4075236667)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_root_node ()-> NodePath {
        let _result: NodePath = NodePath ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_root_node, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_callback_mode_process: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_callback_mode_process")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2153733086)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_callback_mode_process (_ mode: AnimationMixer.AnimationCallbackModeProcess) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_set_callback_mode_process, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_set_callback_mode_process, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_callback_mode_process: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_callback_mode_process")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1394468472)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_callback_mode_process ()-> AnimationMixer.AnimationCallbackModeProcess {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_callback_mode_process, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return AnimationMixer.AnimationCallbackModeProcess (rawValue: _result)!
    }
    
    fileprivate static var method_set_callback_mode_method: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_callback_mode_method")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 742218271)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_callback_mode_method (_ mode: AnimationMixer.AnimationCallbackModeMethod) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_set_callback_mode_method, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_set_callback_mode_method, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_callback_mode_method: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_callback_mode_method")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 489449656)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_callback_mode_method ()-> AnimationMixer.AnimationCallbackModeMethod {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_callback_mode_method, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return AnimationMixer.AnimationCallbackModeMethod (rawValue: _result)!
    }
    
    fileprivate static var method_set_audio_max_polyphony: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_audio_max_polyphony")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_audio_max_polyphony (_ maxPolyphony: Int32) {
        #if false
        
        var copy_max_polyphony: Int = Int (maxPolyphony)
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_set_audio_max_polyphony, UnsafeMutableRawPointer (mutating: handle), nil, &copy_max_polyphony)
        
        #else
        
        var copy_max_polyphony: Int = Int (maxPolyphony)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_max_polyphony) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_set_audio_max_polyphony, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_audio_max_polyphony: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_audio_max_polyphony")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_audio_max_polyphony ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_audio_max_polyphony, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_root_motion_track: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_root_motion_track")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1348162250)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_root_motion_track (_ path: NodePath) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_set_root_motion_track, UnsafeMutableRawPointer (mutating: handle), nil, &path.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &path.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_set_root_motion_track, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_root_motion_track: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_motion_track")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4075236667)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_root_motion_track ()-> NodePath {
        let _result: NodePath = NodePath ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_root_motion_track, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_root_motion_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_motion_position")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3360562783)!
            }
            
        }
        
    }()
    
    /// Retrieve the motion delta of position with the ``rootMotionTrack`` as a ``Vector3`` that can be used elsewhere.
    /// 
    /// If ``rootMotionTrack`` is not a path to a track of type ``Animation/TrackType/typePosition3d``, returns `Vector3(0, 0, 0)`.
    /// 
    /// See also ``rootMotionTrack`` and ``RootMotionView``.
    /// 
    /// The most basic example is applying position to ``CharacterBody3D``:
    /// 
    /// By using this in combination with ``getRootMotionPositionAccumulator()``, you can apply the root motion position more correctly to account for the rotation of the node.
    /// 
    public final func getRootMotionPosition ()-> Vector3 {
        var _result: Vector3 = Vector3 ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_root_motion_position, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_root_motion_rotation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_motion_rotation")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1222331677)!
            }
            
        }
        
    }()
    
    /// Retrieve the motion delta of rotation with the ``rootMotionTrack`` as a ``Quaternion`` that can be used elsewhere.
    /// 
    /// If ``rootMotionTrack`` is not a path to a track of type ``Animation/TrackType/typeRotation3d``, returns `Quaternion(0, 0, 0, 1)`.
    /// 
    /// See also ``rootMotionTrack`` and ``RootMotionView``.
    /// 
    /// The most basic example is applying rotation to ``CharacterBody3D``:
    /// 
    public final func getRootMotionRotation ()-> Quaternion {
        var _result: Quaternion = Quaternion ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_root_motion_rotation, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_root_motion_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_motion_scale")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3360562783)!
            }
            
        }
        
    }()
    
    /// Retrieve the motion delta of scale with the ``rootMotionTrack`` as a ``Vector3`` that can be used elsewhere.
    /// 
    /// If ``rootMotionTrack`` is not a path to a track of type ``Animation/TrackType/typeScale3d``, returns `Vector3(0, 0, 0)`.
    /// 
    /// See also ``rootMotionTrack`` and ``RootMotionView``.
    /// 
    /// The most basic example is applying scale to ``CharacterBody3D``:
    /// 
    public final func getRootMotionScale ()-> Vector3 {
        var _result: Vector3 = Vector3 ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_root_motion_scale, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_root_motion_position_accumulator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_motion_position_accumulator")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3360562783)!
            }
            
        }
        
    }()
    
    /// Retrieve the blended value of the position tracks with the ``rootMotionTrack`` as a ``Vector3`` that can be used elsewhere.
    /// 
    /// This is useful in cases where you want to respect the initial key values of the animation.
    /// 
    /// For example, if an animation with only one key `Vector3(0, 0, 0)` is played in the previous frame and then an animation with only one key `Vector3(1, 0, 1)` is played in the next frame, the difference can be calculated as follows:
    /// 
    /// However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
    /// 
    public final func getRootMotionPositionAccumulator ()-> Vector3 {
        var _result: Vector3 = Vector3 ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_root_motion_position_accumulator, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_root_motion_rotation_accumulator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_motion_rotation_accumulator")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1222331677)!
            }
            
        }
        
    }()
    
    /// Retrieve the blended value of the rotation tracks with the ``rootMotionTrack`` as a ``Quaternion`` that can be used elsewhere.
    /// 
    /// This is necessary to apply the root motion position correctly, taking rotation into account. See also ``getRootMotionPosition()``.
    /// 
    /// Also, this is useful in cases where you want to respect the initial key values of the animation.
    /// 
    /// For example, if an animation with only one key `Quaternion(0, 0, 0, 1)` is played in the previous frame and then an animation with only one key `Quaternion(0, 0.707, 0, 0.707)` is played in the next frame, the difference can be calculated as follows:
    /// 
    /// However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
    /// 
    public final func getRootMotionRotationAccumulator ()-> Quaternion {
        var _result: Quaternion = Quaternion ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_root_motion_rotation_accumulator, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_root_motion_scale_accumulator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root_motion_scale_accumulator")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3360562783)!
            }
            
        }
        
    }()
    
    /// Retrieve the blended value of the scale tracks with the ``rootMotionTrack`` as a ``Vector3`` that can be used elsewhere.
    /// 
    /// For example, if an animation with only one key `Vector3(1, 1, 1)` is played in the previous frame and then an animation with only one key `Vector3(2, 2, 2)` is played in the next frame, the difference can be calculated as follows:
    /// 
    /// However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
    /// 
    public final func getRootMotionScaleAccumulator ()-> Vector3 {
        var _result: Vector3 = Vector3 ()
        gi.object_method_bind_ptrcall (AnimationMixer.method_get_root_motion_scale_accumulator, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clear_caches: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_caches")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// ``AnimationMixer`` caches animated nodes. It may not notice if a node disappears; ``clearCaches()`` forces it to update the cache again.
    public final func clearCaches () {
        gi.object_method_bind_ptrcall (AnimationMixer.method_clear_caches, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_advance: GDExtensionMethodBindPtr = {
        let methodName = StringName ("advance")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    /// Manually advance the animations by the specified time (in seconds).
    public final func advance (delta: Double) {
        #if false
        
        var copy_delta = delta
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_advance, UnsafeMutableRawPointer (mutating: handle), nil, &copy_delta)
        
        #else
        
        var copy_delta = delta
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_delta) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_advance, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_reset_on_save_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_reset_on_save_enabled")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_reset_on_save_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_set_reset_on_save_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_set_reset_on_save_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_reset_on_save_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_reset_on_save_enabled")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_reset_on_save_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (AnimationMixer.method_is_reset_on_save_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_find_animation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("find_animation")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1559484580)!
            }
            
        }
        
    }()
    
    /// Returns the key of `animation` or an empty ``StringName`` if not found.
    public final func findAnimation (_ animation: Animation?)-> StringName {
        let _result: StringName = StringName ()
        #if false
        
        var copy_animation_handle = animation?.handle
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_find_animation, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_animation_handle)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: animation?.handle) { p0 in
        _args.append (animation == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_find_animation, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_find_animation_library: GDExtensionMethodBindPtr = {
        let methodName = StringName ("find_animation_library")
        return withUnsafePointer (to: &AnimationMixer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1559484580)!
            }
            
        }
        
    }()
    
    /// Returns the key for the ``AnimationLibrary`` that contains `animation` or an empty ``StringName`` if not found.
    public final func findAnimationLibrary (animation: Animation?)-> StringName {
        let _result: StringName = StringName ()
        #if false
        
        var copy_animation_handle = animation?.handle
        
        gi.object_method_bind_ptrcall_v (AnimationMixer.method_find_animation_library, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_animation_handle)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: animation?.handle) { p0 in
        _args.append (animation == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (AnimationMixer.method_find_animation_library, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_post_process_key_value":
                return _AnimationMixer_proxy_post_process_key_value
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Editor only. Notifies when the property have been updated to update dummy ``AnimationPlayer`` in animation player editor.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.mixerUpdated.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var mixerUpdated: SimpleSignal { SimpleSignal (target: self, signalName: "mixer_updated") }
    
    /// Notifies when an animation list is changed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.animationListChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var animationListChanged: SimpleSignal { SimpleSignal (target: self, signalName: "animation_list_changed") }
    
    /// Notifies when the animation libraries have changed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.animationLibrariesUpdated.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var animationLibrariesUpdated: SimpleSignal { SimpleSignal (target: self, signalName: "animation_libraries_updated") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ animName: StringName) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Notifies when an animation finished playing.
    /// 
    /// > Note: This signal is not emitted if an animation is looping.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.animationFinished.connect { animName in
    ///    print ("caught signal")
    /// }
    /// ```
    public var animationFinished: Signal1 { Signal1 (target: self, signalName: "animation_finished") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ animName: StringName) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = StringName (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Notifies when an animation starts playing.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.animationStarted.connect { animName in
    ///    print ("caught signal")
    /// }
    /// ```
    public var animationStarted: Signal2 { Signal2 (target: self, signalName: "animation_started") }
    
    /// Notifies when the caches have been cleared, either automatically, or manually via ``clearCaches()``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.cachesCleared.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var cachesCleared: SimpleSignal { SimpleSignal (target: self, signalName: "caches_cleared") }
    
}

// Support methods for proxies
func _AnimationMixer_proxy_post_process_key_value (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<AnimationMixer>.fromOpaque(instance).takeUnretainedValue()
    let resolved_0 = args [0]!.load (as: UnsafeRawPointer.self)
    let resolved_3 = args [3]!.load (as: UnsafeRawPointer.self)
    
    let ret = swiftObject._postProcessKeyValue (animation: lookupLiveObject (handleAddress: resolved_0) as? Animation ?? lookupObject (nativeHandle: resolved_0)!, track: args [1]!.assumingMemoryBound (to: Int32.self).pointee, value: args [2]!.assumingMemoryBound (to: Variant.self).pointee, object: lookupLiveObject (handleAddress: resolved_3) as? Object ?? lookupObject (nativeHandle: resolved_3)!, objectIdx: args [4]!.assumingMemoryBound (to: Int32.self).pointee)
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // Variant
    ret.content = Variant.zero
}

