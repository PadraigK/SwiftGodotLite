// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A container that creates a tab for each child control, displaying only the active tab's control.
/// 
/// Arranges child controls into a tabbed view, creating a tab for each one. The active tab's corresponding control is made visible, while all other child controls are hidden. Ignores non-control children.
/// 
/// > Note: The drawing of the clickable tabs is handled by this node; ``TabBar`` is not needed.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``activeTabRearranged``
/// - ``tabChanged``
/// - ``tabClicked``
/// - ``tabHovered``
/// - ``tabSelected``
/// - ``tabButtonPressed``
/// - ``prePopupPressed``
open class TabContainer: Container {
    override open class var godotClassName: StringName { "TabContainer" }
    
    /* Properties */
    
    /// Sets the position at which tabs will be placed. See ``TabBar.AlignmentMode`` for details.
    final public var tabAlignment: TabBar.AlignmentMode {
        get {
            return get_tab_alignment ()
        }
        
        set {
            set_tab_alignment (newValue)
        }
        
    }
    
    /// The current tab index. When set, this index's ``Control`` node's `visible` property is set to `true` and all others are set to `false`.
    final public var currentTab: Int32 {
        get {
            return get_current_tab ()
        }
        
        set {
            set_current_tab (newValue)
        }
        
    }
    
    /// If `true`, tabs overflowing this node's width will be hidden, displaying two navigation buttons instead. Otherwise, this node's minimum size is updated so that all tabs are visible.
    final public var clipTabs: Bool {
        get {
            return get_clip_tabs ()
        }
        
        set {
            set_clip_tabs (newValue)
        }
        
    }
    
    /// If `true`, tabs are visible. If `false`, tabs' content and titles are hidden.
    final public var tabsVisible: Bool {
        get {
            return are_tabs_visible ()
        }
        
        set {
            set_tabs_visible (newValue)
        }
        
    }
    
    /// If `true`, all tabs are drawn in front of the panel. If `false`, inactive tabs are drawn behind the panel.
    final public var allTabsInFront: Bool {
        get {
            return is_all_tabs_in_front ()
        }
        
        set {
            set_all_tabs_in_front (newValue)
        }
        
    }
    
    /// If `true`, tabs can be rearranged with mouse drag.
    final public var dragToRearrangeEnabled: Bool {
        get {
            return get_drag_to_rearrange_enabled ()
        }
        
        set {
            set_drag_to_rearrange_enabled (newValue)
        }
        
    }
    
    /// ``TabContainer``s with the same rearrange group ID will allow dragging the tabs between them. Enable drag with ``dragToRearrangeEnabled``.
    /// 
    /// Setting this to `-1` will disable rearranging between ``TabContainer``s.
    /// 
    final public var tabsRearrangeGroup: Int32 {
        get {
            return get_tabs_rearrange_group ()
        }
        
        set {
            set_tabs_rearrange_group (newValue)
        }
        
    }
    
    /// If `true`, children ``Control`` nodes that are hidden have their minimum size take into account in the total, instead of only the currently visible one.
    final public var useHiddenTabsForMinSize: Bool {
        get {
            return get_use_hidden_tabs_for_min_size ()
        }
        
        set {
            set_use_hidden_tabs_for_min_size (newValue)
        }
        
    }
    
    /// The focus access mode for the internal ``TabBar`` node.
    final public var tabFocusMode: Control.FocusMode {
        get {
            return get_tab_focus_mode ()
        }
        
        set {
            set_tab_focus_mode (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_tab_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_count")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of tabs.
    public final func getTabCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabContainer.method_get_tab_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_current_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_current_tab")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_current_tab (_ tabIdx: Int32) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_current_tab, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_current_tab, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_current_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_current_tab")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_current_tab ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabContainer.method_get_current_tab, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_previous_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_previous_tab")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the previously active tab index.
    public final func getPreviousTab ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabContainer.method_get_previous_tab, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_select_previous_available: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select_previous_available")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Selects the first available tab with lower index than the currently selected. Returns `true` if tab selection changed.
    public final func selectPreviousAvailable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabContainer.method_select_previous_available, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_select_next_available: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select_next_available")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Selects the first available tab with greater index than the currently selected. Returns `true` if tab selection changed.
    public final func selectNextAvailable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabContainer.method_select_next_available, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_current_tab_control: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_current_tab_control")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2783021301)!
            }
            
        }
        
    }()
    
    /// Returns the child ``Control`` node located at the active tab index.
    public final func getCurrentTabControl ()-> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TabContainer.method_get_current_tab_control, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_tab_bar: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_bar")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1865451809)!
            }
            
        }
        
    }()
    
    /// Returns the ``TabBar`` contained in this container.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it or editing its tabs may cause a crash. If you wish to edit the tabs, use the methods provided in ``TabContainer``.
    /// 
    public final func getTabBar ()-> TabBar? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TabContainer.method_get_tab_bar, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_tab_control: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_control")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1065994134)!
            }
            
        }
        
    }()
    
    /// Returns the ``Control`` node from the tab at index `tabIdx`.
    public final func getTabControl (tabIdx: Int32)-> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_get_tab_control, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_get_tab_control, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_alignment")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2413632353)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tab_alignment (_ alignment: TabBar.AlignmentMode) {
        #if false
        
        var copy_alignment = Int64 (alignment.rawValue)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tab_alignment, UnsafeMutableRawPointer (mutating: handle), nil, &copy_alignment)
        
        #else
        
        var copy_alignment = Int64 (alignment.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_alignment) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_tab_alignment, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_alignment")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2178122193)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tab_alignment ()-> TabBar.AlignmentMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TabContainer.method_get_tab_alignment, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TabBar.AlignmentMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_clip_tabs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_clip_tabs")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_clip_tabs (_ clipTabs: Bool) {
        #if false
        
        var copy_clip_tabs = clipTabs
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_clip_tabs, UnsafeMutableRawPointer (mutating: handle), nil, &copy_clip_tabs)
        
        #else
        
        var copy_clip_tabs = clipTabs
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_clip_tabs) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_clip_tabs, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_clip_tabs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_clip_tabs")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_clip_tabs ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabContainer.method_get_clip_tabs, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_tabs_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tabs_visible")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tabs_visible (_ visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tabs_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_tabs_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_are_tabs_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("are_tabs_visible")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func are_tabs_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabContainer.method_are_tabs_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_all_tabs_in_front: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_all_tabs_in_front")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_all_tabs_in_front (_ isFront: Bool) {
        #if false
        
        var copy_is_front = isFront
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_all_tabs_in_front, UnsafeMutableRawPointer (mutating: handle), nil, &copy_is_front)
        
        #else
        
        var copy_is_front = isFront
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_is_front) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_all_tabs_in_front, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_all_tabs_in_front: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_all_tabs_in_front")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_all_tabs_in_front ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabContainer.method_is_all_tabs_in_front, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_tab_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_title")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets a custom title for the tab at index `tabIdx` (tab titles default to the name of the indexed child node). Set it back to the child's name to make the tab default to it again.
    public final func setTabTitle (tabIdx: Int32, title: String) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        let gstr_title = GString (title)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tab_title, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &gstr_title.content)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        let gstr_title = GString (title)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_title.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabContainer.method_set_tab_title, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_title")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the title of the tab at index `tabIdx`. Tab titles default to the name of the indexed child node, but this can be overridden with ``setTabTitle(tabIdx:title:)``.
    public final func getTabTitle (tabIdx: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_get_tab_title, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_tab_idx)
        return _result.description
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_get_tab_title, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_icon")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 666127730)!
            }
            
        }
        
    }()
    
    /// Sets an icon for the tab at index `tabIdx`.
    public final func setTabIcon (tabIdx: Int32, icon: Texture2D?) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tab_icon, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_icon_handle)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (TabContainer.method_set_tab_icon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_icon")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3536238170)!
            }
            
        }
        
    }()
    
    /// Returns the ``Texture2D`` for the tab at index `tabIdx` or `null` if the tab has no ``Texture2D``.
    public final func getTabIcon (tabIdx: Int32)-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_get_tab_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_get_tab_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_disabled")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `disabled` is `true`, disables the tab at index `tabIdx`, making it non-interactable.
    public final func setTabDisabled (tabIdx: Int32, disabled: Bool) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_disabled = disabled
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tab_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_disabled)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_disabled = disabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_disabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabContainer.method_set_tab_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_tab_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_tab_disabled")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the tab at index `tabIdx` is disabled.
    public final func isTabDisabled (tabIdx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_is_tab_disabled, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        return _result
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_is_tab_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_hidden")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `hidden` is `true`, hides the tab at index `tabIdx`, making it disappear from the tab area.
    public final func setTabHidden (tabIdx: Int32, hidden: Bool) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_hidden = hidden
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tab_hidden, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_hidden)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_hidden = hidden
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_hidden) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabContainer.method_set_tab_hidden, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_tab_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_tab_hidden")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the tab at index `tabIdx` is hidden.
    public final func isTabHidden (tabIdx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_is_tab_hidden, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        return _result
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_is_tab_hidden, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_metadata")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2152698145)!
            }
            
        }
        
    }()
    
    /// Sets the metadata value for the tab at index `tabIdx`, which can be retrieved later using ``getTabMetadata(tabIdx:)``.
    public final func setTabMetadata (tabIdx: Int32, metadata: Variant) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tab_metadata, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &metadata.content)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &metadata.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabContainer.method_set_tab_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_metadata")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4227898402)!
            }
            
        }
        
    }()
    
    /// Returns the metadata value set to the tab at index `tabIdx` using ``setTabMetadata(tabIdx:metadata:)``. If no metadata was previously set, returns `null` by default.
    public final func getTabMetadata (tabIdx: Int32)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_get_tab_metadata, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_tab_idx)
        return _result
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_get_tab_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_button_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_button_icon")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 666127730)!
            }
            
        }
        
    }()
    
    /// Sets the button icon from the tab at index `tabIdx`.
    public final func setTabButtonIcon (tabIdx: Int32, icon: Texture2D?) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tab_button_icon, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_icon_handle)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (TabContainer.method_set_tab_button_icon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_button_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_button_icon")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3536238170)!
            }
            
        }
        
    }()
    
    /// Returns the button icon from the tab at index `tabIdx`.
    public final func getTabButtonIcon (tabIdx: Int32)-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_get_tab_button_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_get_tab_button_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_idx_at_point: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_idx_at_point")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3820158470)!
            }
            
        }
        
    }()
    
    /// Returns the index of the tab at local coordinates `point`. Returns `-1` if the point is outside the control boundaries or if there's no tab at the queried position.
    public final func getTabIdxAtPoint (_ point: Vector2)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_point = point
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_get_tab_idx_at_point, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_point)
        return _result
        #else
        
        var copy_point = point
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_point) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_get_tab_idx_at_point, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_idx_from_control: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_idx_from_control")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2787397975)!
            }
            
        }
        
    }()
    
    /// Returns the index of the tab tied to the given `control`. The control must be a child of the ``TabContainer``.
    public final func getTabIdxFromControl (_ control: Control?)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_control_handle = control?.handle
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_get_tab_idx_from_control, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_control_handle)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: control?.handle) { p0 in
        _args.append (control == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_get_tab_idx_from_control, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_popup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_popup")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1078189570)!
            }
            
        }
        
    }()
    
    /// If set on a ``Popup`` node instance, a popup menu icon appears in the top-right corner of the ``TabContainer`` (setting it to `null` will make it go away). Clicking it will expand the ``Popup`` node.
    public final func setPopup (_ popup: Node?) {
        #if false
        
        var copy_popup_handle = popup?.handle
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_popup, UnsafeMutableRawPointer (mutating: handle), nil, &copy_popup_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: popup?.handle) { p0 in
        _args.append (popup == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_popup, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_popup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_popup")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 111095082)!
            }
            
        }
        
    }()
    
    /// Returns the ``Popup`` node instance if one has been set already with ``setPopup(_:)``.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``Window/visible`` property.
    /// 
    public final func getPopup ()-> Popup? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (TabContainer.method_get_popup, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_drag_to_rearrange_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_drag_to_rearrange_enabled")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drag_to_rearrange_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_drag_to_rearrange_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_drag_to_rearrange_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_drag_to_rearrange_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_drag_to_rearrange_enabled")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_drag_to_rearrange_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabContainer.method_get_drag_to_rearrange_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_tabs_rearrange_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tabs_rearrange_group")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tabs_rearrange_group (_ groupId: Int32) {
        #if false
        
        var copy_group_id: Int = Int (groupId)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tabs_rearrange_group, UnsafeMutableRawPointer (mutating: handle), nil, &copy_group_id)
        
        #else
        
        var copy_group_id: Int = Int (groupId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_group_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_tabs_rearrange_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tabs_rearrange_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tabs_rearrange_group")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tabs_rearrange_group ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabContainer.method_get_tabs_rearrange_group, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_hidden_tabs_for_min_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_hidden_tabs_for_min_size")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_hidden_tabs_for_min_size (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_use_hidden_tabs_for_min_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_use_hidden_tabs_for_min_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_use_hidden_tabs_for_min_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_use_hidden_tabs_for_min_size")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_use_hidden_tabs_for_min_size ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabContainer.method_get_use_hidden_tabs_for_min_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_tab_focus_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_focus_mode")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3232914922)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tab_focus_mode (_ focusMode: Control.FocusMode) {
        #if false
        
        var copy_focus_mode = Int64 (focusMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (TabContainer.method_set_tab_focus_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_focus_mode)
        
        #else
        
        var copy_focus_mode = Int64 (focusMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_focus_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabContainer.method_set_tab_focus_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_focus_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_focus_mode")
        return withUnsafePointer (to: &TabContainer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2132829277)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tab_focus_mode ()-> Control.FocusMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TabContainer.method_get_tab_focus_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Control.FocusMode (rawValue: _result)!
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ idxTo: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the active tab is rearranged via mouse drag. See ``dragToRearrangeEnabled``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.activeTabRearranged.connect { idxTo in
    ///    print ("caught signal")
    /// }
    /// ```
    public var activeTabRearranged: Signal1 { Signal1 (target: self, signalName: "active_tab_rearranged") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when switching to another tab.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabChanged.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabChanged: Signal2 { Signal2 (target: self, signalName: "tab_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab is clicked, even if it is the current tab.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabClicked.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabClicked: Signal3 { Signal3 (target: self, signalName: "tab_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab is hovered by the mouse.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabHovered.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabHovered: Signal4 { Signal4 (target: self, signalName: "tab_hovered") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab is selected via click, directional input, or script, even if it is the current tab.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabSelected.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabSelected: Signal5 { Signal5 (target: self, signalName: "tab_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal6/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal6/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal6/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal6 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal6 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user clicks on the button icon on this tab.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabButtonPressed.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabButtonPressed: Signal6 { Signal6 (target: self, signalName: "tab_button_pressed") }
    
    /// Emitted when the ``TabContainer``'s ``Popup`` button is clicked. See ``setPopup(_:)`` for details.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.prePopupPressed.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var prePopupPressed: SimpleSignal { SimpleSignal (target: self, signalName: "pre_popup_pressed") }
    
}

