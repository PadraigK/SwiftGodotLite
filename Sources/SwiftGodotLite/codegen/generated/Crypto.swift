// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Provides access to advanced cryptographic functionalities.
/// 
/// The Crypto class provides access to advanced cryptographic functionalities.
/// 
/// Currently, this includes asymmetric key encryption/decryption, signing/verification, and generating cryptographically secure random bytes, RSA keys, HMAC digests, and self-signed ``X509Certificate``s.
/// 
open class Crypto: RefCounted {
    override open class var godotClassName: StringName { "Crypto" }
    /* Methods */
    fileprivate static var method_generate_random_bytes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_random_bytes")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 47165747)!
            }
            
        }
        
    }()
    
    /// Generates a ``PackedByteArray`` of cryptographically secure random bytes with given `size`.
    public final func generateRandomBytes (size: Int32)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        var copy_size: Int = Int (size)
        
        gi.object_method_bind_ptrcall_v (Crypto.method_generate_random_bytes, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_size)
        return _result
        #else
        
        var copy_size: Int = Int (size)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Crypto.method_generate_random_bytes, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_generate_rsa: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_rsa")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1237515462)!
            }
            
        }
        
    }()
    
    /// Generates an RSA ``CryptoKey`` that can be used for creating self-signed certificates and passed to ``StreamPeerTLS/acceptStream(_:serverOptions:)``.
    public final func generateRsa (size: Int32)-> CryptoKey? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_size: Int = Int (size)
        
        gi.object_method_bind_ptrcall_v (Crypto.method_generate_rsa, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_size)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_size: Int = Int (size)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Crypto.method_generate_rsa, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_generate_self_signed_certificate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("generate_self_signed_certificate")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 492266173)!
            }
            
        }
        
    }()
    
    /// Generates a self-signed ``X509Certificate`` from the given ``CryptoKey`` and `issuerName`. The certificate validity will be defined by `notBefore` and `notAfter` (first valid date and last valid date). The `issuerName` must contain at least "CN=" (common name, i.e. the domain name), "O=" (organization, i.e. your company name), "C=" (country, i.e. 2 lettered ISO-3166 code of the country the organization is based in).
    /// 
    /// A small example to generate an RSA key and a X509 self-signed certificate.
    /// 
    public final func generateSelfSignedCertificate (key: CryptoKey?, issuerName: String = "CN=myserver,O=myorganisation,C=IT", notBefore: String = "20140101000000", notAfter: String = "20340101000000")-> X509Certificate? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        let gstr_issuer_name = GString (issuerName)
        let gstr_not_before = GString (notBefore)
        let gstr_not_after = GString (notAfter)
        var copy_key_handle = key?.handle
        
        gi.object_method_bind_ptrcall_v (Crypto.method_generate_self_signed_certificate, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_key_handle, &gstr_issuer_name.content, &gstr_not_before.content, &gstr_not_after.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_issuer_name = GString (issuerName)
        let gstr_not_before = GString (notBefore)
        let gstr_not_after = GString (notAfter)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: key?.handle) { p0 in
        _args.append (key == nil ? nil : p0)
            return withUnsafePointer (to: &gstr_issuer_name.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &gstr_not_before.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &gstr_not_after.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Crypto.method_generate_self_signed_certificate, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_sign: GDExtensionMethodBindPtr = {
        let methodName = StringName ("sign")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1673662703)!
            }
            
        }
        
    }()
    
    /// Sign a given `hash` of type `hashType` with the provided private `key`.
    public final func sign (hashType: HashingContext.HashType, hash: PackedByteArray, key: CryptoKey?)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        var copy_hash_type = Int64 (hashType.rawValue)
        var copy_key_handle = key?.handle
        
        gi.object_method_bind_ptrcall_v (Crypto.method_sign, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_hash_type, &hash.content, &copy_key_handle)
        return _result
        #else
        
        var copy_hash_type = Int64 (hashType.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hash_type) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &hash.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: key?.handle) { p2 in
                _args.append (key == nil ? nil : p2)
        
                    gi.object_method_bind_ptrcall (Crypto.method_sign, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_verify: GDExtensionMethodBindPtr = {
        let methodName = StringName ("verify")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2805902225)!
            }
            
        }
        
    }()
    
    /// Verify that a given `signature` for `hash` of type `hashType` against the provided public `key`.
    public final func verify (hashType: HashingContext.HashType, hash: PackedByteArray, signature: PackedByteArray, key: CryptoKey?)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_hash_type = Int64 (hashType.rawValue)
        var copy_key_handle = key?.handle
        
        gi.object_method_bind_ptrcall_v (Crypto.method_verify, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_hash_type, &hash.content, &signature.content, &copy_key_handle)
        return _result
        #else
        
        var copy_hash_type = Int64 (hashType.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hash_type) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &hash.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &signature.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: key?.handle) { p3 in
                    _args.append (key == nil ? nil : p3)
        
                        gi.object_method_bind_ptrcall (Crypto.method_verify, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_encrypt: GDExtensionMethodBindPtr = {
        let methodName = StringName ("encrypt")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2361793670)!
            }
            
        }
        
    }()
    
    /// Encrypt the given `plaintext` with the provided public `key`.
    /// 
    /// > Note: The maximum size of accepted plaintext is limited by the key size.
    /// 
    public final func encrypt (key: CryptoKey?, plaintext: PackedByteArray)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        var copy_key_handle = key?.handle
        
        gi.object_method_bind_ptrcall_v (Crypto.method_encrypt, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_key_handle, &plaintext.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: key?.handle) { p0 in
        _args.append (key == nil ? nil : p0)
            return withUnsafePointer (to: &plaintext.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Crypto.method_encrypt, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_decrypt: GDExtensionMethodBindPtr = {
        let methodName = StringName ("decrypt")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2361793670)!
            }
            
        }
        
    }()
    
    /// Decrypt the given `ciphertext` with the provided private `key`.
    /// 
    /// > Note: The maximum size of accepted ciphertext is limited by the key size.
    /// 
    public final func decrypt (key: CryptoKey?, ciphertext: PackedByteArray)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        var copy_key_handle = key?.handle
        
        gi.object_method_bind_ptrcall_v (Crypto.method_decrypt, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_key_handle, &ciphertext.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: key?.handle) { p0 in
        _args.append (key == nil ? nil : p0)
            return withUnsafePointer (to: &ciphertext.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Crypto.method_decrypt, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_hmac_digest: GDExtensionMethodBindPtr = {
        let methodName = StringName ("hmac_digest")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2368951203)!
            }
            
        }
        
    }()
    
    /// Generates an [url=https://en.wikipedia.org/wiki/HMAC]HMAC[/url] digest of `msg` using `key`. The `hashType` parameter is the hashing algorithm that is used for the inner and outer hashes.
    /// 
    /// Currently, only ``HashingContext/HashType/hashSha256`` and ``HashingContext/HashType/hashSha1`` are supported.
    /// 
    public final func hmacDigest (hashType: HashingContext.HashType, key: PackedByteArray, msg: PackedByteArray)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        var copy_hash_type = Int64 (hashType.rawValue)
        
        gi.object_method_bind_ptrcall_v (Crypto.method_hmac_digest, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_hash_type, &key.content, &msg.content)
        return _result
        #else
        
        var copy_hash_type = Int64 (hashType.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hash_type) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &key.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &msg.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Crypto.method_hmac_digest, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_constant_time_compare: GDExtensionMethodBindPtr = {
        let methodName = StringName ("constant_time_compare")
        return withUnsafePointer (to: &Crypto.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1024142237)!
            }
            
        }
        
    }()
    
    /// Compares two ``PackedByteArray``s for equality without leaking timing information in order to prevent timing attacks.
    /// 
    /// See [url=https://paragonie.com/blog/2015/11/preventing-timing-attacks-on-string-comparison-with-double-hmac-strategy]this blog post[/url] for more information.
    /// 
    public final func constantTimeCompare (trusted: PackedByteArray, received: PackedByteArray)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (Crypto.method_constant_time_compare, UnsafeMutableRawPointer (mutating: handle), &_result, &trusted.content, &received.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &trusted.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &received.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Crypto.method_constant_time_compare, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
}

