// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// TLS configuration for clients and servers.
/// 
/// TLSOptions abstracts the configuration options for the ``StreamPeerTLS`` and ``PacketPeerDTLS`` classes.
/// 
/// Objects of this class cannot be instantiated directly, and one of the static methods ``client(trustedChain:commonNameOverride:)``, ``clientUnsafe(trustedChain:)``, or ``server(key:certificate:)`` should be used instead.
/// 
open class TLSOptions: RefCounted {
    override open class var godotClassName: StringName { "TLSOptions" }
    /* Methods */
    fileprivate static var method_client: GDExtensionMethodBindPtr = {
        let methodName = StringName ("client")
        return withUnsafePointer (to: &TLSOptions.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3565000357)!
            }
            
        }
        
    }()
    
    /// Creates a TLS client configuration which validates certificates and their common names (fully qualified domain names).
    /// 
    /// You can specify a custom `trustedChain` of certification authorities (the default CA list will be used if `null`), and optionally provide a `commonNameOverride` if you expect the certificate to have a common name other than the server FQDN.
    /// 
    /// > Note: On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
    /// 
    public static func client (trustedChain: X509Certificate? = nil, commonNameOverride: String = "")-> TLSOptions? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        let gstr_common_name_override = GString (commonNameOverride)
        var copy_trusted_chain_handle = trustedChain?.handle
        
        gi.object_method_bind_ptrcall_v (TLSOptions.method_client, nil, &_result, &copy_trusted_chain_handle, &gstr_common_name_override.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_common_name_override = GString (commonNameOverride)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: trustedChain?.handle) { p0 in
        _args.append (trustedChain == nil ? nil : p0)
            return withUnsafePointer (to: &gstr_common_name_override.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TLSOptions.method_client, nil, &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_client_unsafe: GDExtensionMethodBindPtr = {
        let methodName = StringName ("client_unsafe")
        return withUnsafePointer (to: &TLSOptions.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2090251749)!
            }
            
        }
        
    }()
    
    /// Creates an **unsafe** TLS client configuration where certificate validation is optional. You can optionally provide a valid `trustedChain`, but the common name of the certificates will never be checked. Using this configuration for purposes other than testing **is not recommended**.
    /// 
    /// > Note: On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
    /// 
    public static func clientUnsafe (trustedChain: X509Certificate? = nil)-> TLSOptions? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_trusted_chain_handle = trustedChain?.handle
        
        gi.object_method_bind_ptrcall_v (TLSOptions.method_client_unsafe, nil, &_result, &copy_trusted_chain_handle)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: trustedChain?.handle) { p0 in
        _args.append (trustedChain == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (TLSOptions.method_client_unsafe, nil, &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_server: GDExtensionMethodBindPtr = {
        let methodName = StringName ("server")
        return withUnsafePointer (to: &TLSOptions.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36969539)!
            }
            
        }
        
    }()
    
    /// Creates a TLS server configuration using the provided `key` and `certificate`.
    /// 
    /// > Note: The `certificate` should include the full certificate chain up to the signing CA (certificates file can be concatenated using a general purpose text editor).
    /// 
    public static func server (key: CryptoKey?, certificate: X509Certificate?)-> TLSOptions? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_key_handle = key?.handle
        var copy_certificate_handle = certificate?.handle
        
        gi.object_method_bind_ptrcall_v (TLSOptions.method_server, nil, &_result, &copy_key_handle, &copy_certificate_handle)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: key?.handle) { p0 in
        _args.append (key == nil ? nil : p0)
            return withUnsafePointer (to: certificate?.handle) { p1 in
            _args.append (certificate == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (TLSOptions.method_server, nil, &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
}

