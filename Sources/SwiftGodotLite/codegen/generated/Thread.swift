// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A unit of execution in a process.
/// 
/// A unit of execution in a process. Can run methods on ``Object``s simultaneously. The use of synchronization via ``Mutex`` or ``Semaphore`` is advised if working with shared objects.
/// 
/// > Warning:
/// 
/// To ensure proper cleanup without crashes or deadlocks, when a ``Thread``'s reference count reaches zero and it is therefore destroyed, the following conditions must be met:
/// 
/// - It must not have any ``Mutex`` objects locked.
/// 
/// - It must not be waiting on any ``Semaphore`` objects.
/// 
/// - ``waitToFinish()`` should have been called on it.
/// 
open class Thread: RefCounted {
    override open class var godotClassName: StringName { "Thread" }
    public enum Priority: Int64 {
        /// A thread running with lower priority than normally.
        case low = 0 // PRIORITY_LOW
        /// A thread with a standard priority.
        case normal = 1 // PRIORITY_NORMAL
        /// A thread running with higher priority than normally.
        case high = 2 // PRIORITY_HIGH
    }
    
    /* Methods */
    fileprivate static var method_start: GDExtensionMethodBindPtr = {
        let methodName = StringName ("start")
        return withUnsafePointer (to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1327203254)!
            }
            
        }
        
    }()
    
    /// Starts a new ``Thread`` that calls `callable`.
    /// 
    /// If the method takes some arguments, you can pass them using ``Callable/bind()``.
    /// 
    /// The `priority` of the ``Thread`` can be changed by passing a value from the ``Thread/Priority`` enum.
    /// 
    /// Returns ``GodotError/ok`` on success, or ``GodotError/errCantCreate`` on failure.
    /// 
    public final func start (callable: Callable, priority: Thread.Priority = .normal)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_priority = Int64 (priority.rawValue)
        
        gi.object_method_bind_ptrcall_v (Thread.method_start, UnsafeMutableRawPointer (mutating: handle), &_result, &callable.content, &copy_priority)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_priority = Int64 (priority.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &callable.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_priority) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Thread.method_start, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_id")
        return withUnsafePointer (to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the current ``Thread``'s ID, uniquely identifying it among all threads. If the ``Thread`` has not started running or if ``waitToFinish()`` has been called, this returns an empty string.
    public final func getId ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Thread.method_get_id, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_is_started: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_started")
        return withUnsafePointer (to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this ``Thread`` has been started. Once started, this will return `true` until it is joined using ``waitToFinish()``. For checking if a ``Thread`` is still executing its task, use ``isAlive()``.
    public final func isStarted ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Thread.method_is_started, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_alive: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_alive")
        return withUnsafePointer (to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this ``Thread`` is currently running the provided function. This is useful for determining if ``waitToFinish()`` can be called without blocking the calling thread.
    /// 
    /// To check if a ``Thread`` is joinable, use ``isStarted()``.
    /// 
    public final func isAlive ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Thread.method_is_alive, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_wait_to_finish: GDExtensionMethodBindPtr = {
        let methodName = StringName ("wait_to_finish")
        return withUnsafePointer (to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1460262497)!
            }
            
        }
        
    }()
    
    /// Joins the ``Thread`` and waits for it to finish. Returns the output of the ``Callable`` passed to ``start(callable:priority:)``.
    /// 
    /// Should either be used when you want to retrieve the value returned from the method called by the ``Thread`` or before freeing the instance that contains the ``Thread``.
    /// 
    /// To determine if this can be called without blocking the calling thread, check if ``isAlive()`` is `false`.
    /// 
    public final func waitToFinish ()-> Variant {
        let _result: Variant = Variant ()
        gi.object_method_bind_ptrcall (Thread.method_wait_to_finish, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_thread_safety_checks_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_thread_safety_checks_enabled")
        return withUnsafePointer (to: &Thread.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets whether the thread safety checks the engine normally performs in methods of certain classes (e.g., ``Node``) should happen **on the current thread**.
    /// 
    /// The default, for every thread, is that they are enabled (as if called with `enabled` being `true`).
    /// 
    /// Those checks are conservative. That means that they will only succeed in considering a call thread-safe (and therefore allow it to happen) if the engine can guarantee such safety.
    /// 
    /// Because of that, there may be cases where the user may want to disable them (`enabled` being `false`) to make certain operations allowed again. By doing so, it becomes the user's responsibility to ensure thread safety (e.g., by using ``Mutex``) for those objects that are otherwise protected by the engine.
    /// 
    /// > Note: This is an advanced usage of the engine. You are advised to use it only if you know what you are doing and there is no safer way.
    /// 
    /// > Note: This is useful for scripts running on either arbitrary ``Thread`` objects or tasks submitted to the ``WorkerThreadPool``. It doesn't apply to code running during ``Node`` group processing, where the checks will be always performed.
    /// 
    /// > Note: Even in the case of having disabled the checks in a ``WorkerThreadPool`` task, there's no need to re-enable them at the end. The engine will do so.
    /// 
    public static func setThreadSafetyChecksEnabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (Thread.method_set_thread_safety_checks_enabled, nil, nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Thread.method_set_thread_safety_checks_enabled, nil, &_args, nil)
        }
        
        #endif
    }
    
}

