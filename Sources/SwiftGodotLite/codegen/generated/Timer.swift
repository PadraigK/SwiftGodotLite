// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A countdown timer.
/// 
/// Counts down a specified interval and emits a signal on reaching 0. Can be set to repeat or "one-shot" mode.
/// 
/// > Note: Timers are affected by ``Engine/timeScale``, a higher scale means quicker timeouts, and vice versa.
/// 
/// > Note: To create a one-shot timer without instantiating a node, use ``SceneTree/createTimer(timeSec:processAlways:processInPhysics:ignoreTimeScale:)``.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``timeout``
open class Timer: Node {
    override open class var godotClassName: StringName { "Timer" }
    public enum TimerProcessCallback: Int64 {
        /// Update the timer during physics frames (see ``Node/``notificationInternalPhysicsProcess````).
        case physics = 0 // TIMER_PROCESS_PHYSICS
        /// Update the timer during process frames (see ``Node/``notificationInternalProcess````).
        case idle = 1 // TIMER_PROCESS_IDLE
    }
    
    
    /* Properties */
    
    /// Processing callback. See ``Timer/TimerProcessCallback``.
    final public var processCallback: Timer.TimerProcessCallback {
        get {
            return get_timer_process_callback ()
        }
        
        set {
            set_timer_process_callback (newValue)
        }
        
    }
    
    /// The wait time in seconds.
    /// 
    /// > Note: Timers can only emit once per rendered frame at most (or once per physics frame if ``processCallback`` is .timerProcessPhysics). This means very low wait times (lower than 0.05 seconds) will behave in significantly different ways depending on the rendered framerate. For very low wait times, it is recommended to use a process loop in a script instead of using a Timer node. Timers are affected by ``Engine/timeScale``, a higher scale means quicker timeouts, and vice versa.
    /// 
    final public var waitTime: Double {
        get {
            return get_wait_time ()
        }
        
        set {
            set_wait_time (newValue)
        }
        
    }
    
    /// If `true`, the timer will stop when reaching 0. If `false`, it will restart.
    final public var oneShot: Bool {
        get {
            return is_one_shot ()
        }
        
        set {
            set_one_shot (newValue)
        }
        
    }
    
    /// If `true`, the timer will automatically start when entering the scene tree.
    /// 
    /// > Note: This property is automatically set to `false` after the timer enters the scene tree and starts.
    /// 
    final public var autostart: Bool {
        get {
            return has_autostart ()
        }
        
        set {
            set_autostart (newValue)
        }
        
    }
    
    /// If `true`, the timer is paused and will not process until it is unpaused again, even if ``start(timeSec:)`` is called.
    final public var paused: Bool {
        get {
            return is_paused ()
        }
        
        set {
            set_paused (newValue)
        }
        
    }
    
    /// The timer's remaining time in seconds. Returns 0 if the timer is inactive.
    /// 
    /// > Note: This value is read-only and cannot be set. It is based on ``waitTime``, which can be set using ``start(timeSec:)``.
    /// 
    final public var timeLeft: Double {
        get {
            return get_time_left ()
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_wait_time: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_wait_time")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_wait_time (_ timeSec: Double) {
        #if true
        
        var copy_time_sec = timeSec
        
        gi.object_method_bind_ptrcall_v (Timer.method_set_wait_time, UnsafeMutableRawPointer (mutating: handle), nil, &copy_time_sec)
        
        #else
        
        var copy_time_sec = timeSec
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_time_sec) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Timer.method_set_wait_time, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_wait_time: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_wait_time")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_wait_time ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Timer.method_get_wait_time, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_one_shot: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_one_shot")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_one_shot (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Timer.method_set_one_shot, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Timer.method_set_one_shot, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_one_shot: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_one_shot")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_one_shot ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Timer.method_is_one_shot, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_autostart: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_autostart")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_autostart (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Timer.method_set_autostart, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Timer.method_set_autostart, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_has_autostart: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_autostart")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func has_autostart ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Timer.method_has_autostart, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_start: GDExtensionMethodBindPtr = {
        let methodName = StringName ("start")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1392008558)!
            }
            
        }
        
    }()
    
    /// Starts the timer. Sets ``waitTime`` to `timeSec` if `time_sec > 0`. This also resets the remaining time to ``waitTime``.
    /// 
    /// > Note: This method will not resume a paused timer. See ``paused``.
    /// 
    public final func start (timeSec: Double = -1) {
        #if true
        
        var copy_time_sec = timeSec
        
        gi.object_method_bind_ptrcall_v (Timer.method_start, UnsafeMutableRawPointer (mutating: handle), nil, &copy_time_sec)
        
        #else
        
        var copy_time_sec = timeSec
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_time_sec) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Timer.method_start, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_stop: GDExtensionMethodBindPtr = {
        let methodName = StringName ("stop")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Stops the timer.
    public final func stop () {
        gi.object_method_bind_ptrcall (Timer.method_stop, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_paused: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_paused")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_paused (_ paused: Bool) {
        #if true
        
        var copy_paused = paused
        
        gi.object_method_bind_ptrcall_v (Timer.method_set_paused, UnsafeMutableRawPointer (mutating: handle), nil, &copy_paused)
        
        #else
        
        var copy_paused = paused
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_paused) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Timer.method_set_paused, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_paused: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_paused")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_paused ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Timer.method_is_paused, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_stopped: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_stopped")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the timer is stopped.
    public final func isStopped ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Timer.method_is_stopped, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_time_left: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_time_left")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_time_left ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Timer.method_get_time_left, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_timer_process_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_timer_process_callback")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3469495063)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_timer_process_callback (_ callback: Timer.TimerProcessCallback) {
        #if true
        
        var copy_callback = Int64 (callback.rawValue)
        
        gi.object_method_bind_ptrcall_v (Timer.method_set_timer_process_callback, UnsafeMutableRawPointer (mutating: handle), nil, &copy_callback)
        
        #else
        
        var copy_callback = Int64 (callback.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_callback) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Timer.method_set_timer_process_callback, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_timer_process_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_timer_process_callback")
        return withUnsafePointer (to: &Timer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2672570227)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_timer_process_callback ()-> Timer.TimerProcessCallback {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Timer.method_get_timer_process_callback, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Timer.TimerProcessCallback (rawValue: _result)!
    }
    
    // Signals 
    /// Emitted when the timer reaches 0.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.timeout.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var timeout: SimpleSignal { SimpleSignal (target: self, signalName: "timeout") }
    
}

