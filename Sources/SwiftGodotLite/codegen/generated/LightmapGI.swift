// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Computes and stores baked lightmaps for fast global illumination.
/// 
/// The ``LightmapGI`` node is used to compute and store baked lightmaps. Lightmaps are used to provide high-quality indirect lighting with very little light leaking. ``LightmapGI`` can also provide rough reflections using spherical harmonics if ``directional`` is enabled. Dynamic objects can receive indirect lighting thanks to _light probes_, which can be automatically placed by setting ``generateProbesSubdiv`` to a value other than .disabled. Additional lightmap probes can also be added by creating ``LightmapProbe`` nodes. The downside is that lightmaps are fully static and cannot be baked in an exported project. Baking a ``LightmapGI`` node is also slower compared to ``VoxelGI``.
/// 
/// **Procedural generation:** Lightmap baking functionality is only available in the editor. This means ``LightmapGI`` is not suited to procedurally generated or user-built levels. For procedurally generated or user-built levels, use ``VoxelGI`` or SDFGI instead (see ``Environment/sdfgiEnabled``).
/// 
/// **Performance:** ``LightmapGI`` provides the best possible run-time performance for global illumination. It is suitable for low-end hardware including integrated graphics and mobile devices.
/// 
/// > Note: Due to how lightmaps work, most properties only have a visible effect once lightmaps are baked again.
/// 
/// > Note: Lightmap baking on ``CSGShape3D``s and ``PrimitiveMesh``es is not supported, as these cannot store UV2 data required for baking.
/// 
/// > Note: If no custom lightmappers are installed, ``LightmapGI`` can only be baked when using the Vulkan backend (Forward+ or Mobile), not OpenGL.
/// 
open class LightmapGI: VisualInstance3D {
    override open class var godotClassName: StringName { "LightmapGI" }
    public enum BakeQuality: Int64 {
        /// Low bake quality (fastest bake times). The quality of this preset can be adjusted by changing ``ProjectSettings/rendering/lightmapping/bakeQuality/lowQualityRayCount`` and ``ProjectSettings/rendering/lightmapping/bakeQuality/lowQualityProbeRayCount``.
        case low = 0 // BAKE_QUALITY_LOW
        /// Medium bake quality (fast bake times). The quality of this preset can be adjusted by changing ``ProjectSettings/rendering/lightmapping/bakeQuality/mediumQualityRayCount`` and ``ProjectSettings/rendering/lightmapping/bakeQuality/mediumQualityProbeRayCount``.
        case medium = 1 // BAKE_QUALITY_MEDIUM
        /// High bake quality (slow bake times). The quality of this preset can be adjusted by changing ``ProjectSettings/rendering/lightmapping/bakeQuality/highQualityRayCount`` and ``ProjectSettings/rendering/lightmapping/bakeQuality/highQualityProbeRayCount``.
        case high = 2 // BAKE_QUALITY_HIGH
        /// Highest bake quality (slowest bake times). The quality of this preset can be adjusted by changing ``ProjectSettings/rendering/lightmapping/bakeQuality/ultraQualityRayCount`` and ``ProjectSettings/rendering/lightmapping/bakeQuality/ultraQualityProbeRayCount``.
        case ultra = 3 // BAKE_QUALITY_ULTRA
    }
    
    public enum GenerateProbes: Int64 {
        /// Don't generate lightmap probes for lighting dynamic objects.
        case disabled = 0 // GENERATE_PROBES_DISABLED
        /// Lowest level of subdivision (fastest bake times, smallest file sizes).
        case subdiv4 = 1 // GENERATE_PROBES_SUBDIV_4
        /// Low level of subdivision (fast bake times, small file sizes).
        case subdiv8 = 2 // GENERATE_PROBES_SUBDIV_8
        /// High level of subdivision (slow bake times, large file sizes).
        case subdiv16 = 3 // GENERATE_PROBES_SUBDIV_16
        /// Highest level of subdivision (slowest bake times, largest file sizes).
        case subdiv32 = 4 // GENERATE_PROBES_SUBDIV_32
    }
    
    public enum BakeError: Int64 {
        /// Lightmap baking was successful.
        case ok = 0 // BAKE_ERROR_OK
        /// Lightmap baking failed because the root node for the edited scene could not be accessed.
        case noSceneRoot = 1 // BAKE_ERROR_NO_SCENE_ROOT
        /// Lightmap baking failed as the lightmap data resource is embedded in a foreign resource.
        case foreignData = 2 // BAKE_ERROR_FOREIGN_DATA
        /// Lightmap baking failed as there is no lightmapper available in this Godot build.
        case noLightmapper = 3 // BAKE_ERROR_NO_LIGHTMAPPER
        /// Lightmap baking failed as the ``LightmapGIData`` save path isn't configured in the resource.
        case noSavePath = 4 // BAKE_ERROR_NO_SAVE_PATH
        /// Lightmap baking failed as there are no meshes whose ``GeometryInstance3D/giMode`` is ``GeometryInstance3D/GIMode/`static``` and with valid UV2 mapping in the current scene. You may need to select 3D scenes in the Import dock and change their global illumination mode accordingly.
        case noMeshes = 5 // BAKE_ERROR_NO_MESHES
        /// Lightmap baking failed as the lightmapper failed to analyze some of the meshes marked as static for baking.
        case meshesInvalid = 6 // BAKE_ERROR_MESHES_INVALID
        /// Lightmap baking failed as the resulting image couldn't be saved or imported by Godot after it was saved.
        case cantCreateImage = 7 // BAKE_ERROR_CANT_CREATE_IMAGE
        /// The user aborted the lightmap baking operation (typically by clicking the **Cancel** button in the progress dialog).
        case userAborted = 8 // BAKE_ERROR_USER_ABORTED
        /// Lightmap baking failed as the maximum texture size is too small to fit some of the meshes marked for baking.
        case textureSizeTooSmall = 9 // BAKE_ERROR_TEXTURE_SIZE_TOO_SMALL
    }
    
    public enum EnvironmentMode: Int64 {
        /// Ignore environment lighting when baking lightmaps.
        case disabled = 0 // ENVIRONMENT_MODE_DISABLED
        /// Use the scene's environment lighting when baking lightmaps.
        /// 
        /// > Note: If baking lightmaps in a scene with no ``WorldEnvironment`` node, this will act like .disabled. The editor's preview sky and sun is _not_ taken into account by ``LightmapGI`` when baking lightmaps.
        /// 
        case scene = 1 // ENVIRONMENT_MODE_SCENE
        /// Use ``environmentCustomSky`` as a source of environment lighting when baking lightmaps.
        case customSky = 2 // ENVIRONMENT_MODE_CUSTOM_SKY
        /// Use ``environmentCustomColor`` multiplied by ``environmentCustomEnergy`` as a constant source of environment lighting when baking lightmaps.
        case customColor = 3 // ENVIRONMENT_MODE_CUSTOM_COLOR
    }
    
    
    /* Properties */
    
    /// The quality preset to use when baking lightmaps. This affects bake times, but output file sizes remain mostly identical across quality levels.
    /// 
    /// To further speed up bake times, decrease ``bounces``, disable ``useDenoiser`` and increase the lightmap texel size on 3D scenes in the Import doc.
    /// 
    final public var quality: LightmapGI.BakeQuality {
        get {
            return get_bake_quality ()
        }
        
        set {
            set_bake_quality (newValue)
        }
        
    }
    
    /// Number of light bounces that are taken into account during baking. Higher values result in brighter, more realistic lighting, at the cost of longer bake times. If set to `0`, only environment lighting, direct light and emissive lighting is baked.
    final public var bounces: Int32 {
        get {
            return get_bounces ()
        }
        
        set {
            set_bounces (newValue)
        }
        
    }
    
    /// The energy multiplier for each bounce. Higher values will make indirect lighting brighter. A value of `1.0` represents physically accurate behavior, but higher values can be used to make indirect lighting propagate more visibly when using a low number of bounces. This can be used to speed up bake times by lowering the number of ``bounces`` then increasing ``bounceIndirectEnergy``.
    /// 
    /// > Note: ``bounceIndirectEnergy`` only has an effect if ``bounces`` is set to a value greater than or equal to `1`.
    /// 
    final public var bounceIndirectEnergy: Double {
        get {
            return get_bounce_indirect_energy ()
        }
        
        set {
            set_bounce_indirect_energy (newValue)
        }
        
    }
    
    /// If `true`, bakes lightmaps to contain directional information as spherical harmonics. This results in more realistic lighting appearance, especially with normal mapped materials and for lights that have their direct light baked (``Light3D/lightBakeMode`` set to ``Light3D/BakeMode/bakeStatic`` and with ``Light3D/editorOnly`` set to `false`). The directional information is also used to provide rough reflections for static and dynamic objects. This has a small run-time performance cost as the shader has to perform more work to interpret the direction information from the lightmap. Directional lightmaps also take longer to bake and result in larger file sizes.
    /// 
    /// > Note: The property's name has no relationship with ``DirectionalLight3D``. ``directional`` works with all light types.
    /// 
    final public var directional: Bool {
        get {
            return is_directional ()
        }
        
        set {
            set_directional (newValue)
        }
        
    }
    
    /// If `true`, a texture with the lighting information will be generated to speed up the generation of indirect lighting at the cost of some accuracy. The geometry might exhibit extra light leak artifacts when using low resolution lightmaps or UVs that stretch the lightmap significantly across surfaces. Leave ``useTextureForBounces`` at its default value of `true` if unsure.
    /// 
    /// > Note: ``useTextureForBounces`` only has an effect if ``bounces`` is set to a value greater than or equal to `1`.
    /// 
    final public var useTextureForBounces: Bool {
        get {
            return is_using_texture_for_bounces ()
        }
        
        set {
            set_use_texture_for_bounces (newValue)
        }
        
    }
    
    /// If `true`, ignore environment lighting when baking lightmaps.
    final public var interior: Bool {
        get {
            return is_interior ()
        }
        
        set {
            set_interior (newValue)
        }
        
    }
    
    /// If `true`, uses a GPU-based denoising algorithm on the generated lightmap. This eliminates most noise within the generated lightmap at the cost of longer bake times. File sizes are generally not impacted significantly by the use of a denoiser, although lossless compression may do a better job at compressing a denoised image.
    final public var useDenoiser: Bool {
        get {
            return is_using_denoiser ()
        }
        
        set {
            set_use_denoiser (newValue)
        }
        
    }
    
    /// The strength of denoising step applied to the generated lightmaps. Only effective if ``useDenoiser`` is `true` and ``ProjectSettings/rendering/lightmapping/denoising/denoiser`` is set to JNLM.
    final public var denoiserStrength: Double {
        get {
            return get_denoiser_strength ()
        }
        
        set {
            set_denoiser_strength (newValue)
        }
        
    }
    
    /// The bias to use when computing shadows. Increasing ``bias`` can fix shadow acne on the resulting baked lightmap, but can introduce peter-panning (shadows not connecting to their casters). Real-time ``Light3D`` shadows are not affected by this ``bias`` property.
    final public var bias: Double {
        get {
            return get_bias ()
        }
        
        set {
            set_bias (newValue)
        }
        
    }
    
    /// The maximum texture size for the generated texture atlas. Higher values will result in fewer slices being generated, but may not work on all hardware as a result of hardware limitations on texture sizes. Leave ``maxTextureSize`` at its default value of `16384` if unsure.
    final public var maxTextureSize: Int32 {
        get {
            return get_max_texture_size ()
        }
        
        set {
            set_max_texture_size (newValue)
        }
        
    }
    
    /// The environment mode to use when baking lightmaps.
    final public var environmentMode: LightmapGI.EnvironmentMode {
        get {
            return get_environment_mode ()
        }
        
        set {
            set_environment_mode (newValue)
        }
        
    }
    
    /// The sky to use as a source of environment lighting. Only effective if ``environmentMode`` is .customSky.
    final public var environmentCustomSky: Sky? {
        get {
            return get_environment_custom_sky ()
        }
        
        set {
            set_environment_custom_sky (newValue)
        }
        
    }
    
    /// The color to use for environment lighting. Only effective if ``environmentMode`` is .customColor.
    final public var environmentCustomColor: Color {
        get {
            return get_environment_custom_color ()
        }
        
        set {
            set_environment_custom_color (newValue)
        }
        
    }
    
    /// The color multiplier to use for environment lighting. Only effective if ``environmentMode`` is .customColor.
    final public var environmentCustomEnergy: Double {
        get {
            return get_environment_custom_energy ()
        }
        
        set {
            set_environment_custom_energy (newValue)
        }
        
    }
    
    /// The ``CameraAttributes`` resource that specifies exposure levels to bake at. Auto-exposure and non exposure properties will be ignored. Exposure settings should be used to reduce the dynamic range present when baking. If exposure is too high, the ``LightmapGI`` will have banding artifacts or may have over-exposure artifacts.
    final public var cameraAttributes: CameraAttributes? {
        get {
            return get_camera_attributes ()
        }
        
        set {
            set_camera_attributes (newValue)
        }
        
    }
    
    /// The level of subdivision to use when automatically generating ``LightmapProbe``s for dynamic object lighting. Higher values result in more accurate indirect lighting on dynamic objects, at the cost of longer bake times and larger file sizes.
    /// 
    /// > Note: Automatically generated ``LightmapProbe``s are not visible as nodes in the Scene tree dock, and cannot be modified this way after they are generated.
    /// 
    /// > Note: Regardless of ``generateProbesSubdiv``, direct lighting on dynamic objects is always applied using ``Light3D`` nodes in real-time.
    /// 
    final public var generateProbesSubdiv: LightmapGI.GenerateProbes {
        get {
            return get_generate_probes ()
        }
        
        set {
            set_generate_probes (newValue)
        }
        
    }
    
    /// The ``LightmapGIData`` associated to this ``LightmapGI`` node. This resource is automatically created after baking, and is not meant to be created manually.
    final public var lightData: LightmapGIData? {
        get {
            return get_light_data ()
        }
        
        set {
            set_light_data (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_light_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_light_data")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1790597277)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_light_data (_ data: LightmapGIData?) {
        #if true
        
        var copy_data_handle = data?.handle
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_light_data, UnsafeMutableRawPointer (mutating: handle), nil, &copy_data_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: data?.handle) { p0 in
        _args.append (data == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_light_data, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_light_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_light_data")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 290354153)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_light_data ()-> LightmapGIData? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (LightmapGI.method_get_light_data, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_bake_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_bake_quality")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1192215803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bake_quality (_ bakeQuality: LightmapGI.BakeQuality) {
        #if true
        
        var copy_bake_quality = Int64 (bakeQuality.rawValue)
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_bake_quality, UnsafeMutableRawPointer (mutating: handle), nil, &copy_bake_quality)
        
        #else
        
        var copy_bake_quality = Int64 (bakeQuality.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_bake_quality) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_bake_quality, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_bake_quality: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_bake_quality")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 688832735)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bake_quality ()-> LightmapGI.BakeQuality {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (LightmapGI.method_get_bake_quality, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return LightmapGI.BakeQuality (rawValue: _result)!
    }
    
    fileprivate static var method_set_bounces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_bounces")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bounces (_ bounces: Int32) {
        #if true
        
        var copy_bounces: Int = Int (bounces)
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_bounces, UnsafeMutableRawPointer (mutating: handle), nil, &copy_bounces)
        
        #else
        
        var copy_bounces: Int = Int (bounces)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_bounces) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_bounces, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_bounces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_bounces")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bounces ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (LightmapGI.method_get_bounces, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_bounce_indirect_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_bounce_indirect_energy")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bounce_indirect_energy (_ bounceIndirectEnergy: Double) {
        #if true
        
        var copy_bounce_indirect_energy = bounceIndirectEnergy
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_bounce_indirect_energy, UnsafeMutableRawPointer (mutating: handle), nil, &copy_bounce_indirect_energy)
        
        #else
        
        var copy_bounce_indirect_energy = bounceIndirectEnergy
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_bounce_indirect_energy) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_bounce_indirect_energy, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_bounce_indirect_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_bounce_indirect_energy")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bounce_indirect_energy ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (LightmapGI.method_get_bounce_indirect_energy, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_generate_probes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_generate_probes")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 549981046)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_generate_probes (_ subdivision: LightmapGI.GenerateProbes) {
        #if true
        
        var copy_subdivision = Int64 (subdivision.rawValue)
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_generate_probes, UnsafeMutableRawPointer (mutating: handle), nil, &copy_subdivision)
        
        #else
        
        var copy_subdivision = Int64 (subdivision.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_subdivision) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_generate_probes, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_generate_probes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_generate_probes")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3930596226)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_generate_probes ()-> LightmapGI.GenerateProbes {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (LightmapGI.method_get_generate_probes, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return LightmapGI.GenerateProbes (rawValue: _result)!
    }
    
    fileprivate static var method_set_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_bias")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_bias (_ bias: Double) {
        #if true
        
        var copy_bias = bias
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_bias, UnsafeMutableRawPointer (mutating: handle), nil, &copy_bias)
        
        #else
        
        var copy_bias = bias
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_bias) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_bias, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_bias")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_bias ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (LightmapGI.method_get_bias, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_environment_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_environment_mode")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2282650285)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_environment_mode (_ mode: LightmapGI.EnvironmentMode) {
        #if true
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_environment_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_environment_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_environment_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_environment_mode")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4128646479)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_environment_mode ()-> LightmapGI.EnvironmentMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (LightmapGI.method_get_environment_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return LightmapGI.EnvironmentMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_environment_custom_sky: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_environment_custom_sky")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3336722921)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_environment_custom_sky (_ sky: Sky?) {
        #if true
        
        var copy_sky_handle = sky?.handle
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_environment_custom_sky, UnsafeMutableRawPointer (mutating: handle), nil, &copy_sky_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: sky?.handle) { p0 in
        _args.append (sky == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_environment_custom_sky, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_environment_custom_sky: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_environment_custom_sky")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1177136966)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_environment_custom_sky ()-> Sky? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (LightmapGI.method_get_environment_custom_sky, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_environment_custom_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_environment_custom_color")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_environment_custom_color (_ color: Color) {
        #if true
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_environment_custom_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_environment_custom_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_environment_custom_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_environment_custom_color")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3444240500)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_environment_custom_color ()-> Color {
        var _result: Color = Color ()
        gi.object_method_bind_ptrcall (LightmapGI.method_get_environment_custom_color, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_environment_custom_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_environment_custom_energy")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_environment_custom_energy (_ energy: Double) {
        #if true
        
        var copy_energy = energy
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_environment_custom_energy, UnsafeMutableRawPointer (mutating: handle), nil, &copy_energy)
        
        #else
        
        var copy_energy = energy
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_energy) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_environment_custom_energy, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_environment_custom_energy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_environment_custom_energy")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_environment_custom_energy ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (LightmapGI.method_get_environment_custom_energy, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_max_texture_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_max_texture_size")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_texture_size (_ maxTextureSize: Int32) {
        #if true
        
        var copy_max_texture_size: Int = Int (maxTextureSize)
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_max_texture_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_max_texture_size)
        
        #else
        
        var copy_max_texture_size: Int = Int (maxTextureSize)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_max_texture_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_max_texture_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_max_texture_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_max_texture_size")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_texture_size ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (LightmapGI.method_get_max_texture_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_denoiser: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_denoiser")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_denoiser (_ useDenoiser: Bool) {
        #if true
        
        var copy_use_denoiser = useDenoiser
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_use_denoiser, UnsafeMutableRawPointer (mutating: handle), nil, &copy_use_denoiser)
        
        #else
        
        var copy_use_denoiser = useDenoiser
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_use_denoiser) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_use_denoiser, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_denoiser: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_denoiser")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_denoiser ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LightmapGI.method_is_using_denoiser, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_denoiser_strength: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_denoiser_strength")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_denoiser_strength (_ denoiserStrength: Double) {
        #if true
        
        var copy_denoiser_strength = denoiserStrength
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_denoiser_strength, UnsafeMutableRawPointer (mutating: handle), nil, &copy_denoiser_strength)
        
        #else
        
        var copy_denoiser_strength = denoiserStrength
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_denoiser_strength) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_denoiser_strength, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_denoiser_strength: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_denoiser_strength")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_denoiser_strength ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (LightmapGI.method_get_denoiser_strength, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_interior: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_interior")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_interior (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_interior, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_interior, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_interior: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_interior")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_interior ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LightmapGI.method_is_interior, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_directional: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_directional")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_directional (_ directional: Bool) {
        #if true
        
        var copy_directional = directional
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_directional, UnsafeMutableRawPointer (mutating: handle), nil, &copy_directional)
        
        #else
        
        var copy_directional = directional
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_directional) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_directional, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_directional: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_directional")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_directional ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LightmapGI.method_is_directional, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_texture_for_bounces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_texture_for_bounces")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_texture_for_bounces (_ useTextureForBounces: Bool) {
        #if true
        
        var copy_use_texture_for_bounces = useTextureForBounces
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_use_texture_for_bounces, UnsafeMutableRawPointer (mutating: handle), nil, &copy_use_texture_for_bounces)
        
        #else
        
        var copy_use_texture_for_bounces = useTextureForBounces
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_use_texture_for_bounces) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_use_texture_for_bounces, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_texture_for_bounces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_texture_for_bounces")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_texture_for_bounces ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (LightmapGI.method_is_using_texture_for_bounces, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_camera_attributes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_camera_attributes")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2817810567)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_camera_attributes (_ cameraAttributes: CameraAttributes?) {
        #if true
        
        var copy_camera_attributes_handle = cameraAttributes?.handle
        
        gi.object_method_bind_ptrcall_v (LightmapGI.method_set_camera_attributes, UnsafeMutableRawPointer (mutating: handle), nil, &copy_camera_attributes_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: cameraAttributes?.handle) { p0 in
        _args.append (cameraAttributes == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (LightmapGI.method_set_camera_attributes, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_camera_attributes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_camera_attributes")
        return withUnsafePointer (to: &LightmapGI.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3921283215)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_camera_attributes ()-> CameraAttributes? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (LightmapGI.method_get_camera_attributes, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
}

