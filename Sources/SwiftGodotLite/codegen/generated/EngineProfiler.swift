// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for creating custom profilers.
/// 
/// This class can be used to implement custom profilers that are able to interact with the engine and editor debugger.
/// 
/// See ``EngineDebugger`` and ``EditorDebuggerPlugin`` for more information.
/// 
open class EngineProfiler: RefCounted {
    override open class var godotClassName: StringName { "EngineProfiler" }
    /* Methods */
    /// Called when the profiler is enabled/disabled, along with a set of `options`.
    @_documentation(visibility: public)
    open func _toggle (enable: Bool, options: GArray) {
    }
    
    /// Called when data is added to profiler using ``EngineDebugger/profilerAddFrameData(name:data:)``.
    @_documentation(visibility: public)
    open func _addFrame (data: GArray) {
    }
    
    /// Called once every engine iteration when the profiler is active with information about the current frame. All time values are in seconds. Lower values represent faster processing times and are therefore considered better.
    @_documentation(visibility: public)
    open func _tick (frameTime: Double, processTime: Double, physicsTime: Double, physicsFrameTime: Double) {
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_add_frame":
                return _EngineProfiler_proxy_add_frame
            case "_tick":
                return _EngineProfiler_proxy_tick
            case "_toggle":
                return _EngineProfiler_proxy_toggle
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
}

// Support methods for proxies
func _EngineProfiler_proxy_add_frame (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EngineProfiler>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._addFrame (data: GArray (content: args [0]!.assumingMemoryBound (to: Int64.self).pointee))
}

func _EngineProfiler_proxy_tick (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EngineProfiler>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._tick (frameTime: args [0]!.assumingMemoryBound (to: Double.self).pointee, processTime: args [1]!.assumingMemoryBound (to: Double.self).pointee, physicsTime: args [2]!.assumingMemoryBound (to: Double.self).pointee, physicsFrameTime: args [3]!.assumingMemoryBound (to: Double.self).pointee)
}

func _EngineProfiler_proxy_toggle (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<EngineProfiler>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._toggle (enable: args [0]!.assumingMemoryBound (to: Bool.self).pointee, options: GArray (content: args [1]!.assumingMemoryBound (to: Int64.self).pointee))
}

