// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A wrapper class for an [url=http://enet.bespin.org/group__host.html]ENetHost[/url].
/// 
/// ENet's purpose is to provide a relatively thin, simple and robust network communication layer on top of UDP (User Datagram Protocol).
open class ENetConnection: RefCounted {
    override open class var godotClassName: StringName { "ENetConnection" }
    public enum CompressionMode: Int64 {
        /// No compression. This uses the most bandwidth, but has the upside of requiring the fewest CPU resources. This option may also be used to make network debugging using tools like Wireshark easier.
        case none = 0 // COMPRESS_NONE
        /// ENet's built-in range encoding. Works well on small packets, but is not the most efficient algorithm on packets larger than 4 KB.
        case rangeCoder = 1 // COMPRESS_RANGE_CODER
        /// [url=https://fastlz.org/]FastLZ[/url] compression. This option uses less CPU resources compared to .compressZlib, at the expense of using more bandwidth.
        case fastlz = 2 // COMPRESS_FASTLZ
        /// [url=https://www.zlib.net/]Zlib[/url] compression. This option uses less bandwidth compared to .compressFastlz, at the expense of using more CPU resources.
        case zlib = 3 // COMPRESS_ZLIB
        /// [url=https://facebook.github.io/zstd/]Zstandard[/url] compression. Note that this algorithm is not very efficient on packets smaller than 4 KB. Therefore, it's recommended to use other compression algorithms in most cases.
        case zstd = 4 // COMPRESS_ZSTD
    }
    
    public enum EventType: Int64 {
        /// An error occurred during ``service(timeout:)``. You will likely need to ``destroy()`` the host and recreate it.
        case error = -1 // EVENT_ERROR
        /// No event occurred within the specified time limit.
        case none = 0 // EVENT_NONE
        /// A connection request initiated by enet_host_connect has completed. The array will contain the peer which successfully connected.
        case connect = 1 // EVENT_CONNECT
        /// A peer has disconnected. This event is generated on a successful completion of a disconnect initiated by ``ENetPacketPeer/peerDisconnect(data:)``, if a peer has timed out, or if a connection request initialized by ``connectToHost(address:port:channels:data:)`` has timed out. The array will contain the peer which disconnected. The data field contains user supplied data describing the disconnection, or 0, if none is available.
        case disconnect = 2 // EVENT_DISCONNECT
        /// A packet has been received from a peer. The array will contain the peer which sent the packet and the channel number upon which the packet was received. The received packet will be queued to the associated ``ENetPacketPeer``.
        case receive = 3 // EVENT_RECEIVE
    }
    
    public enum HostStatistic: Int64 {
        /// Total data sent.
        case sentData = 0 // HOST_TOTAL_SENT_DATA
        /// Total UDP packets sent.
        case sentPackets = 1 // HOST_TOTAL_SENT_PACKETS
        /// Total data received.
        case receivedData = 2 // HOST_TOTAL_RECEIVED_DATA
        /// Total UDP packets received.
        case receivedPackets = 3 // HOST_TOTAL_RECEIVED_PACKETS
    }
    
    /* Methods */
    fileprivate static var method_create_host_bound: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_host_bound")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1515002313)!
            }
            
        }
        
    }()
    
    /// Create an ENetHost like ``createHost(maxPeers:maxChannels:inBandwidth:outBandwidth:)`` which is also bound to the given `bindAddress` and `bindPort`.
    public final func createHostBound (bindAddress: String, bindPort: Int32, maxPeers: Int32 = 32, maxChannels: Int32 = 0, inBandwidth: Int32 = 0, outBandwidth: Int32 = 0)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_bind_address = GString (bindAddress)
        var copy_bind_port: Int = Int (bindPort)
        var copy_max_peers: Int = Int (maxPeers)
        var copy_max_channels: Int = Int (maxChannels)
        var copy_in_bandwidth: Int = Int (inBandwidth)
        var copy_out_bandwidth: Int = Int (outBandwidth)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_create_host_bound, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_bind_address.content, &copy_bind_port, &copy_max_peers, &copy_max_channels, &copy_in_bandwidth, &copy_out_bandwidth)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_bind_address = GString (bindAddress)
        var copy_bind_port: Int = Int (bindPort)
        var copy_max_peers: Int = Int (maxPeers)
        var copy_max_channels: Int = Int (maxChannels)
        var copy_in_bandwidth: Int = Int (inBandwidth)
        var copy_out_bandwidth: Int = Int (outBandwidth)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_bind_address.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_bind_port) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_max_peers) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_max_channels) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_in_bandwidth) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &copy_out_bandwidth) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (ENetConnection.method_create_host_bound, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                                return GodotError (rawValue: _result)!
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_create_host: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_host")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 117198950)!
            }
            
        }
        
    }()
    
    /// Create an ENetHost that will allow up to `maxPeers` connected peers, each allocating up to `maxChannels` channels, optionally limiting bandwidth to `inBandwidth` and `outBandwidth`.
    public final func createHost (maxPeers: Int32 = 32, maxChannels: Int32 = 0, inBandwidth: Int32 = 0, outBandwidth: Int32 = 0)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_max_peers: Int = Int (maxPeers)
        var copy_max_channels: Int = Int (maxChannels)
        var copy_in_bandwidth: Int = Int (inBandwidth)
        var copy_out_bandwidth: Int = Int (outBandwidth)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_create_host, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_max_peers, &copy_max_channels, &copy_in_bandwidth, &copy_out_bandwidth)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_max_peers: Int = Int (maxPeers)
        var copy_max_channels: Int = Int (maxChannels)
        var copy_in_bandwidth: Int = Int (inBandwidth)
        var copy_out_bandwidth: Int = Int (outBandwidth)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_max_peers) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_max_channels) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_in_bandwidth) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_out_bandwidth) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (ENetConnection.method_create_host, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return GodotError (rawValue: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_destroy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("destroy")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Destroys the host and all resources associated with it.
    public final func destroy () {
        gi.object_method_bind_ptrcall (ENetConnection.method_destroy, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_connect_to_host: GDExtensionMethodBindPtr = {
        let methodName = StringName ("connect_to_host")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2171300490)!
            }
            
        }
        
    }()
    
    /// Initiates a connection to a foreign `address` using the specified `port` and allocating the requested `channels`. Optional `data` can be passed during connection in the form of a 32 bit integer.
    /// 
    /// > Note: You must call either ``createHost(maxPeers:maxChannels:inBandwidth:outBandwidth:)`` or ``createHostBound(bindAddress:bindPort:maxPeers:maxChannels:inBandwidth:outBandwidth:)`` before calling this method.
    /// 
    public final func connectToHost (address: String, port: Int32, channels: Int32 = 0, data: Int32 = 0)-> ENetPacketPeer? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        let gstr_address = GString (address)
        var copy_port: Int = Int (port)
        var copy_channels: Int = Int (channels)
        var copy_data: Int = Int (data)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_connect_to_host, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_address.content, &copy_port, &copy_channels, &copy_data)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_address = GString (address)
        var copy_port: Int = Int (port)
        var copy_channels: Int = Int (channels)
        var copy_data: Int = Int (data)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_address.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_port) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_channels) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_data) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (ENetConnection.method_connect_to_host, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_service: GDExtensionMethodBindPtr = {
        let methodName = StringName ("service")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2402345344)!
            }
            
        }
        
    }()
    
    /// Waits for events on the host specified and shuttles packets between the host and its peers. The returned ``GArray`` will have 4 elements. An ``ENetConnection/EventType``, the ``ENetPacketPeer`` which generated the event, the event associated data (if any), the event associated channel (if any). If the generated event is .eventReceive, the received packet will be queued to the associated ``ENetPacketPeer``.
    /// 
    /// Call this function regularly to handle connections, disconnections, and to receive new packets.
    /// 
    public final func service (timeout: Int32 = 0)-> GArray {
        let _result: GArray = GArray ()
        #if false
        
        var copy_timeout: Int = Int (timeout)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_service, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_timeout)
        return _result
        #else
        
        var copy_timeout: Int = Int (timeout)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_timeout) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ENetConnection.method_service, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_flush: GDExtensionMethodBindPtr = {
        let methodName = StringName ("flush")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Sends any queued packets on the host specified to its designated peers.
    public final func flush () {
        gi.object_method_bind_ptrcall (ENetConnection.method_flush, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_bandwidth_limit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("bandwidth_limit")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2302169788)!
            }
            
        }
        
    }()
    
    /// Adjusts the bandwidth limits of a host.
    public final func bandwidthLimit (inBandwidth: Int32 = 0, outBandwidth: Int32 = 0) {
        #if false
        
        var copy_in_bandwidth: Int = Int (inBandwidth)
        var copy_out_bandwidth: Int = Int (outBandwidth)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_bandwidth_limit, UnsafeMutableRawPointer (mutating: handle), nil, &copy_in_bandwidth, &copy_out_bandwidth)
        
        #else
        
        var copy_in_bandwidth: Int = Int (inBandwidth)
        var copy_out_bandwidth: Int = Int (outBandwidth)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_in_bandwidth) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_out_bandwidth) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (ENetConnection.method_bandwidth_limit, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_channel_limit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("channel_limit")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Limits the maximum allowed channels of future incoming connections.
    public final func channelLimit (_ limit: Int32) {
        #if false
        
        var copy_limit: Int = Int (limit)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_channel_limit, UnsafeMutableRawPointer (mutating: handle), nil, &copy_limit)
        
        #else
        
        var copy_limit: Int = Int (limit)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_limit) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ENetConnection.method_channel_limit, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_broadcast: GDExtensionMethodBindPtr = {
        let methodName = StringName ("broadcast")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2772371345)!
            }
            
        }
        
    }()
    
    /// Queues a `packet` to be sent to all peers associated with the host over the specified `channel`. See ``ENetPacketPeer`` `FLAG_*` constants for available packet flags.
    public final func broadcast (channel: Int32, packet: PackedByteArray, flags: Int32) {
        #if false
        
        var copy_channel: Int = Int (channel)
        var copy_flags: Int = Int (flags)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_broadcast, UnsafeMutableRawPointer (mutating: handle), nil, &copy_channel, &packet.content, &copy_flags)
        
        #else
        
        var copy_channel: Int = Int (channel)
        var copy_flags: Int = Int (flags)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_channel) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &packet.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_flags) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (ENetConnection.method_broadcast, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_compress: GDExtensionMethodBindPtr = {
        let methodName = StringName ("compress")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2660215187)!
            }
            
        }
        
    }()
    
    /// Sets the compression method used for network packets. These have different tradeoffs of compression speed versus bandwidth, you may need to test which one works best for your use case if you use compression at all.
    /// 
    /// > Note: Most games' network design involve sending many small packets frequently (smaller than 4 KB each). If in doubt, it is recommended to keep the default compression algorithm as it works best on these small packets.
    /// 
    /// > Note: The compression mode must be set to the same value on both the server and all its clients. Clients will fail to connect if the compression mode set on the client differs from the one set on the server.
    /// 
    public final func compress (mode: ENetConnection.CompressionMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_compress, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ENetConnection.method_compress, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_dtls_server_setup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("dtls_server_setup")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1262296096)!
            }
            
        }
        
    }()
    
    /// Configure this ENetHost to use the custom Godot extension allowing DTLS encryption for ENet servers. Call this right after ``createHostBound(bindAddress:bindPort:maxPeers:maxChannels:inBandwidth:outBandwidth:)`` to have ENet expect peers to connect using DTLS. See ``TLSOptions/server(key:certificate:)``.
    public final func dtlsServerSetup (serverOptions: TLSOptions?)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_server_options_handle = serverOptions?.handle
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_dtls_server_setup, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_server_options_handle)
        return GodotError (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: serverOptions?.handle) { p0 in
        _args.append (serverOptions == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (ENetConnection.method_dtls_server_setup, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return GodotError (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_dtls_client_setup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("dtls_client_setup")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1966198364)!
            }
            
        }
        
    }()
    
    /// Configure this ENetHost to use the custom Godot extension allowing DTLS encryption for ENet clients. Call this before ``connectToHost(address:port:channels:data:)`` to have ENet connect using DTLS validating the server certificate against `hostname`. You can pass the optional `clientOptions` parameter to customize the trusted certification authorities, or disable the common name verification. See ``TLSOptions/client(trustedChain:commonNameOverride:)`` and ``TLSOptions/clientUnsafe(trustedChain:)``.
    public final func dtlsClientSetup (hostname: String, clientOptions: TLSOptions? = nil)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_hostname = GString (hostname)
        var copy_client_options_handle = clientOptions?.handle
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_dtls_client_setup, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_hostname.content, &copy_client_options_handle)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_hostname = GString (hostname)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_hostname.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: clientOptions?.handle) { p1 in
            _args.append (clientOptions == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (ENetConnection.method_dtls_client_setup, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_refuse_new_connections: GDExtensionMethodBindPtr = {
        let methodName = StringName ("refuse_new_connections")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Configures the DTLS server to automatically drop new connections.
    /// 
    /// > Note: This method is only relevant after calling ``dtlsServerSetup(serverOptions:)``.
    /// 
    public final func refuseNewConnections (refuse: Bool) {
        #if false
        
        var copy_refuse = refuse
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_refuse_new_connections, UnsafeMutableRawPointer (mutating: handle), nil, &copy_refuse)
        
        #else
        
        var copy_refuse = refuse
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_refuse) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ENetConnection.method_refuse_new_connections, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_pop_statistic: GDExtensionMethodBindPtr = {
        let methodName = StringName ("pop_statistic")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2166904170)!
            }
            
        }
        
    }()
    
    /// Returns and resets host statistics. See ``ENetConnection/HostStatistic`` for more info.
    public final func popStatistic (_ statistic: ENetConnection.HostStatistic)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_statistic = Int64 (statistic.rawValue)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_pop_statistic, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_statistic)
        return _result
        #else
        
        var copy_statistic = Int64 (statistic.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_statistic) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ENetConnection.method_pop_statistic, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_max_channels: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_max_channels")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the maximum number of channels allowed for connected peers.
    public final func getMaxChannels ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (ENetConnection.method_get_max_channels, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_local_port: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_local_port")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the local port to which this peer is bound.
    public final func getLocalPort ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (ENetConnection.method_get_local_port, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_peers: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_peers")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2915620761)!
            }
            
        }
        
    }()
    
    /// Returns the list of peers associated with this host.
    /// 
    /// > Note: This list might include some peers that are not fully connected or are still being disconnected.
    /// 
    public final func getPeers ()-> ObjectCollection<ENetPacketPeer> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (ENetConnection.method_get_peers, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return ObjectCollection<ENetPacketPeer>(content: _result)
    }
    
    fileprivate static var method_socket_send: GDExtensionMethodBindPtr = {
        let methodName = StringName ("socket_send")
        return withUnsafePointer (to: &ENetConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1100646812)!
            }
            
        }
        
    }()
    
    /// Sends a `packet` toward a destination from the address and port currently bound by this ENetConnection instance. 
    /// 
    /// This is useful as it serves to establish entries in NAT routing tables on all devices between this bound instance and the public facing internet, allowing a prospective client's connection packets to be routed backward through the NAT device(s) between the public internet and this host.
    /// 
    /// This requires forward knowledge of a prospective client's address and communication port as seen by the public internet - after any NAT devices have handled their connection request. This information can be obtained by a [url=https://en.wikipedia.org/wiki/STUN]STUN[/url] service, and must be handed off to your host by an entity that is not the prospective client. This will never work for a client behind a Symmetric NAT due to the nature of the Symmetric NAT routing algorithm, as their IP and Port cannot be known beforehand.
    /// 
    public final func socketSend (destinationAddress: String, destinationPort: Int32, packet: PackedByteArray) {
        #if false
        
        let gstr_destination_address = GString (destinationAddress)
        var copy_destination_port: Int = Int (destinationPort)
        
        gi.object_method_bind_ptrcall_v (ENetConnection.method_socket_send, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_destination_address.content, &copy_destination_port, &packet.content)
        
        #else
        
        let gstr_destination_address = GString (destinationAddress)
        var copy_destination_port: Int = Int (destinationPort)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_destination_address.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_destination_port) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &packet.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (ENetConnection.method_socket_send, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
}

