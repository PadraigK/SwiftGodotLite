// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A multiline text editor designed for editing code.
/// 
/// CodeEdit is a specialized ``TextEdit`` designed for editing plain text code files. It has many features commonly found in code editors such as line numbers, line folding, code completion, indent management, and string/comment management.
/// 
/// > Note: Regardless of locale, ``CodeEdit`` will by default always use left-to-right text direction to correctly display source code.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``breakpointToggled``
/// - ``codeCompletionRequested``
/// - ``symbolLookup``
/// - ``symbolValidate``
open class CodeEdit: TextEdit {
    override open class var godotClassName: StringName { "CodeEdit" }
    public enum CodeCompletionKind: Int64 {
        /// Marks the option as a class.
        case `class` = 0 // KIND_CLASS
        /// Marks the option as a function.
        case function = 1 // KIND_FUNCTION
        /// Marks the option as a Godot signal.
        case signal = 2 // KIND_SIGNAL
        /// Marks the option as a variable.
        case variable = 3 // KIND_VARIABLE
        /// Marks the option as a member.
        case member = 4 // KIND_MEMBER
        /// Marks the option as an enum entry.
        case `enum` = 5 // KIND_ENUM
        /// Marks the option as a constant.
        case constant = 6 // KIND_CONSTANT
        /// Marks the option as a Godot node path.
        case nodePath = 7 // KIND_NODE_PATH
        /// Marks the option as a file path.
        case filePath = 8 // KIND_FILE_PATH
        /// Marks the option as unclassified or plain text.
        case plainText = 9 // KIND_PLAIN_TEXT
    }
    
    public enum CodeCompletionLocation: Int64 {
        /// The option is local to the location of the code completion query - e.g. a local variable. Subsequent value of location represent options from the outer class, the exact value represent how far they are (in terms of inner classes).
        case local = 0 // LOCATION_LOCAL
        /// The option is from the containing class or a parent class, relative to the location of the code completion query. Perform a bitwise OR with the class depth (e.g. 0 for the local class, 1 for the parent, 2 for the grandparent, etc) to store the depth of an option in the class or a parent class.
        case parentMask = 256 // LOCATION_PARENT_MASK
        /// The option is from user code which is not local and not in a derived class (e.g. Autoload Singletons).
        case otherUserCode = 512 // LOCATION_OTHER_USER_CODE
        /// The option is from other engine code, not covered by the other enum constants - e.g. built-in classes.
        case other = 1024 // LOCATION_OTHER
    }
    
    
    /* Properties */
    
    /// Set when a validated word from [signal symbol_validate] is clicked, the [signal symbol_lookup] should be emitted.
    final public var symbolLookupOnClick: Bool {
        get {
            return is_symbol_lookup_on_click_enabled ()
        }
        
        set {
            set_symbol_lookup_on_click_enabled (newValue)
        }
        
    }
    
    /// Sets whether line folding is allowed.
    final public var lineFolding: Bool {
        get {
            return is_line_folding_enabled ()
        }
        
        set {
            set_line_folding_enabled (newValue)
        }
        
    }
    
    /// Draws vertical lines at the provided columns. The first entry is considered a main hard guideline and is draw more prominently.
    final public var lineLengthGuidelines: VariantCollection<Int64> {
        get {
            return get_line_length_guidelines ()
        }
        
        set {
            set_line_length_guidelines (newValue)
        }
        
    }
    
    /// Sets if breakpoints should be drawn in the gutter. This gutter is shared with bookmarks and executing lines.
    final public var guttersDrawBreakpointsGutter: Bool {
        get {
            return is_drawing_breakpoints_gutter ()
        }
        
        set {
            set_draw_breakpoints_gutter (newValue)
        }
        
    }
    
    /// Sets if bookmarked should be drawn in the gutter. This gutter is shared with breakpoints and executing lines.
    final public var guttersDrawBookmarks: Bool {
        get {
            return is_drawing_bookmarks_gutter ()
        }
        
        set {
            set_draw_bookmarks_gutter (newValue)
        }
        
    }
    
    /// Sets if executing lines should be marked in the gutter. This gutter is shared with breakpoints and bookmarks lines.
    final public var guttersDrawExecutingLines: Bool {
        get {
            return is_drawing_executing_lines_gutter ()
        }
        
        set {
            set_draw_executing_lines_gutter (newValue)
        }
        
    }
    
    /// Sets if line numbers should be drawn in the gutter.
    final public var guttersDrawLineNumbers: Bool {
        get {
            return is_draw_line_numbers_enabled ()
        }
        
        set {
            set_draw_line_numbers (newValue)
        }
        
    }
    
    /// Sets if line numbers drawn in the gutter are zero padded.
    final public var guttersZeroPadLineNumbers: Bool {
        get {
            return is_line_numbers_zero_padded ()
        }
        
        set {
            set_line_numbers_zero_padded (newValue)
        }
        
    }
    
    /// Sets if foldable lines icons should be drawn in the gutter.
    final public var guttersDrawFoldGutter: Bool {
        get {
            return is_drawing_fold_gutter ()
        }
        
        set {
            set_draw_fold_gutter (newValue)
        }
        
    }
    
    /// Sets the string delimiters. All existing string delimiters will be removed.
    final public var delimiterStrings: VariantCollection<String> {
        get {
            return get_string_delimiters ()
        }
        
        set {
            set_string_delimiters (newValue)
        }
        
    }
    
    /// Sets the comment delimiters. All existing comment delimiters will be removed.
    final public var delimiterComments: VariantCollection<String> {
        get {
            return get_comment_delimiters ()
        }
        
        set {
            set_comment_delimiters (newValue)
        }
        
    }
    
    /// Sets whether code completion is allowed.
    final public var codeCompletionEnabled: Bool {
        get {
            return is_code_completion_enabled ()
        }
        
        set {
            set_code_completion_enabled (newValue)
        }
        
    }
    
    /// Sets prefixes that will trigger code completion.
    final public var codeCompletionPrefixes: VariantCollection<String> {
        get {
            return get_code_completion_prefixes ()
        }
        
        set {
            set_code_completion_prefixes (newValue)
        }
        
    }
    
    /// Size of the tabulation indent (one [kbd]Tab[/kbd] press) in characters. If ``indentUseSpaces`` is enabled the number of spaces to use.
    final public var indentSize: Int32 {
        get {
            return get_indent_size ()
        }
        
        set {
            set_indent_size (newValue)
        }
        
    }
    
    /// Use spaces instead of tabs for indentation.
    final public var indentUseSpaces: Bool {
        get {
            return is_indent_using_spaces ()
        }
        
        set {
            set_indent_using_spaces (newValue)
        }
        
    }
    
    /// Sets whether automatic indent are enabled, this will add an extra indent if a prefix or brace is found.
    final public var indentAutomatic: Bool {
        get {
            return is_auto_indent_enabled ()
        }
        
        set {
            set_auto_indent_enabled (newValue)
        }
        
    }
    
    /// Prefixes to trigger an automatic indent.
    final public var indentAutomaticPrefixes: VariantCollection<String> {
        get {
            return get_auto_indent_prefixes ()
        }
        
        set {
            set_auto_indent_prefixes (newValue)
        }
        
    }
    
    /// Sets whether brace pairs should be autocompleted.
    final public var autoBraceCompletionEnabled: Bool {
        get {
            return is_auto_brace_completion_enabled ()
        }
        
        set {
            set_auto_brace_completion_enabled (newValue)
        }
        
    }
    
    /// Highlight mismatching brace pairs.
    final public var autoBraceCompletionHighlightMatching: Bool {
        get {
            return is_highlight_matching_braces_enabled ()
        }
        
        set {
            set_highlight_matching_braces_enabled (newValue)
        }
        
    }
    
    /// Sets the brace pairs to be autocompleted.
    final public var autoBraceCompletionPairs: GDictionary {
        get {
            return get_auto_brace_completion_pairs ()
        }
        
        set {
            set_auto_brace_completion_pairs (newValue)
        }
        
    }
    
    /* Methods */
    /// Override this method to define how the selected entry should be inserted. If `replace` is true, any existing text should be replaced.
    @_documentation(visibility: public)
    open func _confirmCodeCompletion (replace: Bool) {
    }
    
    /// Override this method to define what happens when the user requests code completion. If `force` is true, any checks should be bypassed.
    @_documentation(visibility: public)
    open func _requestCodeCompletion (force: Bool) {
    }
    
    /// Override this method to define what items in `candidates` should be displayed.
    /// 
    /// Both `candidates` and the return is a ``GArray`` of ``GDictionary``, see ``getCodeCompletionOption(index:)`` for ``GDictionary`` content.
    /// 
    @_documentation(visibility: public)
    open func _filterCodeCompletionCandidates (_ candidates: VariantCollection<GDictionary>)-> VariantCollection<GDictionary> {
        return VariantCollection<GDictionary>()
    }
    
    fileprivate static var method_set_indent_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_indent_size")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_indent_size (_ size: Int32) {
        #if false
        
        var copy_size: Int = Int (size)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_indent_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_size)
        
        #else
        
        var copy_size: Int = Int (size)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_indent_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_indent_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_indent_size")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_indent_size ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_indent_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_indent_using_spaces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_indent_using_spaces")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_indent_using_spaces (_ useSpaces: Bool) {
        #if false
        
        var copy_use_spaces = useSpaces
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_indent_using_spaces, UnsafeMutableRawPointer (mutating: handle), nil, &copy_use_spaces)
        
        #else
        
        var copy_use_spaces = useSpaces
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_use_spaces) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_indent_using_spaces, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_indent_using_spaces: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_indent_using_spaces")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_indent_using_spaces ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_indent_using_spaces, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_indent_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_auto_indent_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_indent_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_auto_indent_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_auto_indent_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_auto_indent_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_auto_indent_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_indent_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_auto_indent_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_auto_indent_prefixes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_auto_indent_prefixes")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_indent_prefixes (_ prefixes: VariantCollection<String>) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_auto_indent_prefixes, UnsafeMutableRawPointer (mutating: handle), nil, &prefixes.array.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &prefixes.array.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_auto_indent_prefixes, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_auto_indent_prefixes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_auto_indent_prefixes")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_auto_indent_prefixes ()-> VariantCollection<String> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_auto_indent_prefixes, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<String>(content: _result)
    }
    
    fileprivate static var method_do_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("do_indent")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Perform an indent as if the user activated the "ui_text_indent" action.
    public final func doIndent () {
        gi.object_method_bind_ptrcall (CodeEdit.method_do_indent, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_indent_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("indent_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Indents selected lines, or in the case of no selection the caret line by one.
    public final func indentLines () {
        gi.object_method_bind_ptrcall (CodeEdit.method_indent_lines, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_unindent_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("unindent_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Unindents selected lines, or in the case of no selection the caret line by one. Same as performing "ui_text_unindent" action.
    public final func unindentLines () {
        gi.object_method_bind_ptrcall (CodeEdit.method_unindent_lines, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_convert_indent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("convert_indent")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 423910286)!
            }
            
        }
        
    }()
    
    /// Converts the indents of lines between `fromLine` and `toLine` to tabs or spaces as set by ``indentUseSpaces``.
    /// 
    /// Values of `-1` convert the entire text.
    /// 
    public final func convertIndent (fromLine: Int32 = -1, toLine: Int32 = -1) {
        #if false
        
        var copy_from_line: Int = Int (fromLine)
        var copy_to_line: Int = Int (toLine)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_convert_indent, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from_line, &copy_to_line)
        
        #else
        
        var copy_from_line: Int = Int (fromLine)
        var copy_to_line: Int = Int (toLine)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to_line) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_convert_indent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_auto_brace_completion_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_auto_brace_completion_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_brace_completion_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_auto_brace_completion_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_auto_brace_completion_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_auto_brace_completion_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_auto_brace_completion_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_auto_brace_completion_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_auto_brace_completion_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_highlight_matching_braces_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_highlight_matching_braces_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_highlight_matching_braces_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_highlight_matching_braces_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_highlight_matching_braces_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_highlight_matching_braces_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_highlight_matching_braces_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_highlight_matching_braces_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_highlight_matching_braces_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_auto_brace_completion_pair: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_auto_brace_completion_pair")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3186203200)!
            }
            
        }
        
    }()
    
    /// Adds a brace pair.
    /// 
    /// Both the start and end keys must be symbols. Only the start key has to be unique.
    /// 
    public final func addAutoBraceCompletionPair (startKey: String, endKey: String) {
        #if false
        
        let gstr_start_key = GString (startKey)
        let gstr_end_key = GString (endKey)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_add_auto_brace_completion_pair, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_start_key.content, &gstr_end_key.content)
        
        #else
        
        let gstr_start_key = GString (startKey)
        let gstr_end_key = GString (endKey)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_start_key.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_end_key.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_add_auto_brace_completion_pair, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_auto_brace_completion_pairs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_auto_brace_completion_pairs")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155329257)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_auto_brace_completion_pairs (_ pairs: GDictionary) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_auto_brace_completion_pairs, UnsafeMutableRawPointer (mutating: handle), nil, &pairs.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &pairs.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_auto_brace_completion_pairs, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_auto_brace_completion_pairs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_auto_brace_completion_pairs")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3102165223)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_auto_brace_completion_pairs ()-> GDictionary {
        let _result: GDictionary = GDictionary ()
        gi.object_method_bind_ptrcall (CodeEdit.method_get_auto_brace_completion_pairs, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_has_auto_brace_completion_open_key: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_auto_brace_completion_open_key")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if open key `openKey` exists.
    public final func hasAutoBraceCompletionOpenKey (_ openKey: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_open_key = GString (openKey)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_has_auto_brace_completion_open_key, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_open_key.content)
        return _result
        #else
        
        let gstr_open_key = GString (openKey)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_open_key.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_has_auto_brace_completion_open_key, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_has_auto_brace_completion_close_key: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_auto_brace_completion_close_key")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if close key `closeKey` exists.
    public final func hasAutoBraceCompletionCloseKey (_ closeKey: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_close_key = GString (closeKey)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_has_auto_brace_completion_close_key, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_close_key.content)
        return _result
        #else
        
        let gstr_close_key = GString (closeKey)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_close_key.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_has_auto_brace_completion_close_key, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_auto_brace_completion_close_key: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_auto_brace_completion_close_key")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3135753539)!
            }
            
        }
        
    }()
    
    /// Gets the matching auto brace close key for `openKey`.
    public final func getAutoBraceCompletionCloseKey (openKey: String)-> String {
        let _result = GString ()
        #if false
        
        let gstr_open_key = GString (openKey)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_get_auto_brace_completion_close_key, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_open_key.content)
        return _result.description
        #else
        
        let gstr_open_key = GString (openKey)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_open_key.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_get_auto_brace_completion_close_key, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_set_draw_breakpoints_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_breakpoints_gutter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_breakpoints_gutter (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_draw_breakpoints_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_draw_breakpoints_gutter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drawing_breakpoints_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drawing_breakpoints_gutter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_breakpoints_gutter ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_drawing_breakpoints_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_bookmarks_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_bookmarks_gutter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_bookmarks_gutter (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_draw_bookmarks_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_draw_bookmarks_gutter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drawing_bookmarks_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drawing_bookmarks_gutter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_bookmarks_gutter ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_drawing_bookmarks_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_executing_lines_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_executing_lines_gutter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_executing_lines_gutter (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_draw_executing_lines_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_draw_executing_lines_gutter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drawing_executing_lines_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drawing_executing_lines_gutter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_executing_lines_gutter ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_drawing_executing_lines_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_line_as_breakpoint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_as_breakpoint")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the line as breakpointed.
    public final func setLineAsBreakpoint (line: Int32, breakpointed: Bool) {
        #if false
        
        var copy_line: Int = Int (line)
        var copy_breakpointed = breakpointed
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_line_as_breakpoint, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_breakpointed)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_breakpointed = breakpointed
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_breakpointed) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_set_line_as_breakpoint, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_breakpointed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_breakpointed")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is breakpointed or not.
    public final func isLineBreakpointed (line: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_is_line_breakpointed, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_is_line_breakpointed, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_clear_breakpointed_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_breakpointed_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all breakpointed lines.
    public final func clearBreakpointedLines () {
        gi.object_method_bind_ptrcall (CodeEdit.method_clear_breakpointed_lines, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_breakpointed_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_breakpointed_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Gets all breakpointed lines.
    public final func getBreakpointedLines ()-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall (CodeEdit.method_get_breakpointed_lines, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_line_as_bookmarked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_as_bookmarked")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the line as bookmarked.
    public final func setLineAsBookmarked (line: Int32, bookmarked: Bool) {
        #if false
        
        var copy_line: Int = Int (line)
        var copy_bookmarked = bookmarked
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_line_as_bookmarked, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_bookmarked)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_bookmarked = bookmarked
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_bookmarked) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_set_line_as_bookmarked, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_bookmarked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_bookmarked")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is bookmarked or not.
    public final func isLineBookmarked (line: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_is_line_bookmarked, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_is_line_bookmarked, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_clear_bookmarked_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_bookmarked_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all bookmarked lines.
    public final func clearBookmarkedLines () {
        gi.object_method_bind_ptrcall (CodeEdit.method_clear_bookmarked_lines, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_bookmarked_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_bookmarked_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Gets all bookmarked lines.
    public final func getBookmarkedLines ()-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall (CodeEdit.method_get_bookmarked_lines, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_line_as_executing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_as_executing")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets the line as executing.
    public final func setLineAsExecuting (line: Int32, executing: Bool) {
        #if false
        
        var copy_line: Int = Int (line)
        var copy_executing = executing
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_line_as_executing, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line, &copy_executing)
        
        #else
        
        var copy_line: Int = Int (line)
        var copy_executing = executing
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_executing) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_set_line_as_executing, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_executing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_executing")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is marked as executing or not.
    public final func isLineExecuting (line: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_is_line_executing, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_is_line_executing, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_clear_executing_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_executing_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all executed lines.
    public final func clearExecutingLines () {
        gi.object_method_bind_ptrcall (CodeEdit.method_clear_executing_lines, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_executing_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_executing_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Gets all executing lines.
    public final func getExecutingLines ()-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall (CodeEdit.method_get_executing_lines, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_draw_line_numbers: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_line_numbers")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_line_numbers (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_draw_line_numbers, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_draw_line_numbers, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_draw_line_numbers_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_draw_line_numbers_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_draw_line_numbers_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_draw_line_numbers_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_line_numbers_zero_padded: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_numbers_zero_padded")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_line_numbers_zero_padded (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_line_numbers_zero_padded, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_line_numbers_zero_padded, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_numbers_zero_padded: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_numbers_zero_padded")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_line_numbers_zero_padded ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_line_numbers_zero_padded, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_fold_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_fold_gutter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_fold_gutter (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_draw_fold_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_draw_fold_gutter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_drawing_fold_gutter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_drawing_fold_gutter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_drawing_fold_gutter ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_drawing_fold_gutter, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_line_folding_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_folding_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_line_folding_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_line_folding_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_line_folding_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_folding_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_folding_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_line_folding_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_line_folding_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_can_fold_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("can_fold_line")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns if the given line is foldable, that is, it has indented lines right below it or a comment / string block.
    public final func canFoldLine (_ line: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_can_fold_line, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_can_fold_line, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_fold_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("fold_line")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Folds the given line, if possible (see ``canFoldLine(_:)``).
    public final func foldLine (_ line: Int32) {
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_fold_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line)
        
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_fold_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_unfold_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("unfold_line")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Unfolds all lines that were previously folded.
    public final func unfoldLine (_ line: Int32) {
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_unfold_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line)
        
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_unfold_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_fold_all_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("fold_all_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Folds all lines that are possible to be folded (see ``canFoldLine(_:)``).
    public final func foldAllLines () {
        gi.object_method_bind_ptrcall (CodeEdit.method_fold_all_lines, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_unfold_all_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("unfold_all_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Unfolds all lines, folded or not.
    public final func unfoldAllLines () {
        gi.object_method_bind_ptrcall (CodeEdit.method_unfold_all_lines, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_toggle_foldable_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("toggle_foldable_line")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Toggle the folding of the code block at the given line.
    public final func toggleFoldableLine (_ line: Int32) {
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_toggle_foldable_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_line)
        
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_toggle_foldable_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_folded: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_folded")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is folded or not.
    public final func isLineFolded (line: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_is_line_folded, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_is_line_folded, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_folded_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_folded_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns all lines that are current folded.
    public final func getFoldedLines ()-> VariantCollection<Int64> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_folded_lines, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<Int64>(content: _result)
    }
    
    fileprivate static var method_create_code_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_code_region")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Creates a new code region with the selection. At least one single line comment delimiter have to be defined (see ``addCommentDelimiter(startKey:endKey:lineOnly:)``).
    /// 
    /// A code region is a part of code that is highlighted when folded and can help organize your script.
    /// 
    /// Code region start and end tags can be customized (see ``setCodeRegionTags(start:end:)``).
    /// 
    /// Code regions are delimited using start and end tags (respectively `region` and `endregion` by default) preceded by one line comment delimiter. (eg. `#region` and `#endregion`)
    /// 
    public final func createCodeRegion () {
        gi.object_method_bind_ptrcall (CodeEdit.method_create_code_region, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_code_region_start_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_code_region_start_tag")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the code region start tag (without comment delimiter).
    public final func getCodeRegionStartTag ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (CodeEdit.method_get_code_region_start_tag, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_code_region_end_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_code_region_end_tag")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the code region end tag (without comment delimiter).
    public final func getCodeRegionEndTag ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (CodeEdit.method_get_code_region_end_tag, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_code_region_tags: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_code_region_tags")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 708800718)!
            }
            
        }
        
    }()
    
    /// Sets the code region start and end tags (without comment delimiter).
    public final func setCodeRegionTags (start: String = "region", end: String = "endregion") {
        #if false
        
        let gstr_start = GString (start)
        let gstr_end = GString (end)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_code_region_tags, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_start.content, &gstr_end.content)
        
        #else
        
        let gstr_start = GString (start)
        let gstr_end = GString (end)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_start.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_end.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_set_code_region_tags, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_code_region_start: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_code_region_start")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is a code region start.
    public final func isLineCodeRegionStart (line: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_is_line_code_region_start, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_is_line_code_region_start, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_line_code_region_end: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_line_code_region_end")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns whether the line at the specified index is a code region end.
    public final func isLineCodeRegionEnd (line: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_line: Int = Int (line)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_is_line_code_region_end, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_is_line_code_region_end, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_add_string_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_string_delimiter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3146098955)!
            }
            
        }
        
    }()
    
    /// Adds a string delimiter.
    /// 
    /// Both the start and end keys must be symbols. Only the start key has to be unique.
    /// 
    /// `lineOnly` denotes if the region should continue until the end of the line or carry over on to the next line. If the end key is blank this is automatically set to `true`.
    /// 
    public final func addStringDelimiter (startKey: String, endKey: String, lineOnly: Bool = false) {
        #if false
        
        let gstr_start_key = GString (startKey)
        let gstr_end_key = GString (endKey)
        var copy_line_only = lineOnly
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_add_string_delimiter, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_start_key.content, &gstr_end_key.content, &copy_line_only)
        
        #else
        
        let gstr_start_key = GString (startKey)
        let gstr_end_key = GString (endKey)
        var copy_line_only = lineOnly
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_start_key.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_end_key.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_line_only) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (CodeEdit.method_add_string_delimiter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_string_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_string_delimiter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Removes the string delimiter with `startKey`.
    public final func removeStringDelimiter (startKey: String) {
        #if false
        
        let gstr_start_key = GString (startKey)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_remove_string_delimiter, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_start_key.content)
        
        #else
        
        let gstr_start_key = GString (startKey)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_start_key.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_remove_string_delimiter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_has_string_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_string_delimiter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if string `startKey` exists.
    public final func hasStringDelimiter (startKey: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_start_key = GString (startKey)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_has_string_delimiter, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_start_key.content)
        return _result
        #else
        
        let gstr_start_key = GString (startKey)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_start_key.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_has_string_delimiter, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_string_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_string_delimiters")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_string_delimiters (_ stringDelimiters: VariantCollection<String>) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_string_delimiters, UnsafeMutableRawPointer (mutating: handle), nil, &stringDelimiters.array.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &stringDelimiters.array.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_string_delimiters, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_clear_string_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_string_delimiters")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all string delimiters.
    public final func clearStringDelimiters () {
        gi.object_method_bind_ptrcall (CodeEdit.method_clear_string_delimiters, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_string_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_string_delimiters")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_string_delimiters ()-> VariantCollection<String> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_string_delimiters, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<String>(content: _result)
    }
    
    fileprivate static var method_is_in_string: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_in_string")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 688195400)!
            }
            
        }
        
    }()
    
    /// Returns the delimiter index if `line` `column` is in a string. If `column` is not provided, will return the delimiter index if the entire `line` is a string. Otherwise `-1`.
    public final func isInString (line: Int32, column: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_is_in_string, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_column)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_is_in_string, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_comment_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_comment_delimiter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3146098955)!
            }
            
        }
        
    }()
    
    /// Adds a comment delimiter.
    /// 
    /// Both the start and end keys must be symbols. Only the start key has to be unique.
    /// 
    /// `lineOnly` denotes if the region should continue until the end of the line or carry over on to the next line. If the end key is blank this is automatically set to `true`.
    /// 
    public final func addCommentDelimiter (startKey: String, endKey: String, lineOnly: Bool = false) {
        #if false
        
        let gstr_start_key = GString (startKey)
        let gstr_end_key = GString (endKey)
        var copy_line_only = lineOnly
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_add_comment_delimiter, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_start_key.content, &gstr_end_key.content, &copy_line_only)
        
        #else
        
        let gstr_start_key = GString (startKey)
        let gstr_end_key = GString (endKey)
        var copy_line_only = lineOnly
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_start_key.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_end_key.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_line_only) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (CodeEdit.method_add_comment_delimiter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remove_comment_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_comment_delimiter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Removes the comment delimiter with `startKey`.
    public final func removeCommentDelimiter (startKey: String) {
        #if false
        
        let gstr_start_key = GString (startKey)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_remove_comment_delimiter, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_start_key.content)
        
        #else
        
        let gstr_start_key = GString (startKey)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_start_key.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_remove_comment_delimiter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_has_comment_delimiter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_comment_delimiter")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if comment `startKey` exists.
    public final func hasCommentDelimiter (startKey: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_start_key = GString (startKey)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_has_comment_delimiter, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_start_key.content)
        return _result
        #else
        
        let gstr_start_key = GString (startKey)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_start_key.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_has_comment_delimiter, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_comment_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_comment_delimiters")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_comment_delimiters (_ commentDelimiters: VariantCollection<String>) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_comment_delimiters, UnsafeMutableRawPointer (mutating: handle), nil, &commentDelimiters.array.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &commentDelimiters.array.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_comment_delimiters, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_clear_comment_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_comment_delimiters")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes all comment delimiters.
    public final func clearCommentDelimiters () {
        gi.object_method_bind_ptrcall (CodeEdit.method_clear_comment_delimiters, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_comment_delimiters: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_comment_delimiters")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_comment_delimiters ()-> VariantCollection<String> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_comment_delimiters, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<String>(content: _result)
    }
    
    fileprivate static var method_is_in_comment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_in_comment")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 688195400)!
            }
            
        }
        
    }()
    
    /// Returns delimiter index if `line` `column` is in a comment. If `column` is not provided, will return delimiter index if the entire `line` is a comment. Otherwise `-1`.
    public final func isInComment (line: Int32, column: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_is_in_comment, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_column)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_is_in_comment, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_delimiter_start_key: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_delimiter_start_key")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Gets the start key for a string or comment region index.
    public final func getDelimiterStartKey (delimiterIndex: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_delimiter_index: Int = Int (delimiterIndex)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_get_delimiter_start_key, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_delimiter_index)
        return _result.description
        #else
        
        var copy_delimiter_index: Int = Int (delimiterIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_delimiter_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_get_delimiter_start_key, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_delimiter_end_key: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_delimiter_end_key")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Gets the end key for a string or comment region index.
    public final func getDelimiterEndKey (delimiterIndex: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_delimiter_index: Int = Int (delimiterIndex)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_get_delimiter_end_key, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_delimiter_index)
        return _result.description
        #else
        
        var copy_delimiter_index: Int = Int (delimiterIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_delimiter_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_get_delimiter_end_key, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_delimiter_start_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_delimiter_start_position")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3016396712)!
            }
            
        }
        
    }()
    
    /// If `line` `column` is in a string or comment, returns the start position of the region. If not or no start could be found, both ``Vector2`` values will be `-1`.
    public final func getDelimiterStartPosition (line: Int32, column: Int32)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_get_delimiter_start_position, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_column)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_get_delimiter_start_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_delimiter_end_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_delimiter_end_position")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3016396712)!
            }
            
        }
        
    }()
    
    /// If `line` `column` is in a string or comment, returns the end position of the region. If not or no end could be found, both ``Vector2`` values will be `-1`.
    public final func getDelimiterEndPosition (line: Int32, column: Int32)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_get_delimiter_end_position, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_line, &copy_column)
        return _result
        #else
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_get_delimiter_end_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_code_hint: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_code_hint")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Sets the code hint text. Pass an empty string to clear.
    public final func setCodeHint (_ codeHint: String) {
        #if false
        
        let gstr_code_hint = GString (codeHint)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_code_hint, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_code_hint.content)
        
        #else
        
        let gstr_code_hint = GString (codeHint)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_code_hint.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_code_hint, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_code_hint_draw_below: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_code_hint_draw_below")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets if the code hint should draw below the text.
    public final func setCodeHintDrawBelow (_ drawBelow: Bool) {
        #if false
        
        var copy_draw_below = drawBelow
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_code_hint_draw_below, UnsafeMutableRawPointer (mutating: handle), nil, &copy_draw_below)
        
        #else
        
        var copy_draw_below = drawBelow
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_draw_below) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_code_hint_draw_below, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_text_for_code_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text_for_code_completion")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the full text with char `0xFFFF` at the caret location.
    public final func getTextForCodeCompletion ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (CodeEdit.method_get_text_for_code_completion, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_request_code_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName ("request_code_completion")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 107499316)!
            }
            
        }
        
    }()
    
    /// Emits [signal code_completion_requested], if `force` is true will bypass all checks. Otherwise will check that the caret is in a word or in front of a prefix. Will ignore the request if all current options are of type file path, node path or signal.
    public final func requestCodeCompletion (force: Bool = false) {
        #if false
        
        var copy_force = force
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_request_code_completion, UnsafeMutableRawPointer (mutating: handle), nil, &copy_force)
        
        #else
        
        var copy_force = force
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_force) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_request_code_completion, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_code_completion_option: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_code_completion_option")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 947964390)!
            }
            
        }
        
    }()
    
    /// Submits an item to the queue of potential candidates for the autocomplete menu. Call ``updateCodeCompletionOptions(force:)`` to update the list.
    /// 
    /// `location` indicates location of the option relative to the location of the code completion query. See ``CodeEdit.CodeCompletionLocation`` for how to set this value.
    /// 
    /// > Note: This list will replace all current candidates.
    /// 
    public final func addCodeCompletionOption (type: CodeEdit.CodeCompletionKind, displayText: String, insertText: String, textColor: Color = Color (r: 1, g: 1, b: 1, a: 1), icon: Resource? = nil, value: Variant, location: Int32 = 1024) {
        #if false
        
        var copy_type = Int64 (type.rawValue)
        let gstr_display_text = GString (displayText)
        let gstr_insert_text = GString (insertText)
        var copy_text_color = textColor
        var copy_location: Int = Int (location)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_add_code_completion_option, UnsafeMutableRawPointer (mutating: handle), nil, &copy_type, &gstr_display_text.content, &gstr_insert_text.content, &copy_text_color, &copy_icon_handle, &value.content, &copy_location)
        
        #else
        
        var copy_type = Int64 (type.rawValue)
        let gstr_display_text = GString (displayText)
        let gstr_insert_text = GString (insertText)
        var copy_text_color = textColor
        var copy_location: Int = Int (location)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_display_text.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_insert_text.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_text_color) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: icon?.handle) { p4 in
                        _args.append (icon == nil ? nil : p4)
                            withUnsafePointer (to: &value.content) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_location) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (CodeEdit.method_add_code_completion_option, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_update_code_completion_options: GDExtensionMethodBindPtr = {
        let methodName = StringName ("update_code_completion_options")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Submits all completion options added with ``addCodeCompletionOption(type:displayText:insertText:textColor:icon:value:location:)``. Will try to force the autocomplete menu to popup, if `force` is `true`.
    /// 
    /// > Note: This will replace all current candidates.
    /// 
    public final func updateCodeCompletionOptions (force: Bool) {
        #if false
        
        var copy_force = force
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_update_code_completion_options, UnsafeMutableRawPointer (mutating: handle), nil, &copy_force)
        
        #else
        
        var copy_force = force
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_force) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_update_code_completion_options, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_code_completion_options: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_code_completion_options")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Gets all completion options, see ``getCodeCompletionOption(index:)`` for return content.
    public final func getCodeCompletionOptions ()-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_code_completion_options, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_get_code_completion_option: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_code_completion_option")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3485342025)!
            }
            
        }
        
    }()
    
    /// Gets the completion option at `index`. The return ``GDictionary`` has the following key-values:
    /// 
    /// `kind`: ``CodeEdit/CodeCompletionKind``
    /// 
    /// `display_text`: Text that is shown on the autocomplete menu.
    /// 
    /// `insert_text`: Text that is to be inserted when this item is selected.
    /// 
    /// `font_color`: Color of the text on the autocomplete menu.
    /// 
    /// `icon`: Icon to draw on the autocomplete menu.
    /// 
    /// `default_value`: Value of the symbol.
    /// 
    public final func getCodeCompletionOption (index: Int32)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_get_code_completion_option, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_index)
        return _result
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_get_code_completion_option, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_code_completion_selected_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_code_completion_selected_index")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Gets the index of the current selected completion option.
    public final func getCodeCompletionSelectedIndex ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_code_completion_selected_index, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_code_completion_selected_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_code_completion_selected_index")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the current selected completion option.
    public final func setCodeCompletionSelectedIndex (_ index: Int32) {
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_code_completion_selected_index, UnsafeMutableRawPointer (mutating: handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_code_completion_selected_index, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_confirm_code_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName ("confirm_code_completion")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 107499316)!
            }
            
        }
        
    }()
    
    /// Inserts the selected entry into the text. If `replace` is true, any existing text is replaced rather than merged.
    public final func confirmCodeCompletion (replace: Bool = false) {
        #if false
        
        var copy_replace = replace
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_confirm_code_completion, UnsafeMutableRawPointer (mutating: handle), nil, &copy_replace)
        
        #else
        
        var copy_replace = replace
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_replace) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_confirm_code_completion, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_cancel_code_completion: GDExtensionMethodBindPtr = {
        let methodName = StringName ("cancel_code_completion")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Cancels the autocomplete menu.
    public final func cancelCodeCompletion () {
        gi.object_method_bind_ptrcall (CodeEdit.method_cancel_code_completion, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_code_completion_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_code_completion_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_code_completion_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_code_completion_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_code_completion_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_code_completion_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_code_completion_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_code_completion_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_code_completion_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_code_completion_prefixes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_code_completion_prefixes")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_code_completion_prefixes (_ prefixes: VariantCollection<String>) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_code_completion_prefixes, UnsafeMutableRawPointer (mutating: handle), nil, &prefixes.array.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &prefixes.array.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_code_completion_prefixes, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_code_completion_prefixes: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_code_completion_prefixes")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_code_completion_prefixes ()-> VariantCollection<String> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_code_completion_prefixes, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<String>(content: _result)
    }
    
    fileprivate static var method_set_line_length_guidelines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_line_length_guidelines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 381264803)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_line_length_guidelines (_ guidelineColumns: VariantCollection<Int64>) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_line_length_guidelines, UnsafeMutableRawPointer (mutating: handle), nil, &guidelineColumns.array.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &guidelineColumns.array.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_line_length_guidelines, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_line_length_guidelines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_line_length_guidelines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_line_length_guidelines ()-> VariantCollection<Int64> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (CodeEdit.method_get_line_length_guidelines, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return VariantCollection<Int64>(content: _result)
    }
    
    fileprivate static var method_set_symbol_lookup_on_click_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_symbol_lookup_on_click_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_symbol_lookup_on_click_enabled (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_symbol_lookup_on_click_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_symbol_lookup_on_click_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_symbol_lookup_on_click_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_symbol_lookup_on_click_enabled")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_symbol_lookup_on_click_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CodeEdit.method_is_symbol_lookup_on_click_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_text_for_symbol_lookup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text_for_symbol_lookup")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the full text with char `0xFFFF` at the cursor location.
    public final func getTextForSymbolLookup ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (CodeEdit.method_get_text_for_symbol_lookup, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_text_with_cursor_char: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_text_with_cursor_char")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1391810591)!
            }
            
        }
        
    }()
    
    /// Returns the full text with char `0xFFFF` at the specified location.
    public final func getTextWithCursorChar (line: Int32, column: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_get_text_with_cursor_char, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_line, &copy_column)
        return _result.description
        #else
        
        var copy_line: Int = Int (line)
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_line) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CodeEdit.method_get_text_with_cursor_char, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_symbol_lookup_word_as_valid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_symbol_lookup_word_as_valid")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets the symbol emitted by [signal symbol_validate] as a valid lookup.
    public final func setSymbolLookupWordAsValid (_ valid: Bool) {
        #if false
        
        var copy_valid = valid
        
        gi.object_method_bind_ptrcall_v (CodeEdit.method_set_symbol_lookup_word_as_valid, UnsafeMutableRawPointer (mutating: handle), nil, &copy_valid)
        
        #else
        
        var copy_valid = valid
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_valid) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CodeEdit.method_set_symbol_lookup_word_as_valid, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_duplicate_lines: GDExtensionMethodBindPtr = {
        let methodName = StringName ("duplicate_lines")
        return withUnsafePointer (to: &CodeEdit.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Duplicates all lines currently selected with any caret. Duplicates the entire line beneath the current one no matter where the caret is within the line.
    public final func duplicateLines () {
        gi.object_method_bind_ptrcall (CodeEdit.method_duplicate_lines, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_confirm_code_completion":
                return _CodeEdit_proxy_confirm_code_completion
            case "_filter_code_completion_candidates":
                return _CodeEdit_proxy_filter_code_completion_candidates
            case "_request_code_completion":
                return _CodeEdit_proxy_request_code_completion
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ line: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a breakpoint is added or removed from a line. If the line is moved via backspace a removed is emitted at the old line.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.breakpointToggled.connect { line in
    ///    print ("caught signal")
    /// }
    /// ```
    public var breakpointToggled: Signal1 { Signal1 (target: self, signalName: "breakpoint_toggled") }
    
    /// Emitted when the user requests code completion.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.codeCompletionRequested.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var codeCompletionRequested: SimpleSignal { SimpleSignal (target: self, signalName: "code_completion_requested") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ symbol: String, _ line: Int64, _ column: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                let arg_1 = Int64 (args [1])!
                let arg_2 = Int64 (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user has clicked on a valid symbol.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.symbolLookup.connect { symbol, line, column in
    ///    print ("caught signal")
    /// }
    /// ```
    public var symbolLookup: Signal2 { Signal2 (target: self, signalName: "symbol_lookup") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ symbol: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user hovers over a symbol. The symbol should be validated and responded to, by calling ``setSymbolLookupWordAsValid(_:)``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.symbolValidate.connect { symbol in
    ///    print ("caught signal")
    /// }
    /// ```
    public var symbolValidate: Signal3 { Signal3 (target: self, signalName: "symbol_validate") }
    
}

// Support methods for proxies
func _CodeEdit_proxy_confirm_code_completion (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CodeEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._confirmCodeCompletion (replace: args [0]!.assumingMemoryBound (to: Bool.self).pointee)
}

func _CodeEdit_proxy_filter_code_completion_candidates (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CodeEdit>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._filterCodeCompletionCandidates (args [0]!.assumingMemoryBound (to: VariantCollection<GDictionary>.self).pointee)
    retPtr!.storeBytes (of: ret.array.content, as: type (of: ret.array.content)) // typedarray::Dictionary
}

func _CodeEdit_proxy_request_code_completion (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    guard let args else { return }
    let swiftObject = Unmanaged<CodeEdit>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._requestCodeCompletion (force: args [0]!.assumingMemoryBound (to: Bool.self).pointee)
}

