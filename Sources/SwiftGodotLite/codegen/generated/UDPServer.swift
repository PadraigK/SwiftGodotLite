// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Helper class to implement a UDP server.
/// 
/// A simple server that opens a UDP socket and returns connected ``PacketPeerUDP`` upon receiving new packets. See also ``PacketPeerUDP/connectToHost(_:port:)``.
/// 
/// After starting the server (``listen(port:bindAddress:)``), you will need to ``poll()`` it at regular intervals (e.g. inside ``Node/_process(delta:)``) for it to process new packets, delivering them to the appropriate ``PacketPeerUDP``, and taking new connections.
/// 
/// Below a small example of how it can be used:
/// 
open class UDPServer: RefCounted {
    override open class var godotClassName: StringName { "UDPServer" }
    
    /* Properties */
    
    /// Define the maximum number of pending connections, during ``poll()``, any new pending connection exceeding that value will be automatically dropped. Setting this value to `0` effectively prevents any new pending connection to be accepted (e.g. when all your players have connected).
    final public var maxPendingConnections: Int32 {
        get {
            return get_max_pending_connections ()
        }
        
        set {
            set_max_pending_connections (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_listen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("listen")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3167955072)!
            }
            
        }
        
    }()
    
    /// Starts the server by opening a UDP socket listening on the given `port`. You can optionally specify a `bindAddress` to only listen for packets sent to that address. See also ``PacketPeerUDP/bind(port:bindAddress:recvBufSize:)``.
    public final func listen (port: UInt16, bindAddress: String = "*")-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_port: Int = Int (port)
        let gstr_bind_address = GString (bindAddress)
        
        gi.object_method_bind_ptrcall_v (UDPServer.method_listen, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_port, &gstr_bind_address.content)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_port: Int = Int (port)
        let gstr_bind_address = GString (bindAddress)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_port) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_bind_address.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (UDPServer.method_listen, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_poll: GDExtensionMethodBindPtr = {
        let methodName = StringName ("poll")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Call this method at regular intervals (e.g. inside ``Node/_process(delta:)``) to process new packets. And packet from known address/port pair will be delivered to the appropriate ``PacketPeerUDP``, any packet received from an unknown address/port pair will be added as a pending connection (see ``isConnectionAvailable()``, ``takeConnection()``). The maximum number of pending connection is defined via ``maxPendingConnections``.
    public final func poll ()-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (UDPServer.method_poll, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_is_connection_available: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_connection_available")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a packet with a new address/port combination was received on the socket.
    public final func isConnectionAvailable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (UDPServer.method_is_connection_available, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_local_port: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_local_port")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the local port this server is listening to.
    public final func getLocalPort ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (UDPServer.method_get_local_port, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_listening: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_listening")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the socket is open and listening on a port.
    public final func isListening ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (UDPServer.method_is_listening, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_take_connection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("take_connection")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 808734560)!
            }
            
        }
        
    }()
    
    /// Returns the first pending connection (connected to the appropriate address/port). Will return `null` if no new connection is available. See also ``isConnectionAvailable()``, ``PacketPeerUDP/connectToHost(_:port:)``.
    public final func takeConnection ()-> PacketPeerUDP? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (UDPServer.method_take_connection, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_stop: GDExtensionMethodBindPtr = {
        let methodName = StringName ("stop")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Stops the server, closing the UDP socket if open. Will close all connected ``PacketPeerUDP`` accepted via ``takeConnection()`` (remote peers will not be notified).
    public final func stop () {
        gi.object_method_bind_ptrcall (UDPServer.method_stop, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_max_pending_connections: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_max_pending_connections")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_pending_connections (_ maxPendingConnections: Int32) {
        #if true
        
        var copy_max_pending_connections: Int = Int (maxPendingConnections)
        
        gi.object_method_bind_ptrcall_v (UDPServer.method_set_max_pending_connections, UnsafeMutableRawPointer (mutating: handle), nil, &copy_max_pending_connections)
        
        #else
        
        var copy_max_pending_connections: Int = Int (maxPendingConnections)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_max_pending_connections) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (UDPServer.method_set_max_pending_connections, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_max_pending_connections: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_max_pending_connections")
        return withUnsafePointer (to: &UDPServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_pending_connections ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (UDPServer.method_get_max_pending_connections, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
}

