// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Abstract base class for viewports. Encapsulates drawing and interaction with a game world.
/// 
/// A Viewport creates a different view into the screen, or a sub-view inside another viewport. Children 2D Nodes will display on it, and children Camera3D 3D nodes will render on it too.
/// 
/// Optionally, a viewport can have its own 2D or 3D world, so it doesn't share what it draws with other viewports.
/// 
/// Viewports can also choose to be audio listeners, so they generate positional audio depending on a 2D or 3D camera child of it.
/// 
/// Also, viewports can be assigned to different screens in case the devices have multiple screens.
/// 
/// Finally, viewports can also behave as render targets, in which case they will not be visible unless the associated texture is used to draw.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``sizeChanged``
/// - ``guiFocusChanged``
open class Viewport: Node {
    override open class var godotClassName: StringName { "Viewport" }
    public enum PositionalShadowAtlasQuadrantSubdiv: Int64 {
        /// This quadrant will not be used.
        case disabled = 0 // SHADOW_ATLAS_QUADRANT_SUBDIV_DISABLED
        /// This quadrant will only be used by one shadow map.
        case shadowAtlasQuadrantSubdiv1 = 1 // SHADOW_ATLAS_QUADRANT_SUBDIV_1
        /// This quadrant will be split in 4 and used by up to 4 shadow maps.
        case shadowAtlasQuadrantSubdiv4 = 2 // SHADOW_ATLAS_QUADRANT_SUBDIV_4
        /// This quadrant will be split 16 ways and used by up to 16 shadow maps.
        case shadowAtlasQuadrantSubdiv16 = 3 // SHADOW_ATLAS_QUADRANT_SUBDIV_16
        /// This quadrant will be split 64 ways and used by up to 64 shadow maps.
        case shadowAtlasQuadrantSubdiv64 = 4 // SHADOW_ATLAS_QUADRANT_SUBDIV_64
        /// This quadrant will be split 256 ways and used by up to 256 shadow maps. Unless the ``positionalShadowAtlasSize`` is very high, the shadows in this quadrant will be very low resolution.
        case shadowAtlasQuadrantSubdiv256 = 5 // SHADOW_ATLAS_QUADRANT_SUBDIV_256
        /// This quadrant will be split 1024 ways and used by up to 1024 shadow maps. Unless the ``positionalShadowAtlasSize`` is very high, the shadows in this quadrant will be very low resolution.
        case shadowAtlasQuadrantSubdiv1024 = 6 // SHADOW_ATLAS_QUADRANT_SUBDIV_1024
        /// Represents the size of the ``Viewport/PositionalShadowAtlasQuadrantSubdiv`` enum.
        case max = 7 // SHADOW_ATLAS_QUADRANT_SUBDIV_MAX
    }
    
    public enum Scaling3DMode: Int64 {
        /// Use bilinear scaling for the viewport's 3D buffer. The amount of scaling can be set using ``scaling3dScale``. Values less than `1.0` will result in undersampling while values greater than `1.0` will result in supersampling. A value of `1.0` disables scaling.
        case bilinear = 0 // SCALING_3D_MODE_BILINEAR
        /// Use AMD FidelityFX Super Resolution 1.0 upscaling for the viewport's 3D buffer. The amount of scaling can be set using ``scaling3dScale``. Values less than `1.0` will be result in the viewport being upscaled using FSR. Values greater than `1.0` are not supported and bilinear downsampling will be used instead. A value of `1.0` disables scaling.
        case fsr = 1 // SCALING_3D_MODE_FSR
        /// Use AMD FidelityFX Super Resolution 2.2 upscaling for the viewport's 3D buffer. The amount of scaling can be set using ``Viewport/scaling3dScale``. Values less than `1.0` will be result in the viewport being upscaled using FSR2. Values greater than `1.0` are not supported and bilinear downsampling will be used instead. A value of `1.0` will use FSR2 at native resolution as a TAA solution.
        case fsr2 = 2 // SCALING_3D_MODE_FSR2
        /// Represents the size of the ``Viewport/Scaling3DMode`` enum.
        case max = 3 // SCALING_3D_MODE_MAX
    }
    
    public enum MSAA: Int64 {
        /// Multisample antialiasing mode disabled. This is the default value, and is also the fastest setting.
        case disabled = 0 // MSAA_DISABLED
        /// Use 2× Multisample Antialiasing. This has a moderate performance cost. It helps reduce aliasing noticeably, but 4× MSAA still looks substantially better.
        case msaa2x = 1 // MSAA_2X
        /// Use 4× Multisample Antialiasing. This has a significant performance cost, and is generally a good compromise between performance and quality.
        case msaa4x = 2 // MSAA_4X
        /// Use 8× Multisample Antialiasing. This has a very high performance cost. The difference between 4× and 8× MSAA may not always be visible in real gameplay conditions. Likely unsupported on low-end and older hardware.
        case msaa8x = 3 // MSAA_8X
        /// Represents the size of the ``Viewport/MSAA`` enum.
        case max = 4 // MSAA_MAX
    }
    
    public enum ScreenSpaceAA: Int64 {
        /// Do not perform any antialiasing in the full screen post-process.
        case disabled = 0 // SCREEN_SPACE_AA_DISABLED
        /// Use fast approximate antialiasing. FXAA is a popular screen-space antialiasing method, which is fast but will make the image look blurry, especially at lower resolutions. It can still work relatively well at large resolutions such as 1440p and 4K.
        case fxaa = 1 // SCREEN_SPACE_AA_FXAA
        /// Represents the size of the ``Viewport/ScreenSpaceAA`` enum.
        case max = 2 // SCREEN_SPACE_AA_MAX
    }
    
    public enum RenderInfo: Int64 {
        /// Amount of objects in frame.
        case objectsInFrame = 0 // RENDER_INFO_OBJECTS_IN_FRAME
        /// Amount of vertices in frame.
        case primitivesInFrame = 1 // RENDER_INFO_PRIMITIVES_IN_FRAME
        /// Amount of draw calls in frame.
        case drawCallsInFrame = 2 // RENDER_INFO_DRAW_CALLS_IN_FRAME
        /// Represents the size of the ``Viewport/RenderInfo`` enum.
        case max = 3 // RENDER_INFO_MAX
    }
    
    public enum RenderInfoType: Int64 {
        /// 
        case visible = 0 // RENDER_INFO_TYPE_VISIBLE
        /// 
        case shadow = 1 // RENDER_INFO_TYPE_SHADOW
        /// 
        case max = 2 // RENDER_INFO_TYPE_MAX
    }
    
    public enum DebugDraw: Int64 {
        /// Objects are displayed normally.
        case disabled = 0 // DEBUG_DRAW_DISABLED
        /// Objects are displayed without light information.
        case unshaded = 1 // DEBUG_DRAW_UNSHADED
        /// 
        case lighting = 2 // DEBUG_DRAW_LIGHTING
        /// Objects are displayed semi-transparent with additive blending so you can see where they are drawing over top of one another. A higher overdraw means you are wasting performance on drawing pixels that are being hidden behind others.
        case overdraw = 3 // DEBUG_DRAW_OVERDRAW
        /// Objects are displayed in wireframe style.
        case wireframe = 4 // DEBUG_DRAW_WIREFRAME
        /// 
        case normalBuffer = 5 // DEBUG_DRAW_NORMAL_BUFFER
        /// Objects are displayed with only the albedo value from ``VoxelGI``s.
        case voxelGiAlbedo = 6 // DEBUG_DRAW_VOXEL_GI_ALBEDO
        /// Objects are displayed with only the lighting value from ``VoxelGI``s.
        case voxelGiLighting = 7 // DEBUG_DRAW_VOXEL_GI_LIGHTING
        /// Objects are displayed with only the emission color from ``VoxelGI``s.
        case voxelGiEmission = 8 // DEBUG_DRAW_VOXEL_GI_EMISSION
        /// Draws the shadow atlas that stores shadows from ``OmniLight3D``s and ``SpotLight3D``s in the upper left quadrant of the ``Viewport``.
        case shadowAtlas = 9 // DEBUG_DRAW_SHADOW_ATLAS
        /// Draws the shadow atlas that stores shadows from ``DirectionalLight3D``s in the upper left quadrant of the ``Viewport``.
        case directionalShadowAtlas = 10 // DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS
        /// 
        case sceneLuminance = 11 // DEBUG_DRAW_SCENE_LUMINANCE
        /// Draws the screen-space ambient occlusion texture instead of the scene so that you can clearly see how it is affecting objects. In order for this display mode to work, you must have ``Environment/ssaoEnabled`` set in your ``WorldEnvironment``.
        case ssao = 12 // DEBUG_DRAW_SSAO
        /// Draws the screen-space indirect lighting texture instead of the scene so that you can clearly see how it is affecting objects. In order for this display mode to work, you must have ``Environment/ssilEnabled`` set in your ``WorldEnvironment``.
        case ssil = 13 // DEBUG_DRAW_SSIL
        /// Colors each PSSM split for the ``DirectionalLight3D``s in the scene a different color so you can see where the splits are. In order, they will be colored red, green, blue, and yellow.
        case pssmSplits = 14 // DEBUG_DRAW_PSSM_SPLITS
        /// Draws the decal atlas used by ``Decal``s and light projector textures in the upper left quadrant of the ``Viewport``.
        case decalAtlas = 15 // DEBUG_DRAW_DECAL_ATLAS
        /// 
        case sdfgi = 16 // DEBUG_DRAW_SDFGI
        /// 
        case sdfgiProbes = 17 // DEBUG_DRAW_SDFGI_PROBES
        /// 
        case giBuffer = 18 // DEBUG_DRAW_GI_BUFFER
        /// 
        case disableLod = 19 // DEBUG_DRAW_DISABLE_LOD
        /// 
        case clusterOmniLights = 20 // DEBUG_DRAW_CLUSTER_OMNI_LIGHTS
        /// 
        case clusterSpotLights = 21 // DEBUG_DRAW_CLUSTER_SPOT_LIGHTS
        /// 
        case clusterDecals = 22 // DEBUG_DRAW_CLUSTER_DECALS
        /// 
        case clusterReflectionProbes = 23 // DEBUG_DRAW_CLUSTER_REFLECTION_PROBES
        /// 
        case occluders = 24 // DEBUG_DRAW_OCCLUDERS
        /// 
        case motionVectors = 25 // DEBUG_DRAW_MOTION_VECTORS
        /// Draws the internal resolution buffer of the scene before post-processing is applied.
        case internalBuffer = 26 // DEBUG_DRAW_INTERNAL_BUFFER
    }
    
    public enum DefaultCanvasItemTextureFilter: Int64 {
        /// The texture filter reads from the nearest pixel only. The simplest and fastest method of filtering, but the texture will look pixelized.
        case nearest = 0 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST
        /// The texture filter blends between the nearest 4 pixels. Use this when you want to avoid a pixelated style, but do not want mipmaps.
        case linear = 1 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR
        /// The texture filter reads from the nearest pixel in the nearest mipmap. The fastest way to read from textures with mipmaps.
        case linearWithMipmaps = 2 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS
        /// The texture filter blends between the nearest 4 pixels and between the nearest 2 mipmaps.
        case nearestWithMipmaps = 3 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS
        /// Max value for ``Viewport/DefaultCanvasItemTextureFilter`` enum.
        case max = 4 // DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_MAX
    }
    
    public enum DefaultCanvasItemTextureRepeat: Int64 {
        /// Disables textures repeating. Instead, when reading UVs outside the 0-1 range, the value will be clamped to the edge of the texture, resulting in a stretched out look at the borders of the texture.
        case disabled = 0 // DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_DISABLED
        /// Enables the texture to repeat when UV coordinates are outside the 0-1 range. If using one of the linear filtering modes, this can result in artifacts at the edges of a texture when the sampler filters across the edges of the texture.
        case enabled = 1 // DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_ENABLED
        /// Flip the texture when repeating so that the edge lines up instead of abruptly changing.
        case mirror = 2 // DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MIRROR
        /// Max value for ``Viewport/DefaultCanvasItemTextureRepeat`` enum.
        case max = 3 // DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MAX
    }
    
    public enum SDFOversize: Int64 {
        /// 
        case sdfOversize100Percent = 0 // SDF_OVERSIZE_100_PERCENT
        /// 
        case sdfOversize120Percent = 1 // SDF_OVERSIZE_120_PERCENT
        /// 
        case sdfOversize150Percent = 2 // SDF_OVERSIZE_150_PERCENT
        /// 
        case sdfOversize200Percent = 3 // SDF_OVERSIZE_200_PERCENT
        /// 
        case max = 4 // SDF_OVERSIZE_MAX
    }
    
    public enum SDFScale: Int64 {
        /// 
        case sdfScale100Percent = 0 // SDF_SCALE_100_PERCENT
        /// 
        case sdfScale50Percent = 1 // SDF_SCALE_50_PERCENT
        /// 
        case sdfScale25Percent = 2 // SDF_SCALE_25_PERCENT
        /// 
        case max = 3 // SDF_SCALE_MAX
    }
    
    public enum VRSMode: Int64 {
        /// VRS is disabled.
        case disabled = 0 // VRS_DISABLED
        /// VRS uses a texture. Note, for stereoscopic use a texture atlas with a texture for each view.
        case texture = 1 // VRS_TEXTURE
        /// VRS texture is supplied by the primary ``XRInterface``.
        case xr = 2 // VRS_XR
        /// Represents the size of the ``Viewport/VRSMode`` enum.
        case max = 3 // VRS_MAX
    }
    
    
    /* Properties */
    
    /// Disable 3D rendering (but keep 2D rendering).
    final public var disable3d: Bool {
        get {
            return is_3d_disabled ()
        }
        
        set {
            set_disable_3d (newValue)
        }
        
    }
    
    /// If `true`, the viewport will use the primary XR interface to render XR output. When applicable this can result in a stereoscopic image and the resulting render being output to a headset.
    final public var useXr: Bool {
        get {
            return is_using_xr ()
        }
        
        set {
            set_use_xr (newValue)
        }
        
    }
    
    /// If `true`, the viewport will use a unique copy of the ``World3D`` defined in ``world3d``.
    final public var ownWorld3d: Bool {
        get {
            return is_using_own_world_3d ()
        }
        
        set {
            set_use_own_world_3d (newValue)
        }
        
    }
    
    /// The custom ``World3D`` which can be used as 3D environment source.
    final public var world3d: World3D? {
        get {
            return get_world_3d ()
        }
        
        set {
            set_world_3d (newValue)
        }
        
    }
    
    /// The custom ``World2D`` which can be used as 2D environment source.
    final public var world2d: World2D? {
        get {
            return get_world_2d ()
        }
        
        set {
            set_world_2d (newValue)
        }
        
    }
    
    /// If `true`, the viewport should render its background as transparent.
    final public var transparentBg: Bool {
        get {
            return has_transparent_background ()
        }
        
        set {
            set_transparent_background (newValue)
        }
        
    }
    
    /// If `true`, this viewport will mark incoming input events as handled by itself. If `false`, this is instead done by the first parent viewport that is set to handle input locally.
    /// 
    /// A ``SubViewportContainer`` will automatically set this property to `false` for the ``Viewport`` contained inside of it.
    /// 
    /// See also ``setInputAsHandled()`` and ``isInputHandled()``.
    /// 
    final public var handleInputLocally: Bool {
        get {
            return is_handling_input_locally ()
        }
        
        set {
            set_handle_input_locally (newValue)
        }
        
    }
    
    final public var snap2dTransformsToPixel: Bool {
        get {
            return is_snap_2d_transforms_to_pixel_enabled ()
        }
        
        set {
            set_snap_2d_transforms_to_pixel (newValue)
        }
        
    }
    
    final public var snap2dVerticesToPixel: Bool {
        get {
            return is_snap_2d_vertices_to_pixel_enabled ()
        }
        
        set {
            set_snap_2d_vertices_to_pixel (newValue)
        }
        
    }
    
    /// The multisample anti-aliasing mode for 2D/Canvas rendering. A higher number results in smoother edges at the cost of significantly worse performance. A value of 2 or 4 is best unless targeting very high-end systems. This has no effect on shader-induced aliasing or texture aliasing.
    final public var msaa2d: Viewport.MSAA {
        get {
            return get_msaa_2d ()
        }
        
        set {
            set_msaa_2d (newValue)
        }
        
    }
    
    /// The multisample anti-aliasing mode for 3D rendering. A higher number results in smoother edges at the cost of significantly worse performance. A value of 2 or 4 is best unless targeting very high-end systems. See also bilinear scaling 3d ``scaling3dMode`` for supersampling, which provides higher quality but is much more expensive. This has no effect on shader-induced aliasing or texture aliasing.
    final public var msaa3d: Viewport.MSAA {
        get {
            return get_msaa_3d ()
        }
        
        set {
            set_msaa_3d (newValue)
        }
        
    }
    
    /// Sets the screen-space antialiasing method used. Screen-space antialiasing works by selectively blurring edges in a post-process shader. It differs from MSAA which takes multiple coverage samples while rendering objects. Screen-space AA methods are typically faster than MSAA and will smooth out specular aliasing, but tend to make scenes appear blurry.
    final public var screenSpaceAa: Viewport.ScreenSpaceAA {
        get {
            return get_screen_space_aa ()
        }
        
        set {
            set_screen_space_aa (newValue)
        }
        
    }
    
    /// Enables Temporal Anti-Aliasing for this viewport. TAA works by jittering the camera and accumulating the images of the last rendered frames, motion vector rendering is used to account for camera and object motion.
    /// 
    /// > Note: The implementation is not complete yet, some visual instances such as particles and skinned meshes may show artifacts.
    /// 
    final public var useTaa: Bool {
        get {
            return is_using_taa ()
        }
        
        set {
            set_use_taa (newValue)
        }
        
    }
    
    /// If `true`, uses a fast post-processing filter to make banding significantly less visible in 3D. 2D rendering is _not_ affected by debanding unless the ``Environment/backgroundMode`` is ``Environment/BGMode/bgCanvas``. See also ``ProjectSettings/rendering/antiAliasing/quality/useDebanding``.
    /// 
    /// In some cases, debanding may introduce a slightly noticeable dithering pattern. It's recommended to enable debanding only when actually needed since the dithering pattern will make lossless-compressed screenshots larger.
    /// 
    final public var useDebanding: Bool {
        get {
            return is_using_debanding ()
        }
        
        set {
            set_use_debanding (newValue)
        }
        
    }
    
    /// If `true`, ``OccluderInstance3D`` nodes will be usable for occlusion culling in 3D for this viewport. For the root viewport, ``ProjectSettings/rendering/occlusionCulling/useOcclusionCulling`` must be set to `true` instead.
    /// 
    /// > Note: Enabling occlusion culling has a cost on the CPU. Only enable occlusion culling if you actually plan to use it, and think whether your scene can actually benefit from occlusion culling. Large, open scenes with few or no objects blocking the view will generally not benefit much from occlusion culling. Large open scenes generally benefit more from mesh LOD and visibility ranges (``GeometryInstance3D/visibilityRangeBegin`` and ``GeometryInstance3D/visibilityRangeEnd``) compared to occlusion culling.
    /// 
    /// > Note: Due to memory constraints, occlusion culling is not supported by default in Web export templates. It can be enabled by compiling custom Web export templates with `module_raycast_enabled=yes`.
    /// 
    final public var useOcclusionCulling: Bool {
        get {
            return is_using_occlusion_culling ()
        }
        
        set {
            set_use_occlusion_culling (newValue)
        }
        
    }
    
    /// The automatic LOD bias to use for meshes rendered within the ``Viewport`` (this is analogous to ``ReflectionProbe/meshLodThreshold``). Higher values will use less detailed versions of meshes that have LOD variations generated. If set to `0.0`, automatic LOD is disabled. Increase ``meshLodThreshold`` to improve performance at the cost of geometry detail.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/meshLod/lodChange/thresholdPixels`` project setting.
    /// 
    /// > Note: ``meshLodThreshold`` does not affect ``GeometryInstance3D`` visibility ranges (also known as "manual" LOD or hierarchical LOD).
    /// 
    final public var meshLodThreshold: Double {
        get {
            return get_mesh_lod_threshold ()
        }
        
        set {
            set_mesh_lod_threshold (newValue)
        }
        
    }
    
    /// The overlay mode for test rendered geometry in debug purposes.
    final public var debugDraw: Viewport.DebugDraw {
        get {
            return get_debug_draw ()
        }
        
        set {
            set_debug_draw (newValue)
        }
        
    }
    
    /// If `true`, 2D rendering will use an high dynamic range (HDR) format framebuffer matching the bit depth of the 3D framebuffer. When using the Forward+ renderer this will be a `RGBA16` framebuffer, while when using the Mobile renderer it will be a `RGB10_A2` framebuffer. Additionally, 2D rendering will take place in linear color space and will be converted to sRGB space immediately before blitting to the screen (if the Viewport is attached to the screen). Practically speaking, this means that the end result of the Viewport will not be clamped into the `0-1` range and can be used in 3D rendering without color space adjustments. This allows 2D rendering to take advantage of effects requiring high dynamic range (e.g. 2D glow) as well as substantially improves the appearance of effects requiring highly detailed gradients.
    /// 
    /// > Note: This setting will have no effect when using the GL Compatibility renderer as the GL Compatibility renderer always renders in low dynamic range for performance reasons.
    /// 
    final public var useHdr2d: Bool {
        get {
            return is_using_hdr_2d ()
        }
        
        set {
            set_use_hdr_2d (newValue)
        }
        
    }
    
    /// Sets scaling 3d mode. Bilinear scaling renders at different resolution to either undersample or supersample the viewport. FidelityFX Super Resolution 1.0, abbreviated to FSR, is an upscaling technology that produces high quality images at fast framerates by using a spatially aware upscaling algorithm. FSR is slightly more expensive than bilinear, but it produces significantly higher image quality. FSR should be used where possible.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/scaling3d/mode`` project setting.
    /// 
    final public var scaling3dMode: Viewport.Scaling3DMode {
        get {
            return get_scaling_3d_mode ()
        }
        
        set {
            set_scaling_3d_mode (newValue)
        }
        
    }
    
    /// Scales the 3D render buffer based on the viewport size uses an image filter specified in ``ProjectSettings/rendering/scaling3d/mode`` to scale the output image to the full viewport size. Values lower than `1.0` can be used to speed up 3D rendering at the cost of quality (undersampling). Values greater than `1.0` are only valid for bilinear mode and can be used to improve 3D rendering quality at a high performance cost (supersampling). See also ``ProjectSettings/rendering/antiAliasing/quality/msaa3d`` for multi-sample antialiasing, which is significantly cheaper but only smooths the edges of polygons.
    /// 
    /// When using FSR upscaling, AMD recommends exposing the following values as preset options to users "Ultra Quality: 0.77", "Quality: 0.67", "Balanced: 0.59", "Performance: 0.5" instead of exposing the entire scale.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/scaling3d/scale`` project setting.
    /// 
    final public var scaling3dScale: Double {
        get {
            return get_scaling_3d_scale ()
        }
        
        set {
            set_scaling_3d_scale (newValue)
        }
        
    }
    
    /// Affects the final texture sharpness by reading from a lower or higher mipmap (also called "texture LOD bias"). Negative values make mipmapped textures sharper but grainier when viewed at a distance, while positive values make mipmapped textures blurrier (even when up close).
    /// 
    /// Enabling temporal antialiasing (``useTaa``) will automatically apply a `-0.5` offset to this value, while enabling FXAA (``screenSpaceAa``) will automatically apply a `-0.25` offset to this value. If both TAA and FXAA are enabled at the same time, an offset of `-0.75` is applied to this value.
    /// 
    /// > Note: If ``scaling3dScale`` is lower than `1.0` (exclusive), ``textureMipmapBias`` is used to adjust the automatic mipmap bias which is calculated internally based on the scale factor. The formula for this is `log2(scaling_3d_scale) + mipmap_bias`.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/textures/defaultFilters/textureMipmapBias`` project setting.
    /// 
    final public var textureMipmapBias: Double {
        get {
            return get_texture_mipmap_bias ()
        }
        
        set {
            set_texture_mipmap_bias (newValue)
        }
        
    }
    
    /// Determines how sharp the upscaled image will be when using the FSR upscaling mode. Sharpness halves with every whole number. Values go from 0.0 (sharpest) to 2.0. Values above 2.0 won't make a visible difference.
    /// 
    /// To control this property on the root viewport, set the ``ProjectSettings/rendering/scaling3d/fsrSharpness`` project setting.
    /// 
    final public var fsrSharpness: Double {
        get {
            return get_fsr_sharpness ()
        }
        
        set {
            set_fsr_sharpness (newValue)
        }
        
    }
    
    /// The Variable Rate Shading (VRS) mode that is used for this viewport. Note, if hardware does not support VRS this property is ignored.
    final public var vrsMode: Viewport.VRSMode {
        get {
            return get_vrs_mode ()
        }
        
        set {
            set_vrs_mode (newValue)
        }
        
    }
    
    /// Texture to use when ``vrsMode`` is set to ``Viewport/VRSMode/vrsTexture``.
    /// 
    /// The texture _must_ use a lossless compression format so that colors can be matched precisely. The following VRS densities are mapped to various colors, with brighter colors representing a lower level of shading precision:
    /// 
    final public var vrsTexture: Texture2D? {
        get {
            return get_vrs_texture ()
        }
        
        set {
            set_vrs_texture (newValue)
        }
        
    }
    
    /// Sets the default filter mode used by ``CanvasItem``s in this Viewport. See ``Viewport/DefaultCanvasItemTextureFilter`` for options.
    final public var canvasItemDefaultTextureFilter: Viewport.DefaultCanvasItemTextureFilter {
        get {
            return get_default_canvas_item_texture_filter ()
        }
        
        set {
            set_default_canvas_item_texture_filter (newValue)
        }
        
    }
    
    /// Sets the default repeat mode used by ``CanvasItem``s in this Viewport. See ``Viewport/DefaultCanvasItemTextureRepeat`` for options.
    final public var canvasItemDefaultTextureRepeat: Viewport.DefaultCanvasItemTextureRepeat {
        get {
            return get_default_canvas_item_texture_repeat ()
        }
        
        set {
            set_default_canvas_item_texture_repeat (newValue)
        }
        
    }
    
    /// If `true`, the viewport will process 2D audio streams.
    final public var audioListenerEnable2d: Bool {
        get {
            return is_audio_listener_2d ()
        }
        
        set {
            set_as_audio_listener_2d (newValue)
        }
        
    }
    
    /// If `true`, the viewport will process 3D audio streams.
    final public var audioListenerEnable3d: Bool {
        get {
            return is_audio_listener_3d ()
        }
        
        set {
            set_as_audio_listener_3d (newValue)
        }
        
    }
    
    /// If `true`, the objects rendered by viewport become subjects of mouse picking process.
    /// 
    /// > Note: The number of simultaneously pickable objects is limited to 64 and they are selected in a non-deterministic order, which can be different in each picking process.
    /// 
    final public var physicsObjectPicking: Bool {
        get {
            return get_physics_object_picking ()
        }
        
        set {
            set_physics_object_picking (newValue)
        }
        
    }
    
    /// If `true`, objects receive mouse picking events sorted primarily by their ``CanvasItem/zIndex`` and secondarily by their position in the scene tree. If `false`, the order is undetermined.
    /// 
    /// > Note: This setting is disabled by default because of its potential expensive computational cost.
    /// 
    /// > Note: Sorting happens after selecting the pickable objects. Because of the limitation of 64 simultaneously pickable objects, it is not guaranteed that the object with the highest ``CanvasItem/zIndex`` receives the picking event.
    /// 
    final public var physicsObjectPickingSort: Bool {
        get {
            return get_physics_object_picking_sort ()
        }
        
        set {
            set_physics_object_picking_sort (newValue)
        }
        
    }
    
    /// If `true`, the viewport will not receive input events.
    final public var guiDisableInput: Bool {
        get {
            return is_input_disabled ()
        }
        
        set {
            set_disable_input (newValue)
        }
        
    }
    
    /// If `true`, the GUI controls on the viewport will lay pixel perfectly.
    final public var guiSnapControlsToPixels: Bool {
        get {
            return is_snap_controls_to_pixels_enabled ()
        }
        
        set {
            set_snap_controls_to_pixels (newValue)
        }
        
    }
    
    /// If `true`, sub-windows (popups and dialogs) will be embedded inside application window as control-like nodes. If `false`, they will appear as separate windows handled by the operating system.
    final public var guiEmbedSubwindows: Bool {
        get {
            return is_embedding_subwindows ()
        }
        
        set {
            set_embedding_subwindows (newValue)
        }
        
    }
    
    final public var sdfOversize: Viewport.SDFOversize {
        get {
            return get_sdf_oversize ()
        }
        
        set {
            set_sdf_oversize (newValue)
        }
        
    }
    
    final public var sdfScale: Viewport.SDFScale {
        get {
            return get_sdf_scale ()
        }
        
        set {
            set_sdf_scale (newValue)
        }
        
    }
    
    /// The shadow atlas' resolution (used for omni and spot lights). The value is rounded up to the nearest power of 2.
    /// 
    /// > Note: If this is set to `0`, no positional shadows will be visible at all. This can improve performance significantly on low-end systems by reducing both the CPU and GPU load (as fewer draw calls are needed to draw the scene without shadows).
    /// 
    final public var positionalShadowAtlasSize: Int32 {
        get {
            return get_positional_shadow_atlas_size ()
        }
        
        set {
            set_positional_shadow_atlas_size (newValue)
        }
        
    }
    
    /// Use 16 bits for the omni/spot shadow depth map. Enabling this results in shadows having less precision and may result in shadow acne, but can lead to performance improvements on some devices.
    final public var positionalShadowAtlas16Bits: Bool {
        get {
            return get_positional_shadow_atlas_16_bits ()
        }
        
        set {
            set_positional_shadow_atlas_16_bits (newValue)
        }
        
    }
    
    /// The subdivision amount of the first quadrant on the shadow atlas.
    final public var positionalShadowAtlasQuad0: Viewport.PositionalShadowAtlasQuadrantSubdiv {
        get {
            return get_positional_shadow_atlas_quadrant_subdiv (0)
        }
        
        set {
            set_positional_shadow_atlas_quadrant_subdiv (0, newValue)
        }
        
    }
    
    /// The subdivision amount of the second quadrant on the shadow atlas.
    final public var positionalShadowAtlasQuad1: Viewport.PositionalShadowAtlasQuadrantSubdiv {
        get {
            return get_positional_shadow_atlas_quadrant_subdiv (1)
        }
        
        set {
            set_positional_shadow_atlas_quadrant_subdiv (1, newValue)
        }
        
    }
    
    /// The subdivision amount of the third quadrant on the shadow atlas.
    final public var positionalShadowAtlasQuad2: Viewport.PositionalShadowAtlasQuadrantSubdiv {
        get {
            return get_positional_shadow_atlas_quadrant_subdiv (2)
        }
        
        set {
            set_positional_shadow_atlas_quadrant_subdiv (2, newValue)
        }
        
    }
    
    /// The subdivision amount of the fourth quadrant on the shadow atlas.
    final public var positionalShadowAtlasQuad3: Viewport.PositionalShadowAtlasQuadrantSubdiv {
        get {
            return get_positional_shadow_atlas_quadrant_subdiv (3)
        }
        
        set {
            set_positional_shadow_atlas_quadrant_subdiv (3, newValue)
        }
        
    }
    
    /// The canvas transform of the viewport, useful for changing the on-screen positions of all child ``CanvasItem``s. This is relative to the global canvas transform of the viewport.
    final public var canvasTransform: Transform2D {
        get {
            return get_canvas_transform ()
        }
        
        set {
            set_canvas_transform (newValue)
        }
        
    }
    
    /// The global canvas transform of the viewport. The canvas transform is relative to this.
    final public var globalCanvasTransform: Transform2D {
        get {
            return get_global_canvas_transform ()
        }
        
        set {
            set_global_canvas_transform (newValue)
        }
        
    }
    
    /// The rendering layers in which this ``Viewport`` renders ``CanvasItem`` nodes.
    final public var canvasCullMask: UInt32 {
        get {
            return get_canvas_cull_mask ()
        }
        
        set {
            set_canvas_cull_mask (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_world_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_world_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2736080068)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_world_2d (_ world2d: World2D?) {
        #if true
        
        var copy_world_2d_handle = world2d?.handle
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_world_2d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_world_2d_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: world2d?.handle) { p0 in
        _args.append (world2d == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_world_2d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_world_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_world_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2339128592)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_world_2d ()-> World2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_get_world_2d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_find_world_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("find_world_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2339128592)!
            }
            
        }
        
    }()
    
    /// Returns the first valid ``World2D`` for this viewport, searching the ``world2d`` property of itself and any Viewport ancestor.
    public final func findWorld2d ()-> World2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_find_world_2d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_canvas_transform")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2761652528)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_canvas_transform (_ xform: Transform2D) {
        #if true
        
        var copy_xform = xform
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_canvas_transform, UnsafeMutableRawPointer (mutating: handle), nil, &copy_xform)
        
        #else
        
        var copy_xform = xform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_xform) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_canvas_transform, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_canvas_transform")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_canvas_transform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (Viewport.method_get_canvas_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_global_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_global_canvas_transform")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2761652528)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_global_canvas_transform (_ xform: Transform2D) {
        #if true
        
        var copy_xform = xform
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_global_canvas_transform, UnsafeMutableRawPointer (mutating: handle), nil, &copy_xform)
        
        #else
        
        var copy_xform = xform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_xform) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_global_canvas_transform, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_global_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_global_canvas_transform")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_global_canvas_transform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (Viewport.method_get_global_canvas_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_final_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_final_transform")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform from the viewport's coordinate system to the embedder's coordinate system.
    public final func getFinalTransform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (Viewport.method_get_final_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_screen_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_screen_transform")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform from the Viewport's coordinates to the screen coordinates of the containing window manager window.
    public final func getScreenTransform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (Viewport.method_get_screen_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_visible_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visible_rect")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1639390495)!
            }
            
        }
        
    }()
    
    /// Returns the visible rectangle in global screen coordinates.
    public final func getVisibleRect ()-> Rect2 {
        var _result: Rect2 = Rect2 ()
        gi.object_method_bind_ptrcall (Viewport.method_get_visible_rect, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_transparent_background: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_transparent_background")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_transparent_background (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_transparent_background, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_transparent_background, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_has_transparent_background: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_transparent_background")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func has_transparent_background ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_has_transparent_background, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_hdr_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_hdr_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_hdr_2d (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_use_hdr_2d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_use_hdr_2d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_hdr_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_hdr_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_hdr_2d ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_using_hdr_2d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_msaa_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_msaa_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3330258708)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_msaa_2d (_ msaa: Viewport.MSAA) {
        #if true
        
        var copy_msaa = Int64 (msaa.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_msaa_2d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_msaa)
        
        #else
        
        var copy_msaa = Int64 (msaa.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_msaa) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_msaa_2d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_msaa_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_msaa_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2542055527)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_msaa_2d ()-> Viewport.MSAA {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_msaa_2d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.MSAA (rawValue: _result)!
    }
    
    fileprivate static var method_set_msaa_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_msaa_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3330258708)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_msaa_3d (_ msaa: Viewport.MSAA) {
        #if true
        
        var copy_msaa = Int64 (msaa.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_msaa_3d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_msaa)
        
        #else
        
        var copy_msaa = Int64 (msaa.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_msaa) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_msaa_3d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_msaa_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_msaa_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2542055527)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_msaa_3d ()-> Viewport.MSAA {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_msaa_3d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.MSAA (rawValue: _result)!
    }
    
    fileprivate static var method_set_screen_space_aa: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_screen_space_aa")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3544169389)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_screen_space_aa (_ screenSpaceAa: Viewport.ScreenSpaceAA) {
        #if true
        
        var copy_screen_space_aa = Int64 (screenSpaceAa.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_screen_space_aa, UnsafeMutableRawPointer (mutating: handle), nil, &copy_screen_space_aa)
        
        #else
        
        var copy_screen_space_aa = Int64 (screenSpaceAa.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_screen_space_aa) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_screen_space_aa, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_screen_space_aa: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_screen_space_aa")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1390814124)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_screen_space_aa ()-> Viewport.ScreenSpaceAA {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_screen_space_aa, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.ScreenSpaceAA (rawValue: _result)!
    }
    
    fileprivate static var method_set_use_taa: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_taa")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_taa (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_use_taa, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_use_taa, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_taa: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_taa")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_taa ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_using_taa, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_debanding: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_debanding")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_debanding (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_use_debanding, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_use_debanding, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_debanding: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_debanding")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_debanding ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_using_debanding, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_occlusion_culling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_occlusion_culling")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_occlusion_culling (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_use_occlusion_culling, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_use_occlusion_culling, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_occlusion_culling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_occlusion_culling")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_occlusion_culling ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_using_occlusion_culling, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_debug_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_debug_draw")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1970246205)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_debug_draw (_ debugDraw: Viewport.DebugDraw) {
        #if true
        
        var copy_debug_draw = Int64 (debugDraw.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_debug_draw, UnsafeMutableRawPointer (mutating: handle), nil, &copy_debug_draw)
        
        #else
        
        var copy_debug_draw = Int64 (debugDraw.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_debug_draw) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_debug_draw, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_debug_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_debug_draw")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 579191299)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_debug_draw ()-> Viewport.DebugDraw {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_debug_draw, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.DebugDraw (rawValue: _result)!
    }
    
    fileprivate static var method_get_render_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_render_info")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 481977019)!
            }
            
        }
        
    }()
    
    /// Returns rendering statistics of the given type. See ``Viewport/RenderInfoType`` and ``Viewport/RenderInfo`` for options.
    public final func getRenderInfo (type: Viewport.RenderInfoType, info: Viewport.RenderInfo)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_type = Int64 (type.rawValue)
        var copy_info = Int64 (info.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_get_render_info, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_type, &copy_info)
        return _result
        #else
        
        var copy_type = Int64 (type.rawValue)
        var copy_info = Int64 (info.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_info) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Viewport.method_get_render_info, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_texture")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1746695840)!
            }
            
        }
        
    }()
    
    /// Returns the viewport's texture.
    /// 
    /// > Note: When trying to store the current texture (e.g. in a file), it might be completely black or outdated if used too early, especially when used in e.g. ``Node/_ready()``. To make sure the texture you get is correct, you can await [signal RenderingServer.frame_post_draw] signal.
    /// 
    public final func getTexture ()-> ViewportTexture? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_get_texture, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_physics_object_picking: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_physics_object_picking")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_physics_object_picking (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_physics_object_picking, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_physics_object_picking, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_physics_object_picking: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_physics_object_picking")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_physics_object_picking ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_get_physics_object_picking, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_physics_object_picking_sort: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_physics_object_picking_sort")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_physics_object_picking_sort (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_physics_object_picking_sort, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_physics_object_picking_sort, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_physics_object_picking_sort: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_physics_object_picking_sort")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_physics_object_picking_sort ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_get_physics_object_picking_sort, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_viewport_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_viewport_rid")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the viewport's RID from the ``RenderingServer``.
    public final func getViewportRid ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (Viewport.method_get_viewport_rid, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_push_text_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_text_input")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Helper method which calls the `set_text()` method on the currently focused ``Control``, provided that it is defined (e.g. if the focused Control is ``Button`` or ``LineEdit``).
    public final func pushTextInput (text: String) {
        #if true
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_push_text_input, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_push_text_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_push_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_input")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3644664830)!
            }
            
        }
        
    }()
    
    /// Triggers the given `event` in this ``Viewport``. This can be used to pass an ``InputEvent`` between viewports, or to locally apply inputs that were sent over the network or saved to a file.
    /// 
    /// If `inLocalCoords` is `false`, the event's position is in the embedder's coordinates and will be converted to viewport coordinates. If `inLocalCoords` is `true`, the event's position is in viewport coordinates.
    /// 
    /// While this method serves a similar purpose as ``Input/parseInputEvent(_:)``, it does not remap the specified `event` based on project settings like ``ProjectSettings/inputDevices/pointing/emulateTouchFromMouse``.
    /// 
    /// Calling this method will propagate calls to child nodes for following methods in the given order:
    /// 
    /// - ``Node/_input(event:)``
    /// 
    /// - ``Control/_guiInput(event:)`` for ``Control`` nodes
    /// 
    /// - ``Node/_shortcutInput(event:)``
    /// 
    /// - ``Node/_unhandledKeyInput(event:)``
    /// 
    /// - ``Node/_unhandledInput(event:)``
    /// 
    /// If an earlier method marks the input as handled via ``setInputAsHandled()``, any later method in this list will not be called.
    /// 
    /// If none of the methods handle the event and ``physicsObjectPicking`` is `true`, the event is used for physics object picking.
    /// 
    public final func pushInput (event: InputEvent?, inLocalCoords: Bool = false) {
        #if true
        
        var copy_in_local_coords = inLocalCoords
        var copy_event_handle = event?.handle
        
        gi.object_method_bind_ptrcall_v (Viewport.method_push_input, UnsafeMutableRawPointer (mutating: handle), nil, &copy_event_handle, &copy_in_local_coords)
        
        #else
        
        var copy_in_local_coords = inLocalCoords
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: event?.handle) { p0 in
        _args.append (event == nil ? nil : p0)
            withUnsafePointer (to: &copy_in_local_coords) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Viewport.method_push_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_push_unhandled_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("push_unhandled_input")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3644664830)!
            }
            
        }
        
    }()
    
    /// Triggers the given ``InputEvent`` in this ``Viewport``. This can be used to pass input events between viewports, or to locally apply inputs that were sent over the network or saved to a file.
    /// 
    /// If `inLocalCoords` is `false`, the event's position is in the embedder's coordinates and will be converted to viewport coordinates. If `inLocalCoords` is `true`, the event's position is in viewport coordinates.
    /// 
    /// While this method serves a similar purpose as ``Input/parseInputEvent(_:)``, it does not remap the specified `event` based on project settings like ``ProjectSettings/inputDevices/pointing/emulateTouchFromMouse``.
    /// 
    /// Calling this method will propagate calls to child nodes for following methods in the given order:
    /// 
    /// - ``Node/_shortcutInput(event:)``
    /// 
    /// - ``Node/_unhandledKeyInput(event:)``
    /// 
    /// - ``Node/_unhandledInput(event:)``
    /// 
    /// If an earlier method marks the input as handled via ``setInputAsHandled()``, any later method in this list will not be called.
    /// 
    /// If none of the methods handle the event and ``physicsObjectPicking`` is `true`, the event is used for physics object picking.
    /// 
    /// > Note: This method doesn't propagate input events to embedded ``Window``s or ``SubViewport``s.
    /// 
    /// _Deprecated._ Use ``pushInput(event:inLocalCoords:)`` instead.
    /// 
    public final func pushUnhandledInput (event: InputEvent?, inLocalCoords: Bool = false) {
        #if true
        
        var copy_in_local_coords = inLocalCoords
        var copy_event_handle = event?.handle
        
        gi.object_method_bind_ptrcall_v (Viewport.method_push_unhandled_input, UnsafeMutableRawPointer (mutating: handle), nil, &copy_event_handle, &copy_in_local_coords)
        
        #else
        
        var copy_in_local_coords = inLocalCoords
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: event?.handle) { p0 in
        _args.append (event == nil ? nil : p0)
            withUnsafePointer (to: &copy_in_local_coords) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Viewport.method_push_unhandled_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_camera_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_camera_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3551466917)!
            }
            
        }
        
    }()
    
    /// Returns the currently active 2D camera. Returns null if there are no active cameras.
    public final func getCamera2d ()-> Camera2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_get_camera_2d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_as_audio_listener_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_as_audio_listener_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_as_audio_listener_2d (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_as_audio_listener_2d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_as_audio_listener_2d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_audio_listener_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_audio_listener_2d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_audio_listener_2d ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_audio_listener_2d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_mouse_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_mouse_position")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the mouse's position in this ``Viewport`` using the coordinate system of this ``Viewport``.
    public final func getMousePosition ()-> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall (Viewport.method_get_mouse_position, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_warp_mouse: GDExtensionMethodBindPtr = {
        let methodName = StringName ("warp_mouse")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 743155724)!
            }
            
        }
        
    }()
    
    /// Moves the mouse pointer to the specified position in this ``Viewport`` using the coordinate system of this ``Viewport``.
    /// 
    /// > Note: ``warpMouse(position:)`` is only supported on Windows, macOS and Linux. It has no effect on Android, iOS and Web.
    /// 
    public final func warpMouse (position: Vector2) {
        #if true
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (Viewport.method_warp_mouse, UnsafeMutableRawPointer (mutating: handle), nil, &copy_position)
        
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_warp_mouse, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_update_mouse_cursor_state: GDExtensionMethodBindPtr = {
        let methodName = StringName ("update_mouse_cursor_state")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Force instantly updating the display based on the current mouse cursor position. This includes updating the mouse cursor shape and sending necessary [signal Control.mouse_entered], [signal CollisionObject2D.mouse_entered], [signal CollisionObject3D.mouse_entered] and [signal Window.mouse_entered] signals and their respective `mouse_exited` counterparts.
    public final func updateMouseCursorState () {
        gi.object_method_bind_ptrcall (Viewport.method_update_mouse_cursor_state, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_gui_get_drag_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("gui_get_drag_data")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1214101251)!
            }
            
        }
        
    }()
    
    /// Returns the drag data from the GUI, that was previously returned by ``Control/_getDragData(atPosition:)``.
    public final func guiGetDragData ()-> Variant {
        let _result: Variant = Variant ()
        gi.object_method_bind_ptrcall (Viewport.method_gui_get_drag_data, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_gui_is_dragging: GDExtensionMethodBindPtr = {
        let methodName = StringName ("gui_is_dragging")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the viewport is currently performing a drag operation.
    /// 
    /// Alternative to ``Node/``notificationDragBegin```` and ``Node/``notificationDragEnd```` when you prefer polling the value.
    /// 
    public final func guiIsDragging ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_gui_is_dragging, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_gui_is_drag_successful: GDExtensionMethodBindPtr = {
        let methodName = StringName ("gui_is_drag_successful")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the drag operation is successful.
    public final func guiIsDragSuccessful ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_gui_is_drag_successful, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_gui_release_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName ("gui_release_focus")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Removes the focus from the currently focused ``Control`` within this viewport. If no ``Control`` has the focus, does nothing.
    public final func guiReleaseFocus () {
        gi.object_method_bind_ptrcall (Viewport.method_gui_release_focus, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_gui_get_focus_owner: GDExtensionMethodBindPtr = {
        let methodName = StringName ("gui_get_focus_owner")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2783021301)!
            }
            
        }
        
    }()
    
    /// Returns the ``Control`` having the focus within this viewport. If no ``Control`` has the focus, returns null.
    public final func guiGetFocusOwner ()-> Control? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_gui_get_focus_owner, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_disable_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_disable_input")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_disable_input (_ disable: Bool) {
        #if true
        
        var copy_disable = disable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_disable_input, UnsafeMutableRawPointer (mutating: handle), nil, &copy_disable)
        
        #else
        
        var copy_disable = disable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_disable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_disable_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_input_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_input_disabled")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_input_disabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_input_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_positional_shadow_atlas_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_positional_shadow_atlas_size")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_positional_shadow_atlas_size (_ size: Int32) {
        #if true
        
        var copy_size: Int = Int (size)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_positional_shadow_atlas_size, UnsafeMutableRawPointer (mutating: handle), nil, &copy_size)
        
        #else
        
        var copy_size: Int = Int (size)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_positional_shadow_atlas_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_positional_shadow_atlas_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_positional_shadow_atlas_size")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_positional_shadow_atlas_size ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Viewport.method_get_positional_shadow_atlas_size, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_positional_shadow_atlas_16_bits: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_positional_shadow_atlas_16_bits")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_positional_shadow_atlas_16_bits (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_positional_shadow_atlas_16_bits, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_positional_shadow_atlas_16_bits, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_positional_shadow_atlas_16_bits: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_positional_shadow_atlas_16_bits")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_positional_shadow_atlas_16_bits ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_get_positional_shadow_atlas_16_bits, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snap_controls_to_pixels: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_snap_controls_to_pixels")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snap_controls_to_pixels (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_snap_controls_to_pixels, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_snap_controls_to_pixels, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_snap_controls_to_pixels_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_snap_controls_to_pixels_enabled")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_snap_controls_to_pixels_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_snap_controls_to_pixels_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snap_2d_transforms_to_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_snap_2d_transforms_to_pixel")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snap_2d_transforms_to_pixel (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_snap_2d_transforms_to_pixel, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_snap_2d_transforms_to_pixel, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_snap_2d_transforms_to_pixel_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_snap_2d_transforms_to_pixel_enabled")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_snap_2d_transforms_to_pixel_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_snap_2d_transforms_to_pixel_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_snap_2d_vertices_to_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_snap_2d_vertices_to_pixel")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_snap_2d_vertices_to_pixel (_ enabled: Bool) {
        #if true
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_snap_2d_vertices_to_pixel, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_snap_2d_vertices_to_pixel, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_snap_2d_vertices_to_pixel_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_snap_2d_vertices_to_pixel_enabled")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_snap_2d_vertices_to_pixel_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_snap_2d_vertices_to_pixel_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_positional_shadow_atlas_quadrant_subdiv: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_positional_shadow_atlas_quadrant_subdiv")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2596956071)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Sets the number of subdivisions to use in the specified quadrant. A higher number of subdivisions allows you to have more shadows in the scene at once, but reduces the quality of the shadows. A good practice is to have quadrants with a varying number of subdivisions and to have as few subdivisions as possible.
    fileprivate final func set_positional_shadow_atlas_quadrant_subdiv (_ quadrant: Int32, _ subdiv: Viewport.PositionalShadowAtlasQuadrantSubdiv) {
        #if true
        
        var copy_quadrant: Int = Int (quadrant)
        var copy_subdiv = Int64 (subdiv.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_positional_shadow_atlas_quadrant_subdiv, UnsafeMutableRawPointer (mutating: handle), nil, &copy_quadrant, &copy_subdiv)
        
        #else
        
        var copy_quadrant: Int = Int (quadrant)
        var copy_subdiv = Int64 (subdiv.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_quadrant) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_subdiv) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Viewport.method_set_positional_shadow_atlas_quadrant_subdiv, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_positional_shadow_atlas_quadrant_subdiv: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_positional_shadow_atlas_quadrant_subdiv")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2676778355)!
            }
            
        }
        
    }()
    
    @inline(__always)
    /// Returns the ``Viewport/PositionalShadowAtlasQuadrantSubdiv`` of the specified quadrant.
    fileprivate final func get_positional_shadow_atlas_quadrant_subdiv (_ quadrant: Int32)-> Viewport.PositionalShadowAtlasQuadrantSubdiv {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_quadrant: Int = Int (quadrant)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_get_positional_shadow_atlas_quadrant_subdiv, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_quadrant)
        return Viewport.PositionalShadowAtlasQuadrantSubdiv (rawValue: _result)!
        #else
        
        var copy_quadrant: Int = Int (quadrant)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_quadrant) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_get_positional_shadow_atlas_quadrant_subdiv, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return Viewport.PositionalShadowAtlasQuadrantSubdiv (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_input_as_handled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_input_as_handled")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Stops the input from propagating further down the ``SceneTree``.
    /// 
    /// > Note: This does not affect the methods in ``Input``, only the way events are propagated.
    /// 
    public final func setInputAsHandled () {
        gi.object_method_bind_ptrcall (Viewport.method_set_input_as_handled, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_is_input_handled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_input_handled")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns whether the current ``InputEvent`` has been handled. Input events are not handled until ``setInputAsHandled()`` has been called during the lifetime of an ``InputEvent``.
    /// 
    /// This is usually done as part of input handling methods like ``Node/_input(event:)``, ``Control/_guiInput(event:)`` or others, as well as in corresponding signal handlers.
    /// 
    /// If ``handleInputLocally`` is set to `false`, this method will try finding the first parent viewport that is set to handle input locally, and return its value for ``isInputHandled()`` instead.
    /// 
    public final func isInputHandled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_input_handled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_handle_input_locally: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_handle_input_locally")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_handle_input_locally (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_handle_input_locally, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_handle_input_locally, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_handling_input_locally: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_handling_input_locally")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_handling_input_locally ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_handling_input_locally, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_default_canvas_item_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_default_canvas_item_texture_filter")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2815160100)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_default_canvas_item_texture_filter (_ mode: Viewport.DefaultCanvasItemTextureFilter) {
        #if true
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_default_canvas_item_texture_filter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_default_canvas_item_texture_filter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_default_canvas_item_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_default_canvas_item_texture_filter")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 896601198)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_default_canvas_item_texture_filter ()-> Viewport.DefaultCanvasItemTextureFilter {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_default_canvas_item_texture_filter, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.DefaultCanvasItemTextureFilter (rawValue: _result)!
    }
    
    fileprivate static var method_set_embedding_subwindows: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_embedding_subwindows")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_embedding_subwindows (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_embedding_subwindows, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_embedding_subwindows, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_embedding_subwindows: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_embedding_subwindows")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_embedding_subwindows ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_embedding_subwindows, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_embedded_subwindows: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_embedded_subwindows")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns a list of the visible embedded ``Window``s inside the viewport.
    /// 
    /// > Note: ``Window``s inside other viewports will not be listed.
    /// 
    public final func getEmbeddedSubwindows ()-> ObjectCollection<Window> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (Viewport.method_get_embedded_subwindows, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return ObjectCollection<Window>(content: _result)
    }
    
    fileprivate static var method_set_canvas_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_canvas_cull_mask")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_canvas_cull_mask (_ mask: UInt32) {
        #if true
        
        var copy_mask: Int = Int (mask)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_canvas_cull_mask, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mask)
        
        #else
        
        var copy_mask: Int = Int (mask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mask) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_canvas_cull_mask, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_canvas_cull_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_canvas_cull_mask")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_canvas_cull_mask ()-> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall (Viewport.method_get_canvas_cull_mask, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_canvas_cull_mask_bit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_canvas_cull_mask_bit")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Set/clear individual bits on the rendering layer mask. This simplifies editing this ``Viewport``'s layers.
    public final func setCanvasCullMaskBit (layer: UInt32, enable: Bool) {
        #if true
        
        var copy_layer: Int = Int (layer)
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_canvas_cull_mask_bit, UnsafeMutableRawPointer (mutating: handle), nil, &copy_layer, &copy_enable)
        
        #else
        
        var copy_layer: Int = Int (layer)
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_layer) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Viewport.method_set_canvas_cull_mask_bit, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_canvas_cull_mask_bit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_canvas_cull_mask_bit")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns an individual bit on the rendering layer mask.
    public final func getCanvasCullMaskBit (layer: UInt32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_layer: Int = Int (layer)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_get_canvas_cull_mask_bit, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_layer)
        return _result
        #else
        
        var copy_layer: Int = Int (layer)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_layer) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_get_canvas_cull_mask_bit, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_default_canvas_item_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_default_canvas_item_texture_repeat")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1658513413)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_default_canvas_item_texture_repeat (_ mode: Viewport.DefaultCanvasItemTextureRepeat) {
        #if true
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_default_canvas_item_texture_repeat, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_default_canvas_item_texture_repeat, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_default_canvas_item_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_default_canvas_item_texture_repeat")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4049774160)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_default_canvas_item_texture_repeat ()-> Viewport.DefaultCanvasItemTextureRepeat {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_default_canvas_item_texture_repeat, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.DefaultCanvasItemTextureRepeat (rawValue: _result)!
    }
    
    fileprivate static var method_set_sdf_oversize: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_sdf_oversize")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2574159017)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_sdf_oversize (_ oversize: Viewport.SDFOversize) {
        #if true
        
        var copy_oversize = Int64 (oversize.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_sdf_oversize, UnsafeMutableRawPointer (mutating: handle), nil, &copy_oversize)
        
        #else
        
        var copy_oversize = Int64 (oversize.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_oversize) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_sdf_oversize, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_sdf_oversize: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_sdf_oversize")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2631427510)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_sdf_oversize ()-> Viewport.SDFOversize {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_sdf_oversize, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.SDFOversize (rawValue: _result)!
    }
    
    fileprivate static var method_set_sdf_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_sdf_scale")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1402773951)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_sdf_scale (_ scale: Viewport.SDFScale) {
        #if true
        
        var copy_scale = Int64 (scale.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_sdf_scale, UnsafeMutableRawPointer (mutating: handle), nil, &copy_scale)
        
        #else
        
        var copy_scale = Int64 (scale.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_scale) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_sdf_scale, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_sdf_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_sdf_scale")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3162688184)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_sdf_scale ()-> Viewport.SDFScale {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_sdf_scale, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.SDFScale (rawValue: _result)!
    }
    
    fileprivate static var method_set_mesh_lod_threshold: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_mesh_lod_threshold")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_mesh_lod_threshold (_ pixels: Double) {
        #if true
        
        var copy_pixels = pixels
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_mesh_lod_threshold, UnsafeMutableRawPointer (mutating: handle), nil, &copy_pixels)
        
        #else
        
        var copy_pixels = pixels
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_pixels) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_mesh_lod_threshold, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_mesh_lod_threshold: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_mesh_lod_threshold")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_mesh_lod_threshold ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Viewport.method_get_mesh_lod_threshold, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_world_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1400875337)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_world_3d (_ world3d: World3D?) {
        #if true
        
        var copy_world_3d_handle = world3d?.handle
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_world_3d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_world_3d_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: world3d?.handle) { p0 in
        _args.append (world3d == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_world_3d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_world_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 317588385)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_world_3d ()-> World3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_get_world_3d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_find_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("find_world_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 317588385)!
            }
            
        }
        
    }()
    
    /// Returns the first valid ``World3D`` for this viewport, searching the ``world3d`` property of itself and any Viewport ancestor.
    public final func findWorld3d ()-> World3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_find_world_3d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_use_own_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_own_world_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_own_world_3d (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_use_own_world_3d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_use_own_world_3d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_own_world_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_own_world_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_own_world_3d ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_using_own_world_3d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_camera_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_camera_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2285090890)!
            }
            
        }
        
    }()
    
    /// Returns the currently active 3D camera.
    public final func getCamera3d ()-> Camera3D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_get_camera_3d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_as_audio_listener_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_as_audio_listener_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_as_audio_listener_3d (_ enable: Bool) {
        #if true
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_as_audio_listener_3d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_as_audio_listener_3d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_audio_listener_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_audio_listener_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_audio_listener_3d ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_audio_listener_3d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_disable_3d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_disable_3d")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_disable_3d (_ disable: Bool) {
        #if true
        
        var copy_disable = disable
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_disable_3d, UnsafeMutableRawPointer (mutating: handle), nil, &copy_disable)
        
        #else
        
        var copy_disable = disable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_disable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_disable_3d, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_3d_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_3d_disabled")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_3d_disabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_3d_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_use_xr: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_xr")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_xr (_ use: Bool) {
        #if true
        
        var copy_use = use
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_use_xr, UnsafeMutableRawPointer (mutating: handle), nil, &copy_use)
        
        #else
        
        var copy_use = use
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_use) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_use_xr, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_using_xr: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_using_xr")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_using_xr ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Viewport.method_is_using_xr, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scaling_3d_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scaling_3d_mode")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1531597597)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scaling_3d_mode (_ scaling3dMode: Viewport.Scaling3DMode) {
        #if true
        
        var copy_scaling_3d_mode = Int64 (scaling3dMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_scaling_3d_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_scaling_3d_mode)
        
        #else
        
        var copy_scaling_3d_mode = Int64 (scaling3dMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_scaling_3d_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_scaling_3d_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_scaling_3d_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scaling_3d_mode")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2597660574)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scaling_3d_mode ()-> Viewport.Scaling3DMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_scaling_3d_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.Scaling3DMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_scaling_3d_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scaling_3d_scale")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scaling_3d_scale (_ scale: Double) {
        #if true
        
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_scaling_3d_scale, UnsafeMutableRawPointer (mutating: handle), nil, &copy_scale)
        
        #else
        
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_scale) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_scaling_3d_scale, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_scaling_3d_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scaling_3d_scale")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scaling_3d_scale ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Viewport.method_get_scaling_3d_scale, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_fsr_sharpness: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_fsr_sharpness")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_fsr_sharpness (_ fsrSharpness: Double) {
        #if true
        
        var copy_fsr_sharpness = fsrSharpness
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_fsr_sharpness, UnsafeMutableRawPointer (mutating: handle), nil, &copy_fsr_sharpness)
        
        #else
        
        var copy_fsr_sharpness = fsrSharpness
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_fsr_sharpness) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_fsr_sharpness, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_fsr_sharpness: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_fsr_sharpness")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_fsr_sharpness ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Viewport.method_get_fsr_sharpness, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_texture_mipmap_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_texture_mipmap_bias")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_texture_mipmap_bias (_ textureMipmapBias: Double) {
        #if true
        
        var copy_texture_mipmap_bias = textureMipmapBias
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_texture_mipmap_bias, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_mipmap_bias)
        
        #else
        
        var copy_texture_mipmap_bias = textureMipmapBias
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_texture_mipmap_bias) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_texture_mipmap_bias, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_texture_mipmap_bias: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_texture_mipmap_bias")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_texture_mipmap_bias ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (Viewport.method_get_texture_mipmap_bias, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_vrs_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_vrs_mode")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2749867817)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vrs_mode (_ mode: Viewport.VRSMode) {
        #if true
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_vrs_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_vrs_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_vrs_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_vrs_mode")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 349660525)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_vrs_mode ()-> Viewport.VRSMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Viewport.method_get_vrs_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Viewport.VRSMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_vrs_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_vrs_texture")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4051416890)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_vrs_texture (_ texture: Texture2D?) {
        #if true
        
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (Viewport.method_set_vrs_texture, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Viewport.method_set_vrs_texture, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_vrs_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_vrs_texture")
        return withUnsafePointer (to: &Viewport.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3635182373)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_vrs_texture ()-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Viewport.method_get_vrs_texture, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    // Signals 
    /// Emitted when the size of the viewport is changed, whether by resizing of window, or some other means.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sizeChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sizeChanged: SimpleSignal { SimpleSignal (target: self, signalName: "size_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ node: Control) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? Control ?? Control (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a Control node grabs keyboard focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.guiFocusChanged.connect { node in
    ///    print ("caught signal")
    /// }
    /// ```
    public var guiFocusChanged: Signal1 { Signal1 (target: self, signalName: "gui_focus_changed") }
    
}

