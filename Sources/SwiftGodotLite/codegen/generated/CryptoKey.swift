// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A cryptographic key (RSA).
/// 
/// The CryptoKey class represents a cryptographic key. Keys can be loaded and saved like any other ``Resource``.
/// 
/// They can be used to generate a self-signed ``X509Certificate`` via ``Crypto/generateSelfSignedCertificate(key:issuerName:notBefore:notAfter:)`` and as private key in ``StreamPeerTLS/acceptStream(_:serverOptions:)`` along with the appropriate certificate.
/// 
open class CryptoKey: Resource {
    override open class var godotClassName: StringName { "CryptoKey" }
    /* Methods */
    fileprivate static var method_save: GDExtensionMethodBindPtr = {
        let methodName = StringName ("save")
        return withUnsafePointer (to: &CryptoKey.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 885841341)!
            }
            
        }
        
    }()
    
    /// Saves a key to the given `path`. If `publicOnly` is `true`, only the public key will be saved.
    /// 
    /// > Note: `path` should be a "*.pub" file if `publicOnly` is `true`, a "*.key" file otherwise.
    /// 
    public final func save (path: String, publicOnly: Bool = false)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_path = GString (path)
        var copy_public_only = publicOnly
        
        gi.object_method_bind_ptrcall_v (CryptoKey.method_save, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_path.content, &copy_public_only)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_path = GString (path)
        var copy_public_only = publicOnly
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_path.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_public_only) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CryptoKey.method_save, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_load: GDExtensionMethodBindPtr = {
        let methodName = StringName ("load")
        return withUnsafePointer (to: &CryptoKey.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 885841341)!
            }
            
        }
        
    }()
    
    /// Loads a key from `path`. If `publicOnly` is `true`, only the public key will be loaded.
    /// 
    /// > Note: `path` should be a "*.pub" file if `publicOnly` is `true`, a "*.key" file otherwise.
    /// 
    public final func load (path: String, publicOnly: Bool = false)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_path = GString (path)
        var copy_public_only = publicOnly
        
        gi.object_method_bind_ptrcall_v (CryptoKey.method_load, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_path.content, &copy_public_only)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_path = GString (path)
        var copy_public_only = publicOnly
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_path.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_public_only) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CryptoKey.method_load, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_public_only: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_public_only")
        return withUnsafePointer (to: &CryptoKey.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this CryptoKey only has the public part, and not the private one.
    public final func isPublicOnly ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CryptoKey.method_is_public_only, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_save_to_string: GDExtensionMethodBindPtr = {
        let methodName = StringName ("save_to_string")
        return withUnsafePointer (to: &CryptoKey.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 32795936)!
            }
            
        }
        
    }()
    
    /// Returns a string containing the key in PEM format. If `publicOnly` is `true`, only the public key will be included.
    public final func saveToString (publicOnly: Bool = false)-> String {
        let _result = GString ()
        #if false
        
        var copy_public_only = publicOnly
        
        gi.object_method_bind_ptrcall_v (CryptoKey.method_save_to_string, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_public_only)
        return _result.description
        #else
        
        var copy_public_only = publicOnly
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_public_only) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CryptoKey.method_save_to_string, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_load_from_string: GDExtensionMethodBindPtr = {
        let methodName = StringName ("load_from_string")
        return withUnsafePointer (to: &CryptoKey.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 885841341)!
            }
            
        }
        
    }()
    
    /// Loads a key from the given `stringKey`. If `publicOnly` is `true`, only the public key will be loaded.
    public final func loadFromString (stringKey: String, publicOnly: Bool = false)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_string_key = GString (stringKey)
        var copy_public_only = publicOnly
        
        gi.object_method_bind_ptrcall_v (CryptoKey.method_load_from_string, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_string_key.content, &copy_public_only)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_string_key = GString (stringKey)
        var copy_public_only = publicOnly
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string_key.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_public_only) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CryptoKey.method_load_from_string, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
}

