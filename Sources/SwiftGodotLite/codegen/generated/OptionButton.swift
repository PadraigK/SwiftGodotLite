// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A button that brings up a dropdown with selectable options when pressed.
/// 
/// ``OptionButton`` is a type of button that brings up a dropdown with selectable items when pressed. The item selected becomes the "current" item and is displayed as the button text.
/// 
/// See also ``BaseButton`` which contains common properties and methods associated with this node.
/// 
/// > Note: The ID values used for items are limited to 32 bits, not full 64 bits of integer. This has a range of `-2^32` to `2^32 - 1`, i.e. `-2147483648` to `2147483647`.
/// 
/// > Note: The ``Button/text`` and ``Button/icon`` properties are set automatically based on the selected item. They shouldn't be changed manually.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``itemSelected``
/// - ``itemFocused``
open class OptionButton: Button {
    override open class var godotClassName: StringName { "OptionButton" }
    
    /* Properties */
    
    /// The number of items to select from.
    final public var itemCount: Int32 {
        get {
            return get_item_count ()
        }
        
        set {
            set_item_count (newValue)
        }
        
    }
    
    /// If `true`, minimum size will be determined by the longest item's text, instead of the currently selected one's.
    /// 
    /// > Note: For performance reasons, the minimum size doesn't update immediately when adding, removing or modifying items.
    /// 
    final public var fitToLongestItem: Bool {
        get {
            return is_fit_to_longest_item ()
        }
        
        set {
            set_fit_to_longest_item (newValue)
        }
        
    }
    
    /// If `true`, the currently selected item can be selected again.
    final public var allowReselect: Bool {
        get {
            return get_allow_reselect ()
        }
        
        set {
            set_allow_reselect (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_add_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_item")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2697778442)!
            }
            
        }
        
    }()
    
    /// Adds an item, with text `label` and (optionally) `id`. If no `id` is passed, the item index will be used as the item's ID. New items are appended at the end.
    public final func addItem (label: String, id: Int32 = -1) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_add_item, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_label.content, &copy_id)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_label.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OptionButton.method_add_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_icon_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_icon_item")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3781678508)!
            }
            
        }
        
    }()
    
    /// Adds an item, with a `texture` icon, text `label` and (optionally) `id`. If no `id` is passed, the item index will be used as the item's ID. New items are appended at the end.
    public final func addIconItem (texture: Texture2D?, label: String, id: Int32 = -1) {
        #if true
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_add_icon_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &gstr_label.content, &copy_id)
        
        #else
        
        let gstr_label = GString (label)
        var copy_id: Int = Int (id)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_id) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (OptionButton.method_add_icon_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_text")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the text of the item at index `idx`.
    public final func setItemText (idx: Int32, text: String) {
        #if true
        
        var copy_idx: Int = Int (idx)
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_item_text, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx, &gstr_text.content)
        
        #else
        
        var copy_idx: Int = Int (idx)
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_text.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OptionButton.method_set_item_text, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_icon")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 666127730)!
            }
            
        }
        
    }()
    
    /// Sets the icon of the item at index `idx`.
    public final func setItemIcon (idx: Int32, texture: Texture2D?) {
        #if true
        
        var copy_idx: Int = Int (idx)
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_item_icon, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx, &copy_texture_handle)
        
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: texture?.handle) { p1 in
            _args.append (texture == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (OptionButton.method_set_item_icon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_disabled")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Sets whether the item at index `idx` is disabled.
    /// 
    /// Disabled items are drawn differently in the dropdown and are not selectable by the user. If the current selected item is set as disabled, it will remain selected.
    /// 
    public final func setItemDisabled (idx: Int32, disabled: Bool) {
        #if true
        
        var copy_idx: Int = Int (idx)
        var copy_disabled = disabled
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_item_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx, &copy_disabled)
        
        #else
        
        var copy_idx: Int = Int (idx)
        var copy_disabled = disabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_disabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OptionButton.method_set_item_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_id")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the ID of the item at index `idx`.
    public final func setItemId (idx: Int32, id: Int32) {
        #if true
        
        var copy_idx: Int = Int (idx)
        var copy_id: Int = Int (id)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_item_id, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx, &copy_id)
        
        #else
        
        var copy_idx: Int = Int (idx)
        var copy_id: Int = Int (id)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OptionButton.method_set_item_id, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_metadata")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2152698145)!
            }
            
        }
        
    }()
    
    /// Sets the metadata of an item. Metadata may be of any type and can be used to store extra information about an item, such as an external string ID.
    public final func setItemMetadata (idx: Int32, metadata: Variant) {
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_item_metadata, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx, &metadata.content)
        
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &metadata.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OptionButton.method_set_item_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_tooltip")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the tooltip of the item at index `idx`.
    public final func setItemTooltip (idx: Int32, tooltip: String) {
        #if true
        
        var copy_idx: Int = Int (idx)
        let gstr_tooltip = GString (tooltip)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_item_tooltip, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx, &gstr_tooltip.content)
        
        #else
        
        var copy_idx: Int = Int (idx)
        let gstr_tooltip = GString (tooltip)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_tooltip.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OptionButton.method_set_item_tooltip, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_text")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the text of the item at index `idx`.
    public final func getItemText (idx: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_get_item_text, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_idx)
        return _result.description
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_get_item_text, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_icon")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3536238170)!
            }
            
        }
        
    }()
    
    /// Returns the icon of the item at index `idx`.
    public final func getItemIcon (idx: Int32)-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_get_item_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_idx)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_get_item_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_id")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the ID of the item at index `idx`.
    public final func getItemId (idx: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_get_item_id, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_idx)
        return _result
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_get_item_id, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_index")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the index of the item with the given `id`.
    public final func getItemIndex (id: Int32)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_id: Int = Int (id)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_get_item_index, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_id)
        return _result
        #else
        
        var copy_id: Int = Int (id)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_get_item_index, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_metadata")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4227898402)!
            }
            
        }
        
    }()
    
    /// Retrieves the metadata of an item. Metadata may be any type and can be used to store extra information about an item, such as an external string ID.
    public final func getItemMetadata (idx: Int32)-> Variant {
        let _result: Variant = Variant ()
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_get_item_metadata, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_idx)
        return _result
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_get_item_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_tooltip")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the tooltip of the item at index `idx`.
    public final func getItemTooltip (idx: Int32)-> String {
        let _result = GString ()
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_get_item_tooltip, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_idx)
        return _result.description
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_get_item_tooltip, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_is_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_item_disabled")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is disabled.
    public final func isItemDisabled (idx: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_is_item_disabled, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_idx)
        return _result
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_is_item_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_item_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_item_separator")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is marked as a separator.
    public final func isItemSeparator (idx: Int32)-> Bool {
        var _result: Bool = false
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_is_item_separator, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_idx)
        return _result
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_is_item_separator, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_add_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_separator")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3005725572)!
            }
            
        }
        
    }()
    
    /// Adds a separator to the list of items. Separators help to group items, and can optionally be given a `text` header. A separator also gets an index assigned, and is appended at the end of the item list.
    public final func addSeparator (text: String = "") {
        #if true
        
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_add_separator, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_text.content)
        
        #else
        
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_add_separator, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all the items in the ``OptionButton``.
    public final func clear () {
        gi.object_method_bind_ptrcall (OptionButton.method_clear, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_select: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Selects an item by index and makes it the current item. This will work even if the item is disabled.
    /// 
    /// Passing `-1` as the index deselects any currently selected item.
    /// 
    public final func select (idx: Int32) {
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_select, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx)
        
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_select, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selected")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    public final func getSelected ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (OptionButton.method_get_selected, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selected_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selected_id")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the ID of the selected item, or `-1` if no item is selected.
    public final func getSelectedId ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (OptionButton.method_get_selected_id, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selected_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selected_metadata")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1214101251)!
            }
            
        }
        
    }()
    
    /// Gets the metadata of the selected item. Metadata for items can be set using ``setItemMetadata(idx:metadata:)``.
    public final func getSelectedMetadata ()-> Variant {
        let _result: Variant = Variant ()
        gi.object_method_bind_ptrcall (OptionButton.method_get_selected_metadata, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_remove_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_item")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the item at index `idx`.
    public final func removeItem (idx: Int32) {
        #if true
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_remove_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx)
        
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_remove_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_popup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_popup")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 229722558)!
            }
            
        }
        
    }()
    
    /// Returns the ``PopupMenu`` contained in this button.
    /// 
    /// > Warning: This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their ``Window/visible`` property.
    /// 
    public final func getPopup ()-> PopupMenu? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (OptionButton.method_get_popup, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_show_popup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("show_popup")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Adjusts popup position and sizing for the ``OptionButton``, then shows the ``PopupMenu``. Prefer this over using `get_popup().popup()`.
    public final func showPopup () {
        gi.object_method_bind_ptrcall (OptionButton.method_show_popup, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_item_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_item_count")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_item_count (_ count: Int32) {
        #if true
        
        var copy_count: Int = Int (count)
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_item_count, UnsafeMutableRawPointer (mutating: handle), nil, &copy_count)
        
        #else
        
        var copy_count: Int = Int (count)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_count) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_set_item_count, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_count")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_item_count ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (OptionButton.method_get_item_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_has_selectable_items: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_selectable_items")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if this button contains at least one item which is not disabled, or marked as a separator.
    public final func hasSelectableItems ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (OptionButton.method_has_selectable_items, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_selectable_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selectable_item")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 894402480)!
            }
            
        }
        
    }()
    
    /// Returns the index of the first item which is not disabled, or marked as a separator. If `fromLast` is `true`, the items will be searched in reverse order.
    /// 
    /// Returns `-1` if no item is found.
    /// 
    public final func getSelectableItem (fromLast: Bool = false)-> Int32 {
        var _result: Int32 = 0
        #if true
        
        var copy_from_last = fromLast
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_get_selectable_item, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_from_last)
        return _result
        #else
        
        var copy_from_last = fromLast
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from_last) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_get_selectable_item, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_fit_to_longest_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_fit_to_longest_item")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_fit_to_longest_item (_ fit: Bool) {
        #if true
        
        var copy_fit = fit
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_fit_to_longest_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_fit)
        
        #else
        
        var copy_fit = fit
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_fit) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_set_fit_to_longest_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_fit_to_longest_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_fit_to_longest_item")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_fit_to_longest_item ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (OptionButton.method_is_fit_to_longest_item, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_reselect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_allow_reselect")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_reselect (_ allow: Bool) {
        #if true
        
        var copy_allow = allow
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_allow_reselect, UnsafeMutableRawPointer (mutating: handle), nil, &copy_allow)
        
        #else
        
        var copy_allow = allow
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_allow) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_set_allow_reselect, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_allow_reselect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_allow_reselect")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_reselect ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (OptionButton.method_get_allow_reselect, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_disable_shortcuts: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_disable_shortcuts")
        return withUnsafePointer (to: &OptionButton.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `true`, shortcuts are disabled and cannot be used to trigger the button.
    public final func setDisableShortcuts (disabled: Bool) {
        #if true
        
        var copy_disabled = disabled
        
        gi.object_method_bind_ptrcall_v (OptionButton.method_set_disable_shortcuts, UnsafeMutableRawPointer (mutating: handle), nil, &copy_disabled)
        
        #else
        
        var copy_disabled = disabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_disabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OptionButton.method_set_disable_shortcuts, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ index: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the current item has been changed by the user. The index of the item selected is passed as argument.
    /// 
    /// ``allowReselect`` must be enabled to reselect an item.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemSelected.connect { index in
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemSelected: Signal1 { Signal1 (target: self, signalName: "item_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ index: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the user navigates to an item using the ``ProjectSettings/input/uiUp`` or ``ProjectSettings/input/uiDown`` input actions. The index of the item selected is passed as argument.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemFocused.connect { index in
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemFocused: Signal2 { Signal2 (target: self, signalName: "item_focused") }
    
}

