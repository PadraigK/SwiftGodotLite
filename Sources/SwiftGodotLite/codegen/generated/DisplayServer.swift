// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A server interface for low-level window management.
/// 
/// ``DisplayServer`` handles everything related to window management. It is separated from ``OS`` as a single operating system may support multiple display servers.
/// 
/// **Headless mode:** Starting the engine with the `--headless` [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url] disables all rendering and window management functions. Most functions from ``DisplayServer`` will return dummy values in this case.
/// 
open class DisplayServer: Object {
    /// The shared instance of this class
    public static var shared: DisplayServer = {
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { ptr in
            DisplayServer (nativeHandle: gi.global_get_singleton (ptr)!)
        }
        
    }()
    
    override open class var godotClassName: StringName { "DisplayServer" }
    public enum Feature: Int64 {
        /// Display server supports global menu. This allows the application to display its menu items in the operating system's top bar. **macOS**
        case globalMenu = 0 // FEATURE_GLOBAL_MENU
        /// Display server supports multiple windows that can be moved outside of the main window. **Windows, macOS, Linux (X11)**
        case subwindows = 1 // FEATURE_SUBWINDOWS
        /// Display server supports touchscreen input. **Windows, Linux (X11), Android, iOS, Web**
        case touchscreen = 2 // FEATURE_TOUCHSCREEN
        /// Display server supports mouse input. **Windows, macOS, Linux (X11), Android, Web**
        case mouse = 3 // FEATURE_MOUSE
        /// Display server supports warping mouse coordinates to keep the mouse cursor constrained within an area, but looping when one of the edges is reached. **Windows, macOS, Linux (X11)**
        case mouseWarp = 4 // FEATURE_MOUSE_WARP
        /// Display server supports setting and getting clipboard data. See also .clipboardPrimary. **Windows, macOS, Linux (X11), Android, iOS, Web**
        case clipboard = 5 // FEATURE_CLIPBOARD
        /// Display server supports popping up a virtual keyboard when requested to input text without a physical keyboard. **Android, iOS, Web**
        case virtualKeyboard = 6 // FEATURE_VIRTUAL_KEYBOARD
        /// Display server supports setting the mouse cursor shape to be different from the default. **Windows, macOS, Linux (X11), Android, Web**
        case cursorShape = 7 // FEATURE_CURSOR_SHAPE
        /// Display server supports setting the mouse cursor shape to a custom image. **Windows, macOS, Linux (X11), Web**
        case customCursorShape = 8 // FEATURE_CUSTOM_CURSOR_SHAPE
        /// Display server supports spawning dialogs using the operating system's native look-and-feel. **macOS**
        case nativeDialog = 9 // FEATURE_NATIVE_DIALOG
        /// Display server supports [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url], which is commonly used for inputting Chinese/Japanese/Korean text. This is handled by the operating system, rather than by Godot. **Windows, macOS, Linux (X11)**
        case ime = 10 // FEATURE_IME
        /// Display server supports windows can use per-pixel transparency to make windows behind them partially or fully visible. **Windows, macOS, Linux (X11)**
        case windowTransparency = 11 // FEATURE_WINDOW_TRANSPARENCY
        /// Display server supports querying the operating system's display scale factor. This allows for _reliable_ automatic hiDPI display detection, as opposed to guessing based on the screen resolution and reported display DPI (which can be unreliable due to broken monitor EDID). **Windows, macOS**
        case hidpi = 12 // FEATURE_HIDPI
        /// Display server supports changing the window icon (usually displayed in the top-left corner). **Windows, macOS, Linux (X11)**
        case icon = 13 // FEATURE_ICON
        /// Display server supports changing the window icon (usually displayed in the top-left corner). **Windows, macOS**
        case nativeIcon = 14 // FEATURE_NATIVE_ICON
        /// Display server supports changing the screen orientation. **Android, iOS**
        case orientation = 15 // FEATURE_ORIENTATION
        /// Display server supports V-Sync status can be changed from the default (which is forced to be enabled platforms not supporting this feature). **Windows, macOS, Linux (X11)**
        case swapBuffers = 16 // FEATURE_SWAP_BUFFERS
        /// Display server supports Primary clipboard can be used. This is a different clipboard from .clipboard. **Linux (X11)**
        case clipboardPrimary = 18 // FEATURE_CLIPBOARD_PRIMARY
        /// Display server supports text-to-speech. See `tts_*` methods. **Windows, macOS, Linux (X11), Android, iOS, Web**
        case textToSpeech = 19 // FEATURE_TEXT_TO_SPEECH
        /// Display server supports expanding window content to the title. See .windowFlagExtendToTitle. **macOS**
        case extendToTitle = 20 // FEATURE_EXTEND_TO_TITLE
        /// Display server supports reading screen pixels. See ``screenGetPixel(position:)``.
        case screenCapture = 21 // FEATURE_SCREEN_CAPTURE
    }
    
    public enum MouseMode: Int64 {
        /// Makes the mouse cursor visible if it is hidden.
        case visible = 0 // MOUSE_MODE_VISIBLE
        /// Makes the mouse cursor hidden if it is visible.
        case hidden = 1 // MOUSE_MODE_HIDDEN
        /// Captures the mouse. The mouse will be hidden and its position locked at the center of the window manager's window.
        /// 
        /// > Note: If you want to process the mouse's movement in this mode, you need to use ``InputEventMouseMotion/relative``.
        /// 
        case captured = 2 // MOUSE_MODE_CAPTURED
        /// Confines the mouse cursor to the game window, and make it visible.
        case confined = 3 // MOUSE_MODE_CONFINED
        /// Confines the mouse cursor to the game window, and make it hidden.
        case confinedHidden = 4 // MOUSE_MODE_CONFINED_HIDDEN
    }
    
    public enum ScreenOrientation: Int64 {
        /// Default landscape orientation.
        case landscape = 0 // SCREEN_LANDSCAPE
        /// Default portrait orientation.
        case portrait = 1 // SCREEN_PORTRAIT
        /// Reverse landscape orientation (upside down).
        case reverseLandscape = 2 // SCREEN_REVERSE_LANDSCAPE
        /// Reverse portrait orientation (upside down).
        case reversePortrait = 3 // SCREEN_REVERSE_PORTRAIT
        /// Automatic landscape orientation (default or reverse depending on sensor).
        case sensorLandscape = 4 // SCREEN_SENSOR_LANDSCAPE
        /// Automatic portrait orientation (default or reverse depending on sensor).
        case sensorPortrait = 5 // SCREEN_SENSOR_PORTRAIT
        /// Automatic landscape or portrait orientation (default or reverse depending on sensor).
        case sensor = 6 // SCREEN_SENSOR
    }
    
    public enum VirtualKeyboardType: Int64 {
        /// Default text virtual keyboard.
        case `default` = 0 // KEYBOARD_TYPE_DEFAULT
        /// Multiline virtual keyboard.
        case multiline = 1 // KEYBOARD_TYPE_MULTILINE
        /// Virtual number keypad, useful for PIN entry.
        case number = 2 // KEYBOARD_TYPE_NUMBER
        /// Virtual number keypad, useful for entering fractional numbers.
        case numberDecimal = 3 // KEYBOARD_TYPE_NUMBER_DECIMAL
        /// Virtual phone number keypad.
        case phone = 4 // KEYBOARD_TYPE_PHONE
        /// Virtual keyboard with additional keys to assist with typing email addresses.
        case emailAddress = 5 // KEYBOARD_TYPE_EMAIL_ADDRESS
        /// Virtual keyboard for entering a password. On most platforms, this should disable autocomplete and autocapitalization.
        /// 
        /// > Note: This is not supported on Web. Instead, this behaves identically to .keyboardTypeDefault.
        /// 
        case password = 6 // KEYBOARD_TYPE_PASSWORD
        /// Virtual keyboard with additional keys to assist with typing URLs.
        case url = 7 // KEYBOARD_TYPE_URL
    }
    
    public enum CursorShape: Int64 {
        /// Arrow cursor shape. This is the default when not pointing anything that overrides the mouse cursor, such as a ``LineEdit`` or ``TextEdit``.
        case arrow = 0 // CURSOR_ARROW
        /// I-beam cursor shape. This is used by default when hovering a control that accepts text input, such as ``LineEdit`` or ``TextEdit``.
        case ibeam = 1 // CURSOR_IBEAM
        /// Pointing hand cursor shape. This is used by default when hovering a ``LinkButton`` or a URL tag in a ``RichTextLabel``.
        case pointingHand = 2 // CURSOR_POINTING_HAND
        /// Crosshair cursor. This is intended to be displayed when the user needs precise aim over an element, such as a rectangle selection tool or a color picker.
        case cross = 3 // CURSOR_CROSS
        /// Wait cursor. On most cursor themes, this displays a spinning icon _besides_ the arrow. Intended to be used for non-blocking operations (when the user can do something else at the moment). See also .cursorBusy.
        case wait = 4 // CURSOR_WAIT
        /// Wait cursor. On most cursor themes, this _replaces_ the arrow with a spinning icon. Intended to be used for blocking operations (when the user can't do anything else at the moment). See also .cursorWait.
        case busy = 5 // CURSOR_BUSY
        /// Dragging hand cursor. This is displayed during drag-and-drop operations. See also .cursorCanDrop.
        case drag = 6 // CURSOR_DRAG
        /// "Can drop" cursor. This is displayed during drag-and-drop operations if hovering over a ``Control`` that can accept the drag-and-drop event. On most cursor themes, this displays a dragging hand with an arrow symbol besides it. See also .cursorDrag.
        case canDrop = 7 // CURSOR_CAN_DROP
        /// Forbidden cursor. This is displayed during drag-and-drop operations if the hovered ``Control`` can't accept the drag-and-drop event.
        case forbidden = 8 // CURSOR_FORBIDDEN
        /// Vertical resize cursor. Intended to be displayed when the hovered ``Control`` can be vertically resized using the mouse. See also .cursorVsplit.
        case vsize = 9 // CURSOR_VSIZE
        /// Horizontal resize cursor. Intended to be displayed when the hovered ``Control`` can be horizontally resized using the mouse. See also .cursorHsplit.
        case hsize = 10 // CURSOR_HSIZE
        /// Secondary diagonal resize cursor (top-right/bottom-left). Intended to be displayed when the hovered ``Control`` can be resized on both axes at once using the mouse.
        case bdiagsize = 11 // CURSOR_BDIAGSIZE
        /// Main diagonal resize cursor (top-left/bottom-right). Intended to be displayed when the hovered ``Control`` can be resized on both axes at once using the mouse.
        case fdiagsize = 12 // CURSOR_FDIAGSIZE
        /// Move cursor. Intended to be displayed when the hovered ``Control`` can be moved using the mouse.
        case move = 13 // CURSOR_MOVE
        /// Vertical split cursor. This is displayed when hovering a ``Control`` with splits that can be vertically resized using the mouse, such as ``VSplitContainer``. On some cursor themes, this cursor may have the same appearance as .cursorVsize.
        case vsplit = 14 // CURSOR_VSPLIT
        /// Horizontal split cursor. This is displayed when hovering a ``Control`` with splits that can be horizontally resized using the mouse, such as ``HSplitContainer``. On some cursor themes, this cursor may have the same appearance as .cursorHsize.
        case hsplit = 15 // CURSOR_HSPLIT
        /// Help cursor. On most cursor themes, this displays a question mark icon instead of the mouse cursor. Intended to be used when the user has requested help on the next element that will be clicked.
        case help = 16 // CURSOR_HELP
        /// Represents the size of the ``DisplayServer/CursorShape`` enum.
        case max = 17 // CURSOR_MAX
    }
    
    public enum FileDialogMode: Int64 {
        /// The native file dialog allows selecting one, and only one file.
        case openFile = 0 // FILE_DIALOG_MODE_OPEN_FILE
        /// The native file dialog allows selecting multiple files.
        case openFiles = 1 // FILE_DIALOG_MODE_OPEN_FILES
        /// The native file dialog only allows selecting a directory, disallowing the selection of any file.
        case openDir = 2 // FILE_DIALOG_MODE_OPEN_DIR
        /// The native file dialog allows selecting one file or directory.
        case openAny = 3 // FILE_DIALOG_MODE_OPEN_ANY
        /// The native file dialog will warn when a file exists.
        case saveFile = 4 // FILE_DIALOG_MODE_SAVE_FILE
    }
    
    public enum WindowMode: Int64 {
        /// Windowed mode, i.e. ``Window`` doesn't occupy the whole screen (unless set to the size of the screen).
        case windowed = 0 // WINDOW_MODE_WINDOWED
        /// Minimized window mode, i.e. ``Window`` is not visible and available on window manager's window list. Normally happens when the minimize button is pressed.
        case minimized = 1 // WINDOW_MODE_MINIMIZED
        /// Maximized window mode, i.e. ``Window`` will occupy whole screen area except task bar and still display its borders. Normally happens when the maximize button is pressed.
        case maximized = 2 // WINDOW_MODE_MAXIMIZED
        /// Full screen mode with full multi-window support.
        /// 
        /// Full screen window covers the entire display area of a screen and has no decorations. The display's video mode is not changed.
        /// 
        /// **On Windows:** Multi-window full-screen mode has a 1px border of the ``ProjectSettings/rendering/environment/defaults/defaultClearColor`` color.
        /// 
        /// **On macOS:** A new desktop is used to display the running project.
        /// 
        /// > Note: Regardless of the platform, enabling full screen will change the window size to match the monitor's size. Therefore, make sure your project supports [url=$DOCS_URL/tutorials/rendering/multiple_resolutions.html]multiple resolutions[/url] when enabling full screen mode.
        /// 
        case fullscreen = 3 // WINDOW_MODE_FULLSCREEN
        /// A single window full screen mode. This mode has less overhead, but only one window can be open on a given screen at a time (opening a child window or application switching will trigger a full screen transition).
        /// 
        /// Full screen window covers the entire display area of a screen and has no border or decorations. The display's video mode is not changed.
        /// 
        /// **On Windows:** Depending on video driver, full screen transition might cause screens to go black for a moment.
        /// 
        /// **On macOS:** A new desktop is used to display the running project. Exclusive full screen mode prevents Dock and Menu from showing up when the mouse pointer is hovering the edge of the screen.
        /// 
        /// **On Linux (X11):** Exclusive full screen mode bypasses compositor.
        /// 
        /// > Note: Regardless of the platform, enabling full screen will change the window size to match the monitor's size. Therefore, make sure your project supports [url=$DOCS_URL/tutorials/rendering/multiple_resolutions.html]multiple resolutions[/url] when enabling full screen mode.
        /// 
        case exclusiveFullscreen = 4 // WINDOW_MODE_EXCLUSIVE_FULLSCREEN
    }
    
    public enum WindowFlags: Int64 {
        /// The window can't be resized by dragging its resize grip. It's still possible to resize the window using ``windowSetSize(_:windowId:)``. This flag is ignored for full screen windows.
        case resizeDisabled = 0 // WINDOW_FLAG_RESIZE_DISABLED
        /// The window do not have native title bar and other decorations. This flag is ignored for full-screen windows.
        case borderless = 1 // WINDOW_FLAG_BORDERLESS
        /// The window is floating on top of all other windows. This flag is ignored for full-screen windows.
        case alwaysOnTop = 2 // WINDOW_FLAG_ALWAYS_ON_TOP
        /// The window background can be transparent.
        /// 
        /// > Note: This flag has no effect if ``ProjectSettings/display/window/perPixelTransparency/allowed`` is set to `false`.
        /// 
        /// > Note: Transparency support is implemented on Linux (X11), macOS and Windows, but availability might vary depending on GPU driver, display manager, and compositor capabilities.
        /// 
        case transparent = 3 // WINDOW_FLAG_TRANSPARENT
        /// The window can't be focused. No-focus window will ignore all input, except mouse clicks.
        case noFocus = 4 // WINDOW_FLAG_NO_FOCUS
        /// Window is part of menu or ``OptionButton`` dropdown. This flag can't be changed when the window is visible. An active popup window will exclusively receive all input, without stealing focus from its parent. Popup windows are automatically closed when uses click outside it, or when an application is switched. Popup window must have transient parent set (see ``windowSetTransient(windowId:parentWindowId:)``).
        case popup = 5 // WINDOW_FLAG_POPUP
        /// Window content is expanded to the full size of the window. Unlike borderless window, the frame is left intact and can be used to resize the window, title bar is transparent, but have minimize/maximize/close buttons.
        /// 
        /// Use ``windowSetWindowButtonsOffset(_:windowId:)`` to adjust minimize/maximize/close buttons offset.
        /// 
        /// Use ``windowGetSafeTitleMargins(windowId:)`` to determine area under the title bar that is not covered by decorations.
        /// 
        /// > Note: This flag is implemented only on macOS.
        /// 
        case extendToTitle = 6 // WINDOW_FLAG_EXTEND_TO_TITLE
        /// All mouse events are passed to the underlying window of the same application.
        case mousePassthrough = 7 // WINDOW_FLAG_MOUSE_PASSTHROUGH
        /// Max value of the ``DisplayServer/WindowFlags``.
        case max = 8 // WINDOW_FLAG_MAX
    }
    
    public enum WindowEvent: Int64 {
        /// Sent when the mouse pointer enters the window.
        case mouseEnter = 0 // WINDOW_EVENT_MOUSE_ENTER
        /// Sent when the mouse pointer exits the window.
        case mouseExit = 1 // WINDOW_EVENT_MOUSE_EXIT
        /// Sent when the window grabs focus.
        case focusIn = 2 // WINDOW_EVENT_FOCUS_IN
        /// Sent when the window loses focus.
        case focusOut = 3 // WINDOW_EVENT_FOCUS_OUT
        /// Sent when the user has attempted to close the window (e.g. close button is pressed).
        case closeRequest = 4 // WINDOW_EVENT_CLOSE_REQUEST
        /// Sent when the device "Back" button is pressed.
        /// 
        /// > Note: This event is implemented only on Android.
        /// 
        case goBackRequest = 5 // WINDOW_EVENT_GO_BACK_REQUEST
        /// Sent when the window is moved to the display with different DPI, or display DPI is changed.
        /// 
        /// > Note: This flag is implemented only on macOS.
        /// 
        case dpiChange = 6 // WINDOW_EVENT_DPI_CHANGE
        /// Sent when the window title bar decoration is changed (e.g. .windowFlagExtendToTitle is set or window entered/exited full screen mode).
        /// 
        /// > Note: This flag is implemented only on macOS.
        /// 
        case titlebarChange = 7 // WINDOW_EVENT_TITLEBAR_CHANGE
    }
    
    public enum VSyncMode: Int64 {
        /// No vertical synchronization, which means the engine will display frames as fast as possible (tearing may be visible). Framerate is unlimited (notwithstanding ``Engine/maxFps``).
        case disabled = 0 // VSYNC_DISABLED
        /// Default vertical synchronization mode, the image is displayed only on vertical blanking intervals (no tearing is visible). Framerate is limited by the monitor refresh rate (notwithstanding ``Engine/maxFps``).
        case enabled = 1 // VSYNC_ENABLED
        /// Behaves like .vsyncDisabled when the framerate drops below the screen's refresh rate to reduce stuttering (tearing may be visible). Otherwise, vertical synchronization is enabled to avoid tearing. Framerate is limited by the monitor refresh rate (notwithstanding ``Engine/maxFps``). Behaves like .vsyncEnabled when using the Compatibility rendering method.
        case adaptive = 2 // VSYNC_ADAPTIVE
        /// Displays the most recent image in the queue on vertical blanking intervals, while rendering to the other images (no tearing is visible). Framerate is unlimited (notwithstanding ``Engine/maxFps``).
        /// 
        /// Although not guaranteed, the images can be rendered as fast as possible, which may reduce input lag (also called "Fast" V-Sync mode). .vsyncMailbox works best when at least twice as many frames as the display refresh rate are rendered. Behaves like .vsyncEnabled when using the Compatibility rendering method.
        /// 
        case mailbox = 3 // VSYNC_MAILBOX
    }
    
    public enum HandleType: Int64 {
        /// Display handle:
        /// 
        /// - Linux (X11): `X11::Display*` for the display.
        /// 
        /// - Android: `EGLDisplay` for the display.
        /// 
        case displayHandle = 0 // DISPLAY_HANDLE
        /// Window handle:
        /// 
        /// - Windows: `HWND` for the window.
        /// 
        /// - Linux (X11): `X11::Window*` for the window.
        /// 
        /// - macOS: `NSWindow*` for the window.
        /// 
        /// - iOS: `UIViewController*` for the view controller.
        /// 
        /// - Android: `jObject` for the activity.
        /// 
        case windowHandle = 1 // WINDOW_HANDLE
        /// Window view:
        /// 
        /// - Windows: `HDC` for the window (only with the GL Compatibility renderer).
        /// 
        /// - macOS: `NSView*` for the window main view.
        /// 
        /// - iOS: `UIView*` for the window main view.
        /// 
        case windowView = 2 // WINDOW_VIEW
        /// OpenGL context (only with the GL Compatibility renderer):
        /// 
        /// - Windows: `HGLRC` for the window (native GL), or `EGLContext` for the window (ANGLE).
        /// 
        /// - Linux: `GLXContext*` for the window.
        /// 
        /// - macOS: `NSOpenGLContext*` for the window (native GL), or `EGLContext` for the window (ANGLE).
        /// 
        /// - Android: `EGLContext` for the window.
        /// 
        case openglContext = 3 // OPENGL_CONTEXT
    }
    
    public enum TTSUtteranceEvent: Int64 {
        /// Utterance has begun to be spoken.
        case started = 0 // TTS_UTTERANCE_STARTED
        /// Utterance was successfully finished.
        case ended = 1 // TTS_UTTERANCE_ENDED
        /// Utterance was canceled, or TTS service was unable to process it.
        case canceled = 2 // TTS_UTTERANCE_CANCELED
        /// Utterance reached a word or sentence boundary.
        case boundary = 3 // TTS_UTTERANCE_BOUNDARY
    }
    
    /* Constants */
    /// Represents the screen containing the mouse pointer.
    public static let screenWithMouseFocus = -4
    /// Represents the screen containing the window with the keyboard focus.
    public static let screenWithKeyboardFocus = -3
    /// Represents the primary screen.
    public static let screenPrimary = -2
    /// Represents the screen where the main window is located. This is usually the default value in functions that allow specifying one of several screens.
    public static let screenOfMainWindow = -1
    /// The ID of the main window spawned by the engine, which can be passed to methods expecting a `window_id`.
    public static let mainWindowId = 0
    /// The ID that refers to a nonexisting window. This is be returned by some ``DisplayServer`` methods if no window matches the requested result.
    public static let invalidWindowId = -1
    /* Methods */
    fileprivate static var method_has_feature: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_feature")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 334065950)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the specified `feature` is supported by the current ``DisplayServer``, `false` otherwise.
    public static func hasFeature (_ feature: DisplayServer.Feature)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_feature = Int64 (feature.rawValue)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_has_feature, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_feature)
        return _result
        #else
        
        var copy_feature = Int64 (feature.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_feature) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_has_feature, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_name")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the name of the ``DisplayServer`` currently in use. Most operating systems only have a single ``DisplayServer``, but Linux has access to more than one ``DisplayServer`` (although only X11 is currently implemented in Godot).
    /// 
    /// The names of built-in display servers are `Windows`, `macOS`, `X11` (Linux), `Android`, `iOS`, `web` (HTML5) and `headless` (when started with the `--headless` [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url]).
    /// 
    public static func getName ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (DisplayServer.method_get_name, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_global_menu_set_popup_callbacks: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_popup_callbacks")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3893727526)!
            }
            
        }
        
    }()
    
    /// Registers callables to emit when the menu is respectively about to show or closed.
    public static func globalMenuSetPopupCallbacks (menuRoot: String, openCallback: Callable, closeCallback: Callable) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_popup_callbacks, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &openCallback.content, &closeCallback.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &openCallback.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &closeCallback.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_popup_callbacks, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_submenu_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_submenu_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2828985934)!
            }
            
        }
        
    }()
    
    /// Adds an item that will act as a submenu of the global menu `menuRoot`. The `submenu` argument is the ID of the global menu root that will be shown when the item is clicked.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddSubmenuItem (menuRoot: String, label: String, submenu: String, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        let gstr_submenu = GString (submenu)
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_submenu_item, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &gstr_label.content, &gstr_submenu.content, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        let gstr_submenu = GString (submenu)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &gstr_submenu.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_index) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_submenu_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3401266716)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label` to the global menu with ID `menuRoot`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddItem (menuRoot: String, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant, accelerator: Key = .none, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_item, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &gstr_label.content, &callback.content, &keyCallback.content, &tag.content, &copy_accelerator, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &callback.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &keyCallback.content) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &tag.content) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &copy_accelerator) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &copy_index) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                                    return _result
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_check_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3401266716)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item with text `label` to the global menu with ID `menuRoot`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddCheckItem (menuRoot: String, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant, accelerator: Key = .none, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_check_item, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &gstr_label.content, &callback.content, &keyCallback.content, &tag.content, &copy_accelerator, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &callback.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &keyCallback.content) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &tag.content) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &copy_accelerator) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &copy_index) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_check_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                                    return _result
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_icon_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_icon_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4245856523)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label` and icon `icon` to the global menu with ID `menuRoot`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddIconItem (menuRoot: String, icon: Texture2D?, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant, accelerator: Key = .none, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_icon_item, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_icon_handle, &gstr_label.content, &callback.content, &keyCallback.content, &tag.content, &copy_accelerator, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
                return withUnsafePointer (to: &gstr_label.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &callback.content) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &keyCallback.content) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &tag.content) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &copy_accelerator) { p6 in
                                    _args.append (p6)
                                    return withUnsafePointer (to: &copy_index) { p7 in
                                        _args.append (p7)
        
                                        gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_icon_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                                        return _result
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_icon_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_icon_check_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4245856523)!
            }
            
        }
        
    }()
    
    /// Adds a new checkable item with text `label` and icon `icon` to the global menu with ID `menuRoot`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddIconCheckItem (menuRoot: String, icon: Texture2D?, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant, accelerator: Key = .none, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_icon_check_item, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_icon_handle, &gstr_label.content, &callback.content, &keyCallback.content, &tag.content, &copy_accelerator, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
                return withUnsafePointer (to: &gstr_label.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &callback.content) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &keyCallback.content) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &tag.content) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &copy_accelerator) { p6 in
                                    _args.append (p6)
                                    return withUnsafePointer (to: &copy_index) { p7 in
                                        _args.append (p7)
        
                                        gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_icon_check_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                                        return _result
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_radio_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_radio_check_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3401266716)!
            }
            
        }
        
    }()
    
    /// Adds a new radio-checkable item with text `label` to the global menu with ID `menuRoot`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``globalMenuSetItemChecked(menuRoot:idx:checked:)`` for more info on how to control it.
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddRadioCheckItem (menuRoot: String, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant, accelerator: Key = .none, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_radio_check_item, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &gstr_label.content, &callback.content, &keyCallback.content, &tag.content, &copy_accelerator, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &callback.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &keyCallback.content) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &tag.content) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &copy_accelerator) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &copy_index) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_radio_check_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                                    return _result
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_icon_radio_check_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_icon_radio_check_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4245856523)!
            }
            
        }
        
    }()
    
    /// Adds a new radio-checkable item with text `label` and icon `icon` to the global menu with ID `menuRoot`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See ``globalMenuSetItemChecked(menuRoot:idx:checked:)`` for more info on how to control it.
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddIconRadioCheckItem (menuRoot: String, icon: Texture2D?, label: String, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant, accelerator: Key = .none, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_icon_radio_check_item, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_icon_handle, &gstr_label.content, &callback.content, &keyCallback.content, &tag.content, &copy_accelerator, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
                return withUnsafePointer (to: &gstr_label.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &callback.content) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &keyCallback.content) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &tag.content) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &copy_accelerator) { p6 in
                                    _args.append (p6)
                                    return withUnsafePointer (to: &copy_index) { p7 in
                                        _args.append (p7)
        
                                        gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_icon_radio_check_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                                        return _result
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_multistate_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_multistate_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3431222859)!
            }
            
        }
        
    }()
    
    /// Adds a new item with text `label` to the global menu with ID `menuRoot`.
    /// 
    /// Contrarily to normal binary items, multistate items can have more than two states, as defined by `maxStates`. Each press or activate of the item will increase the state by one. The default value is defined by `defaultState`.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: By default, there's no indication of the current item state, it should be changed manually.
    /// 
    /// > Note: The `callback` and `keyCallback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddMultistateItem (menuRoot: String, label: String, maxStates: Int32, defaultState: Int32, callback: Callable = Callable(), keyCallback: Callable = Callable(), tag: Variant, accelerator: Key = .none, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_max_states: Int = Int (maxStates)
        var copy_default_state: Int = Int (defaultState)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_multistate_item, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &gstr_label.content, &copy_max_states, &copy_default_state, &callback.content, &keyCallback.content, &tag.content, &copy_accelerator, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_label = GString (label)
        var copy_max_states: Int = Int (maxStates)
        var copy_default_state: Int = Int (defaultState)
        var copy_accelerator = Int64 (accelerator.rawValue)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_label.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_max_states) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_default_state) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &callback.content) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &keyCallback.content) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &tag.content) { p6 in
                                    _args.append (p6)
                                    return withUnsafePointer (to: &copy_accelerator) { p7 in
                                        _args.append (p7)
                                        return withUnsafePointer (to: &copy_index) { p8 in
                                            _args.append (p8)
        
                                            gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_multistate_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                                            return _result
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_add_separator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_add_separator")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3214812433)!
            }
            
        }
        
    }()
    
    /// Adds a separator between items to the global menu with ID `menuRoot`. Separators also occupy an index.
    /// 
    /// Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuAddSeparator (menuRoot: String, index: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_add_separator, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_index)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_add_separator, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_index_from_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_index_from_text")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2878152881)!
            }
            
        }
        
    }()
    
    /// Returns the index of the item with the specified `text`. Index is automatically assigned to each item by the engine. Index can not be set manually.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemIndexFromText (menuRoot: String, text: String)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_index_from_text, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &gstr_text.content)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_text.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_index_from_text, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_index_from_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_index_from_tag")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2941063483)!
            }
            
        }
        
    }()
    
    /// Returns the index of the item with the specified `tag`. Index is automatically assigned to each item by the engine. Index can not be set manually.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemIndexFromTag (menuRoot: String, tag: Variant)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_index_from_tag, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &tag.content)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &tag.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_index_from_tag, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_is_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_is_item_checked")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3511468594)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is checked.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuIsItemChecked (menuRoot: String, idx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_is_item_checked, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_is_item_checked, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_is_item_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_is_item_checkable")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3511468594)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is checkable in some way, i.e. if it has a checkbox or radio button.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuIsItemCheckable (menuRoot: String, idx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_is_item_checkable, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_is_item_checkable, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_is_item_radio_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_is_item_radio_checkable")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3511468594)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` has radio button-style checkability.
    /// 
    /// > Note: This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuIsItemRadioCheckable (menuRoot: String, idx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_is_item_radio_checkable, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_is_item_radio_checkable, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 748666903)!
            }
            
        }
        
    }()
    
    /// Returns the callback of the item at index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemCallback (menuRoot: String, idx: Int32)-> Callable {
        let _result: Callable = Callable ()
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_key_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_key_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 748666903)!
            }
            
        }
        
    }()
    
    /// Returns the callback of the item accelerator at index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemKeyCallback (menuRoot: String, idx: Int32)-> Callable {
        let _result: Callable = Callable ()
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_key_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_key_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_tag")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 330672633)!
            }
            
        }
        
    }()
    
    /// Returns the metadata of the specified item, which might be of any type. You can set it with ``globalMenuSetItemTag(menuRoot:idx:tag:)``, which provides a simple way of assigning context data to items.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemTag (menuRoot: String, idx: Int32)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_tag, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_tag, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_text")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 591067909)!
            }
            
        }
        
    }()
    
    /// Returns the text of the item at index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemText (menuRoot: String, idx: Int32)-> String {
        let _result = GString ()
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_text, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &gstr_menu_root.content, &copy_idx)
        return _result.description
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_text, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_submenu")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 591067909)!
            }
            
        }
        
    }()
    
    /// Returns the submenu ID of the item at index `idx`. See ``globalMenuAddSubmenuItem(menuRoot:label:submenu:index:)`` for more info on how to add a submenu.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemSubmenu (menuRoot: String, idx: Int32)-> String {
        let _result = GString ()
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_submenu, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &gstr_menu_root.content, &copy_idx)
        return _result.description
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_submenu, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_accelerator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_accelerator")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 936065394)!
            }
            
        }
        
    }()
    
    /// Returns the accelerator of the item at index `idx`. Accelerators are special combinations of keys that activate the item, no matter which control is focused.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemAccelerator (menuRoot: String, idx: Int32)-> Key {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_accelerator, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return Key (rawValue: _result)!
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_accelerator, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return Key (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_is_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_is_item_disabled")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3511468594)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is disabled. When it is disabled it can't be selected, or its action invoked.
    /// 
    /// See ``globalMenuSetItemDisabled(menuRoot:idx:disabled:)`` for more info on how to disable an item.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuIsItemDisabled (menuRoot: String, idx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_is_item_disabled, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_is_item_disabled, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_is_item_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_is_item_hidden")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3511468594)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the item at index `idx` is hidden.
    /// 
    /// See ``globalMenuSetItemHidden(menuRoot:idx:hidden:)`` for more info on how to hide an item.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuIsItemHidden (menuRoot: String, idx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_is_item_hidden, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_is_item_hidden, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_tooltip")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 591067909)!
            }
            
        }
        
    }()
    
    /// Returns the tooltip associated with the specified index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemTooltip (menuRoot: String, idx: Int32)-> String {
        let _result = GString ()
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_tooltip, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &gstr_menu_root.content, &copy_idx)
        return _result.description
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_tooltip, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_state: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_state")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3422818498)!
            }
            
        }
        
    }()
    
    /// Returns the state of a multistate item. See ``globalMenuAddMultistateItem(menuRoot:label:maxStates:defaultState:callback:keyCallback:tag:accelerator:index:)`` for details.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemState (menuRoot: String, idx: Int32)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_state, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_state, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_max_states: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_max_states")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3422818498)!
            }
            
        }
        
    }()
    
    /// Returns number of states of a multistate item. See ``globalMenuAddMultistateItem(menuRoot:label:maxStates:defaultState:callback:keyCallback:tag:accelerator:index:)`` for details.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemMaxStates (menuRoot: String, idx: Int32)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_max_states, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_max_states, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_icon")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3591713183)!
            }
            
        }
        
    }()
    
    /// Returns the icon of the item at index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemIcon (menuRoot: String, idx: Int32)-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_icon, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_icon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_indentation_level: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_indentation_level")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3422818498)!
            }
            
        }
        
    }()
    
    /// Returns the horizontal offset of the item at the given `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemIndentationLevel (menuRoot: String, idx: Int32)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_indentation_level, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content, &copy_idx)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_indentation_level, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_checked: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_checked")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4108344793)!
            }
            
        }
        
    }()
    
    /// Sets the checkstate status of the item at index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemChecked (menuRoot: String, idx: Int32, checked: Bool) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_checked = checked
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_checked, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_checked)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_checked = checked
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_checked) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_checked, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_checkable")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4108344793)!
            }
            
        }
        
    }()
    
    /// Sets whether the item at index `idx` has a checkbox. If `false`, sets the type of the item to plain text.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemCheckable (menuRoot: String, idx: Int32, checkable: Bool) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_checkable = checkable
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_checkable, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_checkable)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_checkable = checkable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_checkable) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_checkable, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_radio_checkable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_radio_checkable")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4108344793)!
            }
            
        }
        
    }()
    
    /// Sets the type of the item at the specified index `idx` to radio button. If `false`, sets the type of the item to plain text.
    /// 
    /// > Note: This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemRadioCheckable (menuRoot: String, idx: Int32, checkable: Bool) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_checkable = checkable
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_radio_checkable, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_checkable)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_checkable = checkable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_checkable) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_radio_checkable, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3809915389)!
            }
            
        }
        
    }()
    
    /// Sets the callback of the item at index `idx`. Callback is emitted when an item is pressed.
    /// 
    /// > Note: The `callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemCallback (menuRoot: String, idx: Int32, callback: Callable) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &callback.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &callback.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_hover_callbacks: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_hover_callbacks")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3809915389)!
            }
            
        }
        
    }()
    
    /// Sets the callback of the item at index `idx`. The callback is emitted when an item is hovered.
    /// 
    /// > Note: The `callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemHoverCallbacks (menuRoot: String, idx: Int32, callback: Callable) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_hover_callbacks, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &callback.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &callback.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_hover_callbacks, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_key_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_key_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3809915389)!
            }
            
        }
        
    }()
    
    /// Sets the callback of the item at index `idx`. Callback is emitted when its accelerator is activated.
    /// 
    /// > Note: The `keyCallback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemKeyCallback (menuRoot: String, idx: Int32, keyCallback: Callable) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_key_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &keyCallback.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &keyCallback.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_key_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_tag")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 453659863)!
            }
            
        }
        
    }()
    
    /// Sets the metadata of an item, which may be of any type. You can later get it with ``globalMenuGetItemTag(menuRoot:idx:)``, which provides a simple way of assigning context data to items.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemTag (menuRoot: String, idx: Int32, tag: Variant) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_tag, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &tag.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &tag.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_tag, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_text")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 965966136)!
            }
            
        }
        
    }()
    
    /// Sets the text of the item at index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemText (menuRoot: String, idx: Int32, text: String) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_text, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &gstr_text.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_text.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_text, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_submenu: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_submenu")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 965966136)!
            }
            
        }
        
    }()
    
    /// Sets the submenu of the item at index `idx`. The submenu is the ID of a global menu root that would be shown when the item is clicked.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemSubmenu (menuRoot: String, idx: Int32, submenu: String) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        let gstr_submenu = GString (submenu)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_submenu, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &gstr_submenu.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        let gstr_submenu = GString (submenu)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_submenu.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_submenu, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_accelerator: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_accelerator")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 566943293)!
            }
            
        }
        
    }()
    
    /// Sets the accelerator of the item at index `idx`. `keycode` can be a single ``Key``, or a combination of ``KeyModifierMask``s and ``Key``s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` ([kbd]Ctrl + A[/kbd]).
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemAccelerator (menuRoot: String, idx: Int32, keycode: Key) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_keycode = Int64 (keycode.rawValue)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_accelerator, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_keycode)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_keycode = Int64 (keycode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_keycode) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_accelerator, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_disabled")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4108344793)!
            }
            
        }
        
    }()
    
    /// Enables/disables the item at index `idx`. When it is disabled, it can't be selected and its action can't be invoked.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemDisabled (menuRoot: String, idx: Int32, disabled: Bool) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_disabled = disabled
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_disabled, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_disabled)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_disabled = disabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_disabled) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_disabled, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_hidden")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4108344793)!
            }
            
        }
        
    }()
    
    /// Hides/shows the item at index `idx`. When it is hidden, an item does not appear in a menu and its action cannot be invoked.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemHidden (menuRoot: String, idx: Int32, hidden: Bool) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_hidden = hidden
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_hidden, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_hidden)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_hidden = hidden
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_hidden) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_hidden, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_tooltip: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_tooltip")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 965966136)!
            }
            
        }
        
    }()
    
    /// Sets the ``String`` tooltip of the item at the specified index `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemTooltip (menuRoot: String, idx: Int32, tooltip: String) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        let gstr_tooltip = GString (tooltip)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_tooltip, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &gstr_tooltip.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        let gstr_tooltip = GString (tooltip)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_tooltip.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_tooltip, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_state: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_state")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3474840532)!
            }
            
        }
        
    }()
    
    /// Sets the state of a multistate item. See ``globalMenuAddMultistateItem(menuRoot:label:maxStates:defaultState:callback:keyCallback:tag:accelerator:index:)`` for details.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemState (menuRoot: String, idx: Int32, state: Int32) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_state: Int = Int (state)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_state, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_state)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_state: Int = Int (state)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_state) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_state, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_max_states: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_max_states")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3474840532)!
            }
            
        }
        
    }()
    
    /// Sets number of state of a multistate item. See ``globalMenuAddMultistateItem(menuRoot:label:maxStates:defaultState:callback:keyCallback:tag:accelerator:index:)`` for details.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemMaxStates (menuRoot: String, idx: Int32, maxStates: Int32) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_max_states: Int = Int (maxStates)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_max_states, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_max_states)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_max_states: Int = Int (maxStates)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_max_states) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_max_states, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_icon")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3201338066)!
            }
            
        }
        
    }()
    
    /// Replaces the ``Texture2D`` icon of the specified `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// > Note: This method is not supported by macOS "_dock" menu items.
    /// 
    public static func globalMenuSetItemIcon (menuRoot: String, idx: Int32, icon: Texture2D?) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_icon, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_icon_handle)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: icon?.handle) { p2 in
                _args.append (icon == nil ? nil : p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_icon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_set_item_indentation_level: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_set_item_indentation_level")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3474840532)!
            }
            
        }
        
    }()
    
    /// Sets the horizontal offset of the item at the given `idx`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuSetItemIndentationLevel (menuRoot: String, idx: Int32, level: Int32) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_level: Int = Int (level)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_set_item_indentation_level, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx, &copy_level)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var copy_level: Int = Int (level)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_level) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_set_item_indentation_level, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_get_item_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_get_item_count")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1321353865)!
            }
            
        }
        
    }()
    
    /// Returns number of items in the global menu with ID `menuRoot`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuGetItemCount (menuRoot: String)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_get_item_count, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_menu_root.content)
        return _result
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_get_item_count, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_remove_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_remove_item")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2956805083)!
            }
            
        }
        
    }()
    
    /// Removes the item at index `idx` from the global menu `menuRoot`.
    /// 
    /// > Note: The indices of items after the removed item will be shifted by one.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func globalMenuRemoveItem (menuRoot: String, idx: Int32) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_remove_item, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content, &copy_idx)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_idx) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_remove_item, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_global_menu_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("global_menu_clear")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Removes all items from the global menu with ID `menuRoot`.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    /// **Supported system menu IDs:**
    /// 
    public static func globalMenuClear (menuRoot: String) {
        #if false
        
        let gstr_menu_root = GString (menuRoot)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_global_menu_clear, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_menu_root.content)
        
        #else
        
        let gstr_menu_root = GString (menuRoot)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_menu_root.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_global_menu_clear, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_tts_is_speaking: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_is_speaking")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the synthesizer is generating speech, or have utterance waiting in the queue.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsIsSpeaking ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_tts_is_speaking, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_tts_is_paused: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_is_paused")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the synthesizer is in a paused state.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsIsPaused ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_tts_is_paused, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_tts_get_voices: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_get_voices")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns an ``GArray`` of voice information dictionaries.
    /// 
    /// Each ``GDictionary`` contains two ``String`` entries:
    /// 
    /// - `name` is voice name.
    /// 
    /// - `id` is voice identifier.
    /// 
    /// - `language` is language code in `lang_Variant` format. The `lang` part is a 2 or 3-letter code based on the ISO-639 standard, in lowercase. The [code skip-lint]Variant` part is an engine-dependent string describing country, region or/and dialect.
    /// 
    /// Note that Godot depends on system libraries for text-to-speech functionality. These libraries are installed by default on Windows and macOS, but not on all Linux distributions. If they are not present, this method will return an empty list. This applies to both Godot users on Linux, as well as end-users on Linux running Godot games that use text-to-speech.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsGetVoices ()-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_tts_get_voices, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return VariantCollection<GDictionary>(content: _result)
    }
    
    fileprivate static var method_tts_get_voices_for_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_get_voices_for_language")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4291131558)!
            }
            
        }
        
    }()
    
    /// Returns an ``PackedStringArray`` of voice identifiers for the `language`.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsGetVoicesForLanguage (_ language: String)-> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        #if false
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_tts_get_voices_for_language, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &gstr_language.content)
        return _result
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_language.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_tts_get_voices_for_language, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_tts_speak: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_speak")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 903992738)!
            }
            
        }
        
    }()
    
    /// Adds an utterance to the queue. If `interrupt` is `true`, the queue is cleared first.
    /// 
    /// - `voice` identifier is one of the `"id"` values returned by ``ttsGetVoices()`` or one of the values returned by ``ttsGetVoicesForLanguage(_:)``.
    /// 
    /// - `volume` ranges from `0` (lowest) to `100` (highest).
    /// 
    /// - `pitch` ranges from `0.0` (lowest) to `2.0` (highest), `1.0` is default pitch for the current voice.
    /// 
    /// - `rate` ranges from `0.1` (lowest) to `10.0` (highest), `1.0` is a normal speaking rate. Other values act as a percentage relative.
    /// 
    /// - `utteranceId` is passed as a parameter to the callback functions.
    /// 
    /// > Note: On Windows and Linux (X11), utterance `text` can use SSML markup. SSML support is engine and voice dependent. If the engine does not support SSML, you should strip out all XML markup before calling ``ttsSpeak(text:voice:volume:pitch:rate:utteranceId:interrupt:)``.
    /// 
    /// > Note: The granularity of pitch, rate, and volume is engine and voice dependent. Values may be truncated.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsSpeak (text: String, voice: String, volume: Int32 = 50, pitch: Double = 1.0, rate: Double = 1.0, utteranceId: Int32 = 0, interrupt: Bool = false) {
        #if false
        
        let gstr_text = GString (text)
        let gstr_voice = GString (voice)
        var copy_volume: Int = Int (volume)
        var copy_pitch = pitch
        var copy_rate = rate
        var copy_utterance_id: Int = Int (utteranceId)
        var copy_interrupt = interrupt
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_tts_speak, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_text.content, &gstr_voice.content, &copy_volume, &copy_pitch, &copy_rate, &copy_utterance_id, &copy_interrupt)
        
        #else
        
        let gstr_text = GString (text)
        let gstr_voice = GString (voice)
        var copy_volume: Int = Int (volume)
        var copy_pitch = pitch
        var copy_rate = rate
        var copy_utterance_id: Int = Int (utteranceId)
        var copy_interrupt = interrupt
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_text.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_voice.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_volume) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_pitch) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_rate) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_utterance_id) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_interrupt) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (DisplayServer.method_tts_speak, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_tts_pause: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_pause")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Puts the synthesizer into a paused state.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsPause () {
        gi.object_method_bind_ptrcall (DisplayServer.method_tts_pause, UnsafeMutableRawPointer (mutating: shared.handle), nil, nil)
    }
    
    fileprivate static var method_tts_resume: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_resume")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Resumes the synthesizer if it was paused.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsResume () {
        gi.object_method_bind_ptrcall (DisplayServer.method_tts_resume, UnsafeMutableRawPointer (mutating: shared.handle), nil, nil)
    }
    
    fileprivate static var method_tts_stop: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_stop")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Stops synthesis in progress and removes all utterances from the queue.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsStop () {
        gi.object_method_bind_ptrcall (DisplayServer.method_tts_stop, UnsafeMutableRawPointer (mutating: shared.handle), nil, nil)
    }
    
    fileprivate static var method_tts_set_utterance_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tts_set_utterance_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 109679083)!
            }
            
        }
        
    }()
    
    /// Adds a callback, which is called when the utterance has started, finished, canceled or reached a text boundary.
    /// 
    /// - .ttsUtteranceStarted, .ttsUtteranceEnded, and .ttsUtteranceCanceled callable's method should take one integer parameter, the utterance ID.
    /// 
    /// - .ttsUtteranceBoundary callable's method should take two integer parameters, the index of the character and the utterance ID.
    /// 
    /// > Note: The granularity of the boundary callbacks is engine dependent.
    /// 
    /// > Note: This method is implemented on Android, iOS, Web, Linux (X11), macOS, and Windows.
    /// 
    /// > Note: ``ProjectSettings/audio/general/textToSpeech`` should be `true` to use text-to-speech.
    /// 
    public static func ttsSetUtteranceCallback (event: DisplayServer.TTSUtteranceEvent, callable: Callable) {
        #if false
        
        var copy_event = Int64 (event.rawValue)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_tts_set_utterance_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_event, &callable.content)
        
        #else
        
        var copy_event = Int64 (event.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_event) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &callable.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_tts_set_utterance_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_dark_mode_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_dark_mode_supported")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if OS supports dark mode.
    /// 
    /// > Note: This method is implemented on Android, iOS, macOS, Windows, and Linux (X11).
    /// 
    public static func isDarkModeSupported ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_is_dark_mode_supported, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_dark_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_dark_mode")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if OS is using dark mode.
    /// 
    /// > Note: This method is implemented on Android, iOS, macOS, Windows, and Linux (X11).
    /// 
    public static func isDarkMode ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_is_dark_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_accent_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_accent_color")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3444240500)!
            }
            
        }
        
    }()
    
    /// Returns OS theme accent color. Returns `Color(0, 0, 0, 0)`, if accent color is unknown.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func getAccentColor ()-> Color {
        var _result: Color = Color ()
        gi.object_method_bind_ptrcall (DisplayServer.method_get_accent_color, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_mouse_set_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mouse_set_mode")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 348288463)!
            }
            
        }
        
    }()
    
    /// Sets the current mouse mode. See also ``mouseGetMode()``.
    public static func mouseSetMode (mouseMode: DisplayServer.MouseMode) {
        #if false
        
        var copy_mouse_mode = Int64 (mouseMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_mouse_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_mouse_mode)
        
        #else
        
        var copy_mouse_mode = Int64 (mouseMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mouse_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_mouse_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_mouse_get_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mouse_get_mode")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1353961651)!
            }
            
        }
        
    }()
    
    /// Returns the current mouse mode. See also ``mouseSetMode(mouseMode:)``.
    public static func mouseGetMode ()-> DisplayServer.MouseMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (DisplayServer.method_mouse_get_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return DisplayServer.MouseMode (rawValue: _result)!
    }
    
    fileprivate static var method_warp_mouse: GDExtensionMethodBindPtr = {
        let methodName = StringName ("warp_mouse")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1130785943)!
            }
            
        }
        
    }()
    
    /// Sets the mouse cursor position to the given `position` relative to an origin at the upper left corner of the currently focused game Window Manager window.
    /// 
    /// > Note: ``warpMouse(position:)`` is only supported on Windows, macOS and Linux. It has no effect on Android, iOS and Web.
    /// 
    public static func warpMouse (position: Vector2i) {
        #if false
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_warp_mouse, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_position)
        
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_warp_mouse, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_mouse_get_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mouse_get_position")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    /// Returns the mouse cursor's current position in screen coordinates.
    public static func mouseGetPosition ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (DisplayServer.method_mouse_get_position, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_mouse_get_button_state: GDExtensionMethodBindPtr = {
        let methodName = StringName ("mouse_get_button_state")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2512161324)!
            }
            
        }
        
    }()
    
    /// Returns the current state of mouse buttons (whether each button is pressed) as a bitmask. If multiple mouse buttons are pressed at the same time, the bits are added together. Equivalent to ``Input/getMouseButtonMask()``.
    public static func mouseGetButtonState ()-> MouseButtonMask {
        var _result: MouseButtonMask = MouseButtonMask ()
        gi.object_method_bind_ptrcall (DisplayServer.method_mouse_get_button_state, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clipboard_set: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clipboard_set")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Sets the user's clipboard content to the given string.
    public static func clipboardSet (clipboard: String) {
        #if false
        
        let gstr_clipboard = GString (clipboard)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_clipboard_set, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_clipboard.content)
        
        #else
        
        let gstr_clipboard = GString (clipboard)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_clipboard.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_clipboard_set, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_clipboard_get: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clipboard_get")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the user's clipboard as a string if possible.
    public static func clipboardGet ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (DisplayServer.method_clipboard_get, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_clipboard_get_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clipboard_get_image")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4190603485)!
            }
            
        }
        
    }()
    
    /// Returns the user's clipboard as an image if possible.
    public static func clipboardGetImage ()-> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (DisplayServer.method_clipboard_get_image, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_clipboard_has: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clipboard_has")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is a text content on the user's clipboard.
    public static func clipboardHas ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_clipboard_has, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clipboard_has_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clipboard_has_image")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if there is an image content on the user's clipboard.
    public static func clipboardHasImage ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_clipboard_has_image, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clipboard_set_primary: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clipboard_set_primary")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Sets the user's [url=https://unix.stackexchange.com/questions/139191/whats-the-difference-between-primary-selection-and-clipboard-buffer]primary[/url] clipboard content to the given string. This is the clipboard that is set when the user selects text in any application, rather than when pressing [kbd]Ctrl + C[/kbd]. The clipboard data can then be pasted by clicking the middle mouse button in any application that supports the primary clipboard mechanism.
    /// 
    /// > Note: This method is only implemented on Linux (X11).
    /// 
    public static func clipboardSetPrimary (clipboardPrimary: String) {
        #if false
        
        let gstr_clipboard_primary = GString (clipboardPrimary)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_clipboard_set_primary, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_clipboard_primary.content)
        
        #else
        
        let gstr_clipboard_primary = GString (clipboardPrimary)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_clipboard_primary.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_clipboard_set_primary, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_clipboard_get_primary: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clipboard_get_primary")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the user's [url=https://unix.stackexchange.com/questions/139191/whats-the-difference-between-primary-selection-and-clipboard-buffer]primary[/url] clipboard as a string if possible. This is the clipboard that is set when the user selects text in any application, rather than when pressing [kbd]Ctrl + C[/kbd]. The clipboard data can then be pasted by clicking the middle mouse button in any application that supports the primary clipboard mechanism.
    /// 
    /// > Note: This method is only implemented on Linux (X11).
    /// 
    public static func clipboardGetPrimary ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (DisplayServer.method_clipboard_get_primary, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_display_cutouts: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_display_cutouts")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns an ``GArray`` of ``Rect2``, each of which is the bounding rectangle for a display cutout or notch. These are non-functional areas on edge-to-edge screens used by cameras and sensors. Returns an empty array if the device does not have cutouts. See also ``getDisplaySafeArea()``.
    /// 
    /// > Note: Currently only implemented on Android. Other platforms will return an empty array even if they do have display cutouts or notches.
    /// 
    public static func getDisplayCutouts ()-> VariantCollection<Rect2> {
        var _result: Int64 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_get_display_cutouts, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return VariantCollection<Rect2>(content: _result)
    }
    
    fileprivate static var method_get_display_safe_area: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_display_safe_area")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 410525958)!
            }
            
        }
        
    }()
    
    /// Returns the unobscured area of the display where interactive controls should be rendered. See also ``getDisplayCutouts()``.
    public static func getDisplaySafeArea ()-> Rect2i {
        var _result: Rect2i = Rect2i ()
        gi.object_method_bind_ptrcall (DisplayServer.method_get_display_safe_area, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_screen_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_screen_count")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of displays available.
    public static func getScreenCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_get_screen_count, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_primary_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_primary_screen")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns index of the primary screen.
    public static func getPrimaryScreen ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_get_primary_screen, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_keyboard_focus_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_keyboard_focus_screen")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the index of the screen containing the window with the keyboard focus, or the primary screen if there's no focused window.
    public static func getKeyboardFocusScreen ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_get_keyboard_focus_screen, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_screen_from_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_screen_from_rect")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 741354659)!
            }
            
        }
        
    }()
    
    /// Returns index of the screen which contains specified rectangle.
    public static func getScreenFromRect (_ rect: Rect2)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_rect = rect
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_get_screen_from_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_rect)
        return _result
        #else
        
        var copy_rect = rect
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_rect) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_get_screen_from_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_screen_get_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_position")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1725937825)!
            }
            
        }
        
    }()
    
    /// Returns the screen's top-left corner position in pixels. On multi-monitor setups, the screen position is relative to the virtual desktop area. On multi-monitor setups with different screen resolutions or orientations, the origin may be located outside any display like this:
    /// 
    /// See also ``screenGetSize(screen:)``.
    /// 
    public static func screenGetPosition (screen: Int32 = -1)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_position, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_screen)
        return _result
        #else
        
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_position, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_screen_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_size")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1725937825)!
            }
            
        }
        
    }()
    
    /// Returns the screen's size in pixels. See also ``screenGetPosition(screen:)`` and ``screenGetUsableRect(screen:)``.
    public static func screenGetSize (screen: Int32 = -1)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_size, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_screen)
        return _result
        #else
        
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_screen_get_usable_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_usable_rect")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2439012528)!
            }
            
        }
        
    }()
    
    /// Returns the portion of the screen that is not obstructed by a status bar in pixels. See also ``screenGetSize(screen:)``.
    public static func screenGetUsableRect (screen: Int32 = -1)-> Rect2i {
        var _result: Rect2i = Rect2i ()
        #if false
        
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_usable_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_screen)
        return _result
        #else
        
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_usable_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_screen_get_dpi: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_dpi")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 181039630)!
            }
            
        }
        
    }()
    
    /// Returns the dots per inch density of the specified screen. If `screen` is ``screenOfMainWindow`` (the default value), a screen with the main window will be used.
    /// 
    /// > Note: On macOS, returned value is inaccurate if fractional display scaling mode is used.
    /// 
    /// > Note: On Android devices, the actual screen densities are grouped into six generalized densities:
    /// 
    /// > Note: This method is implemented on Android, Linux (X11), macOS and Windows. Returns `72` on unsupported platforms.
    /// 
    public static func screenGetDpi (screen: Int32 = -1)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_dpi, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_screen)
        return _result
        #else
        
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_dpi, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_screen_get_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_scale")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 909105437)!
            }
            
        }
        
    }()
    
    /// Returns the scale factor of the specified screen by index.
    /// 
    /// > Note: On macOS returned value is `2.0` for hiDPI (Retina) screen, and `1.0` for all other cases.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func screenGetScale (screen: Int32 = -1)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_screen)
        return _result
        #else
        
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_scale, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_touchscreen_available: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_touchscreen_available")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3323674545)!
            }
            
        }
        
    }()
    
    /// Returns `true` if touch events are available (Android or iOS), the capability is detected on the Web platform or if ``ProjectSettings/inputDevices/pointing/emulateTouchFromMouse`` is `true`.
    public static func isTouchscreenAvailable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_is_touchscreen_available, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_screen_get_max_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_max_scale")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the greatest scale factor of all screens.
    /// 
    /// > Note: On macOS returned value is `2.0` if there is at least one hiDPI (Retina) screen in the system, and `1.0` in all other cases.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func screenGetMaxScale ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_max_scale, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_screen_get_refresh_rate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_refresh_rate")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 909105437)!
            }
            
        }
        
    }()
    
    /// Returns the current refresh rate of the specified screen. If `screen` is ``screenOfMainWindow`` (the default value), a screen with the main window will be used.
    /// 
    /// > Note: Returns `-1.0` if the DisplayServer fails to find the refresh rate for the specified screen. On Web, ``screenGetRefreshRate(screen:)`` will always return `-1.0` as there is no way to retrieve the refresh rate on that platform.
    /// 
    /// To fallback to a default refresh rate if the method fails, try:
    /// 
    public static func screenGetRefreshRate (screen: Int32 = -1)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_refresh_rate, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_screen)
        return _result
        #else
        
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_refresh_rate, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_screen_get_pixel: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_pixel")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1532707496)!
            }
            
        }
        
    }()
    
    /// Returns color of the display pixel at the `position`.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS, and Windows.
    /// 
    /// > Note: On macOS, this method requires "Screen Recording" permission, if permission is not granted it will return desktop wallpaper color.
    /// 
    public static func screenGetPixel (position: Vector2i)-> Color {
        var _result: Color = Color ()
        #if false
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_pixel, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_position)
        return _result
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_pixel, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_screen_get_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_image")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3813388802)!
            }
            
        }
        
    }()
    
    /// Returns screenshot of the `screen`.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS, and Windows.
    /// 
    /// > Note: On macOS, this method requires "Screen Recording" permission, if permission is not granted it will return desktop wallpaper color.
    /// 
    public static func screenGetImage (screen: Int32 = -1)-> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_image, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_screen)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_image, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_screen_set_orientation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_set_orientation")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2211511631)!
            }
            
        }
        
    }()
    
    /// Sets the `screen`'s `orientation`. See also ``screenGetOrientation(screen:)``.
    /// 
    /// > Note: On iOS, this method has no effect if ``ProjectSettings/display/window/handheld/orientation`` is not set to .screenSensor.
    /// 
    public static func screenSetOrientation (_ orientation: DisplayServer.ScreenOrientation, screen: Int32 = -1) {
        #if false
        
        var copy_orientation = Int64 (orientation.rawValue)
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_set_orientation, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_orientation, &copy_screen)
        
        #else
        
        var copy_orientation = Int64 (orientation.rawValue)
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_orientation) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_screen) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_screen_set_orientation, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_screen_get_orientation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_get_orientation")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 133818562)!
            }
            
        }
        
    }()
    
    /// Returns the `screen`'s current orientation. See also ``screenSetOrientation(_:screen:)``.
    /// 
    /// > Note: This method is implemented on Android and iOS.
    /// 
    public static func screenGetOrientation (screen: Int32 = -1)-> DisplayServer.ScreenOrientation {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_screen: Int = Int (screen)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_get_orientation, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_screen)
        return DisplayServer.ScreenOrientation (rawValue: _result)!
        #else
        
        var copy_screen: Int = Int (screen)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_get_orientation, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return DisplayServer.ScreenOrientation (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_screen_set_keep_on: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_set_keep_on")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// Sets whether the screen should never be turned off by the operating system's power-saving measures. See also ``screenIsKeptOn()``.
    public static func screenSetKeepOn (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_screen_set_keep_on, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_screen_set_keep_on, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_screen_is_kept_on: GDExtensionMethodBindPtr = {
        let methodName = StringName ("screen_is_kept_on")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the screen should never be turned off by the operating system's power-saving measures. See also ``screenSetKeepOn(enable:)``.
    public static func screenIsKeptOn ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_screen_is_kept_on, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_window_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_window_list")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1930428628)!
            }
            
        }
        
    }()
    
    /// Returns the list of Godot window IDs belonging to this process.
    /// 
    /// > Note: Native dialogs are not included in this list.
    /// 
    public static func getWindowList ()-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        gi.object_method_bind_ptrcall (DisplayServer.method_get_window_list, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_window_at_screen_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_window_at_screen_position")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2485466453)!
            }
            
        }
        
    }()
    
    /// Returns the ID of the window at the specified screen `position` (in pixels). On multi-monitor setups, the screen position is relative to the virtual desktop area. On multi-monitor setups with different screen resolutions or orientations, the origin may be located outside any display like this:
    /// 
    public static func getWindowAtScreenPosition (_ position: Vector2i)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_get_window_at_screen_position, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_position)
        return _result
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_get_window_at_screen_position, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_native_handle: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_native_handle")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1096425680)!
            }
            
        }
        
    }()
    
    /// Returns internal structure pointers for use in plugins.
    /// 
    /// > Note: This method is implemented on Android, Linux (X11), macOS and Windows.
    /// 
    public static func windowGetNativeHandle (handleType: DisplayServer.HandleType, windowId: Int32 = 0)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_handle_type = Int64 (handleType.rawValue)
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_native_handle, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_handle_type, &copy_window_id)
        return _result
        #else
        
        var copy_handle_type = Int64 (handleType.rawValue)
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_handle_type) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_get_native_handle, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_active_popup: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_active_popup")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns ID of the active popup window, or ``invalidWindowId`` if there is none.
    public static func windowGetActivePopup ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_window_get_active_popup, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_window_set_popup_safe_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_popup_safe_rect")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3317281434)!
            }
            
        }
        
    }()
    
    /// Sets the bounding box of control, or menu item that was used to open the popup window, in the screen coordinate system. Clicking this area will not auto-close this popup.
    public static func windowSetPopupSafeRect (window: Int32, rect: Rect2i) {
        #if false
        
        var copy_window: Int = Int (window)
        var copy_rect = rect
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_popup_safe_rect, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_window, &copy_rect)
        
        #else
        
        var copy_window: Int = Int (window)
        var copy_rect = rect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_window) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_popup_safe_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_popup_safe_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_popup_safe_rect")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2161169500)!
            }
            
        }
        
    }()
    
    /// Returns the bounding box of control, or menu item that was used to open the popup window, in the screen coordinate system.
    public static func windowGetPopupSafeRect (window: Int32)-> Rect2i {
        var _result: Rect2i = Rect2i ()
        #if false
        
        var copy_window: Int = Int (window)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_popup_safe_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window)
        return _result
        #else
        
        var copy_window: Int = Int (window)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_popup_safe_rect, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_title")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 441246282)!
            }
            
        }
        
    }()
    
    /// Sets the title of the given window to `title`.
    /// 
    /// > Note: It's recommended to change this value using ``Window/title`` instead.
    /// 
    /// > Note: Avoid changing the window title every frame, as this can cause performance issues on certain window managers. Try to change the window title only a few times per second at most.
    /// 
    public static func windowSetTitle (_ title: String, windowId: Int32 = 0) {
        #if false
        
        let gstr_title = GString (title)
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_title, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_title.content, &copy_window_id)
        
        #else
        
        let gstr_title = GString (title)
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_title.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_title, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_title_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_title_size")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2925301799)!
            }
            
        }
        
    }()
    
    /// Returns the estimated window title bar size (including text and window buttons) for the window specified by `windowId` (in pixels). This method does not change the window title.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func windowGetTitleSize (title: String, windowId: Int32 = 0)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        let gstr_title = GString (title)
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_title_size, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_title.content, &copy_window_id)
        return _result
        #else
        
        let gstr_title = GString (title)
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_title.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_get_title_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_mouse_passthrough: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_mouse_passthrough")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1993637420)!
            }
            
        }
        
    }()
    
    /// Sets a polygonal region of the window which accepts mouse events. Mouse events outside the region will be passed through.
    /// 
    /// Passing an empty array will disable passthrough support (all mouse events will be intercepted by the window, which is the default behavior).
    /// 
    /// > Note: On Windows, the portion of a window that lies outside the region is not drawn, while on Linux (X11) and macOS it is.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS and Windows.
    /// 
    public static func windowSetMousePassthrough (region: PackedVector2Array, windowId: Int32 = 0) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_mouse_passthrough, UnsafeMutableRawPointer (mutating: shared.handle), nil, &region.content, &copy_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &region.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_mouse_passthrough, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_current_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_current_screen")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the screen the window specified by `windowId` is currently positioned on. If the screen overlaps multiple displays, the screen where the window's center is located is returned. See also ``windowSetCurrentScreen(_:windowId:)``.
    public static func windowGetCurrentScreen (windowId: Int32 = 0)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_current_screen, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_current_screen, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_current_screen: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_current_screen")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2230941749)!
            }
            
        }
        
    }()
    
    /// Moves the window specified by `windowId` to the specified `screen`. See also ``windowGetCurrentScreen(windowId:)``.
    public static func windowSetCurrentScreen (_ screen: Int32, windowId: Int32 = 0) {
        #if false
        
        var copy_screen: Int = Int (screen)
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_current_screen, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_screen, &copy_window_id)
        
        #else
        
        var copy_screen: Int = Int (screen)
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_screen) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_current_screen, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_position")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 763922886)!
            }
            
        }
        
    }()
    
    /// Returns the position of the client area of the given window on the screen.
    public static func windowGetPosition (windowId: Int32 = 0)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_position, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_position, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_position_with_decorations: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_position_with_decorations")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 763922886)!
            }
            
        }
        
    }()
    
    /// Returns the position of the given window on the screen including the borders drawn by the operating system. See also ``windowGetPosition(windowId:)``.
    public static func windowGetPositionWithDecorations (windowId: Int32 = 0)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_position_with_decorations, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_position_with_decorations, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_position")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2019273902)!
            }
            
        }
        
    }()
    
    /// Sets the position of the given window to `position`. On multi-monitor setups, the screen position is relative to the virtual desktop area. On multi-monitor setups with different screen resolutions or orientations, the origin may be located outside any display like this:
    /// 
    /// See also ``windowGetPosition(windowId:)`` and ``windowSetSize(_:windowId:)``.
    /// 
    /// > Note: It's recommended to change this value using ``Window/position`` instead.
    /// 
    public static func windowSetPosition (_ position: Vector2i, windowId: Int32 = 0) {
        #if false
        
        var copy_position = position
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_position, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_position, &copy_window_id)
        
        #else
        
        var copy_position = position
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_position, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_size")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 763922886)!
            }
            
        }
        
    }()
    
    /// Returns the size of the window specified by `windowId` (in pixels), excluding the borders drawn by the operating system. This is also called the "client area". See also ``windowGetSizeWithDecorations(windowId:)``, ``windowSetSize(_:windowId:)`` and ``windowGetPosition(windowId:)``.
    public static func windowGetSize (windowId: Int32 = 0)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_size, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_size")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2019273902)!
            }
            
        }
        
    }()
    
    /// Sets the size of the given window to `size` (in pixels). See also ``windowGetSize(windowId:)`` and ``windowGetPosition(windowId:)``.
    /// 
    /// > Note: It's recommended to change this value using ``Window/size`` instead.
    /// 
    public static func windowSetSize (_ size: Vector2i, windowId: Int32 = 0) {
        #if false
        
        var copy_size = size
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_size, &copy_window_id)
        
        #else
        
        var copy_size = size
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_rect_changed_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_rect_changed_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1091192925)!
            }
            
        }
        
    }()
    
    /// Sets the `callback` that will be called when the window specified by `windowId` is moved or resized.
    /// 
    /// > Warning: Advanced users only! Adding such a callback to a ``Window`` node will override its default implementation, which can introduce bugs.
    /// 
    public static func windowSetRectChangedCallback (_ callback: Callable, windowId: Int32 = 0) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_rect_changed_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &callback.content, &copy_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callback.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_rect_changed_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_window_event_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_window_event_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1091192925)!
            }
            
        }
        
    }()
    
    /// Sets the `callback` that will be called when an event occurs in the window specified by `windowId`.
    /// 
    /// > Warning: Advanced users only! Adding such a callback to a ``Window`` node will override its default implementation, which can introduce bugs.
    /// 
    public static func windowSetWindowEventCallback (_ callback: Callable, windowId: Int32 = 0) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_window_event_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &callback.content, &copy_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callback.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_window_event_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_input_event_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_input_event_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1091192925)!
            }
            
        }
        
    }()
    
    /// Sets the `callback` that should be called when any ``InputEvent`` is sent to the window specified by `windowId`.
    /// 
    /// > Warning: Advanced users only! Adding such a callback to a ``Window`` node will override its default implementation, which can introduce bugs.
    /// 
    public static func windowSetInputEventCallback (_ callback: Callable, windowId: Int32 = 0) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_input_event_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &callback.content, &copy_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callback.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_input_event_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_input_text_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_input_text_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1091192925)!
            }
            
        }
        
    }()
    
    /// Sets the `callback` that should be called when text is entered using the virtual keyboard to the window specified by `windowId`.
    /// 
    /// > Warning: Advanced users only! Adding such a callback to a ``Window`` node will override its default implementation, which can introduce bugs.
    /// 
    public static func windowSetInputTextCallback (_ callback: Callable, windowId: Int32 = 0) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_input_text_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &callback.content, &copy_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callback.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_input_text_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_drop_files_callback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_drop_files_callback")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1091192925)!
            }
            
        }
        
    }()
    
    /// Sets the `callback` that should be called when files are dropped from the operating system's file manager to the window specified by `windowId`.
    /// 
    /// > Warning: Advanced users only! Adding such a callback to a ``Window`` node will override its default implementation, which can introduce bugs.
    /// 
    /// > Note: This method is implemented on Windows, macOS, Linux (X11) and Web.
    /// 
    public static func windowSetDropFilesCallback (_ callback: Callable, windowId: Int32 = 0) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_drop_files_callback, UnsafeMutableRawPointer (mutating: shared.handle), nil, &callback.content, &copy_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callback.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_drop_files_callback, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_attached_instance_id: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_attached_instance_id")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1591665591)!
            }
            
        }
        
    }()
    
    /// Returns the ``Object/getInstanceId()`` of the ``Window`` the `windowId` is attached to.
    public static func windowGetAttachedInstanceId (windowId: Int32 = 0)-> UInt {
        var _result: UInt = 0
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_attached_instance_id, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_attached_instance_id, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_max_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_max_size")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 763922886)!
            }
            
        }
        
    }()
    
    /// Returns the window's maximum size (in pixels). See also ``windowSetMaxSize(_:windowId:)``.
    public static func windowGetMaxSize (windowId: Int32 = 0)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_max_size, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_max_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_max_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_max_size")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2019273902)!
            }
            
        }
        
    }()
    
    /// Sets the maximum size of the window specified by `windowId` in pixels. Normally, the user will not be able to drag the window to make it smaller than the specified size. See also ``windowGetMaxSize(windowId:)``.
    /// 
    /// > Note: It's recommended to change this value using ``Window/maxSize`` instead.
    /// 
    /// > Note: Using third-party tools, it is possible for users to disable window geometry restrictions and therefore bypass this limit.
    /// 
    public static func windowSetMaxSize (_ maxSize: Vector2i, windowId: Int32 = 0) {
        #if false
        
        var copy_max_size = maxSize
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_max_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_max_size, &copy_window_id)
        
        #else
        
        var copy_max_size = maxSize
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_max_size) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_max_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_min_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_min_size")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 763922886)!
            }
            
        }
        
    }()
    
    /// Returns the window's minimum size (in pixels). See also ``windowSetMinSize(_:windowId:)``.
    public static func windowGetMinSize (windowId: Int32 = 0)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_min_size, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_min_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_min_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_min_size")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2019273902)!
            }
            
        }
        
    }()
    
    /// Sets the minimum size for the given window to `minSize` (in pixels). Normally, the user will not be able to drag the window to make it larger than the specified size. See also ``windowGetMinSize(windowId:)``.
    /// 
    /// > Note: It's recommended to change this value using ``Window/minSize`` instead.
    /// 
    /// > Note: By default, the main window has a minimum size of `Vector2i(64, 64)`. This prevents issues that can arise when the window is resized to a near-zero size.
    /// 
    /// > Note: Using third-party tools, it is possible for users to disable window geometry restrictions and therefore bypass this limit.
    /// 
    public static func windowSetMinSize (_ minSize: Vector2i, windowId: Int32 = 0) {
        #if false
        
        var copy_min_size = minSize
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_min_size, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_min_size, &copy_window_id)
        
        #else
        
        var copy_min_size = minSize
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_min_size) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_min_size, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_size_with_decorations: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_size_with_decorations")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 763922886)!
            }
            
        }
        
    }()
    
    /// Returns the size of the window specified by `windowId` (in pixels), including the borders drawn by the operating system. See also ``windowGetSize(windowId:)``.
    public static func windowGetSizeWithDecorations (windowId: Int32 = 0)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_size_with_decorations, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_size_with_decorations, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_mode")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2185728461)!
            }
            
        }
        
    }()
    
    /// Returns the mode of the given window.
    public static func windowGetMode (windowId: Int32 = 0)-> DisplayServer.WindowMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return DisplayServer.WindowMode (rawValue: _result)!
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return DisplayServer.WindowMode (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_mode")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1319965401)!
            }
            
        }
        
    }()
    
    /// Sets window mode for the given window to `mode`. See ``DisplayServer/WindowMode`` for possible values and how each mode behaves.
    /// 
    /// > Note: Setting the window to full screen forcibly sets the borderless flag to `true`, so make sure to set it back to `false` when not wanted.
    /// 
    public static func windowSetMode (_ mode: DisplayServer.WindowMode, windowId: Int32 = 0) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_mode, &copy_window_id)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_flag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_flag")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 254894155)!
            }
            
        }
        
    }()
    
    /// Enables or disables the given window's given `flag`. See ``DisplayServer/WindowFlags`` for possible values and their behavior.
    public static func windowSetFlag (_ flag: DisplayServer.WindowFlags, enabled: Bool, windowId: Int32 = 0) {
        #if false
        
        var copy_flag = Int64 (flag.rawValue)
        var copy_enabled = enabled
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_flag, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_flag, &copy_enabled, &copy_window_id)
        
        #else
        
        var copy_flag = Int64 (flag.rawValue)
        var copy_enabled = enabled
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_flag) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_window_id) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_window_set_flag, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_flag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_flag")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 802816991)!
            }
            
        }
        
    }()
    
    /// Returns the current value of the given window's `flag`.
    public static func windowGetFlag (_ flag: DisplayServer.WindowFlags, windowId: Int32 = 0)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_flag = Int64 (flag.rawValue)
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_flag, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_flag, &copy_window_id)
        return _result
        #else
        
        var copy_flag = Int64 (flag.rawValue)
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_flag) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_get_flag, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_window_buttons_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_window_buttons_offset")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2019273902)!
            }
            
        }
        
    }()
    
    /// When .windowFlagExtendToTitle flag is set, set offset to the center of the first titlebar button.
    /// 
    /// > Note: This flag is implemented only on macOS.
    /// 
    public static func windowSetWindowButtonsOffset (_ offset: Vector2i, windowId: Int32 = 0) {
        #if false
        
        var copy_offset = offset
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_window_buttons_offset, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_offset, &copy_window_id)
        
        #else
        
        var copy_offset = offset
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_offset) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_window_buttons_offset, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_safe_title_margins: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_safe_title_margins")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2295066620)!
            }
            
        }
        
    }()
    
    /// Returns left margins (`x`), right margins (`y`) and height (`z`) of the title that are safe to use (contains no buttons or other elements) when .windowFlagExtendToTitle flag is set.
    public static func windowGetSafeTitleMargins (windowId: Int32 = 0)-> Vector3i {
        var _result: Vector3i = Vector3i ()
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_safe_title_margins, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_safe_title_margins, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_request_attention: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_request_attention")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1995695955)!
            }
            
        }
        
    }()
    
    /// Makes the window specified by `windowId` request attention, which is materialized by the window title and taskbar entry blinking until the window is focused. This usually has no visible effect if the window is currently focused. The exact behavior varies depending on the operating system.
    public static func windowRequestAttention (windowId: Int32 = 0) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_request_attention, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_request_attention, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_window_move_to_foreground: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_move_to_foreground")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1995695955)!
            }
            
        }
        
    }()
    
    /// Moves the window specified by `windowId` to the foreground, so that it is visible over other windows.
    public static func windowMoveToForeground (windowId: Int32 = 0) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_move_to_foreground, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_move_to_foreground, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_window_is_focused: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_is_focused")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1051549951)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the window specified by `windowId` is focused.
    public static func windowIsFocused (windowId: Int32 = 0)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_is_focused, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_is_focused, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_can_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_can_draw")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1051549951)!
            }
            
        }
        
    }()
    
    /// Returns `true` if anything can be drawn in the window specified by `windowId`, `false` otherwise. Using the `--disable-render-loop` command line argument or a headless build will return `false`.
    public static func windowCanDraw (windowId: Int32 = 0)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_can_draw, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_can_draw, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_transient: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_transient")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets window transient parent. Transient window is will be destroyed with its transient parent and will return focus to their parent when closed. The transient window is displayed on top of a non-exclusive full-screen parent window. Transient windows can't enter full-screen mode.
    /// 
    /// > Note: It's recommended to change this value using ``Window/transient`` instead.
    /// 
    /// > Note: The behavior might be different depending on the platform.
    /// 
    public static func windowSetTransient (windowId: Int32, parentWindowId: Int32) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        var copy_parent_window_id: Int = Int (parentWindowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_transient, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_window_id, &copy_parent_window_id)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var copy_parent_window_id: Int = Int (parentWindowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_parent_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_transient, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_exclusive: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_exclusive")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If set to `true`, this window will always stay on top of its parent window, parent window will ignore input while this window is opened.
    /// 
    /// > Note: On macOS, exclusive windows are confined to the same space (virtual desktop or screen) as the parent window.
    /// 
    /// > Note: This method is implemented on macOS and Windows.
    /// 
    public static func windowSetExclusive (windowId: Int32, exclusive: Bool) {
        #if false
        
        var copy_window_id: Int = Int (windowId)
        var copy_exclusive = exclusive
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_exclusive, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_window_id, &copy_exclusive)
        
        #else
        
        var copy_window_id: Int = Int (windowId)
        var copy_exclusive = exclusive
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_exclusive) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_exclusive, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_ime_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_ime_active")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1661950165)!
            }
            
        }
        
    }()
    
    /// Sets whether [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] should be enabled for the window specified by `windowId`. See also ``windowSetImePosition(_:windowId:)``.
    public static func windowSetImeActive (_ active: Bool, windowId: Int32 = 0) {
        #if false
        
        var copy_active = active
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_ime_active, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_active, &copy_window_id)
        
        #else
        
        var copy_active = active
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_active) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_ime_active, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_ime_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_ime_position")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2019273902)!
            }
            
        }
        
    }()
    
    /// Sets the position of the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] popup for the specified `windowId`. Only effective if ``windowSetImeActive(_:windowId:)`` was set to `true` for the specified `windowId`.
    public static func windowSetImePosition (_ position: Vector2i, windowId: Int32 = 0) {
        #if false
        
        var copy_position = position
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_ime_position, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_position, &copy_window_id)
        
        #else
        
        var copy_position = position
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_ime_position, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_set_vsync_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_set_vsync_mode")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2179333492)!
            }
            
        }
        
    }()
    
    /// Sets the V-Sync mode of the given window. See also ``ProjectSettings/display/window/vsync/vsyncMode``.
    /// 
    /// See ``DisplayServer.VSyncMode`` for possible values and how they affect the behavior of your application.
    /// 
    /// Depending on the platform and used renderer, the engine will fall back to .vsyncEnabled if the desired mode is not supported.
    /// 
    /// > Note: V-Sync modes other than .vsyncEnabled are only supported in the Forward+ and Mobile rendering methods, not Compatibility.
    /// 
    public static func windowSetVsyncMode (_ vsyncMode: DisplayServer.VSyncMode, windowId: Int32 = 0) {
        #if false
        
        var copy_vsync_mode = Int64 (vsyncMode.rawValue)
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_set_vsync_mode, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_vsync_mode, &copy_window_id)
        
        #else
        
        var copy_vsync_mode = Int64 (vsyncMode.rawValue)
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_vsync_mode) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_window_id) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (DisplayServer.method_window_set_vsync_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_window_get_vsync_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_get_vsync_mode")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 578873795)!
            }
            
        }
        
    }()
    
    /// Returns the V-Sync mode of the given window.
    public static func windowGetVsyncMode (windowId: Int32 = 0)-> DisplayServer.VSyncMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_get_vsync_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return DisplayServer.VSyncMode (rawValue: _result)!
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_get_vsync_mode, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return DisplayServer.VSyncMode (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_window_is_maximize_allowed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_is_maximize_allowed")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1051549951)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the given window can be maximized (the maximize button is enabled).
    public static func windowIsMaximizeAllowed (windowId: Int32 = 0)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_window_id: Int = Int (windowId)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_window_is_maximize_allowed, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_window_id)
        return _result
        #else
        
        var copy_window_id: Int = Int (windowId)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_window_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_window_is_maximize_allowed, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_window_maximize_on_title_dbl_click: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_maximize_on_title_dbl_click")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true`, if double-click on a window title should maximize it.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func windowMaximizeOnTitleDblClick ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_window_maximize_on_title_dbl_click, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_window_minimize_on_title_dbl_click: GDExtensionMethodBindPtr = {
        let methodName = StringName ("window_minimize_on_title_dbl_click")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true`, if double-click on a window title should minimize it.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func windowMinimizeOnTitleDblClick ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_window_minimize_on_title_dbl_click, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_ime_get_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("ime_get_selection")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3690982128)!
            }
            
        }
        
    }()
    
    /// Returns the text selection in the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] composition string, with the ``Vector2i``'s `x` component being the caret position and `y` being the length of the selection.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func imeGetSelection ()-> Vector2i {
        var _result: Vector2i = Vector2i ()
        gi.object_method_bind_ptrcall (DisplayServer.method_ime_get_selection, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_ime_get_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("ime_get_text")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the composition string contained within the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] window.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func imeGetText ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (DisplayServer.method_ime_get_text, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_virtual_keyboard_show: GDExtensionMethodBindPtr = {
        let methodName = StringName ("virtual_keyboard_show")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3042891259)!
            }
            
        }
        
    }()
    
    /// Shows the virtual keyboard if the platform has one.
    /// 
    /// `existingText` parameter is useful for implementing your own ``LineEdit`` or ``TextEdit``, as it tells the virtual keyboard what text has already been typed (the virtual keyboard uses it for auto-correct and predictions).
    /// 
    /// `position` parameter is the screen space ``Rect2`` of the edited text.
    /// 
    /// `type` parameter allows configuring which type of virtual keyboard to show.
    /// 
    /// `maxLength` limits the number of characters that can be entered if different from `-1`.
    /// 
    /// `cursorStart` can optionally define the current text cursor position if `cursorEnd` is not set.
    /// 
    /// `cursorStart` and `cursorEnd` can optionally define the current text selection.
    /// 
    /// > Note: This method is implemented on Android, iOS and Web.
    /// 
    public static func virtualKeyboardShow (existingText: String, position: Rect2 = Rect2 (x: 0, y: 0, width: 0, height: 0), type: DisplayServer.VirtualKeyboardType = .`default`, maxLength: Int32 = -1, cursorStart: Int32 = -1, cursorEnd: Int32 = -1) {
        #if false
        
        let gstr_existing_text = GString (existingText)
        var copy_position = position
        var copy_type = Int64 (type.rawValue)
        var copy_max_length: Int = Int (maxLength)
        var copy_cursor_start: Int = Int (cursorStart)
        var copy_cursor_end: Int = Int (cursorEnd)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_virtual_keyboard_show, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_existing_text.content, &copy_position, &copy_type, &copy_max_length, &copy_cursor_start, &copy_cursor_end)
        
        #else
        
        let gstr_existing_text = GString (existingText)
        var copy_position = position
        var copy_type = Int64 (type.rawValue)
        var copy_max_length: Int = Int (maxLength)
        var copy_cursor_start: Int = Int (cursorStart)
        var copy_cursor_end: Int = Int (cursorEnd)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_existing_text.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_position) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_type) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_max_length) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_cursor_start) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_cursor_end) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (DisplayServer.method_virtual_keyboard_show, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_virtual_keyboard_hide: GDExtensionMethodBindPtr = {
        let methodName = StringName ("virtual_keyboard_hide")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Hides the virtual keyboard if it is shown, does nothing otherwise.
    public static func virtualKeyboardHide () {
        gi.object_method_bind_ptrcall (DisplayServer.method_virtual_keyboard_hide, UnsafeMutableRawPointer (mutating: shared.handle), nil, nil)
    }
    
    fileprivate static var method_virtual_keyboard_get_height: GDExtensionMethodBindPtr = {
        let methodName = StringName ("virtual_keyboard_get_height")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the on-screen keyboard's height in pixels. Returns 0 if there is no keyboard or if it is currently hidden.
    public static func virtualKeyboardGetHeight ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_virtual_keyboard_get_height, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_cursor_set_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("cursor_set_shape")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2026291549)!
            }
            
        }
        
    }()
    
    /// Sets the default mouse cursor shape. The cursor's appearance will vary depending on the user's operating system and mouse cursor theme. See also ``cursorGetShape()`` and ``cursorSetCustomImage(cursor:shape:hotspot:)``.
    public static func cursorSetShape (_ shape: DisplayServer.CursorShape) {
        #if false
        
        var copy_shape = Int64 (shape.rawValue)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_cursor_set_shape, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_shape)
        
        #else
        
        var copy_shape = Int64 (shape.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_shape) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_cursor_set_shape, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_cursor_get_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("cursor_get_shape")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1087724927)!
            }
            
        }
        
    }()
    
    /// Returns the default mouse cursor shape set by ``cursorSetShape(_:)``.
    public static func cursorGetShape ()-> DisplayServer.CursorShape {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (DisplayServer.method_cursor_get_shape, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return DisplayServer.CursorShape (rawValue: _result)!
    }
    
    fileprivate static var method_cursor_set_custom_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("cursor_set_custom_image")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1816663697)!
            }
            
        }
        
    }()
    
    /// Sets a custom mouse cursor image for the defined `shape`. This means the user's operating system and mouse cursor theme will no longer influence the mouse cursor's appearance. The image must be `256x256` or smaller for correct appearance. `hotspot` can optionally be set to define the area where the cursor will click. By default, `hotspot` is set to `Vector2(0, 0)`, which is the top-left corner of the image. See also ``cursorSetShape(_:)``.
    public static func cursorSetCustomImage (cursor: Resource?, shape: DisplayServer.CursorShape = .arrow, hotspot: Vector2 = Vector2 (x: 0, y: 0)) {
        #if false
        
        var copy_shape = Int64 (shape.rawValue)
        var copy_hotspot = hotspot
        var copy_cursor_handle = cursor?.handle
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_cursor_set_custom_image, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_cursor_handle, &copy_shape, &copy_hotspot)
        
        #else
        
        var copy_shape = Int64 (shape.rawValue)
        var copy_hotspot = hotspot
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: cursor?.handle) { p0 in
        _args.append (cursor == nil ? nil : p0)
            withUnsafePointer (to: &copy_shape) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_hotspot) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (DisplayServer.method_cursor_set_custom_image, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_swap_cancel_ok: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_swap_cancel_ok")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Returns `true` if positions of **OK** and **Cancel** buttons are swapped in dialogs. This is enabled by default on Windows to follow interface conventions, and be toggled by changing ``ProjectSettings/gui/common/swapCancelOk``.
    /// 
    /// > Note: This doesn't affect native dialogs such as the ones spawned by ``DisplayServer/dialogShow(title:description:buttons:callback:)``.
    /// 
    public static func getSwapCancelOk ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (DisplayServer.method_get_swap_cancel_ok, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_enable_for_stealing_focus: GDExtensionMethodBindPtr = {
        let methodName = StringName ("enable_for_stealing_focus")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Allows the `processId` PID to steal focus from this window. In other words, this disables the operating system's focus stealing protection for the specified PID.
    /// 
    /// > Note: This method is implemented only on Windows.
    /// 
    public static func enableForStealingFocus (processId: Int) {
        #if false
        
        var copy_process_id = processId
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_enable_for_stealing_focus, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_process_id)
        
        #else
        
        var copy_process_id = processId
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_process_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_enable_for_stealing_focus, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_dialog_show: GDExtensionMethodBindPtr = {
        let methodName = StringName ("dialog_show")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4115553226)!
            }
            
        }
        
    }()
    
    /// Shows a text dialog which uses the operating system's native look-and-feel. `callback` will be called when the dialog is closed for any reason.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func dialogShow (title: String, description: String, buttons: PackedStringArray, callback: Callable)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_title = GString (title)
        let gstr_description = GString (description)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_dialog_show, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_title.content, &gstr_description.content, &buttons.content, &callback.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_title = GString (title)
        let gstr_description = GString (description)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_title.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_description.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &buttons.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &callback.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (DisplayServer.method_dialog_show, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                        return GodotError (rawValue: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_dialog_input_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("dialog_input_text")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3088703427)!
            }
            
        }
        
    }()
    
    /// Shows a text input dialog which uses the operating system's native look-and-feel. `callback` will be called with a ``String`` argument equal to the text field's contents when the dialog is closed for any reason.
    /// 
    /// > Note: This method is implemented only on macOS.
    /// 
    public static func dialogInputText (title: String, description: String, existingText: String, callback: Callable)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_title = GString (title)
        let gstr_description = GString (description)
        let gstr_existing_text = GString (existingText)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_dialog_input_text, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_title.content, &gstr_description.content, &gstr_existing_text.content, &callback.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_title = GString (title)
        let gstr_description = GString (description)
        let gstr_existing_text = GString (existingText)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_title.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_description.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &gstr_existing_text.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &callback.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (DisplayServer.method_dialog_input_text, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                        return GodotError (rawValue: _result)!
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_file_dialog_show: GDExtensionMethodBindPtr = {
        let methodName = StringName ("file_dialog_show")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1531299078)!
            }
            
        }
        
    }()
    
    /// Displays OS native dialog for selecting files or directories in the file system.
    /// 
    /// Callbacks have the following arguments: `bool status, PackedStringArray selected_paths, int selected_filter_index`.
    /// 
    /// > Note: This method is implemented if the display server has the .nativeDialog feature.
    /// 
    /// > Note: This method is implemented on Linux, Windows and macOS.
    /// 
    /// > Note: `currentDirectory` might be ignored.
    /// 
    /// > Note: On Linux, `showHidden` is ignored.
    /// 
    /// > Note: On macOS, native file dialogs have no title.
    /// 
    /// > Note: On macOS, sandboxed apps will save security-scoped bookmarks to retain access to the opened folders across multiple sessions. Use ``OS/getGrantedPermissions()`` to get a list of saved bookmarks.
    /// 
    public static func fileDialogShow (title: String, currentDirectory: String, filename: String, showHidden: Bool, mode: DisplayServer.FileDialogMode, filters: PackedStringArray, callback: Callable)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        let gstr_title = GString (title)
        let gstr_current_directory = GString (currentDirectory)
        let gstr_filename = GString (filename)
        var copy_show_hidden = showHidden
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_file_dialog_show, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &gstr_title.content, &gstr_current_directory.content, &gstr_filename.content, &copy_show_hidden, &copy_mode, &filters.content, &callback.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_title = GString (title)
        let gstr_current_directory = GString (currentDirectory)
        let gstr_filename = GString (filename)
        var copy_show_hidden = showHidden
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_title.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_current_directory.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &gstr_filename.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_show_hidden) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_mode) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &filters.content) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &callback.content) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (DisplayServer.method_file_dialog_show, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
                                    return GodotError (rawValue: _result)!
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_keyboard_get_layout_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("keyboard_get_layout_count")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of keyboard layouts.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS and Windows.
    /// 
    public static func keyboardGetLayoutCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_keyboard_get_layout_count, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_keyboard_get_current_layout: GDExtensionMethodBindPtr = {
        let methodName = StringName ("keyboard_get_current_layout")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns active keyboard layout index.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS and Windows.
    /// 
    public static func keyboardGetCurrentLayout ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_keyboard_get_current_layout, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_keyboard_set_current_layout: GDExtensionMethodBindPtr = {
        let methodName = StringName ("keyboard_set_current_layout")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Sets the active keyboard layout.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS and Windows.
    /// 
    public static func keyboardSetCurrentLayout (index: Int32) {
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_keyboard_set_current_layout, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_index)
        
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_keyboard_set_current_layout, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_keyboard_get_layout_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("keyboard_get_layout_language")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the ISO-639/BCP-47 language code of the keyboard layout at position `index`.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS and Windows.
    /// 
    public static func keyboardGetLayoutLanguage (index: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_keyboard_get_layout_language, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_index)
        return _result.description
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_keyboard_get_layout_language, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_keyboard_get_layout_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("keyboard_get_layout_name")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the localized name of the keyboard layout at position `index`.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS and Windows.
    /// 
    public static func keyboardGetLayoutName (index: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_index: Int = Int (index)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_keyboard_get_layout_name, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_index)
        return _result.description
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_keyboard_get_layout_name, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_keyboard_get_keycode_from_physical: GDExtensionMethodBindPtr = {
        let methodName = StringName ("keyboard_get_keycode_from_physical")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3447613187)!
            }
            
        }
        
    }()
    
    /// Converts a physical (US QWERTY) `keycode` to one in the active keyboard layout.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS and Windows.
    /// 
    public static func keyboardGetKeycodeFromPhysical (keycode: Key)-> Key {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_keycode = Int64 (keycode.rawValue)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_keyboard_get_keycode_from_physical, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_keycode)
        return Key (rawValue: _result)!
        #else
        
        var copy_keycode = Int64 (keycode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_keycode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_keyboard_get_keycode_from_physical, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return Key (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_keyboard_get_label_from_physical: GDExtensionMethodBindPtr = {
        let methodName = StringName ("keyboard_get_label_from_physical")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3447613187)!
            }
            
        }
        
    }()
    
    /// Converts a physical (US QWERTY) `keycode` to localized label printed on the key in the active keyboard layout.
    /// 
    /// > Note: This method is implemented on Linux (X11), macOS and Windows.
    /// 
    public static func keyboardGetLabelFromPhysical (keycode: Key)-> Key {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_keycode = Int64 (keycode.rawValue)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_keyboard_get_label_from_physical, UnsafeMutableRawPointer (mutating: shared.handle), &_result, &copy_keycode)
        return Key (rawValue: _result)!
        #else
        
        var copy_keycode = Int64 (keycode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_keycode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_keyboard_get_label_from_physical, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result)
            return Key (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_process_events: GDExtensionMethodBindPtr = {
        let methodName = StringName ("process_events")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Perform window manager processing, including input flushing. See also ``forceProcessAndDropEvents()``, ``Input/flushBufferedEvents()`` and ``Input/useAccumulatedInput``.
    public static func processEvents () {
        gi.object_method_bind_ptrcall (DisplayServer.method_process_events, UnsafeMutableRawPointer (mutating: shared.handle), nil, nil)
    }
    
    fileprivate static var method_force_process_and_drop_events: GDExtensionMethodBindPtr = {
        let methodName = StringName ("force_process_and_drop_events")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Forces window manager processing while ignoring all ``InputEvent``s. See also ``processEvents()``.
    /// 
    /// > Note: This method is implemented on Windows and macOS.
    /// 
    public static func forceProcessAndDropEvents () {
        gi.object_method_bind_ptrcall (DisplayServer.method_force_process_and_drop_events, UnsafeMutableRawPointer (mutating: shared.handle), nil, nil)
    }
    
    fileprivate static var method_set_native_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_native_icon")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Sets the window icon (usually displayed in the top-left corner) in the operating system's _native_ format. The file at `filename` must be in `.ico` format on Windows or `.icns` on macOS. By using specially crafted `.ico` or `.icns` icons, ``setNativeIcon(filename:)`` allows specifying different icons depending on the size the icon is displayed at. This size is determined by the operating system and user preferences (including the display scale factor). To use icons in other formats, use ``setIcon(image:)`` instead.
    public static func setNativeIcon (filename: String) {
        #if false
        
        let gstr_filename = GString (filename)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_set_native_icon, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_filename.content)
        
        #else
        
        let gstr_filename = GString (filename)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_filename.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_set_native_icon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_icon")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 532598488)!
            }
            
        }
        
    }()
    
    /// Sets the window icon (usually displayed in the top-left corner) with an ``Image``. To use icons in the operating system's native format, use ``setNativeIcon(filename:)`` instead.
    public static func setIcon (image: Image?) {
        #if false
        
        var copy_image_handle = image?.handle
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_set_icon, UnsafeMutableRawPointer (mutating: shared.handle), nil, &copy_image_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: image?.handle) { p0 in
        _args.append (image == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_set_icon, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_tablet_get_driver_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tablet_get_driver_count")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the total number of available tablet drivers.
    /// 
    /// > Note: This method is implemented only on Windows.
    /// 
    public static func tabletGetDriverCount ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (DisplayServer.method_tablet_get_driver_count, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_tablet_get_driver_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tablet_get_driver_name")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the tablet driver name for the given index.
    /// 
    /// > Note: This method is implemented only on Windows.
    /// 
    public static func tabletGetDriverName (idx: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_tablet_get_driver_name, UnsafeMutableRawPointer (mutating: shared.handle), &_result.content, &copy_idx)
        return _result.description
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_tablet_get_driver_name, UnsafeMutableRawPointer (mutating: shared.handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_tablet_get_current_driver: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tablet_get_current_driver")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns current active tablet driver name.
    /// 
    /// > Note: This method is implemented only on Windows.
    /// 
    public static func tabletGetCurrentDriver ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (DisplayServer.method_tablet_get_current_driver, UnsafeMutableRawPointer (mutating: shared.handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_tablet_set_current_driver: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tablet_set_current_driver")
        return withUnsafePointer (to: &DisplayServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    /// Set active tablet driver name.
    /// 
    /// > Note: This method is implemented only on Windows.
    /// 
    public static func tabletSetCurrentDriver (name: String) {
        #if false
        
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (DisplayServer.method_tablet_set_current_driver, UnsafeMutableRawPointer (mutating: shared.handle), nil, &gstr_name.content)
        
        #else
        
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (DisplayServer.method_tablet_set_current_driver, UnsafeMutableRawPointer (mutating: shared.handle), &_args, nil)
        }
        
        #endif
    }
    
}

