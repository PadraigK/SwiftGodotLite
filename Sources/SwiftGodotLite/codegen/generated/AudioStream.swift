// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Base class for audio streams.
/// 
/// Base class for audio streams. Audio streams are used for sound effects and music playback, and support WAV (via ``AudioStreamWAV``) and Ogg (via ``AudioStreamOggVorbis``) file formats.
open class AudioStream: Resource {
    override open class var godotClassName: StringName { "AudioStream" }
    /* Methods */
    /// 
    @_documentation(visibility: public)
    open func _instantiatePlayback ()-> AudioStreamPlayback? {
        return AudioStreamPlayback ()
    }
    
    /// 
    @_documentation(visibility: public)
    open func _getStreamName ()-> String {
        return String ()
    }
    
    /// 
    @_documentation(visibility: public)
    open func _getLength ()-> Double {
        return 0.0
    }
    
    /// 
    @_documentation(visibility: public)
    open func _isMonophonic ()-> Bool {
        return false
    }
    
    /// 
    @_documentation(visibility: public)
    open func _getBpm ()-> Double {
        return 0.0
    }
    
    /// 
    @_documentation(visibility: public)
    open func _getBeatCount ()-> Int32 {
        return 0
    }
    
    fileprivate static var method_get_length: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_length")
        return withUnsafePointer (to: &AudioStream.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the length of the audio stream in seconds.
    public final func getLength ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (AudioStream.method_get_length, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_monophonic: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_monophonic")
        return withUnsafePointer (to: &AudioStream.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns true if this audio stream only supports monophonic playback, or false if the audio stream supports polyphony.
    public final func isMonophonic ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (AudioStream.method_is_monophonic, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_instantiate_playback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("instantiate_playback")
        return withUnsafePointer (to: &AudioStream.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 210135309)!
            }
            
        }
        
    }()
    
    /// Returns an AudioStreamPlayback. Useful for when you want to extend ``_instantiatePlayback()`` but call ``instantiatePlayback()`` from an internally held AudioStream subresource. An example of this can be found in the source files for `AudioStreamRandomPitch::instantiate_playback`.
    public final func instantiatePlayback ()-> AudioStreamPlayback? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (AudioStream.method_instantiate_playback, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_get_beat_count":
                return _AudioStream_proxy_get_beat_count
            case "_get_bpm":
                return _AudioStream_proxy_get_bpm
            case "_get_length":
                return _AudioStream_proxy_get_length
            case "_get_stream_name":
                return _AudioStream_proxy_get_stream_name
            case "_instantiate_playback":
                return _AudioStream_proxy_instantiate_playback
            case "_is_monophonic":
                return _AudioStream_proxy_is_monophonic
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
}

// Support methods for proxies
func _AudioStream_proxy_get_beat_count (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<AudioStream>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getBeatCount ()
    retPtr!.storeBytes (of: ret, as: Int32.self)
}

func _AudioStream_proxy_get_bpm (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<AudioStream>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getBpm ()
    retPtr!.storeBytes (of: ret, as: Double.self)
}

func _AudioStream_proxy_get_length (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<AudioStream>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._getLength ()
    retPtr!.storeBytes (of: ret, as: Double.self)
}

func _AudioStream_proxy_get_stream_name (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<AudioStream>.fromOpaque(instance).takeUnretainedValue()
    let ret = GString (swiftObject._getStreamName ())
    retPtr!.storeBytes (of: ret.content, as: type (of: ret.content)) // String
    ret.content = GString.zero
}

func _AudioStream_proxy_instantiate_playback (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<AudioStream>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._instantiatePlayback ()
    retPtr!.storeBytes (of: ret?.handle, as: UnsafeRawPointer?.self) // AudioStreamPlayback
}

func _AudioStream_proxy_is_monophonic (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<AudioStream>.fromOpaque(instance).takeUnretainedValue()
    let ret = swiftObject._isMonophonic ()
    retPtr!.storeBytes (of: ret, as: Bool.self)
}

