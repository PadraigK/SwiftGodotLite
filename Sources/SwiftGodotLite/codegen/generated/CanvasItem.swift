// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Abstract base class for everything in 2D space.
/// 
/// Abstract base class for everything in 2D space. Canvas items are laid out in a tree; children inherit and extend their parent's transform. ``CanvasItem`` is extended by ``Control`` for GUI-related nodes, and by ``Node2D`` for 2D game objects.
/// 
/// Any ``CanvasItem`` can draw. For this, ``queueRedraw()`` is called by the engine, then ``notificationDraw`` will be received on idle time to request a redraw. Because of this, canvas items don't need to be redrawn on every frame, improving the performance significantly. Several functions for drawing on the ``CanvasItem`` are provided (see `draw_*` functions). However, they can only be used inside ``_draw()``, its corresponding ``Object/_notification()`` or methods connected to the [signal draw] signal.
/// 
/// Canvas items are drawn in tree order on their canvas layer. By default, children are on top of their parents, so a root ``CanvasItem`` will be drawn behind everything. This behavior can be changed on a per-item basis.
/// 
/// A ``CanvasItem`` can be hidden, which will also hide its children. By adjusting various other properties of a ``CanvasItem``, you can also modulate its color (via ``modulate`` or ``selfModulate``), change its Z-index, blend mode, and more.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``draw``
/// - ``visibilityChanged``
/// - ``hidden``
/// - ``itemRectChanged``
open class CanvasItem: Node {
    override open class var godotClassName: StringName { "CanvasItem" }
    public enum TextureFilter: Int64 {
        /// The ``CanvasItem`` will inherit the filter from its parent.
        case parentNode = 0 // TEXTURE_FILTER_PARENT_NODE
        /// The texture filter reads from the nearest pixel only. The simplest and fastest method of filtering. Useful for pixel art.
        case nearest = 1 // TEXTURE_FILTER_NEAREST
        /// The texture filter blends between the nearest four pixels. Use this for most cases where you want to avoid a pixelated style.
        case linear = 2 // TEXTURE_FILTER_LINEAR
        /// The texture filter reads from the nearest pixel in the nearest mipmap. This is the fastest way to read from textures with mipmaps.
        case nearestWithMipmaps = 3 // TEXTURE_FILTER_NEAREST_WITH_MIPMAPS
        /// The texture filter blends between the nearest 4 pixels and between the nearest 2 mipmaps. Use this for non-pixel art textures that may be viewed at a low scale (e.g. due to ``Camera2D`` zoom), as mipmaps are important to smooth out pixels that are smaller than on-screen pixels.
        case linearWithMipmaps = 4 // TEXTURE_FILTER_LINEAR_WITH_MIPMAPS
        /// The texture filter reads from the nearest pixel, but selects a mipmap based on the angle between the surface and the camera view. This reduces artifacts on surfaces that are almost in line with the camera. The anisotropic filtering level can be changed by adjusting ``ProjectSettings/rendering/textures/defaultFilters/anisotropicFilteringLevel``.
        /// 
        /// > Note: This texture filter is rarely useful in 2D projects. .nearestWithMipmaps is usually more appropriate.
        /// 
        case nearestWithMipmapsAnisotropic = 5 // TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC
        /// The texture filter blends between the nearest 4 pixels and selects a mipmap based on the angle between the surface and the camera view. This reduces artifacts on surfaces that are almost in line with the camera. This is the slowest of the filtering options, but results in the highest quality texturing. The anisotropic filtering level can be changed by adjusting ``ProjectSettings/rendering/textures/defaultFilters/anisotropicFilteringLevel``.
        /// 
        /// > Note: This texture filter is rarely useful in 2D projects. .linearWithMipmaps is usually more appropriate.
        /// 
        case linearWithMipmapsAnisotropic = 6 // TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC
        /// Represents the size of the ``CanvasItem/TextureFilter`` enum.
        case max = 7 // TEXTURE_FILTER_MAX
    }
    
    public enum TextureRepeat: Int64 {
        /// The ``CanvasItem`` will inherit the filter from its parent.
        case parentNode = 0 // TEXTURE_REPEAT_PARENT_NODE
        /// Texture will not repeat.
        case disabled = 1 // TEXTURE_REPEAT_DISABLED
        /// Texture will repeat normally.
        case enabled = 2 // TEXTURE_REPEAT_ENABLED
        /// Texture will repeat in a 2x2 tiled mode, where elements at even positions are mirrored.
        case mirror = 3 // TEXTURE_REPEAT_MIRROR
        /// Represents the size of the ``CanvasItem/TextureRepeat`` enum.
        case max = 4 // TEXTURE_REPEAT_MAX
    }
    
    public enum ClipChildrenMode: Int64 {
        /// Child draws over parent and is not clipped.
        case disabled = 0 // CLIP_CHILDREN_DISABLED
        /// Parent is used for the purposes of clipping only. Child is clipped to the parent's visible area, parent is not drawn.
        case only = 1 // CLIP_CHILDREN_ONLY
        /// Parent is used for clipping child, but parent is also drawn underneath child as normal before clipping child to its visible area.
        case andDraw = 2 // CLIP_CHILDREN_AND_DRAW
        /// Represents the size of the ``CanvasItem/ClipChildrenMode`` enum.
        case max = 3 // CLIP_CHILDREN_MAX
    }
    
    /* Constants */
    /// The ``CanvasItem``'s global transform has changed. This notification is only received if enabled by ``setNotifyTransform(enable:)``.
    public static let notificationTransformChanged = 2000
    /// The ``CanvasItem``'s local transform has changed. This notification is only received if enabled by ``setNotifyLocalTransform(enable:)``.
    public static let notificationLocalTransformChanged = 35
    /// The ``CanvasItem`` is requested to draw (see ``_draw()``).
    public static let notificationDraw = 30
    /// The ``CanvasItem``'s visibility has changed.
    public static let notificationVisibilityChanged = 31
    /// The ``CanvasItem`` has entered the canvas.
    public static let notificationEnterCanvas = 32
    /// The ``CanvasItem`` has exited the canvas.
    public static let notificationExitCanvas = 33
    /// The ``CanvasItem``'s active ``World2D`` changed.
    public static let notificationWorld2dChanged = 36
    
    /* Properties */
    
    /// If `true`, this ``CanvasItem`` is drawn. The node is only visible if all of its ancestors are visible as well (in other words, ``isVisibleInTree()`` must return `true`).
    /// 
    /// > Note: For controls that inherit ``Popup``, the correct way to make them visible is to call one of the multiple `popup*()` functions instead.
    /// 
    final public var visible: Bool {
        get {
            return is_visible ()
        }
        
        set {
            set_visible (newValue)
        }
        
    }
    
    /// The color applied to this ``CanvasItem``. This property does affect child ``CanvasItem``s, unlike ``selfModulate`` which only affects the node itself.
    final public var modulate: Color {
        get {
            return get_modulate ()
        }
        
        set {
            set_modulate (newValue)
        }
        
    }
    
    /// The color applied to this ``CanvasItem``. This property does **not** affect child ``CanvasItem``s, unlike ``modulate`` which affects both the node itself and its children.
    /// 
    /// > Note: Internal children (e.g. sliders in ``ColorPicker`` or tab bar in ``TabContainer``) are also not affected by this property (see `include_internal` parameter of ``Node/getChild(idx:includeInternal:)`` and other similar methods).
    /// 
    final public var selfModulate: Color {
        get {
            return get_self_modulate ()
        }
        
        set {
            set_self_modulate (newValue)
        }
        
    }
    
    /// If `true`, the object draws behind its parent.
    final public var showBehindParent: Bool {
        get {
            return is_draw_behind_parent_enabled ()
        }
        
        set {
            set_draw_behind_parent (newValue)
        }
        
    }
    
    /// If `true`, this ``CanvasItem`` will _not_ inherit its transform from parent ``CanvasItem``s. Its draw order will also be changed to make it draw on top of other ``CanvasItem``s that do not have ``topLevel`` set to `true`. The ``CanvasItem`` will effectively act as if it was placed as a child of a bare ``Node``.
    final public var topLevel: Bool {
        get {
            return is_set_as_top_level ()
        }
        
        set {
            set_as_top_level (newValue)
        }
        
    }
    
    /// Allows the current node to clip children nodes, essentially acting as a mask.
    final public var clipChildren: CanvasItem.ClipChildrenMode {
        get {
            return get_clip_children_mode ()
        }
        
        set {
            set_clip_children_mode (newValue)
        }
        
    }
    
    /// The rendering layers in which this ``CanvasItem`` responds to ``Light2D`` nodes.
    final public var lightMask: Int32 {
        get {
            return get_light_mask ()
        }
        
        set {
            set_light_mask (newValue)
        }
        
    }
    
    /// The rendering layer in which this ``CanvasItem`` is rendered by ``Viewport`` nodes. A ``Viewport`` will render a ``CanvasItem`` if it and all its parents share a layer with the ``Viewport``'s canvas cull mask.
    final public var visibilityLayer: UInt32 {
        get {
            return get_visibility_layer ()
        }
        
        set {
            set_visibility_layer (newValue)
        }
        
    }
    
    /// Z index. Controls the order in which the nodes render. A node with a higher Z index will display in front of others. Must be between ``RenderingServer/``canvasItemZMin```` and ``RenderingServer/``canvasItemZMax```` (inclusive).
    /// 
    /// > Note: Changing the Z index of a ``Control`` only affects the drawing order, not the order in which input events are handled. This can be useful to implement certain UI animations, e.g. a menu where hovered items are scaled and should overlap others.
    /// 
    final public var zIndex: Int32 {
        get {
            return get_z_index ()
        }
        
        set {
            set_z_index (newValue)
        }
        
    }
    
    /// If `true`, the node's Z index is relative to its parent's Z index. If this node's Z index is 2 and its parent's effective Z index is 3, then this node's effective Z index will be 2 + 3 = 5.
    final public var zAsRelative: Bool {
        get {
            return is_z_relative ()
        }
        
        set {
            set_z_as_relative (newValue)
        }
        
    }
    
    /// If `true`, child nodes with the lowest Y position are drawn before those with a higher Y position. If `false`, Y-sorting is disabled. Y-sorting only affects children that inherit from ``CanvasItem``.
    /// 
    /// You can nest nodes with Y-sorting. Child Y-sorted nodes are sorted in the same space as the parent Y-sort. This feature allows you to organize a scene better or divide it into multiple ones without changing your scene tree.
    /// 
    final public var ySortEnabled: Bool {
        get {
            return is_y_sort_enabled ()
        }
        
        set {
            set_y_sort_enabled (newValue)
        }
        
    }
    
    /// The texture filtering mode to use on this ``CanvasItem``.
    final public var textureFilter: CanvasItem.TextureFilter {
        get {
            return get_texture_filter ()
        }
        
        set {
            set_texture_filter (newValue)
        }
        
    }
    
    /// The texture repeating mode to use on this ``CanvasItem``.
    final public var textureRepeat: CanvasItem.TextureRepeat {
        get {
            return get_texture_repeat ()
        }
        
        set {
            set_texture_repeat (newValue)
        }
        
    }
    
    /// The material applied to this ``CanvasItem``.
    final public var material: Material? {
        get {
            return get_material ()
        }
        
        set {
            set_material (newValue)
        }
        
    }
    
    /// If `true`, the parent ``CanvasItem``'s ``material`` property is used as this one's material.
    final public var useParentMaterial: Bool {
        get {
            return get_use_parent_material ()
        }
        
        set {
            set_use_parent_material (newValue)
        }
        
    }
    
    /* Methods */
    /// Called when ``CanvasItem`` has been requested to redraw (after ``queueRedraw()`` is called, either manually or by the engine).
    /// 
    /// Corresponds to the ``notificationDraw`` notification in ``Object/_notification()``.
    /// 
    @_documentation(visibility: public)
    open func _draw () {
    }
    
    fileprivate static var method_get_canvas_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_canvas_item")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the canvas item RID used by ``RenderingServer`` for this item.
    public final func getCanvasItem ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_canvas_item, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_visible")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visible (_ visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_visible")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_is_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_visible_in_tree: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_visible_in_tree")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the node is present in the ``SceneTree``, its ``visible`` property is `true` and all its ancestors are also visible. If any ancestor is hidden, this node will not be visible in the scene tree, and is consequently not drawn (see ``_draw()``).
    public final func isVisibleInTree ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_is_visible_in_tree, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_show: GDExtensionMethodBindPtr = {
        let methodName = StringName ("show")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Show the ``CanvasItem`` if it's currently hidden. This is equivalent to setting ``visible`` to `true`. For controls that inherit ``Popup``, the correct way to make them visible is to call one of the multiple `popup*()` functions instead.
    public final func show () {
        gi.object_method_bind_ptrcall (CanvasItem.method_show, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_hide: GDExtensionMethodBindPtr = {
        let methodName = StringName ("hide")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Hide the ``CanvasItem`` if it's currently visible. This is equivalent to setting ``visible`` to `false`.
    public final func hide () {
        gi.object_method_bind_ptrcall (CanvasItem.method_hide, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_queue_redraw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("queue_redraw")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Queues the ``CanvasItem`` to redraw. During idle time, if ``CanvasItem`` is visible, ``notificationDraw`` is sent and ``_draw()`` is called. This only occurs **once** per frame, even if this method has been called multiple times.
    public final func queueRedraw () {
        gi.object_method_bind_ptrcall (CanvasItem.method_queue_redraw, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_move_to_front: GDExtensionMethodBindPtr = {
        let methodName = StringName ("move_to_front")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Moves this node to display on top of its siblings.
    /// 
    /// Internally, the node is moved to the bottom of parent's children list. The method has no effect on nodes without a parent.
    /// 
    public final func moveToFront () {
        gi.object_method_bind_ptrcall (CanvasItem.method_move_to_front, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_as_top_level: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_as_top_level")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_as_top_level (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_as_top_level, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_as_top_level, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_set_as_top_level: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_set_as_top_level")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_set_as_top_level ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_is_set_as_top_level, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_light_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_light_mask")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_light_mask (_ lightMask: Int32) {
        #if false
        
        var copy_light_mask: Int = Int (lightMask)
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_light_mask, UnsafeMutableRawPointer (mutating: handle), nil, &copy_light_mask)
        
        #else
        
        var copy_light_mask: Int = Int (lightMask)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_light_mask) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_light_mask, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_light_mask: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_light_mask")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_light_mask ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (CanvasItem.method_get_light_mask, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_modulate")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_modulate (_ modulate: Color) {
        #if false
        
        var copy_modulate = modulate
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_modulate, UnsafeMutableRawPointer (mutating: handle), nil, &copy_modulate)
        
        #else
        
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_modulate) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_modulate, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_modulate")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3444240500)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_modulate ()-> Color {
        var _result: Color = Color ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_modulate, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_self_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_self_modulate")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_self_modulate (_ selfModulate: Color) {
        #if false
        
        var copy_self_modulate = selfModulate
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_self_modulate, UnsafeMutableRawPointer (mutating: handle), nil, &copy_self_modulate)
        
        #else
        
        var copy_self_modulate = selfModulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_self_modulate) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_self_modulate, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_self_modulate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_self_modulate")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3444240500)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_self_modulate ()-> Color {
        var _result: Color = Color ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_self_modulate, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_z_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_z_index")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_z_index (_ zIndex: Int32) {
        #if false
        
        var copy_z_index: Int = Int (zIndex)
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_z_index, UnsafeMutableRawPointer (mutating: handle), nil, &copy_z_index)
        
        #else
        
        var copy_z_index: Int = Int (zIndex)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_z_index) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_z_index, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_z_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_z_index")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_z_index ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (CanvasItem.method_get_z_index, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_z_as_relative: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_z_as_relative")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_z_as_relative (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_z_as_relative, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_z_as_relative, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_z_relative: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_z_relative")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_z_relative ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_is_z_relative, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_y_sort_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_y_sort_enabled")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_y_sort_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_y_sort_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_y_sort_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_y_sort_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_y_sort_enabled")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_y_sort_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_is_y_sort_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_draw_behind_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_draw_behind_parent")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_draw_behind_parent (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_draw_behind_parent, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_draw_behind_parent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_draw_behind_parent_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_draw_behind_parent_enabled")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_draw_behind_parent_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_is_draw_behind_parent_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_draw_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_line")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1562330099)!
            }
            
        }
        
    }()
    
    /// Draws a line from a 2D point to another, with a given color and width. It can be optionally antialiased. See also ``drawMultiline(points:color:width:)`` and ``drawPolyline(points:color:width:antialiased:)``.
    /// 
    /// If `width` is negative, then a two-point primitive will be drawn instead of a four-point one. This means that when the CanvasItem is scaled, the line will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
    /// 
    public final func drawLine (from: Vector2, to: Vector2, color: Color, width: Double = -1.0, antialiased: Bool = false) {
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_color = color
        var copy_width = width
        var copy_antialiased = antialiased
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from, &copy_to, &copy_color, &copy_width, &copy_antialiased)
        
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_color = color
        var copy_width = width
        var copy_antialiased = antialiased
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_color) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_width) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_antialiased) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (CanvasItem.method_draw_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_dashed_line: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_dashed_line")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 684651049)!
            }
            
        }
        
    }()
    
    /// Draws a dashed line from a 2D point to another, with a given color and width. See also ``drawMultiline(points:color:width:)`` and ``drawPolyline(points:color:width:antialiased:)``.
    /// 
    /// If `width` is negative, then a two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the line parts will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
    /// 
    public final func drawDashedLine (from: Vector2, to: Vector2, color: Color, width: Double = -1.0, dash: Double = 2.0, aligned: Bool = true) {
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_color = color
        var copy_width = width
        var copy_dash = dash
        var copy_aligned = aligned
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_dashed_line, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from, &copy_to, &copy_color, &copy_width, &copy_dash, &copy_aligned)
        
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_color = color
        var copy_width = width
        var copy_dash = dash
        var copy_aligned = aligned
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_color) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_width) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_dash) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_aligned) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (CanvasItem.method_draw_dashed_line, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_polyline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_polyline")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3797364428)!
            }
            
        }
        
    }()
    
    /// Draws interconnected line segments with a uniform `color` and `width` and optional antialiasing (supported only for positive `width`). When drawing large amounts of lines, this is faster than using individual ``drawLine(from:to:color:width:antialiased:)`` calls. To draw disconnected lines, use ``drawMultiline(points:color:width:)`` instead. See also ``drawPolygon(points:colors:uvs:texture:)``.
    /// 
    /// If `width` is negative, it will be ignored and the polyline will be drawn using ``RenderingServer/PrimitiveType/primitiveLineStrip``. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
    /// 
    public final func drawPolyline (points: PackedVector2Array, color: Color, width: Double = -1.0, antialiased: Bool = false) {
        #if false
        
        var copy_color = color
        var copy_width = width
        var copy_antialiased = antialiased
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_polyline, UnsafeMutableRawPointer (mutating: handle), nil, &points.content, &copy_color, &copy_width, &copy_antialiased)
        
        #else
        
        var copy_color = color
        var copy_width = width
        var copy_antialiased = antialiased
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_width) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_antialiased) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_polyline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_polyline_colors: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_polyline_colors")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2311979562)!
            }
            
        }
        
    }()
    
    /// Draws interconnected line segments with a uniform `width`, point-by-point coloring, and optional antialiasing (supported only for positive `width`). Colors assigned to line points match by index between `points` and `colors`, i.e. each line segment is filled with a gradient between the colors of the endpoints. When drawing large amounts of lines, this is faster than using individual ``drawLine(from:to:color:width:antialiased:)`` calls. To draw disconnected lines, use ``drawMultilineColors(points:colors:width:)`` instead. See also ``drawPolygon(points:colors:uvs:texture:)``.
    /// 
    /// If `width` is negative, it will be ignored and the polyline will be drawn using ``RenderingServer/PrimitiveType/primitiveLineStrip``. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
    /// 
    public final func drawPolylineColors (points: PackedVector2Array, colors: PackedColorArray, width: Double = -1.0, antialiased: Bool = false) {
        #if false
        
        var copy_width = width
        var copy_antialiased = antialiased
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_polyline_colors, UnsafeMutableRawPointer (mutating: handle), nil, &points.content, &colors.content, &copy_width, &copy_antialiased)
        
        #else
        
        var copy_width = width
        var copy_antialiased = antialiased
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &colors.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_width) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_antialiased) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_polyline_colors, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_arc: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_arc")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4140652635)!
            }
            
        }
        
    }()
    
    /// Draws an unfilled arc between the given angles with a uniform `color` and `width` and optional antialiasing (supported only for positive `width`). The larger the value of `pointCount`, the smoother the curve. See also ``drawCircle(position:radius:color:)``.
    /// 
    /// If `width` is negative, it will be ignored and the arc will be drawn using ``RenderingServer/PrimitiveType/primitiveLineStrip``. This means that when the CanvasItem is scaled, the arc will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
    /// 
    /// The arc is drawn from `startAngle` towards the value of `endAngle` so in clockwise direction if `start_angle < end_angle` and counter-clockwise otherwise. Passing the same angles but in reversed order will produce the same arc. If absolute difference of `startAngle` and `endAngle` is greater than ``@GDScript.TAU`` radians, then a full circle arc is drawn (i.e. arc will not overlap itself).
    /// 
    public final func drawArc (center: Vector2, radius: Double, startAngle: Double, endAngle: Double, pointCount: Int32, color: Color, width: Double = -1.0, antialiased: Bool = false) {
        #if false
        
        var copy_center = center
        var copy_radius = radius
        var copy_start_angle = startAngle
        var copy_end_angle = endAngle
        var copy_point_count: Int = Int (pointCount)
        var copy_color = color
        var copy_width = width
        var copy_antialiased = antialiased
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_arc, UnsafeMutableRawPointer (mutating: handle), nil, &copy_center, &copy_radius, &copy_start_angle, &copy_end_angle, &copy_point_count, &copy_color, &copy_width, &copy_antialiased)
        
        #else
        
        var copy_center = center
        var copy_radius = radius
        var copy_start_angle = startAngle
        var copy_end_angle = endAngle
        var copy_point_count: Int = Int (pointCount)
        var copy_color = color
        var copy_width = width
        var copy_antialiased = antialiased
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_center) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_radius) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_start_angle) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_end_angle) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_point_count) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_color) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_width) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_antialiased) { p7 in
                                        _args.append (p7)
        
                                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_arc, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_multiline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_multiline")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2239075205)!
            }
            
        }
        
    }()
    
    /// Draws multiple disconnected lines with a uniform `width` and `color`. Each line is defined by two consecutive points from `points` array, i.e. i-th segment consists of `points[2 * i]`, `points[2 * i + 1]` endpoints. When drawing large amounts of lines, this is faster than using individual ``drawLine(from:to:color:width:antialiased:)`` calls. To draw interconnected lines, use ``drawPolyline(points:color:width:antialiased:)`` instead.
    /// 
    /// If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
    /// 
    public final func drawMultiline (points: PackedVector2Array, color: Color, width: Double = -1.0) {
        #if false
        
        var copy_color = color
        var copy_width = width
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_multiline, UnsafeMutableRawPointer (mutating: handle), nil, &points.content, &copy_color, &copy_width)
        
        #else
        
        var copy_color = color
        var copy_width = width
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_width) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (CanvasItem.method_draw_multiline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_multiline_colors: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_multiline_colors")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4072951537)!
            }
            
        }
        
    }()
    
    /// Draws multiple disconnected lines with a uniform `width` and segment-by-segment coloring. Each segment is defined by two consecutive points from `points` array and a corresponding color from `colors` array, i.e. i-th segment consists of `points[2 * i]`, `points[2 * i + 1]` endpoints and has `colors_` color. When drawing large amounts of lines, this is faster than using individual ``drawLine(from:to:color:width:antialiased:)`` calls. To draw interconnected lines, use ``drawPolylineColors(points:colors:width:antialiased:)`` instead.
    /// 
    /// If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
    /// 
    public final func drawMultilineColors (points: PackedVector2Array, colors: PackedColorArray, width: Double = -1.0) {
        #if false
        
        var copy_width = width
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_multiline_colors, UnsafeMutableRawPointer (mutating: handle), nil, &points.content, &colors.content, &copy_width)
        
        #else
        
        var copy_width = width
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &colors.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_width) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (CanvasItem.method_draw_multiline_colors, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_rect")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2417231121)!
            }
            
        }
        
    }()
    
    /// Draws a rectangle. If `filled` is `true`, the rectangle will be filled with the `color` specified. If `filled` is `false`, the rectangle will be drawn as a stroke with the `color` and `width` specified. See also ``drawTextureRect(texture:rect:tile:modulate:transpose:)``.
    /// 
    /// If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
    /// 
    /// > Note: `width` is only effective if `filled` is `false`.
    /// 
    /// > Note: Unfilled rectangles drawn with a negative `width` may not display perfectly. For example, corners may be missing or brighter due to overlapping lines (for a translucent `color`).
    /// 
    public final func drawRect (_ rect: Rect2, color: Color, filled: Bool = true, width: Double = -1.0) {
        #if false
        
        var copy_rect = rect
        var copy_color = color
        var copy_filled = filled
        var copy_width = width
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_rect, UnsafeMutableRawPointer (mutating: handle), nil, &copy_rect, &copy_color, &copy_filled, &copy_width)
        
        #else
        
        var copy_rect = rect
        var copy_color = color
        var copy_filled = filled
        var copy_width = width
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_rect) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_filled) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_width) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_rect, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_circle: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_circle")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3063020269)!
            }
            
        }
        
    }()
    
    /// Draws a colored, filled circle. See also ``drawArc(center:radius:startAngle:endAngle:pointCount:color:width:antialiased:)``, ``drawPolyline(points:color:width:antialiased:)`` and ``drawPolygon(points:colors:uvs:texture:)``.
    public final func drawCircle (position: Vector2, radius: Double, color: Color) {
        #if false
        
        var copy_position = position
        var copy_radius = radius
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_circle, UnsafeMutableRawPointer (mutating: handle), nil, &copy_position, &copy_radius, &copy_color)
        
        #else
        
        var copy_position = position
        var copy_radius = radius
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_radius) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_color) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (CanvasItem.method_draw_circle, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_texture")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 520200117)!
            }
            
        }
        
    }()
    
    /// Draws a texture at a given position.
    public final func drawTexture (_ texture: Texture2D?, position: Vector2, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_position = position
        var copy_modulate = modulate
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_texture, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &copy_position, &copy_modulate)
        
        #else
        
        var copy_position = position
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &copy_position) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_modulate) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (CanvasItem.method_draw_texture, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_texture_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_texture_rect")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3832805018)!
            }
            
        }
        
    }()
    
    /// Draws a textured rectangle at a given position, optionally modulated by a color. If `transpose` is `true`, the texture will have its X and Y coordinates swapped. See also ``drawRect(_:color:filled:width:)`` and ``drawTextureRectRegion(texture:rect:srcRect:modulate:transpose:clipUv:)``.
    public final func drawTextureRect (texture: Texture2D?, rect: Rect2, tile: Bool, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), transpose: Bool = false) {
        #if false
        
        var copy_rect = rect
        var copy_tile = tile
        var copy_modulate = modulate
        var copy_transpose = transpose
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_texture_rect, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &copy_rect, &copy_tile, &copy_modulate, &copy_transpose)
        
        #else
        
        var copy_rect = rect
        var copy_tile = tile
        var copy_modulate = modulate
        var copy_transpose = transpose
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_tile) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_modulate) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_transpose) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (CanvasItem.method_draw_texture_rect, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_texture_rect_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_texture_rect_region")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3883821411)!
            }
            
        }
        
    }()
    
    /// Draws a textured rectangle from a texture's region (specified by `srcRect`) at a given position, optionally modulated by a color. If `transpose` is `true`, the texture will have its X and Y coordinates swapped. See also ``drawTextureRect(texture:rect:tile:modulate:transpose:)``.
    public final func drawTextureRectRegion (texture: Texture2D?, rect: Rect2, srcRect: Rect2, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), transpose: Bool = false, clipUv: Bool = true) {
        #if false
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_transpose = transpose
        var copy_clip_uv = clipUv
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_texture_rect_region, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &copy_rect, &copy_src_rect, &copy_modulate, &copy_transpose, &copy_clip_uv)
        
        #else
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_transpose = transpose
        var copy_clip_uv = clipUv
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_src_rect) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_modulate) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_transpose) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_clip_uv) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (CanvasItem.method_draw_texture_rect_region, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_msdf_texture_rect_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_msdf_texture_rect_region")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4219163252)!
            }
            
        }
        
    }()
    
    /// Draws a textured rectangle region of the multi-channel signed distance field texture at a given position, optionally modulated by a color. See ``FontFile/multichannelSignedDistanceField`` for more information and caveats about MSDF font rendering.
    /// 
    /// If `outline` is positive, each alpha channel value of pixel in region is set to maximum value of true distance in the `outline` radius.
    /// 
    /// Value of the `pixelRange` should the same that was used during distance field texture generation.
    /// 
    public final func drawMsdfTextureRectRegion (texture: Texture2D?, rect: Rect2, srcRect: Rect2, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), outline: Double = 0.0, pixelRange: Double = 4.0, scale: Double = 1.0) {
        #if false
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_outline = outline
        var copy_pixel_range = pixelRange
        var copy_scale = scale
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_msdf_texture_rect_region, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &copy_rect, &copy_src_rect, &copy_modulate, &copy_outline, &copy_pixel_range, &copy_scale)
        
        #else
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_outline = outline
        var copy_pixel_range = pixelRange
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_src_rect) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_modulate) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_outline) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_pixel_range) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_scale) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (CanvasItem.method_draw_msdf_texture_rect_region, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_lcd_texture_rect_region: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_lcd_texture_rect_region")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3212350954)!
            }
            
        }
        
    }()
    
    /// Draws a textured rectangle region of the font texture with LCD subpixel anti-aliasing at a given position, optionally modulated by a color.
    /// 
    /// Texture is drawn using the following blend operation, blend mode of the ``CanvasItemMaterial`` is ignored:
    /// 
    public final func drawLcdTextureRectRegion (texture: Texture2D?, rect: Rect2, srcRect: Rect2, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_lcd_texture_rect_region, UnsafeMutableRawPointer (mutating: handle), nil, &copy_texture_handle, &copy_rect, &copy_src_rect, &copy_modulate)
        
        #else
        
        var copy_rect = rect
        var copy_src_rect = srcRect
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: texture?.handle) { p0 in
        _args.append (texture == nil ? nil : p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_src_rect) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_modulate) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_lcd_texture_rect_region, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_style_box: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_style_box")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 388176283)!
            }
            
        }
        
    }()
    
    /// Draws a styled rectangle.
    public final func drawStyleBox (_ styleBox: StyleBox?, rect: Rect2) {
        #if false
        
        var copy_rect = rect
        var copy_style_box_handle = styleBox?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_style_box, UnsafeMutableRawPointer (mutating: handle), nil, &copy_style_box_handle, &copy_rect)
        
        #else
        
        var copy_rect = rect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: styleBox?.handle) { p0 in
        _args.append (styleBox == nil ? nil : p0)
            withUnsafePointer (to: &copy_rect) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CanvasItem.method_draw_style_box, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_primitive: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_primitive")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3288481815)!
            }
            
        }
        
    }()
    
    /// Draws a custom primitive. 1 point for a point, 2 points for a line, 3 points for a triangle, and 4 points for a quad. If 0 points or more than 4 points are specified, nothing will be drawn and an error message will be printed. See also ``drawLine(from:to:color:width:antialiased:)``, ``drawPolyline(points:color:width:antialiased:)``, ``drawPolygon(points:colors:uvs:texture:)``, and ``drawRect(_:color:filled:width:)``.
    public final func drawPrimitive (points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array, texture: Texture2D? = nil) {
        #if false
        
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_primitive, UnsafeMutableRawPointer (mutating: handle), nil, &points.content, &colors.content, &uvs.content, &copy_texture_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &colors.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &uvs.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: texture?.handle) { p3 in
                    _args.append (texture == nil ? nil : p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_primitive, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_polygon")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 974537912)!
            }
            
        }
        
    }()
    
    /// Draws a solid polygon of any number of points, convex or concave. Unlike ``drawColoredPolygon(points:color:uvs:texture:)``, each point's color can be changed individually. See also ``drawPolyline(points:color:width:antialiased:)`` and ``drawPolylineColors(points:colors:width:antialiased:)``. If you need more flexibility (such as being able to use bones), use ``RenderingServer/canvasItemAddTriangleArray(item:indices:points:colors:uvs:bones:weights:texture:count:)`` instead.
    public final func drawPolygon (points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array = PackedVector2Array(), texture: Texture2D? = nil) {
        #if false
        
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_polygon, UnsafeMutableRawPointer (mutating: handle), nil, &points.content, &colors.content, &uvs.content, &copy_texture_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &colors.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &uvs.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: texture?.handle) { p3 in
                    _args.append (texture == nil ? nil : p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_polygon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_colored_polygon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_colored_polygon")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 15245644)!
            }
            
        }
        
    }()
    
    /// Draws a colored polygon of any number of points, convex or concave. Unlike ``drawPolygon(points:colors:uvs:texture:)``, a single color must be specified for the whole polygon.
    public final func drawColoredPolygon (points: PackedVector2Array, color: Color, uvs: PackedVector2Array = PackedVector2Array(), texture: Texture2D? = nil) {
        #if false
        
        var copy_color = color
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_colored_polygon, UnsafeMutableRawPointer (mutating: handle), nil, &points.content, &copy_color, &uvs.content, &copy_texture_handle)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &points.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_color) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &uvs.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: texture?.handle) { p3 in
                    _args.append (texture == nil ? nil : p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_colored_polygon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_string: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_string")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 728290553)!
            }
            
        }
        
    }()
    
    /// Draws `text` using the specified `font` at the `pos` (bottom-left corner using the baseline of the font). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
    /// 
    /// **Example using the default project font:**
    /// 
    /// See also ``Font/drawString(canvasItem:pos:text:alignment:width:fontSize:modulate:justificationFlags:direction:orientation:)``.
    /// 
    public final func drawString (font: Font?, pos: Vector2, text: String, alignment: HorizontalAlignment = .left, width: Double = -1, fontSize: Int32 = 16, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), justificationFlags: TextServer.JustificationFlag = [.kashida, .wordBound], direction: TextServer.Direction = .auto, orientation: TextServer.Orientation = .horizontal) {
        #if false
        
        var copy_pos = pos
        let gstr_text = GString (text)
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_width = width
        var copy_font_size: Int = Int (fontSize)
        var copy_modulate = modulate
        var copy_justification_flags = justificationFlags
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_string, UnsafeMutableRawPointer (mutating: handle), nil, &copy_font_handle, &copy_pos, &gstr_text.content, &copy_alignment, &copy_width, &copy_font_size, &copy_modulate, &copy_justification_flags, &copy_direction, &copy_orientation)
        
        #else
        
        var copy_pos = pos
        let gstr_text = GString (text)
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_width = width
        var copy_font_size: Int = Int (fontSize)
        var copy_modulate = modulate
        var copy_justification_flags = justificationFlags
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: font?.handle) { p0 in
        _args.append (font == nil ? nil : p0)
            withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_text.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_alignment) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_width) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_font_size) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_modulate) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_justification_flags) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_direction) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_orientation) { p9 in
                                                _args.append (p9)
        
                                                gi.object_method_bind_ptrcall (CanvasItem.method_draw_string, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_multiline_string: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_multiline_string")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1927038192)!
            }
            
        }
        
    }()
    
    /// Breaks `text` into lines and draws it using the specified `font` at the `pos` (top-left corner). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
    public final func drawMultilineString (font: Font?, pos: Vector2, text: String, alignment: HorizontalAlignment = .left, width: Double = -1, fontSize: Int32 = 16, maxLines: Int32 = -1, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), brkFlags: TextServer.LineBreakFlag = [.mandatory, .wordBound], justificationFlags: TextServer.JustificationFlag = [.kashida, .wordBound], direction: TextServer.Direction = .auto, orientation: TextServer.Orientation = .horizontal) {
        #if false
        
        var copy_pos = pos
        let gstr_text = GString (text)
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_width = width
        var copy_font_size: Int = Int (fontSize)
        var copy_max_lines: Int = Int (maxLines)
        var copy_modulate = modulate
        var copy_brk_flags = brkFlags
        var copy_justification_flags = justificationFlags
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_multiline_string, UnsafeMutableRawPointer (mutating: handle), nil, &copy_font_handle, &copy_pos, &gstr_text.content, &copy_alignment, &copy_width, &copy_font_size, &copy_max_lines, &copy_modulate, &copy_brk_flags, &copy_justification_flags, &copy_direction, &copy_orientation)
        
        #else
        
        var copy_pos = pos
        let gstr_text = GString (text)
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_width = width
        var copy_font_size: Int = Int (fontSize)
        var copy_max_lines: Int = Int (maxLines)
        var copy_modulate = modulate
        var copy_brk_flags = brkFlags
        var copy_justification_flags = justificationFlags
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: font?.handle) { p0 in
        _args.append (font == nil ? nil : p0)
            withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_text.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_alignment) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_width) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_font_size) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_max_lines) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_modulate) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_brk_flags) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_justification_flags) { p9 in
                                                _args.append (p9)
                                                withUnsafePointer (to: &copy_direction) { p10 in
                                                    _args.append (p10)
                                                    withUnsafePointer (to: &copy_orientation) { p11 in
                                                        _args.append (p11)
        
                                                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_multiline_string, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_string_outline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_string_outline")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 340562381)!
            }
            
        }
        
    }()
    
    /// Draws `text` outline using the specified `font` at the `pos` (bottom-left corner using the baseline of the font). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
    public final func drawStringOutline (font: Font?, pos: Vector2, text: String, alignment: HorizontalAlignment = .left, width: Double = -1, fontSize: Int32 = 16, size: Int32 = 1, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), justificationFlags: TextServer.JustificationFlag = [.kashida, .wordBound], direction: TextServer.Direction = .auto, orientation: TextServer.Orientation = .horizontal) {
        #if false
        
        var copy_pos = pos
        let gstr_text = GString (text)
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_width = width
        var copy_font_size: Int = Int (fontSize)
        var copy_size: Int = Int (size)
        var copy_modulate = modulate
        var copy_justification_flags = justificationFlags
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_string_outline, UnsafeMutableRawPointer (mutating: handle), nil, &copy_font_handle, &copy_pos, &gstr_text.content, &copy_alignment, &copy_width, &copy_font_size, &copy_size, &copy_modulate, &copy_justification_flags, &copy_direction, &copy_orientation)
        
        #else
        
        var copy_pos = pos
        let gstr_text = GString (text)
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_width = width
        var copy_font_size: Int = Int (fontSize)
        var copy_size: Int = Int (size)
        var copy_modulate = modulate
        var copy_justification_flags = justificationFlags
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: font?.handle) { p0 in
        _args.append (font == nil ? nil : p0)
            withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_text.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_alignment) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_width) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_font_size) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_size) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_modulate) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_justification_flags) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_direction) { p9 in
                                                _args.append (p9)
                                                withUnsafePointer (to: &copy_orientation) { p10 in
                                                    _args.append (p10)
        
                                                    gi.object_method_bind_ptrcall (CanvasItem.method_draw_string_outline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_multiline_string_outline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_multiline_string_outline")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1912318525)!
            }
            
        }
        
    }()
    
    /// Breaks `text` to the lines and draws text outline using the specified `font` at the `pos` (top-left corner). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
    public final func drawMultilineStringOutline (font: Font?, pos: Vector2, text: String, alignment: HorizontalAlignment = .left, width: Double = -1, fontSize: Int32 = 16, maxLines: Int32 = -1, size: Int32 = 1, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1), brkFlags: TextServer.LineBreakFlag = [.mandatory, .wordBound], justificationFlags: TextServer.JustificationFlag = [.kashida, .wordBound], direction: TextServer.Direction = .auto, orientation: TextServer.Orientation = .horizontal) {
        #if false
        
        var copy_pos = pos
        let gstr_text = GString (text)
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_width = width
        var copy_font_size: Int = Int (fontSize)
        var copy_max_lines: Int = Int (maxLines)
        var copy_size: Int = Int (size)
        var copy_modulate = modulate
        var copy_brk_flags = brkFlags
        var copy_justification_flags = justificationFlags
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_multiline_string_outline, UnsafeMutableRawPointer (mutating: handle), nil, &copy_font_handle, &copy_pos, &gstr_text.content, &copy_alignment, &copy_width, &copy_font_size, &copy_max_lines, &copy_size, &copy_modulate, &copy_brk_flags, &copy_justification_flags, &copy_direction, &copy_orientation)
        
        #else
        
        var copy_pos = pos
        let gstr_text = GString (text)
        var copy_alignment = Int64 (alignment.rawValue)
        var copy_width = width
        var copy_font_size: Int = Int (fontSize)
        var copy_max_lines: Int = Int (maxLines)
        var copy_size: Int = Int (size)
        var copy_modulate = modulate
        var copy_brk_flags = brkFlags
        var copy_justification_flags = justificationFlags
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: font?.handle) { p0 in
        _args.append (font == nil ? nil : p0)
            withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_text.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_alignment) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_width) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_font_size) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_max_lines) { p6 in
                                    _args.append (p6)
                                    withUnsafePointer (to: &copy_size) { p7 in
                                        _args.append (p7)
                                        withUnsafePointer (to: &copy_modulate) { p8 in
                                            _args.append (p8)
                                            withUnsafePointer (to: &copy_brk_flags) { p9 in
                                                _args.append (p9)
                                                withUnsafePointer (to: &copy_justification_flags) { p10 in
                                                    _args.append (p10)
                                                    withUnsafePointer (to: &copy_direction) { p11 in
                                                        _args.append (p11)
                                                        withUnsafePointer (to: &copy_orientation) { p12 in
                                                            _args.append (p12)
        
                                                            gi.object_method_bind_ptrcall (CanvasItem.method_draw_multiline_string_outline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_char: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_char")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3339793283)!
            }
            
        }
        
    }()
    
    /// Draws a string first character using a custom font.
    public final func drawChar (font: Font?, pos: Vector2, char: String, fontSize: Int32 = 16, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_pos = pos
        let gstr_char = GString (char)
        var copy_font_size: Int = Int (fontSize)
        var copy_modulate = modulate
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_char, UnsafeMutableRawPointer (mutating: handle), nil, &copy_font_handle, &copy_pos, &gstr_char.content, &copy_font_size, &copy_modulate)
        
        #else
        
        var copy_pos = pos
        let gstr_char = GString (char)
        var copy_font_size: Int = Int (fontSize)
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: font?.handle) { p0 in
        _args.append (font == nil ? nil : p0)
            withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_char.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_font_size) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_modulate) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (CanvasItem.method_draw_char, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_char_outline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_char_outline")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3302344391)!
            }
            
        }
        
    }()
    
    /// Draws a string first character outline using a custom font.
    public final func drawCharOutline (font: Font?, pos: Vector2, char: String, fontSize: Int32 = 16, size: Int32 = -1, modulate: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_pos = pos
        let gstr_char = GString (char)
        var copy_font_size: Int = Int (fontSize)
        var copy_size: Int = Int (size)
        var copy_modulate = modulate
        var copy_font_handle = font?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_char_outline, UnsafeMutableRawPointer (mutating: handle), nil, &copy_font_handle, &copy_pos, &gstr_char.content, &copy_font_size, &copy_size, &copy_modulate)
        
        #else
        
        var copy_pos = pos
        let gstr_char = GString (char)
        var copy_font_size: Int = Int (fontSize)
        var copy_size: Int = Int (size)
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: font?.handle) { p0 in
        _args.append (font == nil ? nil : p0)
            withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &gstr_char.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_font_size) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_size) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_modulate) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (CanvasItem.method_draw_char_outline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_mesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_mesh")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 153818295)!
            }
            
        }
        
    }()
    
    /// Draws a ``Mesh`` in 2D, using the provided texture. See ``MeshInstance2D`` for related documentation.
    public final func drawMesh (_ mesh: Mesh?, texture: Texture2D?, transform: Transform2D = Transform2D (xAxis: Vector2 (x: 1, y: 0), yAxis: Vector2 (x: 0, y: 1), origin: Vector2 (x: 0, y: 0)), modulate: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_transform = transform
        var copy_modulate = modulate
        var copy_mesh_handle = mesh?.handle
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_mesh, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mesh_handle, &copy_texture_handle, &copy_transform, &copy_modulate)
        
        #else
        
        var copy_transform = transform
        var copy_modulate = modulate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: mesh?.handle) { p0 in
        _args.append (mesh == nil ? nil : p0)
            withUnsafePointer (to: texture?.handle) { p1 in
            _args.append (texture == nil ? nil : p1)
                withUnsafePointer (to: &copy_transform) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_modulate) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_mesh, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_multimesh: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_multimesh")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 937992368)!
            }
            
        }
        
    }()
    
    /// Draws a ``MultiMesh`` in 2D with the provided texture. See ``MultiMeshInstance2D`` for related documentation.
    public final func drawMultimesh (_ multimesh: MultiMesh?, texture: Texture2D?) {
        #if false
        
        var copy_multimesh_handle = multimesh?.handle
        var copy_texture_handle = texture?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_multimesh, UnsafeMutableRawPointer (mutating: handle), nil, &copy_multimesh_handle, &copy_texture_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: multimesh?.handle) { p0 in
        _args.append (multimesh == nil ? nil : p0)
            withUnsafePointer (to: texture?.handle) { p1 in
            _args.append (texture == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (CanvasItem.method_draw_multimesh, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_set_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 288975085)!
            }
            
        }
        
    }()
    
    /// Sets a custom transform for drawing via components. Anything drawn afterwards will be transformed by this.
    /// 
    /// > Note: ``FontFile/oversampling`` does _not_ take `scale` into account. This means that scaling up/down will cause bitmap fonts and rasterized (non-MSDF) dynamic fonts to appear blurry or pixelated. To ensure text remains crisp regardless of scale, you can enable MSDF font rendering by enabling ``ProjectSettings/gui/theme/defaultFontMultichannelSignedDistanceField`` (applies to the default project font only), or enabling **Multichannel Signed Distance Field** in the import options of a DynamicFont for custom fonts. On system fonts, ``SystemFont/multichannelSignedDistanceField`` can be enabled in the inspector.
    /// 
    public final func drawSetTransform (position: Vector2, rotation: Double = 0.0, scale: Vector2 = Vector2 (x: 1, y: 1)) {
        #if false
        
        var copy_position = position
        var copy_rotation = rotation
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_set_transform, UnsafeMutableRawPointer (mutating: handle), nil, &copy_position, &copy_rotation, &copy_scale)
        
        #else
        
        var copy_position = position
        var copy_rotation = rotation
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_rotation) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_scale) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (CanvasItem.method_draw_set_transform, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_set_transform_matrix: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_set_transform_matrix")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2761652528)!
            }
            
        }
        
    }()
    
    /// Sets a custom transform for drawing via matrix. Anything drawn afterwards will be transformed by this.
    public final func drawSetTransformMatrix (xform: Transform2D) {
        #if false
        
        var copy_xform = xform
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_set_transform_matrix, UnsafeMutableRawPointer (mutating: handle), nil, &copy_xform)
        
        #else
        
        var copy_xform = xform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_xform) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_draw_set_transform_matrix, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_draw_animation_slice: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_animation_slice")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3112831842)!
            }
            
        }
        
    }()
    
    /// Subsequent drawing commands will be ignored unless they fall within the specified animation slice. This is a faster way to implement animations that loop on background rather than redrawing constantly.
    public final func drawAnimationSlice (animationLength: Double, sliceBegin: Double, sliceEnd: Double, offset: Double = 0.0) {
        #if false
        
        var copy_animation_length = animationLength
        var copy_slice_begin = sliceBegin
        var copy_slice_end = sliceEnd
        var copy_offset = offset
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_draw_animation_slice, UnsafeMutableRawPointer (mutating: handle), nil, &copy_animation_length, &copy_slice_begin, &copy_slice_end, &copy_offset)
        
        #else
        
        var copy_animation_length = animationLength
        var copy_slice_begin = sliceBegin
        var copy_slice_end = sliceEnd
        var copy_offset = offset
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_animation_length) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_slice_begin) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_slice_end) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_offset) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (CanvasItem.method_draw_animation_slice, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_end_animation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_end_animation")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// After submitting all animations slices via ``drawAnimationSlice(animationLength:sliceBegin:sliceEnd:offset:)``, this function can be used to revert drawing to its default state (all subsequent drawing commands will be visible). If you don't care about this particular use case, usage of this function after submitting the slices is not required.
    public final func drawEndAnimation () {
        gi.object_method_bind_ptrcall (CanvasItem.method_draw_end_animation, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform matrix of this item.
    public final func getTransform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_global_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_global_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the global transform matrix of this item, i.e. the combined transform up to the topmost ``CanvasItem`` node. The topmost item is a ``CanvasItem`` that either has no parent, has non-``CanvasItem`` parent or it has ``topLevel`` enabled.
    public final func getGlobalTransform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_global_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_global_transform_with_canvas: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_global_transform_with_canvas")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform from the local coordinate system of this ``CanvasItem`` to the ``Viewport``s coordinate system.
    public final func getGlobalTransformWithCanvas ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_global_transform_with_canvas, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_viewport_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_viewport_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform from the coordinate system of the canvas, this item is in, to the ``Viewport``s embedders coordinate system.
    public final func getViewportTransform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_viewport_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_viewport_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_viewport_rect")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1639390495)!
            }
            
        }
        
    }()
    
    /// Returns the viewport's boundaries as a ``Rect2``.
    public final func getViewportRect ()-> Rect2 {
        var _result: Rect2 = Rect2 ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_viewport_rect, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_canvas_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_canvas_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform from the coordinate system of the canvas, this item is in, to the ``Viewport``s coordinate system.
    public final func getCanvasTransform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_canvas_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_screen_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_screen_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814499831)!
            }
            
        }
        
    }()
    
    /// Returns the transform of this ``CanvasItem`` in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
    /// 
    /// Equals to ``getGlobalTransform()`` if the window is embedded (see ``Viewport/guiEmbedSubwindows``).
    /// 
    public final func getScreenTransform ()-> Transform2D {
        var _result: Transform2D = Transform2D ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_screen_transform, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_local_mouse_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_local_mouse_position")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the mouse's position in this ``CanvasItem`` using the local coordinate system of this ``CanvasItem``.
    public final func getLocalMousePosition ()-> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_local_mouse_position, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_global_mouse_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_global_mouse_position")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the mouse's position in the ``CanvasLayer`` that this ``CanvasItem`` is in using the coordinate system of the ``CanvasLayer``.
    /// 
    /// > Note: For screen-space coordinates (e.g. when using a non-embedded ``Popup``), you can use ``DisplayServer/mouseGetPosition()``.
    /// 
    public final func getGlobalMousePosition ()-> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_global_mouse_position, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_canvas: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_canvas")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2944877500)!
            }
            
        }
        
    }()
    
    /// Returns the ``RID`` of the ``World2D`` canvas where this item is in.
    public final func getCanvas ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (CanvasItem.method_get_canvas, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_world_2d: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_world_2d")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2339128592)!
            }
            
        }
        
    }()
    
    /// Returns the ``World2D`` where this item is in.
    public final func getWorld2d ()-> World2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (CanvasItem.method_get_world_2d, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_material")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2757459619)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_material (_ material: Material?) {
        #if false
        
        var copy_material_handle = material?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_material, UnsafeMutableRawPointer (mutating: handle), nil, &copy_material_handle)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: material?.handle) { p0 in
        _args.append (material == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_material, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_material")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 5934680)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_material ()-> Material? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (CanvasItem.method_get_material, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_use_parent_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_use_parent_material")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_use_parent_material (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_use_parent_material, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_use_parent_material, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_use_parent_material: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_use_parent_material")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_use_parent_material ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_get_use_parent_material, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_notify_local_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_notify_local_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `enable` is `true`, this node will receive ``notificationLocalTransformChanged`` when its local transform changes.
    public final func setNotifyLocalTransform (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_notify_local_transform, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_notify_local_transform, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_local_transform_notification_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_local_transform_notification_enabled")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if local transform notifications are communicated to children.
    public final func isLocalTransformNotificationEnabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_is_local_transform_notification_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_notify_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_notify_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    /// If `enable` is `true`, this node will receive ``notificationTransformChanged`` when its global transform changes.
    public final func setNotifyTransform (enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_notify_transform, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_notify_transform, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_transform_notification_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_transform_notification_enabled")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if global transform notifications are communicated to children.
    public final func isTransformNotificationEnabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (CanvasItem.method_is_transform_notification_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_force_update_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("force_update_transform")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Forces the transform to update. Transform changes in physics are not instant for performance reasons. Transforms are accumulated and then set. Use this if you need an up-to-date transform when doing physics operations.
    public final func forceUpdateTransform () {
        gi.object_method_bind_ptrcall (CanvasItem.method_force_update_transform, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_make_canvas_position_local: GDExtensionMethodBindPtr = {
        let methodName = StringName ("make_canvas_position_local")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2656412154)!
            }
            
        }
        
    }()
    
    /// Assigns `screenPoint` as this node's new local transform.
    public final func makeCanvasPositionLocal (screenPoint: Vector2)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_screen_point = screenPoint
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_make_canvas_position_local, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_screen_point)
        return _result
        #else
        
        var copy_screen_point = screenPoint
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_screen_point) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_make_canvas_position_local, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_make_input_local: GDExtensionMethodBindPtr = {
        let methodName = StringName ("make_input_local")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 811130057)!
            }
            
        }
        
    }()
    
    /// Transformations issued by `event`'s inputs are applied in local space instead of global space.
    public final func makeInputLocal (event: InputEvent?)-> InputEvent? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_event_handle = event?.handle
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_make_input_local, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_event_handle)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: event?.handle) { p0 in
        _args.append (event == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_make_input_local, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_visibility_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_visibility_layer")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_visibility_layer (_ layer: UInt32) {
        #if false
        
        var copy_layer: Int = Int (layer)
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_visibility_layer, UnsafeMutableRawPointer (mutating: handle), nil, &copy_layer)
        
        #else
        
        var copy_layer: Int = Int (layer)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_layer) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_visibility_layer, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_visibility_layer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visibility_layer")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_visibility_layer ()-> UInt32 {
        var _result: UInt32 = 0
        gi.object_method_bind_ptrcall (CanvasItem.method_get_visibility_layer, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_visibility_layer_bit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_visibility_layer_bit")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Set/clear individual bits on the rendering visibility layer. This simplifies editing this ``CanvasItem``'s visibility layer.
    public final func setVisibilityLayerBit (layer: UInt32, enabled: Bool) {
        #if false
        
        var copy_layer: Int = Int (layer)
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_visibility_layer_bit, UnsafeMutableRawPointer (mutating: handle), nil, &copy_layer, &copy_enabled)
        
        #else
        
        var copy_layer: Int = Int (layer)
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_layer) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (CanvasItem.method_set_visibility_layer_bit, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_visibility_layer_bit: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_visibility_layer_bit")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns an individual bit on the rendering visibility layer.
    public final func getVisibilityLayerBit (layer: UInt32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_layer: Int = Int (layer)
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_get_visibility_layer_bit, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_layer)
        return _result
        #else
        
        var copy_layer: Int = Int (layer)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_layer) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_get_visibility_layer_bit, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_texture_filter")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1037999706)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_texture_filter (_ mode: CanvasItem.TextureFilter) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_texture_filter, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_texture_filter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_texture_filter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_texture_filter")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 121960042)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_texture_filter ()-> CanvasItem.TextureFilter {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (CanvasItem.method_get_texture_filter, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return CanvasItem.TextureFilter (rawValue: _result)!
    }
    
    fileprivate static var method_set_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_texture_repeat")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1716472974)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_texture_repeat (_ mode: CanvasItem.TextureRepeat) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_texture_repeat, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_texture_repeat, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_texture_repeat: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_texture_repeat")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2667158319)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_texture_repeat ()-> CanvasItem.TextureRepeat {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (CanvasItem.method_get_texture_repeat, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return CanvasItem.TextureRepeat (rawValue: _result)!
    }
    
    fileprivate static var method_set_clip_children_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_clip_children_mode")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1319393776)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_clip_children_mode (_ mode: CanvasItem.ClipChildrenMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (CanvasItem.method_set_clip_children_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (CanvasItem.method_set_clip_children_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_clip_children_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_clip_children_mode")
        return withUnsafePointer (to: &CanvasItem.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3581808349)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_clip_children_mode ()-> CanvasItem.ClipChildrenMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (CanvasItem.method_get_clip_children_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return CanvasItem.ClipChildrenMode (rawValue: _result)!
    }
    
    override class func getVirtualDispatcher (name: StringName) -> GDExtensionClassCallVirtual? {
        guard implementedOverrides().contains(name) else { return nil }
        switch name.description {
            case "_draw":
                return _CanvasItem_proxy_draw
            default:
                return super.getVirtualDispatcher (name: name)
        }
        
    }
    
    // Signals 
    /// Emitted when the ``CanvasItem`` must redraw, _after_ the related ``notificationDraw`` notification, and _before_ ``_draw()`` is called.
    /// 
    /// > Note: Deferred connections do not allow drawing through the `draw_*` methods.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.draw.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var draw: SimpleSignal { SimpleSignal (target: self, signalName: "draw") }
    
    /// Emitted when the visibility (hidden/visible) changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.visibilityChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var visibilityChanged: SimpleSignal { SimpleSignal (target: self, signalName: "visibility_changed") }
    
    /// Emitted when becoming hidden.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.hidden.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var hidden: SimpleSignal { SimpleSignal (target: self, signalName: "hidden") }
    
    /// Emitted when the item's ``Rect2`` boundaries (position or size) have changed, or when an action is taking place that may have impacted these boundaries (e.g. changing ``Sprite2D/texture``).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemRectChanged.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemRectChanged: SimpleSignal { SimpleSignal (target: self, signalName: "item_rect_changed") }
    
}

// Support methods for proxies
func _CanvasItem_proxy_draw (instance: UnsafeMutableRawPointer?, args: UnsafePointer<UnsafeRawPointer?>?, retPtr: UnsafeMutableRawPointer?) {
    guard let instance else { return }
    let swiftObject = Unmanaged<CanvasItem>.fromOpaque(instance).takeUnretainedValue()
    swiftObject._draw ()
}

