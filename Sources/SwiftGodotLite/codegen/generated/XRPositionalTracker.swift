// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A tracked object.
/// 
/// An instance of this object represents a device that is tracked, such as a controller or anchor point. HMDs aren't represented here as they are handled internally.
/// 
/// As controllers are turned on and the ``XRInterface`` detects them, instances of this object are automatically added to this list of active tracking objects accessible through the ``XRServer``.
/// 
/// The ``XRController3D`` and ``XRAnchor3D`` both consume objects of this type and should be used in your project. The positional trackers are just under-the-hood objects that make this all work. These are mostly exposed so that GDExtension-based interfaces can interact with them.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``poseChanged``
/// - ``poseLostTracking``
/// - ``buttonPressed``
/// - ``buttonReleased``
/// - ``inputFloatChanged``
/// - ``inputVector2Changed``
/// - ``profileChanged``
open class XRPositionalTracker: RefCounted {
    override open class var godotClassName: StringName { "XRPositionalTracker" }
    public enum TrackerHand: Int64 {
        /// The hand this tracker is held in is unknown or not applicable.
        case unknown = 0 // TRACKER_HAND_UNKNOWN
        /// This tracker is the left hand controller.
        case left = 1 // TRACKER_HAND_LEFT
        /// This tracker is the right hand controller.
        case right = 2 // TRACKER_HAND_RIGHT
    }
    
    
    /* Properties */
    
    /// The type of tracker.
    final public var type: XRServer.TrackerType {
        get {
            return get_tracker_type ()
        }
        
        set {
            set_tracker_type (newValue)
        }
        
    }
    
    /// The unique name of this tracker. The trackers that are available differ between various XR runtimes and can often be configured by the user. Godot maintains a number of reserved names that it expects the ``XRInterface`` to implement if applicable:
    /// 
    /// - `left_hand` identifies the controller held in the players left hand
    /// 
    /// - `right_hand` identifies the controller held in the players right hand
    /// 
    final public var name: StringName {
        get {
            return get_tracker_name ()
        }
        
        set {
            set_tracker_name (newValue)
        }
        
    }
    
    /// The description of this tracker.
    final public var additionalDescription: String {
        get {
            return get_tracker_desc ()
        }
        
        set {
            set_tracker_desc (newValue)
        }
        
    }
    
    /// The profile associated with this tracker, interface dependent but will indicate the type of controller being tracked.
    final public var profile: String {
        get {
            return get_tracker_profile ()
        }
        
        set {
            set_tracker_profile (newValue)
        }
        
    }
    
    /// Defines which hand this tracker relates to.
    final public var hand: XRPositionalTracker.TrackerHand {
        get {
            return get_tracker_hand ()
        }
        
        set {
            set_tracker_hand (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_tracker_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tracker_type")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2784508102)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tracker_type ()-> XRServer.TrackerType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (XRPositionalTracker.method_get_tracker_type, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return XRServer.TrackerType (rawValue: _result)!
    }
    
    fileprivate static var method_set_tracker_type: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tracker_type")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3055763575)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tracker_type (_ type: XRServer.TrackerType) {
        #if false
        
        var copy_type = Int64 (type.rawValue)
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_set_tracker_type, UnsafeMutableRawPointer (mutating: handle), nil, &copy_type)
        
        #else
        
        var copy_type = Int64 (type.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_set_tracker_type, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tracker_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tracker_name")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2002593661)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tracker_name ()-> StringName {
        let _result: StringName = StringName ()
        gi.object_method_bind_ptrcall (XRPositionalTracker.method_get_tracker_name, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_tracker_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tracker_name")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tracker_name (_ name: StringName) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_set_tracker_name, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_set_tracker_name, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tracker_desc: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tracker_desc")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tracker_desc ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (XRPositionalTracker.method_get_tracker_desc, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_tracker_desc: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tracker_desc")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tracker_desc (_ description: String) {
        #if false
        
        let gstr_description = GString (description)
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_set_tracker_desc, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_description.content)
        
        #else
        
        let gstr_description = GString (description)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_description.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_set_tracker_desc, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tracker_profile: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tracker_profile")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tracker_profile ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (XRPositionalTracker.method_get_tracker_profile, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_set_tracker_profile: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tracker_profile")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 83702148)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tracker_profile (_ profile: String) {
        #if false
        
        let gstr_profile = GString (profile)
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_set_tracker_profile, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_profile.content)
        
        #else
        
        let gstr_profile = GString (profile)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_profile.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_set_tracker_profile, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tracker_hand: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tracker_hand")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4181770860)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tracker_hand ()-> XRPositionalTracker.TrackerHand {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (XRPositionalTracker.method_get_tracker_hand, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return XRPositionalTracker.TrackerHand (rawValue: _result)!
    }
    
    fileprivate static var method_set_tracker_hand: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tracker_hand")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3904108980)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tracker_hand (_ hand: XRPositionalTracker.TrackerHand) {
        #if false
        
        var copy_hand = Int64 (hand.rawValue)
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_set_tracker_hand, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hand)
        
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_set_tracker_hand, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_has_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_pose")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2619796661)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the tracker is available and is currently tracking the bound `name` pose.
    public final func hasPose (name: StringName)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_has_pose, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_has_pose, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_pose")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4099720006)!
            }
            
        }
        
    }()
    
    /// Returns the current ``XRPose`` state object for the bound `name` pose.
    public final func getPose (name: StringName)-> XRPose? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_get_pose, UnsafeMutableRawPointer (mutating: handle), &_result, &name.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_get_pose, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_invalidate_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName ("invalidate_pose")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Marks this pose as invalid, we don't clear the last reported state but it allows users to decide if trackers need to be hidden if we lose tracking or just remain at their last known position.
    public final func invalidatePose (name: StringName) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_invalidate_pose, UnsafeMutableRawPointer (mutating: handle), nil, &name.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_invalidate_pose, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_set_pose: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_pose")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3451230163)!
            }
            
        }
        
    }()
    
    /// Sets the transform, linear velocity, angular velocity and tracking confidence for the given pose. This method is called by a ``XRInterface`` implementation and should not be used directly.
    public final func setPose (name: StringName, transform: Transform3D, linearVelocity: Vector3, angularVelocity: Vector3, trackingConfidence: XRPose.TrackingConfidence) {
        #if false
        
        var copy_transform = transform
        var copy_linear_velocity = linearVelocity
        var copy_angular_velocity = angularVelocity
        var copy_tracking_confidence = Int64 (trackingConfidence.rawValue)
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_set_pose, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &copy_transform, &copy_linear_velocity, &copy_angular_velocity, &copy_tracking_confidence)
        
        #else
        
        var copy_transform = transform
        var copy_linear_velocity = linearVelocity
        var copy_angular_velocity = angularVelocity
        var copy_tracking_confidence = Int64 (trackingConfidence.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_linear_velocity) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_angular_velocity) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_tracking_confidence) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (XRPositionalTracker.method_set_pose, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_input")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2760726917)!
            }
            
        }
        
    }()
    
    /// Returns an input for this tracker. It can return a boolean, float or ``Vector2`` value depending on whether the input is a button, trigger or thumbstick/thumbpad.
    public final func getInput (name: StringName)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_get_input, UnsafeMutableRawPointer (mutating: handle), &_result.content, &name.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (XRPositionalTracker.method_get_input, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_input: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_input")
        return withUnsafePointer (to: &XRPositionalTracker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3776071444)!
            }
            
        }
        
    }()
    
    /// Changes the value for the given input. This method is called by a ``XRInterface`` implementation and should not be used directly.
    public final func setInput (name: StringName, value: Variant) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (XRPositionalTracker.method_set_input, UnsafeMutableRawPointer (mutating: handle), nil, &name.content, &value.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &value.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (XRPositionalTracker.method_set_input, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ pose: XRPose) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? XRPose ?? XRPose (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the state of a pose tracked by this tracker changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.poseChanged.connect { pose in
    ///    print ("caught signal")
    /// }
    /// ```
    public var poseChanged: Signal1 { Signal1 (target: self, signalName: "pose_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ pose: XRPose) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? XRPose ?? XRPose (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a pose tracked by this tracker stops getting updated tracking data.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.poseLostTracking.connect { pose in
    ///    print ("caught signal")
    /// }
    /// ```
    public var poseLostTracking: Signal2 { Signal2 (target: self, signalName: "pose_lost_tracking") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ name: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a button on this tracker is pressed. Note that many XR runtimes allow other inputs to be mapped to buttons.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.buttonPressed.connect { name in
    ///    print ("caught signal")
    /// }
    /// ```
    public var buttonPressed: Signal3 { Signal3 (target: self, signalName: "button_pressed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ name: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a button on this tracker is released.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.buttonReleased.connect { name in
    ///    print ("caught signal")
    /// }
    /// ```
    public var buttonReleased: Signal4 { Signal4 (target: self, signalName: "button_released") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ name: String, _ value: Double) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                let arg_1 = Double (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a trigger or similar input on this tracker changes value.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.inputFloatChanged.connect { name, value in
    ///    print ("caught signal")
    /// }
    /// ```
    public var inputFloatChanged: Signal5 { Signal5 (target: self, signalName: "input_float_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal6/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal6/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal6/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal6 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal6 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ name: String, _ vector: Vector2) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                let arg_1 = Vector2 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a thumbstick or thumbpad on this tracker moves.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.inputVector2Changed.connect { name, vector in
    ///    print ("caught signal")
    /// }
    /// ```
    public var inputVector2Changed: Signal6 { Signal6 (target: self, signalName: "input_vector2_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal7/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal7/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal7/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal7 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal7 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ role: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the profile of our tracker changes.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.profileChanged.connect { role in
    ///    print ("caught signal")
    /// }
    /// ```
    public var profileChanged: Signal7 { Signal7 (target: self, signalName: "profile_changed") }
    
}

