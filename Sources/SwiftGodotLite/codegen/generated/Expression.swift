// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A class that stores an expression you can execute.
/// 
/// An expression can be made of any arithmetic operation, built-in math function call, method call of a passed instance, or built-in type construction call.
/// 
/// An example expression text using the built-in math functions could be `sqrt(pow(3, 2) + pow(4, 2))`.
/// 
/// In the following example we use a ``LineEdit`` node to write our expression and show the result.
/// 
open class Expression: RefCounted {
    override open class var godotClassName: StringName { "Expression" }
    /* Methods */
    fileprivate static var method_parse: GDExtensionMethodBindPtr = {
        let methodName = StringName ("parse")
        return withUnsafePointer (to: &Expression.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3069722906)!
            }
            
        }
        
    }()
    
    /// Parses the expression and returns an ``GodotError`` code.
    /// 
    /// You can optionally specify names of variables that may appear in the expression with `inputNames`, so that you can bind them when it gets executed.
    /// 
    public final func parse (expression: String, inputNames: PackedStringArray = PackedStringArray())-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        let gstr_expression = GString (expression)
        
        gi.object_method_bind_ptrcall_v (Expression.method_parse, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_expression.content, &inputNames.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_expression = GString (expression)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_expression.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &inputNames.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Expression.method_parse, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_execute: GDExtensionMethodBindPtr = {
        let methodName = StringName ("execute")
        return withUnsafePointer (to: &Expression.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3712471238)!
            }
            
        }
        
    }()
    
    /// Executes the expression that was previously parsed by ``parse(expression:inputNames:)`` and returns the result. Before you use the returned object, you should check if the method failed by calling ``hasExecuteFailed()``.
    /// 
    /// If you defined input variables in ``parse(expression:inputNames:)``, you can specify their values in the inputs array, in the same order.
    /// 
    public final func execute (inputs: GArray = GArray (), baseInstance: Object? = nil, showError: Bool = true, constCallsOnly: Bool = false)-> Variant {
        let _result: Variant = Variant ()
        #if true
        
        var copy_show_error = showError
        var copy_const_calls_only = constCallsOnly
        var copy_base_instance_handle = baseInstance?.handle
        
        gi.object_method_bind_ptrcall_v (Expression.method_execute, UnsafeMutableRawPointer (mutating: handle), &_result.content, &inputs.content, &copy_base_instance_handle, &copy_show_error, &copy_const_calls_only)
        return _result
        #else
        
        var copy_show_error = showError
        var copy_const_calls_only = constCallsOnly
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &inputs.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: baseInstance?.handle) { p1 in
            _args.append (baseInstance == nil ? nil : p1)
                return withUnsafePointer (to: &copy_show_error) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_const_calls_only) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (Expression.method_execute, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_has_execute_failed: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_execute_failed")
        return withUnsafePointer (to: &Expression.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if ``execute(inputs:baseInstance:showError:constCallsOnly:)`` has failed.
    public final func hasExecuteFailed ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Expression.method_has_execute_failed, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_error_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_error_text")
        return withUnsafePointer (to: &Expression.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the error text if ``parse(expression:inputNames:)`` or ``execute(inputs:baseInstance:showError:constCallsOnly:)`` has failed.
    public final func getErrorText ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (Expression.method_get_error_text, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
}

