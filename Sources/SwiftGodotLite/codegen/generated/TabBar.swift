// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A control that provides a horizontal bar with tabs.
/// 
/// A control that provides a horizontal bar with tabs. Similar to ``TabContainer`` but is only in charge of drawing tabs, not interacting with children.
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``tabSelected``
/// - ``tabChanged``
/// - ``tabClicked``
/// - ``tabRmbClicked``
/// - ``tabClosePressed``
/// - ``tabButtonPressed``
/// - ``tabHovered``
/// - ``activeTabRearranged``
open class TabBar: Control {
    override open class var godotClassName: StringName { "TabBar" }
    public enum AlignmentMode: Int64 {
        /// Places tabs to the left.
        case left = 0 // ALIGNMENT_LEFT
        /// Places tabs in the middle.
        case center = 1 // ALIGNMENT_CENTER
        /// Places tabs to the right.
        case right = 2 // ALIGNMENT_RIGHT
        /// Represents the size of the ``TabBar/AlignmentMode`` enum.
        case max = 3 // ALIGNMENT_MAX
    }
    
    public enum CloseButtonDisplayPolicy: Int64 {
        /// Never show the close buttons.
        case showNever = 0 // CLOSE_BUTTON_SHOW_NEVER
        /// Only show the close button on the currently active tab.
        case showActiveOnly = 1 // CLOSE_BUTTON_SHOW_ACTIVE_ONLY
        /// Show the close button on all tabs.
        case showAlways = 2 // CLOSE_BUTTON_SHOW_ALWAYS
        /// Represents the size of the ``TabBar/CloseButtonDisplayPolicy`` enum.
        case max = 3 // CLOSE_BUTTON_MAX
    }
    
    
    /* Properties */
    
    /// The number of tabs currently in the bar.
    final public var tabCount: Int32 {
        get {
            return get_tab_count ()
        }
        
        set {
            set_tab_count (newValue)
        }
        
    }
    
    /// Select tab at index `tab_idx`.
    final public var currentTab: Int32 {
        get {
            return get_current_tab ()
        }
        
        set {
            set_current_tab (newValue)
        }
        
    }
    
    /// Sets the position at which tabs will be placed. See ``TabBar/AlignmentMode`` for details.
    final public var tabAlignment: TabBar.AlignmentMode {
        get {
            return get_tab_alignment ()
        }
        
        set {
            set_tab_alignment (newValue)
        }
        
    }
    
    /// If `true`, tabs overflowing this node's width will be hidden, displaying two navigation buttons instead. Otherwise, this node's minimum size is updated so that all tabs are visible.
    final public var clipTabs: Bool {
        get {
            return get_clip_tabs ()
        }
        
        set {
            set_clip_tabs (newValue)
        }
        
    }
    
    /// Sets when the close button will appear on the tabs. See ``TabBar/CloseButtonDisplayPolicy`` for details.
    final public var tabCloseDisplayPolicy: TabBar.CloseButtonDisplayPolicy {
        get {
            return get_tab_close_display_policy ()
        }
        
        set {
            set_tab_close_display_policy (newValue)
        }
        
    }
    
    /// Sets the maximum width which all tabs should be limited to. Unlimited if set to `0`.
    final public var maxTabWidth: Int32 {
        get {
            return get_max_tab_width ()
        }
        
        set {
            set_max_tab_width (newValue)
        }
        
    }
    
    /// if `true`, the mouse's scroll wheel can be used to navigate the scroll view.
    final public var scrollingEnabled: Bool {
        get {
            return get_scrolling_enabled ()
        }
        
        set {
            set_scrolling_enabled (newValue)
        }
        
    }
    
    /// If `true`, tabs can be rearranged with mouse drag.
    final public var dragToRearrangeEnabled: Bool {
        get {
            return get_drag_to_rearrange_enabled ()
        }
        
        set {
            set_drag_to_rearrange_enabled (newValue)
        }
        
    }
    
    /// ``TabBar``s with the same rearrange group ID will allow dragging the tabs between them. Enable drag with ``dragToRearrangeEnabled``.
    /// 
    /// Setting this to `-1` will disable rearranging between ``TabBar``s.
    /// 
    final public var tabsRearrangeGroup: Int32 {
        get {
            return get_tabs_rearrange_group ()
        }
        
        set {
            set_tabs_rearrange_group (newValue)
        }
        
    }
    
    /// If `true`, the tab offset will be changed to keep the currently selected tab visible.
    final public var scrollToSelected: Bool {
        get {
            return get_scroll_to_selected ()
        }
        
        set {
            set_scroll_to_selected (newValue)
        }
        
    }
    
    /// If `true`, enables selecting a tab with the right mouse button.
    final public var selectWithRmb: Bool {
        get {
            return get_select_with_rmb ()
        }
        
        set {
            set_select_with_rmb (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_tab_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_count")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tab_count (_ count: Int32) {
        #if false
        
        var copy_count: Int = Int (count)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_count, UnsafeMutableRawPointer (mutating: handle), nil, &copy_count)
        
        #else
        
        var copy_count: Int = Int (count)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_count) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_tab_count, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_count")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tab_count ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabBar.method_get_tab_count, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_current_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_current_tab")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_current_tab (_ tabIdx: Int32) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_current_tab, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_current_tab, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_current_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_current_tab")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_current_tab ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabBar.method_get_current_tab, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_previous_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_previous_tab")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the previously active tab index.
    public final func getPreviousTab ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabBar.method_get_previous_tab, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_select_previous_available: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select_previous_available")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Selects the first available tab with lower index than the currently selected. Returns `true` if tab selection changed.
    public final func selectPreviousAvailable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabBar.method_select_previous_available, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_select_next_available: GDExtensionMethodBindPtr = {
        let methodName = StringName ("select_next_available")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Selects the first available tab with greater index than the currently selected. Returns `true` if tab selection changed.
    public final func selectNextAvailable ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabBar.method_select_next_available, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_tab_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_title")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets a `title` for the tab at index `tabIdx`.
    public final func setTabTitle (tabIdx: Int32, title: String) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        let gstr_title = GString (title)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_title, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &gstr_title.content)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        let gstr_title = GString (title)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_title.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_title, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_title")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the title of the tab at index `tabIdx`.
    public final func getTabTitle (tabIdx: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_title, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_tab_idx)
        return _result.description
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_title, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_text_direction")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1707680378)!
            }
            
        }
        
    }()
    
    /// Sets tab title base writing direction.
    public final func setTabTextDirection (tabIdx: Int32, direction: Control.TextDirection) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_direction = Int64 (direction.rawValue)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_text_direction, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_direction)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_direction = Int64 (direction.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_direction) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_text_direction, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_text_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_text_direction")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4235602388)!
            }
            
        }
        
    }()
    
    /// Returns tab title text base writing direction.
    public final func getTabTextDirection (tabIdx: Int32)-> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_text_direction, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        return Control.TextDirection (rawValue: _result)!
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_text_direction, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return Control.TextDirection (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_language")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets language code of tab title used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    public final func setTabLanguage (tabIdx: Int32, language: String) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_language, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &gstr_language.content)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_language, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_language")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns tab title language code.
    public final func getTabLanguage (tabIdx: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_language, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_tab_idx)
        return _result.description
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_language, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_icon")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 666127730)!
            }
            
        }
        
    }()
    
    /// Sets an `icon` for the tab at index `tabIdx`.
    public final func setTabIcon (tabIdx: Int32, icon: Texture2D?) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_icon, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_icon_handle)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_icon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_icon")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3536238170)!
            }
            
        }
        
    }()
    
    /// Returns the icon for the tab at index `tabIdx` or `null` if the tab has no icon.
    public final func getTabIcon (tabIdx: Int32)-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_icon_max_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_icon_max_width")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the maximum allowed width of the icon for the tab at index `tabIdx`. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
    public final func setTabIconMaxWidth (tabIdx: Int32, width: Int32) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_width: Int = Int (width)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_icon_max_width, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_width)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_width: Int = Int (width)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_icon_max_width, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_icon_max_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_icon_max_width")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the maximum allowed width of the icon for the tab at index `tabIdx`.
    public final func getTabIconMaxWidth (tabIdx: Int32)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_icon_max_width, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        return _result
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_icon_max_width, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_button_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_button_icon")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 666127730)!
            }
            
        }
        
    }()
    
    /// Sets an `icon` for the button of the tab at index `tabIdx` (located to the right, before the close button), making it visible and clickable (See [signal tab_button_pressed]). Giving it a `null` value will hide the button.
    public final func setTabButtonIcon (tabIdx: Int32, icon: Texture2D?) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_button_icon, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_icon_handle)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_button_icon, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_button_icon: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_button_icon")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3536238170)!
            }
            
        }
        
    }()
    
    /// Returns the icon for the right button of the tab at index `tabIdx` or `null` if the right button has no icon.
    public final func getTabButtonIcon (tabIdx: Int32)-> Texture2D? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_button_icon, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_button_icon, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_disabled")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `disabled` is `true`, disables the tab at index `tabIdx`, making it non-interactable.
    public final func setTabDisabled (tabIdx: Int32, disabled: Bool) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_disabled = disabled
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_disabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_disabled)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_disabled = disabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_disabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_tab_disabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_tab_disabled")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the tab at index `tabIdx` is disabled.
    public final func isTabDisabled (tabIdx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_is_tab_disabled, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        return _result
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_is_tab_disabled, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_hidden")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `hidden` is `true`, hides the tab at index `tabIdx`, making it disappear from the tab area.
    public final func setTabHidden (tabIdx: Int32, hidden: Bool) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_hidden = hidden
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_hidden, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &copy_hidden)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var copy_hidden = hidden
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_hidden) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_hidden, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_tab_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_tab_hidden")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the tab at index `tabIdx` is hidden.
    public final func isTabHidden (tabIdx: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_is_tab_hidden, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        return _result
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_is_tab_hidden, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_metadata")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2152698145)!
            }
            
        }
        
    }()
    
    /// Sets the metadata value for the tab at index `tabIdx`, which can be retrieved later using ``getTabMetadata(tabIdx:)``.
    public final func setTabMetadata (tabIdx: Int32, metadata: Variant) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_metadata, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx, &metadata.content)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &metadata.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_set_tab_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_metadata: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_metadata")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4227898402)!
            }
            
        }
        
    }()
    
    /// Returns the metadata value set to the tab at index `tabIdx` using ``setTabMetadata(tabIdx:metadata:)``. If no metadata was previously set, returns `null` by default.
    public final func getTabMetadata (tabIdx: Int32)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_metadata, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_tab_idx)
        return _result
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_metadata, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_remove_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("remove_tab")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Removes the tab at index `tabIdx`.
    public final func removeTab (tabIdx: Int32) {
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_remove_tab, UnsafeMutableRawPointer (mutating: handle), nil, &copy_tab_idx)
        
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_remove_tab, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_add_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_tab")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1465444425)!
            }
            
        }
        
    }()
    
    /// Adds a new tab.
    public final func addTab (title: String = "", icon: Texture2D? = nil) {
        #if false
        
        let gstr_title = GString (title)
        var copy_icon_handle = icon?.handle
        
        gi.object_method_bind_ptrcall_v (TabBar.method_add_tab, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_title.content, &copy_icon_handle)
        
        #else
        
        let gstr_title = GString (title)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_title.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: icon?.handle) { p1 in
            _args.append (icon == nil ? nil : p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_add_tab, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_idx_at_point: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_idx_at_point")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3820158470)!
            }
            
        }
        
    }()
    
    /// Returns the index of the tab at local coordinates `point`. Returns `-1` if the point is outside the control boundaries or if there's no tab at the queried position.
    public final func getTabIdxAtPoint (_ point: Vector2)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_point = point
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_idx_at_point, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_point)
        return _result
        #else
        
        var copy_point = point
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_point) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_idx_at_point, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_alignment")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2413632353)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tab_alignment (_ alignment: TabBar.AlignmentMode) {
        #if false
        
        var copy_alignment = Int64 (alignment.rawValue)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_alignment, UnsafeMutableRawPointer (mutating: handle), nil, &copy_alignment)
        
        #else
        
        var copy_alignment = Int64 (alignment.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_alignment) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_tab_alignment, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_alignment")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2178122193)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tab_alignment ()-> TabBar.AlignmentMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TabBar.method_get_tab_alignment, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TabBar.AlignmentMode (rawValue: _result)!
    }
    
    fileprivate static var method_set_clip_tabs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_clip_tabs")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_clip_tabs (_ clipTabs: Bool) {
        #if false
        
        var copy_clip_tabs = clipTabs
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_clip_tabs, UnsafeMutableRawPointer (mutating: handle), nil, &copy_clip_tabs)
        
        #else
        
        var copy_clip_tabs = clipTabs
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_clip_tabs) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_clip_tabs, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_clip_tabs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_clip_tabs")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_clip_tabs ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabBar.method_get_clip_tabs, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_tab_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_offset")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the number of hidden tabs offsetted to the left.
    public final func getTabOffset ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabBar.method_get_tab_offset, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_offset_buttons_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_offset_buttons_visible")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the offset buttons (the ones that appear when there's not enough space for all tabs) are visible.
    public final func getOffsetButtonsVisible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabBar.method_get_offset_buttons_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_ensure_tab_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("ensure_tab_visible")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    /// Moves the scroll view to make the tab visible.
    public final func ensureTabVisible (idx: Int32) {
        #if false
        
        var copy_idx: Int = Int (idx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_ensure_tab_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_idx)
        
        #else
        
        var copy_idx: Int = Int (idx)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_ensure_tab_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_rect")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3327874267)!
            }
            
        }
        
    }()
    
    /// Returns tab ``Rect2`` with local position and size.
    public final func getTabRect (tabIdx: Int32)-> Rect2 {
        var _result: Rect2 = Rect2 ()
        #if false
        
        var copy_tab_idx: Int = Int (tabIdx)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_get_tab_rect, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_tab_idx)
        return _result
        #else
        
        var copy_tab_idx: Int = Int (tabIdx)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tab_idx) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_get_tab_rect, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_move_tab: GDExtensionMethodBindPtr = {
        let methodName = StringName ("move_tab")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Moves a tab from `from` to `to`.
    public final func moveTab (from: Int32, to: Int32) {
        #if false
        
        var copy_from: Int = Int (from)
        var copy_to: Int = Int (to)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_move_tab, UnsafeMutableRawPointer (mutating: handle), nil, &copy_from, &copy_to)
        
        #else
        
        var copy_from: Int = Int (from)
        var copy_to: Int = Int (to)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TabBar.method_move_tab, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_tab_close_display_policy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tab_close_display_policy")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2212906737)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tab_close_display_policy (_ policy: TabBar.CloseButtonDisplayPolicy) {
        #if false
        
        var copy_policy = Int64 (policy.rawValue)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tab_close_display_policy, UnsafeMutableRawPointer (mutating: handle), nil, &copy_policy)
        
        #else
        
        var copy_policy = Int64 (policy.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_policy) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_tab_close_display_policy, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tab_close_display_policy: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tab_close_display_policy")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2956568028)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tab_close_display_policy ()-> TabBar.CloseButtonDisplayPolicy {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (TabBar.method_get_tab_close_display_policy, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return TabBar.CloseButtonDisplayPolicy (rawValue: _result)!
    }
    
    fileprivate static var method_set_max_tab_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_max_tab_width")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_max_tab_width (_ width: Int32) {
        #if false
        
        var copy_width: Int = Int (width)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_max_tab_width, UnsafeMutableRawPointer (mutating: handle), nil, &copy_width)
        
        #else
        
        var copy_width: Int = Int (width)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_width) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_max_tab_width, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_max_tab_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_max_tab_width")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_max_tab_width ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabBar.method_get_max_tab_width, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scrolling_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scrolling_enabled")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scrolling_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_scrolling_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_scrolling_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_scrolling_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scrolling_enabled")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scrolling_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabBar.method_get_scrolling_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_drag_to_rearrange_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_drag_to_rearrange_enabled")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drag_to_rearrange_enabled (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_drag_to_rearrange_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_drag_to_rearrange_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_drag_to_rearrange_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_drag_to_rearrange_enabled")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_drag_to_rearrange_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabBar.method_get_drag_to_rearrange_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_tabs_rearrange_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_tabs_rearrange_group")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_tabs_rearrange_group (_ groupId: Int32) {
        #if false
        
        var copy_group_id: Int = Int (groupId)
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_tabs_rearrange_group, UnsafeMutableRawPointer (mutating: handle), nil, &copy_group_id)
        
        #else
        
        var copy_group_id: Int = Int (groupId)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_group_id) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_tabs_rearrange_group, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_tabs_rearrange_group: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_tabs_rearrange_group")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_tabs_rearrange_group ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (TabBar.method_get_tabs_rearrange_group, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_scroll_to_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_scroll_to_selected")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_scroll_to_selected (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_scroll_to_selected, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_scroll_to_selected, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_scroll_to_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scroll_to_selected")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_scroll_to_selected ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabBar.method_get_scroll_to_selected, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_select_with_rmb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_select_with_rmb")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_select_with_rmb (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TabBar.method_set_select_with_rmb, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TabBar.method_set_select_with_rmb, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_select_with_rmb: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_select_with_rmb")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_select_with_rmb ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (TabBar.method_get_select_with_rmb, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_clear_tabs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear_tabs")
        return withUnsafePointer (to: &TabBar.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears all tabs.
    public final func clearTabs () {
        gi.object_method_bind_ptrcall (TabBar.method_clear_tabs, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab is selected via click, directional input, or script, even if it is the current tab.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabSelected.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabSelected: Signal1 { Signal1 (target: self, signalName: "tab_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when switching to another tab.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabChanged.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabChanged: Signal2 { Signal2 (target: self, signalName: "tab_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab is clicked, even if it is the current tab.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabClicked.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabClicked: Signal3 { Signal3 (target: self, signalName: "tab_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab is right-clicked. ``selectWithRmb`` must be enabled.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabRmbClicked.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabRmbClicked: Signal4 { Signal4 (target: self, signalName: "tab_rmb_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab's close button is pressed.
    /// 
    /// > Note: Tabs are not removed automatically once the close button is pressed, this behavior needs to be programmed manually. For example:
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabClosePressed.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabClosePressed: Signal5 { Signal5 (target: self, signalName: "tab_close_pressed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal6/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal6/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal6/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal6 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal6 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab's right button is pressed. See ``setTabButtonIcon(tabIdx:icon:)``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabButtonPressed.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabButtonPressed: Signal6 { Signal6 (target: self, signalName: "tab_button_pressed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal7/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal7/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal7/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal7 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal7 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ tab: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a tab is hovered by the mouse.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.tabHovered.connect { tab in
    ///    print ("caught signal")
    /// }
    /// ```
    public var tabHovered: Signal7 { Signal7 (target: self, signalName: "tab_hovered") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal8/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal8/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal8/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal8 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal8 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ idxTo: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the active tab is rearranged via mouse drag. See ``dragToRearrangeEnabled``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.activeTabRearranged.connect { idxTo in
    ///    print ("caught signal")
    /// }
    /// ```
    public var activeTabRearranged: Signal8 { Signal8 (target: self, signalName: "active_tab_rearranged") }
    
}

