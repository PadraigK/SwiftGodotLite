// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A control used to show a set of internal ``TreeItem``s in a hierarchical structure.
/// 
/// A control used to show a set of internal ``TreeItem``s in a hierarchical structure. The tree items can be selected, expanded and collapsed. The tree can have multiple columns with custom controls like ``LineEdit``s, buttons and popups. It can be useful for structured displays and interactions.
/// 
/// Trees are built via code, using ``TreeItem`` objects to create the structure. They have a single root, but multiple roots can be simulated with ``hideRoot``:
/// 
/// To iterate over all the ``TreeItem`` objects in a ``Tree`` object, use ``TreeItem/getNext()`` and ``TreeItem/getFirstChild()`` after getting the root through ``getRoot()``. You can use ``Object/free()`` on a ``TreeItem`` to remove it from the ``Tree``.
/// 
/// **Incremental search:** Like ``ItemList`` and ``PopupMenu``, ``Tree`` supports searching within the list while the control is focused. Press a key that matches the first letter of an item's name to select the first item starting with the given letter. After that point, there are two ways to perform incremental search: 1) Press the same key again before the timeout duration to select the next item starting with the same letter. 2) Press letter keys that match the rest of the word before the timeout duration to match to select the item in question directly. Both of these actions will be reset to the beginning of the list if the timeout duration has passed since the last keystroke was registered. You can adjust the timeout duration by changing ``ProjectSettings/gui/timers/incrementalSearchMaxIntervalMsec``.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``itemSelected``
/// - ``cellSelected``
/// - ``multiSelected``
/// - ``itemMouseSelected``
/// - ``emptyClicked``
/// - ``itemEdited``
/// - ``customItemClicked``
/// - ``itemIconDoubleClicked``
/// - ``itemCollapsed``
/// - ``checkPropagatedToItem``
/// - ``buttonClicked``
/// - ``customPopupEdited``
/// - ``itemActivated``
/// - ``columnTitleClicked``
/// - ``nothingSelected``
open class Tree: Control {
    override open class var godotClassName: StringName { "Tree" }
    public enum SelectMode: Int64 {
        /// Allows selection of a single cell at a time. From the perspective of items, only a single item is allowed to be selected. And there is only one column selected in the selected item.
        /// 
        /// The focus cursor is always hidden in this mode, but it is positioned at the current selection, making the currently selected item the currently focused item.
        /// 
        case single = 0 // SELECT_SINGLE
        /// Allows selection of a single row at a time. From the perspective of items, only a single items is allowed to be selected. And all the columns are selected in the selected item.
        /// 
        /// The focus cursor is always hidden in this mode, but it is positioned at the first column of the current selection, making the currently selected item the currently focused item.
        /// 
        case row = 1 // SELECT_ROW
        /// Allows selection of multiple cells at the same time. From the perspective of items, multiple items are allowed to be selected. And there can be multiple columns selected in each selected item.
        /// 
        /// The focus cursor is visible in this mode, the item or column under the cursor is not necessarily selected.
        /// 
        case multi = 2 // SELECT_MULTI
    }
    
    public enum DropModeFlags: Int64 {
        /// Disables all drop sections, but still allows to detect the "on item" drop section by ``getDropSectionAtPosition(_:)``.
        /// 
        /// > Note: This is the default flag, it has no effect when combined with other flags.
        /// 
        case disabled = 0 // DROP_MODE_DISABLED
        /// Enables the "on item" drop section. This drop section covers the entire item.
        /// 
        /// When combined with .dropModeInbetween, this drop section halves the height and stays centered vertically.
        /// 
        case onItem = 1 // DROP_MODE_ON_ITEM
        /// Enables "above item" and "below item" drop sections. The "above item" drop section covers the top half of the item, and the "below item" drop section covers the bottom half.
        /// 
        /// When combined with .dropModeOnItem, these drop sections halves the height and stays on top / bottom accordingly.
        /// 
        case inbetween = 2 // DROP_MODE_INBETWEEN
    }
    
    
    /* Properties */
    
    /// The number of columns.
    final public var columns: Int32 {
        get {
            return get_columns ()
        }
        
        set {
            set_columns (newValue)
        }
        
    }
    
    /// If `true`, column titles are visible.
    final public var columnTitlesVisible: Bool {
        get {
            return are_column_titles_visible ()
        }
        
        set {
            set_column_titles_visible (newValue)
        }
        
    }
    
    /// If `true`, the currently selected cell may be selected again.
    final public var allowReselect: Bool {
        get {
            return get_allow_reselect ()
        }
        
        set {
            set_allow_reselect (newValue)
        }
        
    }
    
    /// If `true`, a right mouse button click can select items.
    final public var allowRmbSelect: Bool {
        get {
            return get_allow_rmb_select ()
        }
        
        set {
            set_allow_rmb_select (newValue)
        }
        
    }
    
    /// If `true`, allows navigating the ``Tree`` with letter keys through incremental search.
    final public var allowSearch: Bool {
        get {
            return get_allow_search ()
        }
        
        set {
            set_allow_search (newValue)
        }
        
    }
    
    /// If `true`, the folding arrow is hidden.
    final public var hideFolding: Bool {
        get {
            return is_folding_hidden ()
        }
        
        set {
            set_hide_folding (newValue)
        }
        
    }
    
    /// If `true`, recursive folding is enabled for this ``Tree``. Holding down Shift while clicking the fold arrow collapses or uncollapses the ``TreeItem`` and all its descendants.
    final public var enableRecursiveFolding: Bool {
        get {
            return is_recursive_folding_enabled ()
        }
        
        set {
            set_enable_recursive_folding (newValue)
        }
        
    }
    
    /// If `true`, the tree's root is hidden.
    final public var hideRoot: Bool {
        get {
            return is_root_hidden ()
        }
        
        set {
            set_hide_root (newValue)
        }
        
    }
    
    /// The drop mode as an OR combination of flags. See ``Tree/DropModeFlags`` constants. Once dropping is done, reverts to .dropModeDisabled. Setting this during ``Control/_canDropData(atPosition:data:)`` is recommended.
    /// 
    /// This controls the drop sections, i.e. the decision and drawing of possible drop locations based on the mouse position.
    /// 
    final public var dropModeFlags: Int32 {
        get {
            return get_drop_mode_flags ()
        }
        
        set {
            set_drop_mode_flags (newValue)
        }
        
    }
    
    /// Allows single or multiple selection. See the ``Tree/SelectMode`` constants.
    final public var selectMode: Tree.SelectMode {
        get {
            return get_select_mode ()
        }
        
        set {
            set_select_mode (newValue)
        }
        
    }
    
    /// If `true`, enables horizontal scrolling.
    final public var scrollHorizontalEnabled: Bool {
        get {
            return is_h_scroll_enabled ()
        }
        
        set {
            set_h_scroll_enabled (newValue)
        }
        
    }
    
    /// If `true`, enables vertical scrolling.
    final public var scrollVerticalEnabled: Bool {
        get {
            return is_v_scroll_enabled ()
        }
        
        set {
            set_v_scroll_enabled (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears the tree. This removes all items.
    public final func clear () {
        gi.object_method_bind_ptrcall (Tree.method_clear, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_create_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_item")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 528467046)!
            }
            
        }
        
    }()
    
    /// Creates an item in the tree and adds it as a child of `parent`, which can be either a valid ``TreeItem`` or `null`.
    /// 
    /// If `parent` is `null`, the root item will be the parent, or the new item will be the root itself if the tree is empty.
    /// 
    /// The new item will be the `index`-th child of parent, or it will be the last child if there are not enough siblings.
    /// 
    public final func createItem (parent: TreeItem? = nil, index: Int32 = -1)-> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_index: Int = Int (index)
        var copy_parent_handle = parent?.handle
        
        gi.object_method_bind_ptrcall_v (Tree.method_create_item, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_parent_handle, &copy_index)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_index: Int = Int (index)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: parent?.handle) { p0 in
        _args.append (parent == nil ? nil : p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_create_item, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_root: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_root")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1514277247)!
            }
            
        }
        
    }()
    
    /// Returns the tree's root item, or `null` if the tree is empty.
    public final func getRoot ()-> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Tree.method_get_root, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_column_custom_minimum_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_custom_minimum_width")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Overrides the calculated minimum width of a column. It can be set to `0` to restore the default behavior. Columns that have the "Expand" flag will use their "min_width" in a similar fashion to ``Control/sizeFlagsStretchRatio``.
    public final func setColumnCustomMinimumWidth (column: Int32, minWidth: Int32) {
        #if false
        
        var copy_column: Int = Int (column)
        var copy_min_width: Int = Int (minWidth)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_custom_minimum_width, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &copy_min_width)
        
        #else
        
        var copy_column: Int = Int (column)
        var copy_min_width: Int = Int (minWidth)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_min_width) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_column_custom_minimum_width, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_column_expand: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_expand")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// If `true`, the column will have the "Expand" flag of ``Control``. Columns that have the "Expand" flag will use their expand ratio in a similar fashion to ``Control/sizeFlagsStretchRatio`` (see ``setColumnExpandRatio(column:ratio:)``).
    public final func setColumnExpand (column: Int32, expand: Bool) {
        #if false
        
        var copy_column: Int = Int (column)
        var copy_expand = expand
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_expand, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &copy_expand)
        
        #else
        
        var copy_column: Int = Int (column)
        var copy_expand = expand
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_expand) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_column_expand, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_column_expand_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_expand_ratio")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3937882851)!
            }
            
        }
        
    }()
    
    /// Sets the relative expand ratio for a column. See ``setColumnExpand(column:expand:)``.
    public final func setColumnExpandRatio (column: Int32, ratio: Int32) {
        #if false
        
        var copy_column: Int = Int (column)
        var copy_ratio: Int = Int (ratio)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_expand_ratio, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &copy_ratio)
        
        #else
        
        var copy_column: Int = Int (column)
        var copy_ratio: Int = Int (ratio)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_ratio) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_column_expand_ratio, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_column_clip_content: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_clip_content")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 300928843)!
            }
            
        }
        
    }()
    
    /// Allows to enable clipping for column's content, making the content size ignored.
    public final func setColumnClipContent (column: Int32, enable: Bool) {
        #if false
        
        var copy_column: Int = Int (column)
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_clip_content, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &copy_enable)
        
        #else
        
        var copy_column: Int = Int (column)
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enable) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_column_clip_content, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_column_expanding: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_column_expanding")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the column has enabled expanding (see ``setColumnExpand(column:expand:)``).
    public final func isColumnExpanding (column: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (Tree.method_is_column_expanding, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_column)
        return _result
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_is_column_expanding, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_column_clipping_content: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_column_clipping_content")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1116898809)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the column has enabled clipping (see ``setColumnClipContent(column:enable:)``).
    public final func isColumnClippingContent (column: Int32)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (Tree.method_is_column_clipping_content, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_column)
        return _result
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_is_column_clipping_content, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_column_expand_ratio: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_column_expand_ratio")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the expand ratio assigned to the column.
    public final func getColumnExpandRatio (column: Int32)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_column_expand_ratio, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_column)
        return _result
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_column_expand_ratio, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_column_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_column_width")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 923996154)!
            }
            
        }
        
    }()
    
    /// Returns the column's width in pixels.
    public final func getColumnWidth (column: Int32)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_column_width, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_column)
        return _result
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_column_width, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_hide_root: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hide_root")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_root (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_hide_root, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_hide_root, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_root_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_root_hidden")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_root_hidden ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_is_root_hidden, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_next_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_next_selected")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 873446299)!
            }
            
        }
        
    }()
    
    /// Returns the next selected ``TreeItem`` after the given one, or `null` if the end is reached.
    /// 
    /// If `from` is `null`, this returns the first selected item.
    /// 
    public final func getNextSelected (from: TreeItem?)-> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_from_handle = from?.handle
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_next_selected, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_from_handle)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: from?.handle) { p0 in
        _args.append (from == nil ? nil : p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_next_selected, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selected")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1514277247)!
            }
            
        }
        
    }()
    
    /// Returns the currently focused item, or `null` if no item is focused.
    /// 
    /// In .selectRow and .selectSingle modes, the focused item is same as the selected item. In .selectMulti mode, the focused item is the item under the focus cursor, not necessarily selected.
    /// 
    /// To get the currently selected item(s), use ``getNextSelected(from:)``.
    /// 
    public final func getSelected ()-> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Tree.method_get_selected, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_set_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_selected")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2662547442)!
            }
            
        }
        
    }()
    
    /// Selects the specified ``TreeItem`` and column.
    public final func setSelected (item: TreeItem?, column: Int32) {
        #if false
        
        var copy_column: Int = Int (column)
        var copy_item_handle = item?.handle
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_selected, UnsafeMutableRawPointer (mutating: handle), nil, &copy_item_handle, &copy_column)
        
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: item?.handle) { p0 in
        _args.append (item == nil ? nil : p0)
            withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_selected, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_selected_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_selected_column")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the currently focused column, or -1 if no column is focused.
    /// 
    /// In .selectSingle mode, the focused column is the selected column. In .selectRow mode, the focused column is always 0 if any item is selected. In .selectMulti mode, the focused column is the column under the focus cursor, and there are not necessarily any column selected.
    /// 
    /// To tell whether a column of an item is selected, use ``TreeItem/isSelected(column:)``.
    /// 
    public final func getSelectedColumn ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Tree.method_get_selected_column, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_pressed_button: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_pressed_button")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the last pressed button's index.
    public final func getPressedButton ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Tree.method_get_pressed_button, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_select_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_select_mode")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3223887270)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_select_mode (_ mode: Tree.SelectMode) {
        #if false
        
        var copy_mode = Int64 (mode.rawValue)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_select_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = Int64 (mode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_select_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_select_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_select_mode")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 100748571)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_select_mode ()-> Tree.SelectMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (Tree.method_get_select_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return Tree.SelectMode (rawValue: _result)!
    }
    
    fileprivate static var method_deselect_all: GDExtensionMethodBindPtr = {
        let methodName = StringName ("deselect_all")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Deselects all tree items (rows and columns). In .selectMulti mode also removes selection cursor.
    public final func deselectAll () {
        gi.object_method_bind_ptrcall (Tree.method_deselect_all, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_columns: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_columns")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_columns (_ amount: Int32) {
        #if false
        
        var copy_amount: Int = Int (amount)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_columns, UnsafeMutableRawPointer (mutating: handle), nil, &copy_amount)
        
        #else
        
        var copy_amount: Int = Int (amount)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_amount) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_columns, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_columns: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_columns")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_columns ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Tree.method_get_columns, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_edited: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_edited")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1514277247)!
            }
            
        }
        
    }()
    
    /// Returns the currently edited item. Can be used with [signal item_edited] to get the item that was modified.
    /// 
    public final func getEdited ()-> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        gi.object_method_bind_ptrcall (Tree.method_get_edited, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
    }
    
    fileprivate static var method_get_edited_column: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_edited_column")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns the column for the currently edited item.
    public final func getEditedColumn ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Tree.method_get_edited_column, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_edit_selected: GDExtensionMethodBindPtr = {
        let methodName = StringName ("edit_selected")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2595650253)!
            }
            
        }
        
    }()
    
    /// Edits the selected tree item as if it was clicked.
    /// 
    /// Either the item must be set editable with ``TreeItem/setEditable(column:enabled:)`` or `forceEdit` must be `true`.
    /// 
    /// Returns `true` if the item could be edited. Fails if no item is selected.
    /// 
    public final func editSelected (forceEdit: Bool = false)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_force_edit = forceEdit
        
        gi.object_method_bind_ptrcall_v (Tree.method_edit_selected, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_force_edit)
        return _result
        #else
        
        var copy_force_edit = forceEdit
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_force_edit) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_edit_selected, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_custom_popup_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_custom_popup_rect")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1639390495)!
            }
            
        }
        
    }()
    
    /// Returns the rectangle for custom popups. Helper to create custom cell controls that display a popup. See ``TreeItem/setCellMode(column:mode:)``.
    public final func getCustomPopupRect ()-> Rect2 {
        var _result: Rect2 = Rect2 ()
        gi.object_method_bind_ptrcall (Tree.method_get_custom_popup_rect, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_item_area_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_area_rect")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 47968679)!
            }
            
        }
        
    }()
    
    /// Returns the rectangle area for the specified ``TreeItem``. If `column` is specified, only get the position and size of that column, otherwise get the rectangle containing all columns. If a button index is specified, the rectangle of that button will be returned.
    public final func getItemAreaRect (item: TreeItem?, column: Int32 = -1, buttonIndex: Int32 = -1)-> Rect2 {
        var _result: Rect2 = Rect2 ()
        #if false
        
        var copy_column: Int = Int (column)
        var copy_button_index: Int = Int (buttonIndex)
        var copy_item_handle = item?.handle
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_item_area_rect, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_item_handle, &copy_column, &copy_button_index)
        return _result
        #else
        
        var copy_column: Int = Int (column)
        var copy_button_index: Int = Int (buttonIndex)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: item?.handle) { p0 in
        _args.append (item == nil ? nil : p0)
            return withUnsafePointer (to: &copy_column) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_button_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (Tree.method_get_item_area_rect, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_item_at_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_item_at_position")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4193340126)!
            }
            
        }
        
    }()
    
    /// Returns the tree item at the specified position (relative to the tree origin position).
    public final func getItemAtPosition (_ position: Vector2)-> TreeItem? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_item_at_position, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_position)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_item_at_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_column_at_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_column_at_position")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3820158470)!
            }
            
        }
        
    }()
    
    /// Returns the column index at `position`, or -1 if no item is there.
    public final func getColumnAtPosition (_ position: Vector2)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_column_at_position, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_position)
        return _result
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_column_at_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_drop_section_at_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_drop_section_at_position")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3820158470)!
            }
            
        }
        
    }()
    
    /// Returns the drop section at `position`, or -100 if no item is there.
    /// 
    /// Values -1, 0, or 1 will be returned for the "above item", "on item", and "below item" drop sections, respectively. See ``Tree/DropModeFlags`` for a description of each drop section.
    /// 
    /// To get the item which the returned drop section is relative to, use ``getItemAtPosition(_:)``.
    /// 
    public final func getDropSectionAtPosition (_ position: Vector2)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_drop_section_at_position, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_position)
        return _result
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_drop_section_at_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_button_id_at_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_button_id_at_position")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3820158470)!
            }
            
        }
        
    }()
    
    /// Returns the button ID at `position`, or -1 if no button is there.
    public final func getButtonIdAtPosition (_ position: Vector2)-> Int32 {
        var _result: Int32 = 0
        #if false
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_button_id_at_position, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_position)
        return _result
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_position) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_button_id_at_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_ensure_cursor_is_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("ensure_cursor_is_visible")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Makes the currently focused cell visible.
    /// 
    /// This will scroll the tree if necessary. In .selectRow mode, this will not do horizontal scrolling, as all the cells in the selected row is focused logically.
    /// 
    /// > Note: Despite the name of this method, the focus cursor itself is only visible in .selectMulti mode.
    /// 
    public final func ensureCursorIsVisible () {
        gi.object_method_bind_ptrcall (Tree.method_ensure_cursor_is_visible, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_set_column_titles_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_titles_visible")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_column_titles_visible (_ visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_titles_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_column_titles_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_are_column_titles_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("are_column_titles_visible")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func are_column_titles_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_are_column_titles_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_column_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_title")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets the title of a column.
    public final func setColumnTitle (column: Int32, title: String) {
        #if false
        
        var copy_column: Int = Int (column)
        let gstr_title = GString (title)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_title, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &gstr_title.content)
        
        #else
        
        var copy_column: Int = Int (column)
        let gstr_title = GString (title)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_title.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_column_title, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_column_title: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_column_title")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns the column's title.
    public final func getColumnTitle (column: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_column_title, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_column)
        return _result.description
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_column_title, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_set_column_title_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_title_alignment")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3276431499)!
            }
            
        }
        
    }()
    
    /// Sets the column title alignment. Note that ``@GlobalScope.HORIZONTAL_ALIGNMENT_FILL`` is not supported for column titles.
    public final func setColumnTitleAlignment (column: Int32, titleAlignment: HorizontalAlignment) {
        #if false
        
        var copy_column: Int = Int (column)
        var copy_title_alignment = Int64 (titleAlignment.rawValue)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_title_alignment, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &copy_title_alignment)
        
        #else
        
        var copy_column: Int = Int (column)
        var copy_title_alignment = Int64 (titleAlignment.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_title_alignment) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_column_title_alignment, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_column_title_alignment: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_column_title_alignment")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4171562184)!
            }
            
        }
        
    }()
    
    /// Returns the column title alignment.
    public final func getColumnTitleAlignment (column: Int32)-> HorizontalAlignment {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_column_title_alignment, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_column)
        return HorizontalAlignment (rawValue: _result)!
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_column_title_alignment, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return HorizontalAlignment (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_column_title_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_title_direction")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1707680378)!
            }
            
        }
        
    }()
    
    /// Sets column title base writing direction.
    public final func setColumnTitleDirection (column: Int32, direction: Control.TextDirection) {
        #if false
        
        var copy_column: Int = Int (column)
        var copy_direction = Int64 (direction.rawValue)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_title_direction, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &copy_direction)
        
        #else
        
        var copy_column: Int = Int (column)
        var copy_direction = Int64 (direction.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_direction) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_column_title_direction, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_column_title_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_column_title_direction")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4235602388)!
            }
            
        }
        
    }()
    
    /// Returns column title base writing direction.
    public final func getColumnTitleDirection (column: Int32)-> Control.TextDirection {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_column_title_direction, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_column)
        return Control.TextDirection (rawValue: _result)!
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_column_title_direction, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return Control.TextDirection (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_set_column_title_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_column_title_language")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 501894301)!
            }
            
        }
        
    }()
    
    /// Sets language code of column title used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
    public final func setColumnTitleLanguage (column: Int32, language: String) {
        #if false
        
        var copy_column: Int = Int (column)
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_column_title_language, UnsafeMutableRawPointer (mutating: handle), nil, &copy_column, &gstr_language.content)
        
        #else
        
        var copy_column: Int = Int (column)
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_set_column_title_language, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_column_title_language: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_column_title_language")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Returns column title language code.
    public final func getColumnTitleLanguage (column: Int32)-> String {
        let _result = GString ()
        #if false
        
        var copy_column: Int = Int (column)
        
        gi.object_method_bind_ptrcall_v (Tree.method_get_column_title_language, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_column)
        return _result.description
        #else
        
        var copy_column: Int = Int (column)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_column) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_get_column_title_language, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_get_scroll: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_scroll")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3341600327)!
            }
            
        }
        
    }()
    
    /// Returns the current scrolling position.
    public final func getScroll ()-> Vector2 {
        var _result: Vector2 = Vector2 ()
        gi.object_method_bind_ptrcall (Tree.method_get_scroll, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_scroll_to_item: GDExtensionMethodBindPtr = {
        let methodName = StringName ("scroll_to_item")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1314737213)!
            }
            
        }
        
    }()
    
    /// Causes the ``Tree`` to jump to the specified ``TreeItem``.
    public final func scrollToItem (_ item: TreeItem?, centerOnItem: Bool = false) {
        #if false
        
        var copy_center_on_item = centerOnItem
        var copy_item_handle = item?.handle
        
        gi.object_method_bind_ptrcall_v (Tree.method_scroll_to_item, UnsafeMutableRawPointer (mutating: handle), nil, &copy_item_handle, &copy_center_on_item)
        
        #else
        
        var copy_center_on_item = centerOnItem
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: item?.handle) { p0 in
        _args.append (item == nil ? nil : p0)
            withUnsafePointer (to: &copy_center_on_item) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (Tree.method_scroll_to_item, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_h_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_h_scroll_enabled")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_h_scroll_enabled (_ hScroll: Bool) {
        #if false
        
        var copy_h_scroll = hScroll
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_h_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_h_scroll)
        
        #else
        
        var copy_h_scroll = hScroll
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_h_scroll) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_h_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_h_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_h_scroll_enabled")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_h_scroll_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_is_h_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_v_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_v_scroll_enabled")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_v_scroll_enabled (_ hScroll: Bool) {
        #if false
        
        var copy_h_scroll = hScroll
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_v_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &copy_h_scroll)
        
        #else
        
        var copy_h_scroll = hScroll
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_h_scroll) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_v_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_v_scroll_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_v_scroll_enabled")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_v_scroll_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_is_v_scroll_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hide_folding: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hide_folding")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hide_folding (_ hide: Bool) {
        #if false
        
        var copy_hide = hide
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_hide_folding, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hide)
        
        #else
        
        var copy_hide = hide
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hide) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_hide_folding, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_folding_hidden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_folding_hidden")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_folding_hidden ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_is_folding_hidden, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_enable_recursive_folding: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_enable_recursive_folding")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_enable_recursive_folding (_ enable: Bool) {
        #if false
        
        var copy_enable = enable
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_enable_recursive_folding, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enable)
        
        #else
        
        var copy_enable = enable
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enable) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_enable_recursive_folding, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_recursive_folding_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_recursive_folding_enabled")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_recursive_folding_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_is_recursive_folding_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_drop_mode_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_drop_mode_flags")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_drop_mode_flags (_ flags: Int32) {
        #if false
        
        var copy_flags: Int = Int (flags)
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_drop_mode_flags, UnsafeMutableRawPointer (mutating: handle), nil, &copy_flags)
        
        #else
        
        var copy_flags: Int = Int (flags)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_flags) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_drop_mode_flags, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_drop_mode_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_drop_mode_flags")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_drop_mode_flags ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (Tree.method_get_drop_mode_flags, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_rmb_select: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_allow_rmb_select")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_rmb_select (_ allow: Bool) {
        #if false
        
        var copy_allow = allow
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_allow_rmb_select, UnsafeMutableRawPointer (mutating: handle), nil, &copy_allow)
        
        #else
        
        var copy_allow = allow
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_allow) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_allow_rmb_select, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_allow_rmb_select: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_allow_rmb_select")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_rmb_select ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_get_allow_rmb_select, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_reselect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_allow_reselect")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_reselect (_ allow: Bool) {
        #if false
        
        var copy_allow = allow
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_allow_reselect, UnsafeMutableRawPointer (mutating: handle), nil, &copy_allow)
        
        #else
        
        var copy_allow = allow
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_allow) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_allow_reselect, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_allow_reselect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_allow_reselect")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_reselect ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_get_allow_reselect, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_allow_search: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_allow_search")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_allow_search (_ allow: Bool) {
        #if false
        
        var copy_allow = allow
        
        gi.object_method_bind_ptrcall_v (Tree.method_set_allow_search, UnsafeMutableRawPointer (mutating: handle), nil, &copy_allow)
        
        #else
        
        var copy_allow = allow
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_allow) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (Tree.method_set_allow_search, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_allow_search: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_allow_search")
        return withUnsafePointer (to: &Tree.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_allow_search ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (Tree.method_get_allow_search, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    // Signals 
    /// Emitted when an item is selected.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemSelected.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemSelected: SimpleSignal { SimpleSignal (target: self, signalName: "item_selected") }
    
    /// Emitted when a cell is selected.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.cellSelected.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var cellSelected: SimpleSignal { SimpleSignal (target: self, signalName: "cell_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ item: TreeItem, _ column: Int64, _ selected: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? TreeItem ?? TreeItem (nativeHandle: ptr_0!)
                let arg_1 = Int64 (args [1])!
                let arg_2 = Bool (args [2])!
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted instead of [signal item_selected] if ``selectMode`` is set to .selectMulti.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.multiSelected.connect { item, column, selected in
    ///    print ("caught signal")
    /// }
    /// ```
    public var multiSelected: Signal1 { Signal1 (target: self, signalName: "multi_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ position: Vector2, _ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector2 (args [0])!
                let arg_1 = Int64 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item is selected with a mouse button.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemMouseSelected.connect { position, mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemMouseSelected: Signal2 { Signal2 (target: self, signalName: "item_mouse_selected") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ position: Vector2, _ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Vector2 (args [0])!
                let arg_1 = Int64 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a mouse button is clicked in the empty space of the tree.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.emptyClicked.connect { position, mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var emptyClicked: Signal3 { Signal3 (target: self, signalName: "empty_clicked") }
    
    /// Emitted when an item is edited.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemEdited.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemEdited: SimpleSignal { SimpleSignal (target: self, signalName: "item_edited") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal4/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal4/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal4/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal4 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal4 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item with ``TreeItem/TreeCellMode/cellModeCustom`` is clicked with a mouse button.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.customItemClicked.connect { mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var customItemClicked: Signal4 { Signal4 (target: self, signalName: "custom_item_clicked") }
    
    /// Emitted when an item's icon is double-clicked. For a signal that emits when any part of the item is double-clicked, see [signal item_activated].
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemIconDoubleClicked.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemIconDoubleClicked: SimpleSignal { SimpleSignal (target: self, signalName: "item_icon_double_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal5/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal5/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal5/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal5 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal5 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ item: TreeItem) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? TreeItem ?? TreeItem (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when an item is collapsed by a click on the folding arrow.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemCollapsed.connect { item in
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemCollapsed: Signal5 { Signal5 (target: self, signalName: "item_collapsed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal6/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal6/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal6/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal6 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal6 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ item: TreeItem, _ column: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? TreeItem ?? TreeItem (nativeHandle: ptr_0!)
                let arg_1 = Int64 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when ``TreeItem/propagateCheck(column:emitSignal:)`` is called. Connect to this signal to process the items that are affected when ``TreeItem/propagateCheck(column:emitSignal:)`` is invoked. The order that the items affected will be processed is as follows: the item that invoked the method, children of that item, and finally parents of that item.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.checkPropagatedToItem.connect { item, column in
    ///    print ("caught signal")
    /// }
    /// ```
    public var checkPropagatedToItem: Signal6 { Signal6 (target: self, signalName: "check_propagated_to_item") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal7/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal7/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal7/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal7 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal7 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ item: TreeItem, _ column: Int64, _ id: Int64, _ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? TreeItem ?? TreeItem (nativeHandle: ptr_0!)
                let arg_1 = Int64 (args [1])!
                let arg_2 = Int64 (args [2])!
                let arg_3 = Int64 (args [3])!
                
                callback (arg_0, arg_1, arg_2, arg_3)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a button on the tree was pressed (see ``TreeItem/addButton(column:button:id:disabled:tooltipText:)``).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.buttonClicked.connect { item, column, id, mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var buttonClicked: Signal7 { Signal7 (target: self, signalName: "button_clicked") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal8/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal8/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal8/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal8 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal8 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ arrowClicked: Bool) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Bool (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a cell with the ``TreeItem/TreeCellMode/cellModeCustom`` is clicked to be edited.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.customPopupEdited.connect { arrowClicked in
    ///    print ("caught signal")
    /// }
    /// ```
    public var customPopupEdited: Signal8 { Signal8 (target: self, signalName: "custom_popup_edited") }
    
    /// Emitted when an item is double-clicked, or selected with a `ui_accept` input event (e.g. using [kbd]Enter[/kbd] or [kbd]Space[/kbd] on the keyboard).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.itemActivated.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var itemActivated: SimpleSignal { SimpleSignal (target: self, signalName: "item_activated") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal9/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal9/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal9/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal9 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal9 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ column: Int64, _ mouseButtonIndex: Int64) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Int64 (args [0])!
                let arg_1 = Int64 (args [1])!
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a column's title is clicked with either ``MouseButton/left`` or ``MouseButton/right``.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.columnTitleClicked.connect { column, mouseButtonIndex in
    ///    print ("caught signal")
    /// }
    /// ```
    public var columnTitleClicked: Signal9 { Signal9 (target: self, signalName: "column_title_clicked") }
    
    /// Emitted when a left mouse button click does not select any item.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.nothingSelected.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var nothingSelected: SimpleSignal { SimpleSignal (target: self, signalName: "nothing_selected") }
    
}

