// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Interface to a WebRTC peer connection.
/// 
/// A WebRTC connection between the local computer and a remote peer. Provides an interface to connect, maintain and monitor the connection.
/// 
/// Setting up a WebRTC connection between two peers may not seem a trivial task, but it can be broken down into 3 main steps:
/// 
/// - The peer that wants to initiate the connection (`A` from now on) creates an offer and send it to the other peer (`B` from now on).
/// 
/// - `B` receives the offer, generate and answer, and sends it to `A`).
/// 
/// - `A` and `B` then generates and exchange ICE candidates with each other.
/// 
/// After these steps, the connection should become connected. Keep on reading or look into the tutorial for more information.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``sessionDescriptionCreated``
/// - ``iceCandidateCreated``
/// - ``dataChannelReceived``
open class WebRTCPeerConnection: RefCounted {
    override open class var godotClassName: StringName { "WebRTCPeerConnection" }
    public enum ConnectionState: Int64 {
        /// The connection is new, data channels and an offer can be created in this state.
        case new = 0 // STATE_NEW
        /// The peer is connecting, ICE is in progress, none of the transports has failed.
        case connecting = 1 // STATE_CONNECTING
        /// The peer is connected, all ICE transports are connected.
        case connected = 2 // STATE_CONNECTED
        /// At least one ICE transport is disconnected.
        case disconnected = 3 // STATE_DISCONNECTED
        /// One or more of the ICE transports failed.
        case failed = 4 // STATE_FAILED
        /// The peer connection is closed (after calling ``close()`` for example).
        case closed = 5 // STATE_CLOSED
    }
    
    public enum GatheringState: Int64 {
        /// The peer connection was just created and hasn't done any networking yet.
        case new = 0 // GATHERING_STATE_NEW
        /// The ICE agent is in the process of gathering candidates for the connection.
        case gathering = 1 // GATHERING_STATE_GATHERING
        /// The ICE agent has finished gathering candidates. If something happens that requires collecting new candidates, such as a new interface being added or the addition of a new ICE server, the state will revert to gathering to gather those candidates.
        case complete = 2 // GATHERING_STATE_COMPLETE
    }
    
    public enum SignalingState: Int64 {
        /// There is no ongoing exchange of offer and answer underway. This may mean that the ``WebRTCPeerConnection`` is new (.stateNew) or that negotiation is complete and a connection has been established (.stateConnected).
        case stable = 0 // SIGNALING_STATE_STABLE
        /// The local peer has called ``setLocalDescription(type:sdp:)``, passing in SDP representing an offer (usually created by calling ``createOffer()``), and the offer has been applied successfully.
        case haveLocalOffer = 1 // SIGNALING_STATE_HAVE_LOCAL_OFFER
        /// The remote peer has created an offer and used the signaling server to deliver it to the local peer, which has set the offer as the remote description by calling ``setRemoteDescription(type:sdp:)``.
        case haveRemoteOffer = 2 // SIGNALING_STATE_HAVE_REMOTE_OFFER
        /// The offer sent by the remote peer has been applied and an answer has been created and applied by calling ``setLocalDescription(type:sdp:)``. This provisional answer describes the supported media formats and so forth, but may not have a complete set of ICE candidates included. Further candidates will be delivered separately later.
        case haveLocalPranswer = 3 // SIGNALING_STATE_HAVE_LOCAL_PRANSWER
        /// A provisional answer has been received and successfully applied in response to an offer previously sent and established by calling ``setLocalDescription(type:sdp:)``.
        case haveRemotePranswer = 4 // SIGNALING_STATE_HAVE_REMOTE_PRANSWER
        /// The ``WebRTCPeerConnection`` has been closed.
        case closed = 5 // SIGNALING_STATE_CLOSED
    }
    
    /* Methods */
    fileprivate static var method_set_default_extension: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_default_extension")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3304788590)!
            }
            
        }
        
    }()
    
    /// Sets the `extensionClass` as the default ``WebRTCPeerConnectionExtension`` returned when creating a new ``WebRTCPeerConnection``.
    public static func setDefaultExtension (extensionClass: StringName) {
        #if true
        
        
        gi.object_method_bind_ptrcall_v (WebRTCPeerConnection.method_set_default_extension, nil, nil, &extensionClass.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &extensionClass.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_set_default_extension, nil, &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_initialize: GDExtensionMethodBindPtr = {
        let methodName = StringName ("initialize")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2625064318)!
            }
            
        }
        
    }()
    
    /// Re-initialize this peer connection, closing any previously active connection, and going back to state .stateNew. A dictionary of `configuration` options can be passed to configure the peer connection.
    /// 
    /// Valid `configuration` options are:
    /// 
    public final func initialize (configuration: GDictionary = GDictionary ())-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        
        gi.object_method_bind_ptrcall_v (WebRTCPeerConnection.method_initialize, UnsafeMutableRawPointer (mutating: handle), &_result, &configuration.content)
        return GodotError (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &configuration.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_initialize, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return GodotError (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_create_data_channel: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_data_channel")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1288557393)!
            }
            
        }
        
    }()
    
    /// Returns a new ``WebRTCDataChannel`` (or `null` on failure) with given `label` and optionally configured via the `options` dictionary. This method can only be called when the connection is in state .stateNew.
    /// 
    /// There are two ways to create a working data channel: either call ``createDataChannel(label:options:)`` on only one of the peer and listen to [signal data_channel_received] on the other, or call ``createDataChannel(label:options:)`` on both peers, with the same values, and the `"negotiated"` option set to `true`.
    /// 
    /// Valid `options` are:
    /// 
    /// > Note: You must keep a reference to channels created this way, or it will be closed.
    /// 
    public final func createDataChannel (label: String, options: GDictionary = GDictionary ())-> WebRTCDataChannel? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if true
        
        let gstr_label = GString (label)
        
        gi.object_method_bind_ptrcall_v (WebRTCPeerConnection.method_create_data_channel, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_label.content, &options.content)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        let gstr_label = GString (label)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_label.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &options.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_create_data_channel, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_create_offer: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_offer")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Creates a new SDP offer to start a WebRTC connection with a remote peer. At least one ``WebRTCDataChannel`` must have been created before calling this method.
    /// 
    /// If this functions returns ``GodotError/ok``, [signal session_description_created] will be called when the session is ready to be sent.
    /// 
    public final func createOffer ()-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_create_offer, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_set_local_description: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_local_description")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 852856452)!
            }
            
        }
        
    }()
    
    /// Sets the SDP description of the local peer. This should be called in response to [signal session_description_created].
    /// 
    /// After calling this function the peer will start emitting [signal ice_candidate_created] (unless an ``GodotError`` different from ``GodotError/ok`` is returned).
    /// 
    public final func setLocalDescription (type: String, sdp: String)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        let gstr_type = GString (type)
        let gstr_sdp = GString (sdp)
        
        gi.object_method_bind_ptrcall_v (WebRTCPeerConnection.method_set_local_description, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_type.content, &gstr_sdp.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_type = GString (type)
        let gstr_sdp = GString (sdp)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_type.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_sdp.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_set_local_description, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_set_remote_description: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_remote_description")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 852856452)!
            }
            
        }
        
    }()
    
    /// Sets the SDP description of the remote peer. This should be called with the values generated by a remote peer and received over the signaling server.
    /// 
    /// If `type` is `"offer"` the peer will emit [signal session_description_created] with the appropriate answer.
    /// 
    /// If `type` is `"answer"` the peer will start emitting [signal ice_candidate_created].
    /// 
    public final func setRemoteDescription (type: String, sdp: String)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        let gstr_type = GString (type)
        let gstr_sdp = GString (sdp)
        
        gi.object_method_bind_ptrcall_v (WebRTCPeerConnection.method_set_remote_description, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_type.content, &gstr_sdp.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_type = GString (type)
        let gstr_sdp = GString (sdp)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_type.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_sdp.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_set_remote_description, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_add_ice_candidate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_ice_candidate")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3958950400)!
            }
            
        }
        
    }()
    
    /// Add an ice candidate generated by a remote peer (and received over the signaling server). See [signal ice_candidate_created].
    public final func addIceCandidate (media: String, index: Int32, name: String)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        let gstr_media = GString (media)
        var copy_index: Int = Int (index)
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (WebRTCPeerConnection.method_add_ice_candidate, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_media.content, &copy_index, &gstr_name.content)
        return GodotError (rawValue: _result)!
        #else
        
        let gstr_media = GString (media)
        var copy_index: Int = Int (index)
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_media.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &gstr_name.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_add_ice_candidate, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return GodotError (rawValue: _result)!
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_poll: GDExtensionMethodBindPtr = {
        let methodName = StringName ("poll")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Call this method frequently (e.g. in ``Node/_process(delta:)`` or ``Node/_physicsProcess(delta:)``) to properly receive signals.
    public final func poll ()-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_poll, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_close: GDExtensionMethodBindPtr = {
        let methodName = StringName ("close")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Close the peer connection and all data channels associated with it.
    /// 
    /// > Note: You cannot reuse this object for a new connection unless you call ``initialize(configuration:)``.
    /// 
    public final func close () {
        gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_close, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
    fileprivate static var method_get_connection_state: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_connection_state")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2275710506)!
            }
            
        }
        
    }()
    
    /// Returns the connection state. See ``WebRTCPeerConnection/ConnectionState``.
    public final func getConnectionState ()-> WebRTCPeerConnection.ConnectionState {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_get_connection_state, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return WebRTCPeerConnection.ConnectionState (rawValue: _result)!
    }
    
    fileprivate static var method_get_gathering_state: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_gathering_state")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4262591401)!
            }
            
        }
        
    }()
    
    /// Returns the ICE ``WebRTCPeerConnection/GatheringState`` of the connection. This lets you detect, for example, when collection of ICE candidates has finished.
    public final func getGatheringState ()-> WebRTCPeerConnection.GatheringState {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_get_gathering_state, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return WebRTCPeerConnection.GatheringState (rawValue: _result)!
    }
    
    fileprivate static var method_get_signaling_state: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_signaling_state")
        return withUnsafePointer (to: &WebRTCPeerConnection.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3342956226)!
            }
            
        }
        
    }()
    
    /// Returns the ``WebRTCPeerConnection/SignalingState`` on the local end of the connection while connecting or reconnecting to another peer.
    public final func getSignalingState ()-> WebRTCPeerConnection.SignalingState {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (WebRTCPeerConnection.method_get_signaling_state, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return WebRTCPeerConnection.SignalingState (rawValue: _result)!
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ type: String, _ sdp: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                let arg_1 = GString (args [1])!.description
                
                callback (arg_0, arg_1)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted after a successful call to ``createOffer()`` or ``setRemoteDescription(type:sdp:)`` (when it generates an answer). The parameters are meant to be passed to ``setLocalDescription(type:sdp:)`` on this object, and sent to the remote peer over the signaling server.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionDescriptionCreated.connect { type, sdp in
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionDescriptionCreated: Signal1 { Signal1 (target: self, signalName: "session_description_created") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ media: String, _ index: Int64, _ name: String) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = GString (args [0])!.description
                let arg_1 = Int64 (args [1])!
                let arg_2 = GString (args [2])!.description
                
                callback (arg_0, arg_1, arg_2)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _, _, _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a new ICE candidate has been created. The three parameters are meant to be passed to the remote peer over the signaling server.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.iceCandidateCreated.connect { media, index, name in
    ///    print ("caught signal")
    /// }
    /// ```
    public var iceCandidateCreated: Signal2 { Signal2 (target: self, signalName: "ice_candidate_created") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ channel: WebRTCDataChannel) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                var ptr_0: UnsafeMutableRawPointer?
                args [0].toType (Variant.GType.object, dest: &ptr_0)
                let arg_0 = lookupLiveObject (handleAddress: ptr_0!) as? WebRTCDataChannel ?? WebRTCDataChannel (nativeHandle: ptr_0!)
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a new in-band channel is received, i.e. when the channel was created with `negotiated: false` (default).
    /// 
    /// The object will be an instance of ``WebRTCDataChannel``. You must keep a reference of it or it will be closed automatically. See ``createDataChannel(label:options:)``.
    /// 
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.dataChannelReceived.connect { channel in
    ///    print ("caught signal")
    /// }
    /// ```
    public var dataChannelReceived: Signal3 { Signal3 (target: self, signalName: "data_channel_received") }
    
}

