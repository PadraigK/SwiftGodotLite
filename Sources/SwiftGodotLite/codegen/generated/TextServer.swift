// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A server interface for font management and text rendering.
/// 
/// ``TextServer`` is the API backend for managing fonts and rendering text.
open class TextServer: RefCounted {
    override open class var godotClassName: StringName { "TextServer" }
    public enum FontAntialiasing: Int64 {
        /// Font glyphs are rasterized as 1-bit bitmaps.
        case none = 0 // FONT_ANTIALIASING_NONE
        /// Font glyphs are rasterized as 8-bit grayscale anti-aliased bitmaps.
        case gray = 1 // FONT_ANTIALIASING_GRAY
        /// Font glyphs are rasterized for LCD screens.
        /// 
        /// LCD subpixel layout is determined by the value of `gui/theme/lcd_subpixel_layout` project settings.
        /// 
        /// LCD subpixel anti-aliasing mode is suitable only for rendering horizontal, unscaled text in 2D.
        /// 
        case lcd = 2 // FONT_ANTIALIASING_LCD
    }
    
    public enum FontLCDSubpixelLayout: Int64 {
        /// Unknown or unsupported subpixel layout, LCD subpixel antialiasing is disabled.
        case none = 0 // FONT_LCD_SUBPIXEL_LAYOUT_NONE
        /// Horizontal RGB subpixel layout.
        case hrgb = 1 // FONT_LCD_SUBPIXEL_LAYOUT_HRGB
        /// Horizontal BGR subpixel layout.
        case hbgr = 2 // FONT_LCD_SUBPIXEL_LAYOUT_HBGR
        /// Vertical RGB subpixel layout.
        case vrgb = 3 // FONT_LCD_SUBPIXEL_LAYOUT_VRGB
        /// Vertical BGR subpixel layout.
        case vbgr = 4 // FONT_LCD_SUBPIXEL_LAYOUT_VBGR
        /// 
        case max = 5 // FONT_LCD_SUBPIXEL_LAYOUT_MAX
    }
    
    public enum Direction: Int64 {
        /// Text direction is determined based on contents and current locale.
        case auto = 0 // DIRECTION_AUTO
        /// Text is written from left to right.
        case ltr = 1 // DIRECTION_LTR
        /// Text is written from right to left.
        case rtl = 2 // DIRECTION_RTL
        /// Text writing direction is the same as base string writing direction. Used for BiDi override only.
        case inherited = 3 // DIRECTION_INHERITED
    }
    
    public enum Orientation: Int64 {
        /// Text is written horizontally.
        case horizontal = 0 // ORIENTATION_HORIZONTAL
        /// Left to right text is written vertically from top to bottom.
        /// 
        /// Right to left text is written vertically from bottom to top.
        /// 
        case vertical = 1 // ORIENTATION_VERTICAL
    }
    
    public struct JustificationFlag: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Justify text by adding and removing kashidas.
        public static let kashida = JustificationFlag (rawValue: 1)
        /// Justify text by changing width of the spaces between the words.
        public static let wordBound = JustificationFlag (rawValue: 2)
        /// Remove trailing and leading spaces from the justified text.
        public static let trimEdgeSpaces = JustificationFlag (rawValue: 4)
        /// Only apply justification to the part of the text after the last tab.
        public static let afterLastTab = JustificationFlag (rawValue: 8)
        /// Apply justification to the trimmed line with ellipsis.
        public static let constrainEllipsis = JustificationFlag (rawValue: 16)
        /// Do not apply justification to the last line of the paragraph.
        public static let skipLastLine = JustificationFlag (rawValue: 32)
        /// Do not apply justification to the last line of the paragraph with visible characters (takes precedence over .justificationSkipLastLine).
        public static let skipLastLineWithVisibleChars = JustificationFlag (rawValue: 64)
        /// Always apply justification to the paragraphs with a single line (.justificationSkipLastLine and .justificationSkipLastLineWithVisibleChars are ignored).
        public static let doNotSkipSingleLine = JustificationFlag (rawValue: 128)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.kashida) { result += "kashida, " }
            if self.contains (.wordBound) { result += "wordBound, " }
            if self.contains (.trimEdgeSpaces) { result += "trimEdgeSpaces, " }
            if self.contains (.afterLastTab) { result += "afterLastTab, " }
            if self.contains (.constrainEllipsis) { result += "constrainEllipsis, " }
            if self.contains (.skipLastLine) { result += "skipLastLine, " }
            if self.contains (.skipLastLineWithVisibleChars) { result += "skipLastLineWithVisibleChars, " }
            if self.contains (.doNotSkipSingleLine) { result += "doNotSkipSingleLine, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum AutowrapMode: Int64 {
        /// Autowrap is disabled.
        case off = 0 // AUTOWRAP_OFF
        /// Wraps the text inside the node's bounding rectangle by allowing to break lines at arbitrary positions, which is useful when very limited space is available.
        case arbitrary = 1 // AUTOWRAP_ARBITRARY
        /// Wraps the text inside the node's bounding rectangle by soft-breaking between words.
        case word = 2 // AUTOWRAP_WORD
        /// Behaves similarly to .autowrapWord, but force-breaks a word if that single word does not fit in one line.
        case wordSmart = 3 // AUTOWRAP_WORD_SMART
    }
    
    public struct LineBreakFlag: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Break the line at the line mandatory break characters (e.g. `"\n"`).
        public static let mandatory = LineBreakFlag (rawValue: 1)
        /// Break the line between the words.
        public static let wordBound = LineBreakFlag (rawValue: 2)
        /// Break the line between any unconnected graphemes.
        public static let graphemeBound = LineBreakFlag (rawValue: 4)
        /// Should be used only in conjunction with .breakWordBound, break the line between any unconnected graphemes, if it's impossible to break it between the words.
        public static let adaptive = LineBreakFlag (rawValue: 8)
        /// Remove edge spaces from the broken line segments.
        public static let trimEdgeSpaces = LineBreakFlag (rawValue: 16)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.mandatory) { result += "mandatory, " }
            if self.contains (.wordBound) { result += "wordBound, " }
            if self.contains (.graphemeBound) { result += "graphemeBound, " }
            if self.contains (.adaptive) { result += "adaptive, " }
            if self.contains (.trimEdgeSpaces) { result += "trimEdgeSpaces, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum VisibleCharactersBehavior: Int64 {
        /// Trims text before the shaping. e.g, increasing ``Label/visibleCharacters`` or ``RichTextLabel/visibleCharacters`` value is visually identical to typing the text.
        case charsBeforeShaping = 0 // VC_CHARS_BEFORE_SHAPING
        /// Displays glyphs that are mapped to the first ``Label/visibleCharacters`` or ``RichTextLabel/visibleCharacters`` characters from the beginning of the text.
        case charsAfterShaping = 1 // VC_CHARS_AFTER_SHAPING
        /// Displays ``Label/visibleRatio`` or ``RichTextLabel/visibleRatio`` glyphs, starting from the left or from the right, depending on ``Control/layoutDirection`` value.
        case glyphsAuto = 2 // VC_GLYPHS_AUTO
        /// Displays ``Label/visibleRatio`` or ``RichTextLabel/visibleRatio`` glyphs, starting from the left.
        case glyphsLtr = 3 // VC_GLYPHS_LTR
        /// Displays ``Label/visibleRatio`` or ``RichTextLabel/visibleRatio`` glyphs, starting from the right.
        case glyphsRtl = 4 // VC_GLYPHS_RTL
    }
    
    public enum OverrunBehavior: Int64 {
        /// No text trimming is performed.
        case noTrimming = 0 // OVERRUN_NO_TRIMMING
        /// Trims the text per character.
        case trimChar = 1 // OVERRUN_TRIM_CHAR
        /// Trims the text per word.
        case trimWord = 2 // OVERRUN_TRIM_WORD
        /// Trims the text per character and adds an ellipsis to indicate that parts are hidden.
        case trimEllipsis = 3 // OVERRUN_TRIM_ELLIPSIS
        /// Trims the text per word and adds an ellipsis to indicate that parts are hidden.
        case trimWordEllipsis = 4 // OVERRUN_TRIM_WORD_ELLIPSIS
    }
    
    public struct TextOverrunFlag: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Trims the text when it exceeds the given width.
        public static let trim = TextOverrunFlag (rawValue: 1)
        /// Trims the text per word instead of per grapheme.
        public static let trimWordOnly = TextOverrunFlag (rawValue: 2)
        /// Determines whether an ellipsis should be added at the end of the text.
        public static let addEllipsis = TextOverrunFlag (rawValue: 4)
        /// Determines whether the ellipsis at the end of the text is enforced and may not be hidden.
        public static let enforceEllipsis = TextOverrunFlag (rawValue: 8)
        /// 
        public static let justificationAware = TextOverrunFlag (rawValue: 16)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.trim) { result += "trim, " }
            if self.contains (.trimWordOnly) { result += "trimWordOnly, " }
            if self.contains (.addEllipsis) { result += "addEllipsis, " }
            if self.contains (.enforceEllipsis) { result += "enforceEllipsis, " }
            if self.contains (.justificationAware) { result += "justificationAware, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public struct GraphemeFlag: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Grapheme is supported by the font, and can be drawn.
        public static let valid = GraphemeFlag (rawValue: 1)
        /// Grapheme is part of right-to-left or bottom-to-top run.
        public static let rtl = GraphemeFlag (rawValue: 2)
        /// Grapheme is not part of source text, it was added by justification process.
        public static let virtual = GraphemeFlag (rawValue: 4)
        /// Grapheme is whitespace.
        public static let space = GraphemeFlag (rawValue: 8)
        /// Grapheme is mandatory break point (e.g. `"\n"`).
        public static let breakHard = GraphemeFlag (rawValue: 16)
        /// Grapheme is optional break point (e.g. space).
        public static let breakSoft = GraphemeFlag (rawValue: 32)
        /// Grapheme is the tabulation character.
        public static let tab = GraphemeFlag (rawValue: 64)
        /// Grapheme is kashida.
        public static let elongation = GraphemeFlag (rawValue: 128)
        /// Grapheme is punctuation character.
        public static let punctuation = GraphemeFlag (rawValue: 256)
        /// Grapheme is underscore character.
        public static let underscore = GraphemeFlag (rawValue: 512)
        /// Grapheme is connected to the previous grapheme. Breaking line before this grapheme is not safe.
        public static let connected = GraphemeFlag (rawValue: 1024)
        /// It is safe to insert a U+0640 before this grapheme for elongation.
        public static let safeToInsertTatweel = GraphemeFlag (rawValue: 2048)
        /// Grapheme is an object replacement character for the embedded object.
        public static let embeddedObject = GraphemeFlag (rawValue: 4096)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.valid) { result += "valid, " }
            if self.contains (.rtl) { result += "rtl, " }
            if self.contains (.virtual) { result += "virtual, " }
            if self.contains (.space) { result += "space, " }
            if self.contains (.breakHard) { result += "breakHard, " }
            if self.contains (.breakSoft) { result += "breakSoft, " }
            if self.contains (.tab) { result += "tab, " }
            if self.contains (.elongation) { result += "elongation, " }
            if self.contains (.punctuation) { result += "punctuation, " }
            if self.contains (.underscore) { result += "underscore, " }
            if self.contains (.connected) { result += "connected, " }
            if self.contains (.safeToInsertTatweel) { result += "safeToInsertTatweel, " }
            if self.contains (.embeddedObject) { result += "embeddedObject, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum Hinting: Int64 {
        /// Disables font hinting (smoother but less crisp).
        case none = 0 // HINTING_NONE
        /// Use the light font hinting mode.
        case light = 1 // HINTING_LIGHT
        /// Use the default font hinting mode (crisper but less smooth).
        /// 
        /// > Note: This hinting mode changes both horizontal and vertical glyph metrics. If applied to monospace font, some glyphs might have different width.
        /// 
        case normal = 2 // HINTING_NORMAL
    }
    
    public enum SubpixelPositioning: Int64 {
        /// Glyph horizontal position is rounded to the whole pixel size, each glyph is rasterized once.
        case disabled = 0 // SUBPIXEL_POSITIONING_DISABLED
        /// Glyph horizontal position is rounded based on font size.
        /// 
        /// - To one quarter of the pixel size if font size is smaller or equal to .oneQuarterMaxSize.
        /// 
        /// - To one half of the pixel size if font size is smaller or equal to .oneHalfMaxSize.
        /// 
        /// - To the whole pixel size for larger fonts.
        /// 
        case auto = 1 // SUBPIXEL_POSITIONING_AUTO
        /// Glyph horizontal position is rounded to one half of the pixel size, each glyph is rasterized up to two times.
        case oneHalf = 2 // SUBPIXEL_POSITIONING_ONE_HALF
        /// Glyph horizontal position is rounded to one quarter of the pixel size, each glyph is rasterized up to four times.
        case oneQuarter = 3 // SUBPIXEL_POSITIONING_ONE_QUARTER
        /// Maximum font size which will use one half of the pixel subpixel positioning in .auto mode.
        case oneHalfMaxSize = 20 // SUBPIXEL_POSITIONING_ONE_HALF_MAX_SIZE
        /// Maximum font size which will use one quarter of the pixel subpixel positioning in .auto mode.
        case oneQuarterMaxSize = 16 // SUBPIXEL_POSITIONING_ONE_QUARTER_MAX_SIZE
    }
    
    public enum Feature: Int64 {
        /// TextServer supports simple text layouts.
        case simpleLayout = 1 // FEATURE_SIMPLE_LAYOUT
        /// TextServer supports bidirectional text layouts.
        case bidiLayout = 2 // FEATURE_BIDI_LAYOUT
        /// TextServer supports vertical layouts.
        case verticalLayout = 4 // FEATURE_VERTICAL_LAYOUT
        /// TextServer supports complex text shaping.
        case shaping = 8 // FEATURE_SHAPING
        /// TextServer supports justification using kashidas.
        case kashidaJustification = 16 // FEATURE_KASHIDA_JUSTIFICATION
        /// TextServer supports complex line/word breaking rules (e.g. dictionary based).
        case breakIterators = 32 // FEATURE_BREAK_ITERATORS
        /// TextServer supports loading bitmap fonts.
        case fontBitmap = 64 // FEATURE_FONT_BITMAP
        /// TextServer supports loading dynamic (TrueType, OpeType, etc.) fonts.
        case fontDynamic = 128 // FEATURE_FONT_DYNAMIC
        /// TextServer supports multichannel signed distance field dynamic font rendering.
        case fontMsdf = 256 // FEATURE_FONT_MSDF
        /// TextServer supports loading system fonts.
        case fontSystem = 512 // FEATURE_FONT_SYSTEM
        /// TextServer supports variable fonts.
        case fontVariable = 1024 // FEATURE_FONT_VARIABLE
        /// TextServer supports locale dependent and context sensitive case conversion.
        case contextSensitiveCaseConversion = 2048 // FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION
        /// TextServer require external data file for some features, see ``loadSupportData(filename:)``.
        case useSupportData = 4096 // FEATURE_USE_SUPPORT_DATA
        /// TextServer supports UAX #31 identifier validation, see ``isValidIdentifier(string:)``.
        case unicodeIdentifiers = 8192 // FEATURE_UNICODE_IDENTIFIERS
        /// TextServer supports [url=https://unicode.org/reports/tr36/]Unicode Technical Report #36[/url] and [url=https://unicode.org/reports/tr39/]Unicode Technical Standard #39[/url] based spoof detection features.
        case unicodeSecurity = 16384 // FEATURE_UNICODE_SECURITY
    }
    
    public enum ContourPointTag: Int64 {
        /// Contour point is on the curve.
        case on = 1 // CONTOUR_CURVE_TAG_ON
        /// Contour point isn't on the curve, but serves as a control point for a conic (quadratic) Bézier arc.
        case offConic = 0 // CONTOUR_CURVE_TAG_OFF_CONIC
        /// Contour point isn't on the curve, but serves as a control point for a cubic Bézier arc.
        case offCubic = 2 // CONTOUR_CURVE_TAG_OFF_CUBIC
    }
    
    public enum SpacingType: Int64 {
        /// Spacing for each glyph.
        case glyph = 0 // SPACING_GLYPH
        /// Spacing for the space character.
        case space = 1 // SPACING_SPACE
        /// Spacing at the top of the line.
        case top = 2 // SPACING_TOP
        /// Spacing at the bottom of the line.
        case bottom = 3 // SPACING_BOTTOM
        /// 
        case max = 4 // SPACING_MAX
    }
    
    public struct FontStyle: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Font is bold.
        public static let bold = FontStyle (rawValue: 1)
        /// Font is italic or oblique.
        public static let italic = FontStyle (rawValue: 2)
        /// Font have fixed-width characters.
        public static let fixedWidth = FontStyle (rawValue: 4)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.bold) { result += "bold, " }
            if self.contains (.italic) { result += "italic, " }
            if self.contains (.fixedWidth) { result += "fixedWidth, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    public enum StructuredTextParser: Int64 {
        /// Use default Unicode BiDi algorithm.
        case `default` = 0 // STRUCTURED_TEXT_DEFAULT
        /// BiDi override for URI.
        case uri = 1 // STRUCTURED_TEXT_URI
        /// BiDi override for file path.
        case file = 2 // STRUCTURED_TEXT_FILE
        /// BiDi override for email.
        case email = 3 // STRUCTURED_TEXT_EMAIL
        /// BiDi override for lists. Structured text options: list separator ``String``.
        case list = 4 // STRUCTURED_TEXT_LIST
        /// BiDi override for GDScript.
        case gdscript = 5 // STRUCTURED_TEXT_GDSCRIPT
        /// User defined structured text BiDi override function.
        case custom = 6 // STRUCTURED_TEXT_CUSTOM
    }
    
    public enum FixedSizeScaleMode: Int64 {
        /// Bitmap font is not scaled.
        case disable = 0 // FIXED_SIZE_SCALE_DISABLE
        /// Bitmap font is scaled to the closest integer multiple of the font's fixed size. This is the recommended option for pixel art fonts.
        case integerOnly = 1 // FIXED_SIZE_SCALE_INTEGER_ONLY
        /// Bitmap font is scaled to an arbitrary (fractional) size. This is the recommended option for non-pixel art fonts.
        case enabled = 2 // FIXED_SIZE_SCALE_ENABLED
    }
    
    /* Methods */
    fileprivate static var method_has_feature: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has_feature")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3967367083)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the server supports a feature.
    public final func hasFeature (_ feature: TextServer.Feature)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_feature = Int64 (feature.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_has_feature, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_feature)
        return _result
        #else
        
        var copy_feature = Int64 (feature.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_feature) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_has_feature, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_name")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns the name of the server interface.
    public final func getName ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (TextServer.method_get_name, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_features: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_features")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    /// Returns text server features, see ``TextServer/Feature``.
    public final func getFeatures ()-> Int {
        var _result: Int = 0
        gi.object_method_bind_ptrcall (TextServer.method_get_features, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_load_support_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("load_support_data")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2323990056)!
            }
            
        }
        
    }()
    
    /// Loads optional TextServer database (e.g. ICU break iterators and dictionaries).
    /// 
    /// > Note: This function should be called before any other TextServer functions used, otherwise it won't have any effect.
    /// 
    public final func loadSupportData (filename: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_filename = GString (filename)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_load_support_data, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_filename.content)
        return _result
        #else
        
        let gstr_filename = GString (filename)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_filename.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_load_support_data, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_get_support_data_filename: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_support_data_filename")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns default TextServer database (e.g. ICU break iterators and dictionaries) filename.
    public final func getSupportDataFilename ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (TextServer.method_get_support_data_filename, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_get_support_data_info: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_support_data_info")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 201670096)!
            }
            
        }
        
    }()
    
    /// Returns TextServer database (e.g. ICU break iterators and dictionaries) description.
    public final func getSupportDataInfo ()-> String {
        let _result = GString ()
        gi.object_method_bind_ptrcall (TextServer.method_get_support_data_info, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result.description
    }
    
    fileprivate static var method_save_support_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("save_support_data")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Saves optional TextServer database (e.g. ICU break iterators and dictionaries) to the file.
    /// 
    /// > Note: This function is used by during project export, to include TextServer database.
    /// 
    public final func saveSupportData (filename: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_filename = GString (filename)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_save_support_data, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_filename.content)
        return _result
        #else
        
        let gstr_filename = GString (filename)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_filename.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_save_support_data, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_locale_right_to_left: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_locale_right_to_left")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if locale is right-to-left.
    public final func isLocaleRightToLeft (locale: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_locale = GString (locale)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_is_locale_right_to_left, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_locale.content)
        return _result
        #else
        
        let gstr_locale = GString (locale)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_locale.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_is_locale_right_to_left, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_name_to_tag: GDExtensionMethodBindPtr = {
        let methodName = StringName ("name_to_tag")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1321353865)!
            }
            
        }
        
    }()
    
    /// Converts readable feature, variation, script or language name to OpenType tag.
    public final func nameToTag (name: String)-> Int {
        var _result: Int = 0
        #if false
        
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_name_to_tag, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_name.content)
        return _result
        #else
        
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_name_to_tag, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_tag_to_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("tag_to_name")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 844755477)!
            }
            
        }
        
    }()
    
    /// Converts OpenType tag to readable feature, variation, script or language name.
    public final func tagToName (tag: Int)-> String {
        let _result = GString ()
        #if false
        
        var copy_tag = tag
        
        gi.object_method_bind_ptrcall_v (TextServer.method_tag_to_name, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_tag)
        return _result.description
        #else
        
        var copy_tag = tag
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_tag) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_tag_to_name, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_has: GDExtensionMethodBindPtr = {
        let methodName = StringName ("has")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `rid` is valid resource owned by this text server.
    public final func has (rid: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_has, UnsafeMutableRawPointer (mutating: handle), &_result, &rid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &rid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_has, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_free_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("free_rid")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Frees an object created by this ``TextServer``.
    public final func freeRid (_ rid: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_free_rid, UnsafeMutableRawPointer (mutating: handle), nil, &rid.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &rid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_free_rid, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_create_font: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_font")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 529393457)!
            }
            
        }
        
    }()
    
    /// Creates a new, empty font cache entry resource. To free the resulting resource, use the ``freeRid(_:)`` method.
    public final func createFont ()-> RID {
        let _result: RID = RID ()
        gi.object_method_bind_ptrcall (TextServer.method_create_font, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_create_font_linked_variation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_font_linked_variation")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 41030802)!
            }
            
        }
        
    }()
    
    /// Creates a new variation existing font which is reusing the same glyph cache and font data. To free the resulting resource, use the ``freeRid(_:)`` method.
    public final func createFontLinkedVariation (fontRid: RID)-> RID {
        let _result: RID = RID ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_create_font_linked_variation, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_create_font_linked_variation, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_data: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_data")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1355495400)!
            }
            
        }
        
    }()
    
    /// Sets font source data, e.g contents of the dynamic font source file.
    public final func fontSetData (fontRid: RID, data: PackedByteArray) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_data, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &data.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &data.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_data, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_face_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_face_index")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets an active face index in the TrueType / OpenType collection.
    public final func fontSetFaceIndex (fontRid: RID, faceIndex: Int) {
        #if false
        
        var copy_face_index = faceIndex
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_face_index, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_face_index)
        
        #else
        
        var copy_face_index = faceIndex
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_face_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_face_index, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_face_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_face_index")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns an active face index in the TrueType / OpenType collection.
    public final func fontGetFaceIndex (fontRid: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_face_index, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_face_index, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_face_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_face_count")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of faces in the TrueType / OpenType collection.
    public final func fontGetFaceCount (fontRid: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_face_count, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_face_count, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_style: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_style")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 898466325)!
            }
            
        }
        
    }()
    
    /// Sets the font style flags, see ``TextServer/FontStyle``.
    /// 
    /// > Note: This value is used for font matching only and will not affect font rendering. Use ``fontSetFaceIndex(fontRid:faceIndex:)``, ``fontSetVariationCoordinates(fontRid:variationCoordinates:)``, ``fontSetEmbolden(fontRid:strength:)``, or ``fontSetTransform(fontRid:transform:)`` instead.
    /// 
    public final func fontSetStyle (fontRid: RID, style: TextServer.FontStyle) {
        #if false
        
        var copy_style = style
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_style, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_style)
        
        #else
        
        var copy_style = style
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_style) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_style, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_style: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_style")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3082502592)!
            }
            
        }
        
    }()
    
    /// Returns font style flags, see ``TextServer/FontStyle``.
    public final func fontGetStyle (fontRid: RID)-> TextServer.FontStyle {
        var _result: TextServer.FontStyle = TextServer.FontStyle ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_style, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_style, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_name")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets the font family name.
    public final func fontSetName (fontRid: RID, name: String) {
        #if false
        
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_name, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &gstr_name.content)
        
        #else
        
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_name.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_name, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_name")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns font family name.
    public final func fontGetName (fontRid: RID)-> String {
        let _result = GString ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_name, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result.description
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_name, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_ot_name_strings: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_ot_name_strings")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns ``GDictionary`` with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
    public final func fontGetOtNameStrings (fontRid: RID)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_ot_name_strings, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_ot_name_strings, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_style_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_style_name")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets the font style name.
    public final func fontSetStyleName (fontRid: RID, name: String) {
        #if false
        
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_style_name, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &gstr_name.content)
        
        #else
        
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_name.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_style_name, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_style_name: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_style_name")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns font style name.
    public final func fontGetStyleName (fontRid: RID)-> String {
        let _result = GString ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_style_name, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result.description
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_style_name, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_weight: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_weight")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
    /// 
    /// > Note: This value is used for font matching only and will not affect font rendering. Use ``fontSetFaceIndex(fontRid:faceIndex:)``, ``fontSetVariationCoordinates(fontRid:variationCoordinates:)``, or ``fontSetEmbolden(fontRid:strength:)`` instead.
    /// 
    public final func fontSetWeight (fontRid: RID, weight: Int) {
        #if false
        
        var copy_weight = weight
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_weight, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_weight)
        
        #else
        
        var copy_weight = weight
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_weight) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_weight, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_weight: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_weight")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
    public final func fontGetWeight (fontRid: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_weight, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_weight, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_stretch: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_stretch")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
    /// 
    /// > Note: This value is used for font matching only and will not affect font rendering. Use ``fontSetFaceIndex(fontRid:faceIndex:)``, ``fontSetVariationCoordinates(fontRid:variationCoordinates:)``, or ``fontSetTransform(fontRid:transform:)`` instead.
    /// 
    public final func fontSetStretch (fontRid: RID, weight: Int) {
        #if false
        
        var copy_weight = weight
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_stretch, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_weight)
        
        #else
        
        var copy_weight = weight
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_weight) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_stretch, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_stretch: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_stretch")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
    public final func fontGetStretch (fontRid: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_stretch, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_stretch, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_antialiasing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_antialiasing")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 958337235)!
            }
            
        }
        
    }()
    
    /// Sets font anti-aliasing mode.
    public final func fontSetAntialiasing (fontRid: RID, antialiasing: TextServer.FontAntialiasing) {
        #if false
        
        var copy_antialiasing = Int64 (antialiasing.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_antialiasing, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_antialiasing)
        
        #else
        
        var copy_antialiasing = Int64 (antialiasing.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_antialiasing) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_antialiasing, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_antialiasing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_antialiasing")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3389420495)!
            }
            
        }
        
    }()
    
    /// Returns font anti-aliasing mode.
    public final func fontGetAntialiasing (fontRid: RID)-> TextServer.FontAntialiasing {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_antialiasing, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return TextServer.FontAntialiasing (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_antialiasing, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return TextServer.FontAntialiasing (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_generate_mipmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_generate_mipmaps")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true` font texture mipmap generation is enabled.
    public final func fontSetGenerateMipmaps (fontRid: RID, generateMipmaps: Bool) {
        #if false
        
        var copy_generate_mipmaps = generateMipmaps
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_generate_mipmaps, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_generate_mipmaps)
        
        #else
        
        var copy_generate_mipmaps = generateMipmaps
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_generate_mipmaps) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_generate_mipmaps, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_generate_mipmaps: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_generate_mipmaps")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if font texture mipmap generation is enabled.
    public final func fontGetGenerateMipmaps (fontRid: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_generate_mipmaps, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_generate_mipmaps, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_multichannel_signed_distance_field: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_multichannel_signed_distance_field")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true`, glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data. MSDF rendering allows displaying the font at any scaling factor without blurriness, and without incurring a CPU cost when the font size changes (since the font no longer needs to be rasterized on the CPU). As a downside, font hinting is not available with MSDF. The lack of font hinting may result in less crisp and less readable fonts at small sizes.
    /// 
    /// > Note: MSDF font rendering does not render glyphs with overlapping shapes correctly. Overlapping shapes are not valid per the OpenType standard, but are still commonly found in many font files, especially those converted by Google Fonts. To avoid issues with overlapping glyphs, consider downloading the font file directly from the type foundry instead of relying on Google Fonts.
    /// 
    public final func fontSetMultichannelSignedDistanceField (fontRid: RID, msdf: Bool) {
        #if false
        
        var copy_msdf = msdf
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_multichannel_signed_distance_field, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_msdf)
        
        #else
        
        var copy_msdf = msdf
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_msdf) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_multichannel_signed_distance_field, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_is_multichannel_signed_distance_field: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_is_multichannel_signed_distance_field")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data.
    public final func fontIsMultichannelSignedDistanceField (fontRid: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_is_multichannel_signed_distance_field, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_is_multichannel_signed_distance_field, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_msdf_pixel_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_msdf_pixel_range")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets the width of the range around the shape between the minimum and maximum representable signed distance.
    public final func fontSetMsdfPixelRange (fontRid: RID, msdfPixelRange: Int) {
        #if false
        
        var copy_msdf_pixel_range = msdfPixelRange
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_msdf_pixel_range, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_msdf_pixel_range)
        
        #else
        
        var copy_msdf_pixel_range = msdfPixelRange
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_msdf_pixel_range) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_msdf_pixel_range, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_msdf_pixel_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_msdf_pixel_range")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns the width of the range around the shape between the minimum and maximum representable signed distance.
    public final func fontGetMsdfPixelRange (fontRid: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_msdf_pixel_range, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_msdf_pixel_range, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_msdf_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_msdf_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets source font size used to generate MSDF textures.
    public final func fontSetMsdfSize (fontRid: RID, msdfSize: Int) {
        #if false
        
        var copy_msdf_size = msdfSize
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_msdf_size, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_msdf_size)
        
        #else
        
        var copy_msdf_size = msdfSize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_msdf_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_msdf_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_msdf_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_msdf_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns source font size used to generate MSDF textures.
    public final func fontGetMsdfSize (fontRid: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_msdf_size, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_msdf_size, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_fixed_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_fixed_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Sets bitmap font fixed size. If set to value greater than zero, same cache entry will be used for all font sizes.
    public final func fontSetFixedSize (fontRid: RID, fixedSize: Int) {
        #if false
        
        var copy_fixed_size = fixedSize
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_fixed_size, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_fixed_size)
        
        #else
        
        var copy_fixed_size = fixedSize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_fixed_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_fixed_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_fixed_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_fixed_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns bitmap font fixed size.
    public final func fontGetFixedSize (fontRid: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_fixed_size, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_fixed_size, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_fixed_size_scale_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_fixed_size_scale_mode")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1029390307)!
            }
            
        }
        
    }()
    
    /// Sets bitmap font scaling mode. This property is used only if `fixed_size` is greater than zero.
    public final func fontSetFixedSizeScaleMode (fontRid: RID, fixedSizeScaleMode: TextServer.FixedSizeScaleMode) {
        #if false
        
        var copy_fixed_size_scale_mode = Int64 (fixedSizeScaleMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_fixed_size_scale_mode, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_fixed_size_scale_mode)
        
        #else
        
        var copy_fixed_size_scale_mode = Int64 (fixedSizeScaleMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_fixed_size_scale_mode) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_fixed_size_scale_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_fixed_size_scale_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_fixed_size_scale_mode")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4113120379)!
            }
            
        }
        
    }()
    
    /// Returns bitmap font scaling mode.
    public final func fontGetFixedSizeScaleMode (fontRid: RID)-> TextServer.FixedSizeScaleMode {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_fixed_size_scale_mode, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return TextServer.FixedSizeScaleMode (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_fixed_size_scale_mode, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return TextServer.FixedSizeScaleMode (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_allow_system_fallback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_allow_system_fallback")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true`, system fonts can be automatically used as fallbacks.
    public final func fontSetAllowSystemFallback (fontRid: RID, allowSystemFallback: Bool) {
        #if false
        
        var copy_allow_system_fallback = allowSystemFallback
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_allow_system_fallback, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_allow_system_fallback)
        
        #else
        
        var copy_allow_system_fallback = allowSystemFallback
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_allow_system_fallback) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_allow_system_fallback, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_is_allow_system_fallback: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_is_allow_system_fallback")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if system fonts can be automatically used as fallbacks.
    public final func fontIsAllowSystemFallback (fontRid: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_is_allow_system_fallback, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_is_allow_system_fallback, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_force_autohinter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_force_autohinter")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true` auto-hinting is preferred over font built-in hinting.
    public final func fontSetForceAutohinter (fontRid: RID, forceAutohinter: Bool) {
        #if false
        
        var copy_force_autohinter = forceAutohinter
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_force_autohinter, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_force_autohinter)
        
        #else
        
        var copy_force_autohinter = forceAutohinter
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_force_autohinter) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_force_autohinter, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_is_force_autohinter: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_is_force_autohinter")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if auto-hinting is supported and preferred over font built-in hinting. Used by dynamic fonts only.
    public final func fontIsForceAutohinter (fontRid: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_is_force_autohinter, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_is_force_autohinter, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_hinting: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_hinting")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1520010864)!
            }
            
        }
        
    }()
    
    /// Sets font hinting mode. Used by dynamic fonts only.
    public final func fontSetHinting (fontRid: RID, hinting: TextServer.Hinting) {
        #if false
        
        var copy_hinting = Int64 (hinting.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_hinting, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_hinting)
        
        #else
        
        var copy_hinting = Int64 (hinting.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_hinting) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_hinting, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_hinting: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_hinting")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3971592737)!
            }
            
        }
        
    }()
    
    /// Returns the font hinting mode. Used by dynamic fonts only.
    public final func fontGetHinting (fontRid: RID)-> TextServer.Hinting {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_hinting, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return TextServer.Hinting (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_hinting, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return TextServer.Hinting (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_subpixel_positioning: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_subpixel_positioning")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3830459669)!
            }
            
        }
        
    }()
    
    /// Sets font subpixel glyph positioning mode.
    public final func fontSetSubpixelPositioning (fontRid: RID, subpixelPositioning: TextServer.SubpixelPositioning) {
        #if false
        
        var copy_subpixel_positioning = Int64 (subpixelPositioning.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_subpixel_positioning, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_subpixel_positioning)
        
        #else
        
        var copy_subpixel_positioning = Int64 (subpixelPositioning.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_subpixel_positioning) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_subpixel_positioning, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_subpixel_positioning: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_subpixel_positioning")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2752233671)!
            }
            
        }
        
    }()
    
    /// Returns font subpixel glyph positioning mode.
    public final func fontGetSubpixelPositioning (fontRid: RID)-> TextServer.SubpixelPositioning {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_subpixel_positioning, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return TextServer.SubpixelPositioning (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_subpixel_positioning, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return TextServer.SubpixelPositioning (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_embolden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_embolden")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets font embolden strength. If `strength` is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.
    public final func fontSetEmbolden (fontRid: RID, strength: Double) {
        #if false
        
        var copy_strength = strength
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_embolden, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_strength)
        
        #else
        
        var copy_strength = strength
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_strength) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_embolden, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_embolden: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_embolden")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns font embolden strength.
    public final func fontGetEmbolden (fontRid: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_embolden, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_embolden, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_spacing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_spacing")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1307259930)!
            }
            
        }
        
    }()
    
    /// Sets the spacing for `spacing` (see ``TextServer.SpacingType``) to `value` in pixels (not relative to the font size).
    public final func fontSetSpacing (fontRid: RID, spacing: TextServer.SpacingType, value: Int) {
        #if false
        
        var copy_spacing = Int64 (spacing.rawValue)
        var copy_value = value
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_spacing, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_spacing, &copy_value)
        
        #else
        
        var copy_spacing = Int64 (spacing.rawValue)
        var copy_value = value
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_spacing) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_value) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_set_spacing, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_spacing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_spacing")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1213653558)!
            }
            
        }
        
    }()
    
    /// Returns the spacing for `spacing` (see ``TextServer.SpacingType``) in pixels (not relative to the font size).
    public final func fontGetSpacing (fontRid: RID, spacing: TextServer.SpacingType)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_spacing = Int64 (spacing.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_spacing, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_spacing)
        return _result
        #else
        
        var copy_spacing = Int64 (spacing.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_spacing) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_spacing, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_transform")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1246044741)!
            }
            
        }
        
    }()
    
    /// Sets 2D transform, applied to the font outlines, can be used for slanting, flipping and rotating glyphs.
    /// 
    /// For example, to simulate italic typeface by slanting, apply the following transform `Transform2D(1.0, slant, 0.0, 1.0, 0.0, 0.0)`.
    /// 
    public final func fontSetTransform (fontRid: RID, transform: Transform2D) {
        #if false
        
        var copy_transform = transform
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_transform, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_transform)
        
        #else
        
        var copy_transform = transform
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_transform) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_transform, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_transform: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_transform")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 213527486)!
            }
            
        }
        
    }()
    
    /// Returns 2D transform applied to the font outlines.
    public final func fontGetTransform (fontRid: RID)-> Transform2D {
        var _result: Transform2D = Transform2D ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_transform, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_transform, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_variation_coordinates: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_variation_coordinates")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1217542888)!
            }
            
        }
        
    }()
    
    /// Sets variation coordinates for the specified font cache entry. See ``fontSupportedVariationList(fontRid:)`` for more info.
    public final func fontSetVariationCoordinates (fontRid: RID, variationCoordinates: GDictionary) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_variation_coordinates, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &variationCoordinates.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &variationCoordinates.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_variation_coordinates, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_variation_coordinates: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_variation_coordinates")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns variation coordinates for the specified font cache entry. See ``fontSupportedVariationList(fontRid:)`` for more info.
    public final func fontGetVariationCoordinates (fontRid: RID)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_variation_coordinates, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_variation_coordinates, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_oversampling")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1794382983)!
            }
            
        }
        
    }()
    
    /// Sets font oversampling factor, if set to `0.0` global oversampling factor is used instead. Used by dynamic fonts only.
    public final func fontSetOversampling (fontRid: RID, oversampling: Double) {
        #if false
        
        var copy_oversampling = oversampling
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_oversampling, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_oversampling)
        
        #else
        
        var copy_oversampling = oversampling
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_oversampling) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_oversampling, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_oversampling")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns font oversampling factor, if set to `0.0` global oversampling factor is used instead. Used by dynamic fonts only.
    public final func fontGetOversampling (fontRid: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_oversampling, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_oversampling, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_size_cache_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_size_cache_list")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns list of the font sizes in the cache. Each size is ``Vector2i`` with font size and outline size.
    public final func fontGetSizeCacheList (fontRid: RID)-> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_size_cache_list, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content)
        return VariantCollection<Vector2i>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_size_cache_list, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return VariantCollection<Vector2i>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_font_clear_size_cache: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_clear_size_cache")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Removes all font sizes from the cache entry.
    public final func fontClearSizeCache (fontRid: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_clear_size_cache, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_clear_size_cache, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_font_remove_size_cache: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_remove_size_cache")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2450610377)!
            }
            
        }
        
    }()
    
    /// Removes specified font size from the cache entry.
    public final func fontRemoveSizeCache (fontRid: RID, size: Vector2i) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_remove_size_cache, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_remove_size_cache, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_ascent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_ascent")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets the font ascent (number of pixels above the baseline).
    public final func fontSetAscent (fontRid: RID, size: Int, ascent: Double) {
        #if false
        
        var copy_size = size
        var copy_ascent = ascent
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_ascent, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_ascent)
        
        #else
        
        var copy_size = size
        var copy_ascent = ascent
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_ascent) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_set_ascent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_ascent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_ascent")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns the font ascent (number of pixels above the baseline).
    public final func fontGetAscent (fontRid: RID, size: Int)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_ascent, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size)
        return _result
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_ascent, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_descent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_descent")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets the font descent (number of pixels below the baseline).
    public final func fontSetDescent (fontRid: RID, size: Int, descent: Double) {
        #if false
        
        var copy_size = size
        var copy_descent = descent
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_descent, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_descent)
        
        #else
        
        var copy_size = size
        var copy_descent = descent
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_descent) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_set_descent, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_descent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_descent")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns the font descent (number of pixels below the baseline).
    public final func fontGetDescent (fontRid: RID, size: Int)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_descent, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size)
        return _result
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_descent, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_underline_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_underline_position")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets pixel offset of the underline below the baseline.
    public final func fontSetUnderlinePosition (fontRid: RID, size: Int, underlinePosition: Double) {
        #if false
        
        var copy_size = size
        var copy_underline_position = underlinePosition
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_underline_position, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_underline_position)
        
        #else
        
        var copy_size = size
        var copy_underline_position = underlinePosition
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_underline_position) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_set_underline_position, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_underline_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_underline_position")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns pixel offset of the underline below the baseline.
    public final func fontGetUnderlinePosition (fontRid: RID, size: Int)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_underline_position, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size)
        return _result
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_underline_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_underline_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_underline_thickness")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets thickness of the underline in pixels.
    public final func fontSetUnderlineThickness (fontRid: RID, size: Int, underlineThickness: Double) {
        #if false
        
        var copy_size = size
        var copy_underline_thickness = underlineThickness
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_underline_thickness, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_underline_thickness)
        
        #else
        
        var copy_size = size
        var copy_underline_thickness = underlineThickness
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_underline_thickness) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_set_underline_thickness, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_underline_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_underline_thickness")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns thickness of the underline in pixels.
    public final func fontGetUnderlineThickness (fontRid: RID, size: Int)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_underline_thickness, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size)
        return _result
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_underline_thickness, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_scale")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1892459533)!
            }
            
        }
        
    }()
    
    /// Sets scaling factor of the color bitmap font.
    public final func fontSetScale (fontRid: RID, size: Int, scale: Double) {
        #if false
        
        var copy_size = size
        var copy_scale = scale
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_scale, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_scale)
        
        #else
        
        var copy_size = size
        var copy_scale = scale
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_scale) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_set_scale, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_scale: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_scale")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 755457166)!
            }
            
        }
        
    }()
    
    /// Returns scaling factor of the color bitmap font.
    public final func fontGetScale (fontRid: RID, size: Int)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_scale, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size)
        return _result
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_scale, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_texture_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_texture_count")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1311001310)!
            }
            
        }
        
    }()
    
    /// Returns number of textures used by font cache entry.
    public final func fontGetTextureCount (fontRid: RID, size: Vector2i)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_texture_count, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size)
        return _result
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_texture_count, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_clear_textures: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_clear_textures")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2450610377)!
            }
            
        }
        
    }()
    
    /// Removes all textures from font cache entry.
    /// 
    /// > Note: This function will not remove glyphs associated with the texture, use ``fontRemoveGlyph(fontRid:size:glyph:)`` to remove them manually.
    /// 
    public final func fontClearTextures (fontRid: RID, size: Vector2i) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_clear_textures, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_clear_textures, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_remove_texture: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_remove_texture")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3810512262)!
            }
            
        }
        
    }()
    
    /// Removes specified texture from the cache entry.
    /// 
    /// > Note: This function will not remove glyphs associated with the texture, remove them manually, using ``fontRemoveGlyph(fontRid:size:glyph:)``.
    /// 
    public final func fontRemoveTexture (fontRid: RID, size: Vector2i, textureIndex: Int) {
        #if false
        
        var copy_size = size
        var copy_texture_index = textureIndex
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_remove_texture, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_texture_index)
        
        #else
        
        var copy_size = size
        var copy_texture_index = textureIndex
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_texture_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_remove_texture, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_texture_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_texture_image")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2354485091)!
            }
            
        }
        
    }()
    
    /// Sets font cache texture image data.
    public final func fontSetTextureImage (fontRid: RID, size: Vector2i, textureIndex: Int, image: Image?) {
        #if false
        
        var copy_size = size
        var copy_texture_index = textureIndex
        var copy_image_handle = image?.handle
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_texture_image, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_texture_index, &copy_image_handle)
        
        #else
        
        var copy_size = size
        var copy_texture_index = textureIndex
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_texture_index) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: image?.handle) { p3 in
                    _args.append (image == nil ? nil : p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_set_texture_image, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_texture_image: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_texture_image")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2451761155)!
            }
            
        }
        
    }()
    
    /// Returns font cache texture image data.
    public final func fontGetTextureImage (fontRid: RID, size: Vector2i, textureIndex: Int)-> Image? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_size = size
        var copy_texture_index = textureIndex
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_texture_image, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_texture_index)
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_size = size
        var copy_texture_index = textureIndex
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_texture_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_texture_image, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_texture_offsets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_texture_offsets")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3005398047)!
            }
            
        }
        
    }()
    
    /// Sets array containing glyph packing data.
    public final func fontSetTextureOffsets (fontRid: RID, size: Vector2i, textureIndex: Int, offset: PackedInt32Array) {
        #if false
        
        var copy_size = size
        var copy_texture_index = textureIndex
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_texture_offsets, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_texture_index, &offset.content)
        
        #else
        
        var copy_size = size
        var copy_texture_index = textureIndex
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_texture_index) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &offset.content) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_set_texture_offsets, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_texture_offsets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_texture_offsets")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3420028887)!
            }
            
        }
        
    }()
    
    /// Returns array containing glyph packing data.
    public final func fontGetTextureOffsets (fontRid: RID, size: Vector2i, textureIndex: Int)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        var copy_size = size
        var copy_texture_index = textureIndex
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_texture_offsets, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content, &copy_size, &copy_texture_index)
        return _result
        #else
        
        var copy_size = size
        var copy_texture_index = textureIndex
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_texture_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_texture_offsets, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_list")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 46086620)!
            }
            
        }
        
    }()
    
    /// Returns list of rendered glyphs in the cache entry.
    public final func fontGetGlyphList (fontRid: RID, size: Vector2i)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_list, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content, &copy_size)
        return _result
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_list, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_clear_glyphs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_clear_glyphs")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2450610377)!
            }
            
        }
        
    }()
    
    /// Removes all rendered glyphs information from the cache entry.
    /// 
    /// > Note: This function will not remove textures associated with the glyphs, use ``fontRemoveTexture(fontRid:size:textureIndex:)`` to remove them manually.
    /// 
    public final func fontClearGlyphs (fontRid: RID, size: Vector2i) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_clear_glyphs, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_clear_glyphs, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_remove_glyph: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_remove_glyph")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3810512262)!
            }
            
        }
        
    }()
    
    /// Removes specified rendered glyph information from the cache entry.
    /// 
    /// > Note: This function will not remove textures associated with the glyphs, use ``fontRemoveTexture(fontRid:size:textureIndex:)`` to remove them manually.
    /// 
    public final func fontRemoveGlyph (fontRid: RID, size: Vector2i, glyph: Int) {
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_remove_glyph, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_glyph)
        
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_remove_glyph, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_advance: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_advance")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2555689501)!
            }
            
        }
        
    }()
    
    /// Returns glyph advance (offset of the next glyph).
    /// 
    /// > Note: Advance for glyphs outlines is the same as the base glyph advance and is not saved.
    /// 
    public final func fontGetGlyphAdvance (fontRid: RID, size: Int, glyph: Int)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_advance, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_glyph)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_advance, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_glyph_advance: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_glyph_advance")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3219397315)!
            }
            
        }
        
    }()
    
    /// Sets glyph advance (offset of the next glyph).
    /// 
    /// > Note: Advance for glyphs outlines is the same as the base glyph advance and is not saved.
    /// 
    public final func fontSetGlyphAdvance (fontRid: RID, size: Int, glyph: Int, advance: Vector2) {
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_advance = advance
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_glyph_advance, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_glyph, &copy_advance)
        
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_advance = advance
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_advance) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_set_glyph_advance, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_offset")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 513728628)!
            }
            
        }
        
    }()
    
    /// Returns glyph offset from the baseline.
    public final func fontGetGlyphOffset (fontRid: RID, size: Vector2i, glyph: Int)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_offset, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_glyph)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_offset, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_glyph_offset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_glyph_offset")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1812632090)!
            }
            
        }
        
    }()
    
    /// Sets glyph offset from the baseline.
    public final func fontSetGlyphOffset (fontRid: RID, size: Vector2i, glyph: Int, offset: Vector2) {
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_offset = offset
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_glyph_offset, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_glyph, &copy_offset)
        
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_offset = offset
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_offset) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_set_glyph_offset, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 513728628)!
            }
            
        }
        
    }()
    
    /// Returns size of the glyph.
    public final func fontGetGlyphSize (fontRid: RID, size: Vector2i, glyph: Int)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_size, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_glyph)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_size, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_glyph_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_glyph_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1812632090)!
            }
            
        }
        
    }()
    
    /// Sets size of the glyph.
    public final func fontSetGlyphSize (fontRid: RID, size: Vector2i, glyph: Int, glSize: Vector2) {
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_gl_size = glSize
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_glyph_size, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_glyph, &copy_gl_size)
        
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_gl_size = glSize
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_gl_size) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_set_glyph_size, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_uv_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_uv_rect")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2274268786)!
            }
            
        }
        
    }()
    
    /// Returns rectangle in the cache texture containing the glyph.
    public final func fontGetGlyphUvRect (fontRid: RID, size: Vector2i, glyph: Int)-> Rect2 {
        var _result: Rect2 = Rect2 ()
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_uv_rect, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_glyph)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_uv_rect, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_glyph_uv_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_glyph_uv_rect")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1973324081)!
            }
            
        }
        
    }()
    
    /// Sets rectangle in the cache texture containing the glyph.
    public final func fontSetGlyphUvRect (fontRid: RID, size: Vector2i, glyph: Int, uvRect: Rect2) {
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_uv_rect = uvRect
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_glyph_uv_rect, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_glyph, &copy_uv_rect)
        
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_uv_rect = uvRect
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_uv_rect) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_set_glyph_uv_rect, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_texture_idx: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_texture_idx")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4292800474)!
            }
            
        }
        
    }()
    
    /// Returns index of the cache texture containing the glyph.
    public final func fontGetGlyphTextureIdx (fontRid: RID, size: Vector2i, glyph: Int)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_texture_idx, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_glyph)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_texture_idx, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_glyph_texture_idx: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_glyph_texture_idx")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4254580980)!
            }
            
        }
        
    }()
    
    /// Sets index of the cache texture containing the glyph.
    public final func fontSetGlyphTextureIdx (fontRid: RID, size: Vector2i, glyph: Int, textureIdx: Int) {
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_texture_idx = textureIdx
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_glyph_texture_idx, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_glyph, &copy_texture_idx)
        
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var copy_texture_idx = textureIdx
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_texture_idx) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_set_glyph_texture_idx, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_texture_rid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_texture_rid")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1451696141)!
            }
            
        }
        
    }()
    
    /// Returns resource ID of the cache texture containing the glyph.
    /// 
    /// > Note: If there are pending glyphs to render, calling this function might trigger the texture cache update.
    /// 
    public final func fontGetGlyphTextureRid (fontRid: RID, size: Vector2i, glyph: Int)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_texture_rid, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content, &copy_size, &copy_glyph)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_texture_rid, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_texture_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_texture_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 513728628)!
            }
            
        }
        
    }()
    
    /// Returns size of the cache texture containing the glyph.
    /// 
    /// > Note: If there are pending glyphs to render, calling this function might trigger the texture cache update.
    /// 
    public final func fontGetGlyphTextureSize (fontRid: RID, size: Vector2i, glyph: Int)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_size = size
        var copy_glyph = glyph
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_texture_size, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_glyph)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph = glyph
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_texture_size, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_contours: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_contours")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2903964473)!
            }
            
        }
        
    }()
    
    /// Returns outline contours of the glyph as a ``GDictionary`` with the following contents:
    /// 
    /// `points`         - ``PackedVector3Array``, containing outline points. `x` and `y` are point coordinates. `z` is the type of the point, using the ``TextServer/ContourPointTag`` values.
    /// 
    /// `contours`       - ``PackedInt32Array``, containing indices the end points of each contour.
    /// 
    /// `orientation`    - [bool], contour orientation. If `true`, clockwise contours must be filled.
    /// 
    public final func fontGetGlyphContours (font: RID, size: Int, index: Int)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        var copy_size = size
        var copy_index = index
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_contours, UnsafeMutableRawPointer (mutating: handle), &_result.content, &font.content, &copy_size, &copy_index)
        return _result
        #else
        
        var copy_size = size
        var copy_index = index
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &font.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_contours, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_kerning_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_kerning_list")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1778388067)!
            }
            
        }
        
    }()
    
    /// Returns list of the kerning overrides.
    public final func fontGetKerningList (fontRid: RID, size: Int)-> VariantCollection<Vector2i> {
        var _result: Int64 = 0
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_kerning_list, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size)
        return VariantCollection<Vector2i>(content: _result)
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_kerning_list, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return VariantCollection<Vector2i>(content: _result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_clear_kerning_map: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_clear_kerning_map")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3411492887)!
            }
            
        }
        
    }()
    
    /// Removes all kerning overrides.
    public final func fontClearKerningMap (fontRid: RID, size: Int) {
        #if false
        
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_clear_kerning_map, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size)
        
        #else
        
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_clear_kerning_map, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_remove_kerning: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_remove_kerning")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2141860016)!
            }
            
        }
        
    }()
    
    /// Removes kerning override for the pair of glyphs.
    public final func fontRemoveKerning (fontRid: RID, size: Int, glyphPair: Vector2i) {
        #if false
        
        var copy_size = size
        var copy_glyph_pair = glyphPair
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_remove_kerning, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_glyph_pair)
        
        #else
        
        var copy_size = size
        var copy_glyph_pair = glyphPair
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_glyph_pair) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_remove_kerning, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_kerning: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_kerning")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3630965883)!
            }
            
        }
        
    }()
    
    /// Sets kerning for the pair of glyphs.
    public final func fontSetKerning (fontRid: RID, size: Int, glyphPair: Vector2i, kerning: Vector2) {
        #if false
        
        var copy_size = size
        var copy_glyph_pair = glyphPair
        var copy_kerning = kerning
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_kerning, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_glyph_pair, &copy_kerning)
        
        #else
        
        var copy_size = size
        var copy_glyph_pair = glyphPair
        var copy_kerning = kerning
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_glyph_pair) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_kerning) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_set_kerning, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_kerning: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_kerning")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1019980169)!
            }
            
        }
        
    }()
    
    /// Returns kerning for the pair of glyphs.
    public final func fontGetKerning (fontRid: RID, size: Int, glyphPair: Vector2i)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_size = size
        var copy_glyph_pair = glyphPair
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_kerning, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_glyph_pair)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph_pair = glyphPair
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph_pair) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_kerning, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_glyph_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_glyph_index")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1765635060)!
            }
            
        }
        
    }()
    
    /// Returns the glyph index of a `char`, optionally modified by the `variationSelector`. See ``fontGetCharFromGlyphIndex(fontRid:size:glyphIndex:)``.
    public final func fontGetGlyphIndex (fontRid: RID, size: Int, char: Int, variationSelector: Int)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_size = size
        var copy_char = char
        var copy_variation_selector = variationSelector
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_glyph_index, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_char, &copy_variation_selector)
        return _result
        #else
        
        var copy_size = size
        var copy_char = char
        var copy_variation_selector = variationSelector
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_char) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_variation_selector) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_get_glyph_index, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_char_from_glyph_index: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_char_from_glyph_index")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2156738276)!
            }
            
        }
        
    }()
    
    /// Returns character code associated with `glyphIndex`, or `0` if `glyphIndex` is invalid. See ``fontGetGlyphIndex(fontRid:size:char:variationSelector:)``.
    public final func fontGetCharFromGlyphIndex (fontRid: RID, size: Int, glyphIndex: Int)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_size = size
        var copy_glyph_index = glyphIndex
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_char_from_glyph_index, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_size, &copy_glyph_index)
        return _result
        #else
        
        var copy_size = size
        var copy_glyph_index = glyphIndex
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_glyph_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_get_char_from_glyph_index, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_has_char: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_has_char")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3120086654)!
            }
            
        }
        
    }()
    
    /// Returns `true` if a Unicode `char` is available in the font.
    public final func fontHasChar (fontRid: RID, char: Int)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_char = char
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_has_char, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &copy_char)
        return _result
        #else
        
        var copy_char = char
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_char) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_has_char, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_supported_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_supported_chars")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns a string containing all the characters available in the font.
    public final func fontGetSupportedChars (fontRid: RID)-> String {
        let _result = GString ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_supported_chars, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result.description
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_supported_chars, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_font_render_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_render_range")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4254580980)!
            }
            
        }
        
    }()
    
    /// Renders the range of characters to the font cache texture.
    public final func fontRenderRange (fontRid: RID, size: Vector2i, start: Int, end: Int) {
        #if false
        
        var copy_size = size
        var copy_start = start
        var copy_end = end
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_render_range, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_start, &copy_end)
        
        #else
        
        var copy_size = size
        var copy_start = start
        var copy_end = end
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_start) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_end) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_font_render_range, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_render_glyph: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_render_glyph")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3810512262)!
            }
            
        }
        
    }()
    
    /// Renders specified glyph to the font cache texture.
    public final func fontRenderGlyph (fontRid: RID, size: Vector2i, index: Int) {
        #if false
        
        var copy_size = size
        var copy_index = index
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_render_glyph, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &copy_size, &copy_index)
        
        #else
        
        var copy_size = size
        var copy_index = index
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_index) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_render_glyph, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_draw_glyph: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_draw_glyph")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1339057948)!
            }
            
        }
        
    }()
    
    /// Draws single glyph into a canvas item at the position, using `fontRid` at the size `size`.
    /// 
    /// > Note: Glyph index is specific to the font, use glyphs indices returned by ``shapedTextGetGlyphs(shaped:)`` or ``fontGetGlyphIndex(fontRid:size:char:variationSelector:)``.
    /// 
    /// > Note: If there are pending glyphs to render, calling this function might trigger the texture cache update.
    /// 
    public final func fontDrawGlyph (fontRid: RID, canvas: RID, size: Int, pos: Vector2, index: Int, color: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_size = size
        var copy_pos = pos
        var copy_index = index
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_draw_glyph, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &canvas.content, &copy_size, &copy_pos, &copy_index, &copy_color)
        
        #else
        
        var copy_size = size
        var copy_pos = pos
        var copy_index = index
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_size) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_pos) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_index) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_color) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (TextServer.method_font_draw_glyph, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_draw_glyph_outline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_draw_glyph_outline")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2626165733)!
            }
            
        }
        
    }()
    
    /// Draws single glyph outline of size `outlineSize` into a canvas item at the position, using `fontRid` at the size `size`.
    /// 
    /// > Note: Glyph index is specific to the font, use glyphs indices returned by ``shapedTextGetGlyphs(shaped:)`` or ``fontGetGlyphIndex(fontRid:size:char:variationSelector:)``.
    /// 
    /// > Note: If there are pending glyphs to render, calling this function might trigger the texture cache update.
    /// 
    public final func fontDrawGlyphOutline (fontRid: RID, canvas: RID, size: Int, outlineSize: Int, pos: Vector2, index: Int, color: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_size = size
        var copy_outline_size = outlineSize
        var copy_pos = pos
        var copy_index = index
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_draw_glyph_outline, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &canvas.content, &copy_size, &copy_outline_size, &copy_pos, &copy_index, &copy_color)
        
        #else
        
        var copy_size = size
        var copy_outline_size = outlineSize
        var copy_pos = pos
        var copy_index = index
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_size) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_outline_size) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_pos) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_index) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_color) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (TextServer.method_font_draw_glyph_outline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_is_language_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_is_language_supported")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3199320846)!
            }
            
        }
        
    }()
    
    /// Returns `true`, if font supports given language ([url=https://en.wikipedia.org/wiki/ISO_639-1]ISO 639[/url] code).
    public final func fontIsLanguageSupported (fontRid: RID, language: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_is_language_supported, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &gstr_language.content)
        return _result
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_is_language_supported, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_language_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_language_support_override")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2313957094)!
            }
            
        }
        
    }()
    
    /// Adds override for ``fontIsLanguageSupported(fontRid:language:)``.
    public final func fontSetLanguageSupportOverride (fontRid: RID, language: String, supported: Bool) {
        #if false
        
        let gstr_language = GString (language)
        var copy_supported = supported
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_language_support_override, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &gstr_language.content, &copy_supported)
        
        #else
        
        let gstr_language = GString (language)
        var copy_supported = supported
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_supported) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_set_language_support_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_language_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_language_support_override")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2829184646)!
            }
            
        }
        
    }()
    
    /// Returns `true` if support override is enabled for the `language`.
    public final func fontGetLanguageSupportOverride (fontRid: RID, language: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_language_support_override, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &gstr_language.content)
        return _result
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_language_support_override, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_remove_language_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_remove_language_support_override")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Remove language support override.
    public final func fontRemoveLanguageSupportOverride (fontRid: RID, language: String) {
        #if false
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_remove_language_support_override, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &gstr_language.content)
        
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_remove_language_support_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_language_support_overrides: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_language_support_overrides")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2801473409)!
            }
            
        }
        
    }()
    
    /// Returns list of language support overrides.
    public final func fontGetLanguageSupportOverrides (fontRid: RID)-> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_language_support_overrides, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_language_support_overrides, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_is_script_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_is_script_supported")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3199320846)!
            }
            
        }
        
    }()
    
    /// Returns `true`, if font supports given script (ISO 15924 code).
    public final func fontIsScriptSupported (fontRid: RID, script: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_script = GString (script)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_is_script_supported, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &gstr_script.content)
        return _result
        #else
        
        let gstr_script = GString (script)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_script.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_is_script_supported, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_script_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_script_support_override")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2313957094)!
            }
            
        }
        
    }()
    
    /// Adds override for ``fontIsScriptSupported(fontRid:script:)``.
    public final func fontSetScriptSupportOverride (fontRid: RID, script: String, supported: Bool) {
        #if false
        
        let gstr_script = GString (script)
        var copy_supported = supported
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_script_support_override, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &gstr_script.content, &copy_supported)
        
        #else
        
        let gstr_script = GString (script)
        var copy_supported = supported
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_script.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_supported) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_font_set_script_support_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_script_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_script_support_override")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2829184646)!
            }
            
        }
        
    }()
    
    /// Returns `true` if support override is enabled for the `script`.
    public final func fontGetScriptSupportOverride (fontRid: RID, script: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_script = GString (script)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_script_support_override, UnsafeMutableRawPointer (mutating: handle), &_result, &fontRid.content, &gstr_script.content)
        return _result
        #else
        
        let gstr_script = GString (script)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_script.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_get_script_support_override, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_remove_script_support_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_remove_script_support_override")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Removes script support override.
    public final func fontRemoveScriptSupportOverride (fontRid: RID, script: String) {
        #if false
        
        let gstr_script = GString (script)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_remove_script_support_override, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &gstr_script.content)
        
        #else
        
        let gstr_script = GString (script)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_script.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_remove_script_support_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_script_support_overrides: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_script_support_overrides")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2801473409)!
            }
            
        }
        
    }()
    
    /// Returns list of script support overrides.
    public final func fontGetScriptSupportOverrides (fontRid: RID)-> PackedStringArray {
        let _result: PackedStringArray = PackedStringArray ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_script_support_overrides, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_script_support_overrides, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_set_opentype_feature_overrides: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_opentype_feature_overrides")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1217542888)!
            }
            
        }
        
    }()
    
    /// Sets font OpenType feature set override.
    public final func fontSetOpentypeFeatureOverrides (fontRid: RID, overrides: GDictionary) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_opentype_feature_overrides, UnsafeMutableRawPointer (mutating: handle), nil, &fontRid.content, &overrides.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &overrides.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_font_set_opentype_feature_overrides, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_opentype_feature_overrides: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_opentype_feature_overrides")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns font OpenType feature set override.
    public final func fontGetOpentypeFeatureOverrides (fontRid: RID)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_get_opentype_feature_overrides, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_get_opentype_feature_overrides, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_supported_feature_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_supported_feature_list")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns the dictionary of the supported OpenType features.
    public final func fontSupportedFeatureList (fontRid: RID)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_supported_feature_list, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_supported_feature_list, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_supported_variation_list: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_supported_variation_list")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1882737106)!
            }
            
        }
        
    }()
    
    /// Returns the dictionary of the supported OpenType variation coordinates.
    public final func fontSupportedVariationList (fontRid: RID)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_supported_variation_list, UnsafeMutableRawPointer (mutating: handle), &_result.content, &fontRid.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &fontRid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_supported_variation_list, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_font_get_global_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_get_global_oversampling")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    /// Returns the font oversampling factor, shared by all fonts in the TextServer.
    public final func fontGetGlobalOversampling ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (TextServer.method_font_get_global_oversampling, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_font_set_global_oversampling: GDExtensionMethodBindPtr = {
        let methodName = StringName ("font_set_global_oversampling")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    /// Sets oversampling factor, shared by all font in the TextServer.
    /// 
    /// > Note: This value can be automatically changed by display server.
    /// 
    public final func fontSetGlobalOversampling (_ oversampling: Double) {
        #if false
        
        var copy_oversampling = oversampling
        
        gi.object_method_bind_ptrcall_v (TextServer.method_font_set_global_oversampling, UnsafeMutableRawPointer (mutating: handle), nil, &copy_oversampling)
        
        #else
        
        var copy_oversampling = oversampling
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_oversampling) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_font_set_global_oversampling, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_hex_code_box_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hex_code_box_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3016396712)!
            }
            
        }
        
    }()
    
    /// Returns size of the replacement character (box with character hexadecimal code that is drawn in place of invalid characters).
    public final func getHexCodeBoxSize (_ size: Int, index: Int)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_size = size
        var copy_index = index
        
        gi.object_method_bind_ptrcall_v (TextServer.method_get_hex_code_box_size, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_size, &copy_index)
        return _result
        #else
        
        var copy_size = size
        var copy_index = index
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_size) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_get_hex_code_box_size, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_draw_hex_code_box: GDExtensionMethodBindPtr = {
        let methodName = StringName ("draw_hex_code_box")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1602046441)!
            }
            
        }
        
    }()
    
    /// Draws box displaying character hexadecimal code. Used for replacing missing characters.
    public final func drawHexCodeBox (canvas: RID, size: Int, pos: Vector2, index: Int, color: Color) {
        #if false
        
        var copy_size = size
        var copy_pos = pos
        var copy_index = index
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (TextServer.method_draw_hex_code_box, UnsafeMutableRawPointer (mutating: handle), nil, &canvas.content, &copy_size, &copy_pos, &copy_index, &copy_color)
        
        #else
        
        var copy_size = size
        var copy_pos = pos
        var copy_index = index
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &canvas.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_size) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_pos) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_index) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_color) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (TextServer.method_draw_hex_code_box, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_create_shaped_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("create_shaped_text")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1231398698)!
            }
            
        }
        
    }()
    
    /// Creates new buffer for complex text layout, with the given `direction` and `orientation`. To free the resulting buffer, use ``freeRid(_:)`` method.
    /// 
    /// > Note: Direction is ignored if server does not support .bidiLayout feature (supported by ``TextServerAdvanced``).
    /// 
    /// > Note: Orientation is ignored if server does not support .verticalLayout feature (supported by ``TextServerAdvanced``).
    /// 
    public final func createShapedText (direction: TextServer.Direction = .auto, orientation: TextServer.Orientation = .horizontal)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_create_shaped_text, UnsafeMutableRawPointer (mutating: handle), &_result.content, &copy_direction, &copy_orientation)
        return _result
        #else
        
        var copy_direction = Int64 (direction.rawValue)
        var copy_orientation = Int64 (orientation.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_direction) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_orientation) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_create_shaped_text, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_clear")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2722037293)!
            }
            
        }
        
    }()
    
    /// Clears text buffer (removes text and inline objects).
    public final func shapedTextClear (rid: RID) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_clear, UnsafeMutableRawPointer (mutating: handle), nil, &rid.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &rid.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_clear, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_set_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_set_direction")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1551430183)!
            }
            
        }
        
    }()
    
    /// Sets desired text direction. If set to .auto, direction will be detected based on the buffer contents and current locale.
    /// 
    /// > Note: Direction is ignored if server does not support .bidiLayout feature (supported by ``TextServerAdvanced``).
    /// 
    public final func shapedTextSetDirection (shaped: RID, direction: TextServer.Direction = .auto) {
        #if false
        
        var copy_direction = Int64 (direction.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_set_direction, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &copy_direction)
        
        #else
        
        var copy_direction = Int64 (direction.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_direction) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_set_direction, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_direction")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3065904362)!
            }
            
        }
        
    }()
    
    /// Returns direction of the text.
    public final func shapedTextGetDirection (shaped: RID)-> TextServer.Direction {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_direction, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return TextServer.Direction (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_direction, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return TextServer.Direction (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_inferred_direction: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_inferred_direction")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3065904362)!
            }
            
        }
        
    }()
    
    /// Returns direction of the text, inferred by the BiDi algorithm.
    public final func shapedTextGetInferredDirection (shaped: RID)-> TextServer.Direction {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_inferred_direction, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return TextServer.Direction (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_inferred_direction, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return TextServer.Direction (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_set_bidi_override: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_set_bidi_override")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 684822712)!
            }
            
        }
        
    }()
    
    /// Overrides BiDi for the structured text.
    /// 
    /// Override ranges should cover full source text without overlaps. BiDi algorithm will be used on each range separately.
    /// 
    public final func shapedTextSetBidiOverride (shaped: RID, override: GArray) {
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_set_bidi_override, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &override.content)
        
        #else
        
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &override.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_set_bidi_override, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_set_custom_punctuation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_set_custom_punctuation")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2726140452)!
            }
            
        }
        
    }()
    
    /// Sets custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
    public final func shapedTextSetCustomPunctuation (shaped: RID, punct: String) {
        #if false
        
        let gstr_punct = GString (punct)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_set_custom_punctuation, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &gstr_punct.content)
        
        #else
        
        let gstr_punct = GString (punct)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &gstr_punct.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_set_custom_punctuation, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_custom_punctuation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_custom_punctuation")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 642473191)!
            }
            
        }
        
    }()
    
    /// Returns custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
    public final func shapedTextGetCustomPunctuation (shaped: RID)-> String {
        let _result = GString ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_custom_punctuation, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content)
        return _result.description
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_custom_punctuation, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_set_orientation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_set_orientation")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3019609126)!
            }
            
        }
        
    }()
    
    /// Sets desired text orientation.
    /// 
    /// > Note: Orientation is ignored if server does not support .verticalLayout feature (supported by ``TextServerAdvanced``).
    /// 
    public final func shapedTextSetOrientation (shaped: RID, orientation: TextServer.Orientation = .horizontal) {
        #if false
        
        var copy_orientation = Int64 (orientation.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_set_orientation, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &copy_orientation)
        
        #else
        
        var copy_orientation = Int64 (orientation.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_orientation) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_set_orientation, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_orientation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_orientation")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3142708106)!
            }
            
        }
        
    }()
    
    /// Returns text orientation.
    public final func shapedTextGetOrientation (shaped: RID)-> TextServer.Orientation {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_orientation, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return TextServer.Orientation (rawValue: _result)!
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_orientation, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return TextServer.Orientation (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_set_preserve_invalid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_set_preserve_invalid")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true` text buffer will display invalid characters as hexadecimal codes, otherwise nothing is displayed.
    public final func shapedTextSetPreserveInvalid (shaped: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_set_preserve_invalid, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_set_preserve_invalid, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_preserve_invalid: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_preserve_invalid")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if text buffer is configured to display hexadecimal codes in place of invalid characters.
    /// 
    /// > Note: If set to `false`, nothing is displayed in place of invalid characters.
    /// 
    public final func shapedTextGetPreserveInvalid (shaped: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_preserve_invalid, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_preserve_invalid, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_set_preserve_control: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_set_preserve_control")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1265174801)!
            }
            
        }
        
    }()
    
    /// If set to `true` text buffer will display control characters.
    public final func shapedTextSetPreserveControl (shaped: RID, enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_set_preserve_control, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_enabled) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_set_preserve_control, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_preserve_control: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_preserve_control")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if text buffer is configured to display control characters.
    public final func shapedTextGetPreserveControl (shaped: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_preserve_control, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_preserve_control, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_set_spacing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_set_spacing")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1307259930)!
            }
            
        }
        
    }()
    
    /// Sets extra spacing added between glyphs or lines in pixels.
    public final func shapedTextSetSpacing (shaped: RID, spacing: TextServer.SpacingType, value: Int) {
        #if false
        
        var copy_spacing = Int64 (spacing.rawValue)
        var copy_value = value
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_set_spacing, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &copy_spacing, &copy_value)
        
        #else
        
        var copy_spacing = Int64 (spacing.rawValue)
        var copy_value = value
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_spacing) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_value) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_shaped_text_set_spacing, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_spacing: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_spacing")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1213653558)!
            }
            
        }
        
    }()
    
    /// Returns extra spacing added between glyphs or lines in pixels.
    public final func shapedTextGetSpacing (shaped: RID, spacing: TextServer.SpacingType)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_spacing = Int64 (spacing.rawValue)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_spacing, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_spacing)
        return _result
        #else
        
        var copy_spacing = Int64 (spacing.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_spacing) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_spacing, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_add_string: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_add_string")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 623473029)!
            }
            
        }
        
    }()
    
    /// Adds text span and font to draw it to the text buffer.
    public final func shapedTextAddString (shaped: RID, text: String, fonts: VariantCollection<RID>, size: Int, opentypeFeatures: GDictionary = GDictionary (), language: String = "", meta: Variant)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_text = GString (text)
        var copy_size = size
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_add_string, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &gstr_text.content, &fonts.array.content, &copy_size, &opentypeFeatures.content, &gstr_language.content, &meta.content)
        return _result
        #else
        
        let gstr_text = GString (text)
        var copy_size = size
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_text.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &fonts.array.content) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_size) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &opentypeFeatures.content) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &gstr_language.content) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &meta.content) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (TextServer.method_shaped_text_add_string, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                                    return _result
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_add_object: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_add_object")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3664424789)!
            }
            
        }
        
    }()
    
    /// Adds inline object to the text buffer, `key` must be unique. In the text, object is represented as `length` object replacement characters.
    public final func shapedTextAddObject (shaped: RID, key: Variant, size: Vector2, inlineAlign: InlineAlignment = .center, length: Int = 1, baseline: Double = 0.0)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_size = size
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_length = length
        var copy_baseline = baseline
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_add_object, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &key.content, &copy_size, &copy_inline_align, &copy_length, &copy_baseline)
        return _result
        #else
        
        var copy_size = size
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_length = length
        var copy_baseline = baseline
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &key.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_size) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_inline_align) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_length) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &copy_baseline) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_add_object, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                                return _result
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_resize_object: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_resize_object")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 790361552)!
            }
            
        }
        
    }()
    
    /// Sets new size and alignment of embedded object.
    public final func shapedTextResizeObject (shaped: RID, key: Variant, size: Vector2, inlineAlign: InlineAlignment = .center, baseline: Double = 0.0)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_size = size
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_baseline = baseline
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_resize_object, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &key.content, &copy_size, &copy_inline_align, &copy_baseline)
        return _result
        #else
        
        var copy_size = size
        var copy_inline_align = Int64 (inlineAlign.rawValue)
        var copy_baseline = baseline
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &key.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_size) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_inline_align) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_baseline) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_resize_object, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                            return _result
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_get_span_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_get_span_count")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of text spans added using ``shapedTextAddString(shaped:text:fonts:size:opentypeFeatures:language:meta:)`` or ``shapedTextAddObject(shaped:key:size:inlineAlign:length:baseline:)``.
    public final func shapedGetSpanCount (shaped: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_get_span_count, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_get_span_count, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_get_span_meta: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_get_span_meta")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4069510997)!
            }
            
        }
        
    }()
    
    /// Returns text span metadata.
    public final func shapedGetSpanMeta (shaped: RID, index: Int)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        var copy_index = index
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_get_span_meta, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content, &copy_index)
        return _result
        #else
        
        var copy_index = index
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_get_span_meta, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_set_span_update_font: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_set_span_update_font")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2022725822)!
            }
            
        }
        
    }()
    
    /// Changes text span font, font size and OpenType features, without changing the text.
    public final func shapedSetSpanUpdateFont (shaped: RID, index: Int, fonts: VariantCollection<RID>, size: Int, opentypeFeatures: GDictionary = GDictionary ()) {
        #if false
        
        var copy_index = index
        var copy_size = size
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_set_span_update_font, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &copy_index, &fonts.array.content, &copy_size, &opentypeFeatures.content)
        
        #else
        
        var copy_index = index
        var copy_size = size
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_index) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &fonts.array.content) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_size) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &opentypeFeatures.content) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (TextServer.method_shaped_set_span_update_font, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_substr: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_substr")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1937682086)!
            }
            
        }
        
    }()
    
    /// Returns text buffer for the substring of the text in the `shaped` text buffer (including inline objects).
    public final func shapedTextSubstr (shaped: RID, start: Int, length: Int)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_start = start
        var copy_length = length
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_substr, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content, &copy_start, &copy_length)
        return _result
        #else
        
        var copy_start = start
        var copy_length = length
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_start) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_length) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_shaped_text_substr, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_parent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_parent")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3814569979)!
            }
            
        }
        
    }()
    
    /// Returns the parent buffer from which the substring originates.
    public final func shapedTextGetParent (shaped: RID)-> RID {
        let _result: RID = RID ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_parent, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_parent, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_fit_to_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_fit_to_width")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 530670926)!
            }
            
        }
        
    }()
    
    /// Adjusts text width to fit to specified width, returns new text width.
    public final func shapedTextFitToWidth (shaped: RID, width: Double, justificationFlags: TextServer.JustificationFlag = [.kashida, .wordBound])-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_width = width
        var copy_justification_flags = justificationFlags
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_fit_to_width, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_width, &copy_justification_flags)
        return _result
        #else
        
        var copy_width = width
        var copy_justification_flags = justificationFlags
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_justification_flags) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_shaped_text_fit_to_width, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_tab_align: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_tab_align")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1283669550)!
            }
            
        }
        
    }()
    
    /// Aligns shaped text to the given tab-stops.
    public final func shapedTextTabAlign (shaped: RID, tabStops: PackedFloat32Array)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_tab_align, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &tabStops.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &tabStops.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_tab_align, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_shape")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3521089500)!
            }
            
        }
        
    }()
    
    /// Shapes buffer if it's not shaped. Returns `true` if the string is shaped successfully.
    /// 
    /// > Note: It is not necessary to call this function manually, buffer will be shaped automatically as soon as any of its output data is requested.
    /// 
    public final func shapedTextShape (shaped: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_shape, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_shape, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_is_ready: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_is_ready")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if buffer is successfully shaped.
    public final func shapedTextIsReady (shaped: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_is_ready, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_is_ready, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_has_visible_chars: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_has_visible_chars")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 4155700596)!
            }
            
        }
        
    }()
    
    /// Returns `true` if text buffer contains any visible characters.
    public final func shapedTextHasVisibleChars (shaped: RID)-> Bool {
        var _result: Bool = false
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_has_visible_chars, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_has_visible_chars, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_glyphs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_glyphs")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns an array of glyphs in the visual order.
    public final func shapedTextGetGlyphs (shaped: RID)-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_glyphs, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return VariantCollection<GDictionary>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_glyphs, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return VariantCollection<GDictionary>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_sort_logical: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_sort_logical")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2670461153)!
            }
            
        }
        
    }()
    
    /// Returns text glyphs in the logical order.
    public final func shapedTextSortLogical (shaped: RID)-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_sort_logical, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return VariantCollection<GDictionary>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_sort_logical, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return VariantCollection<GDictionary>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_glyph_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_glyph_count")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of glyphs in the buffer.
    public final func shapedTextGetGlyphCount (shaped: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_glyph_count, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_glyph_count, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_range")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 733700038)!
            }
            
        }
        
    }()
    
    /// Returns substring buffer character range in the parent buffer.
    public final func shapedTextGetRange (shaped: RID)-> Vector2i {
        var _result: Vector2i = Vector2i ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_range, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_range, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_line_breaks_adv: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_line_breaks_adv")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2376991424)!
            }
            
        }
        
    }()
    
    /// Breaks text to the lines and columns. Returns character ranges for each segment.
    public final func shapedTextGetLineBreaksAdv (shaped: RID, width: PackedFloat32Array, start: Int = 0, once: Bool = true, breakFlags: TextServer.LineBreakFlag = [.mandatory, .wordBound])-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        var copy_start = start
        var copy_once = once
        var copy_break_flags = breakFlags
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_line_breaks_adv, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content, &width.content, &copy_start, &copy_once, &copy_break_flags)
        return _result
        #else
        
        var copy_start = start
        var copy_once = once
        var copy_break_flags = breakFlags
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &width.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_start) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_once) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_break_flags) { p4 in
                            _args.append (p4)
        
                            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_line_breaks_adv, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                            return _result
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_line_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_line_breaks")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2651359741)!
            }
            
        }
        
    }()
    
    /// Breaks text to the lines and returns character ranges for each line.
    public final func shapedTextGetLineBreaks (shaped: RID, width: Double, start: Int = 0, breakFlags: TextServer.LineBreakFlag = [.mandatory, .wordBound])-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        var copy_width = width
        var copy_start = start
        var copy_break_flags = breakFlags
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_line_breaks, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content, &copy_width, &copy_start, &copy_break_flags)
        return _result
        #else
        
        var copy_width = width
        var copy_start = start
        var copy_break_flags = breakFlags
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_start) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_break_flags) { p3 in
                        _args.append (p3)
        
                        gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_line_breaks, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                        return _result
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_word_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_word_breaks")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 185957063)!
            }
            
        }
        
    }()
    
    /// Breaks text into words and returns array of character ranges. Use `graphemeFlags` to set what characters are used for breaking (see ``TextServer/GraphemeFlag``).
    public final func shapedTextGetWordBreaks (shaped: RID, graphemeFlags: TextServer.GraphemeFlag = [.space, .punctuation])-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        var copy_grapheme_flags = graphemeFlags
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_word_breaks, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content, &copy_grapheme_flags)
        return _result
        #else
        
        var copy_grapheme_flags = graphemeFlags
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_grapheme_flags) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_word_breaks, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_trim_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_trim_pos")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns the position of the overrun trim.
    public final func shapedTextGetTrimPos (shaped: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_trim_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_trim_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_ellipsis_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_ellipsis_pos")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns position of the ellipsis.
    public final func shapedTextGetEllipsisPos (shaped: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_ellipsis_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_ellipsis_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_ellipsis_glyphs: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_ellipsis_glyphs")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns array of the glyphs in the ellipsis.
    public final func shapedTextGetEllipsisGlyphs (shaped: RID)-> VariantCollection<GDictionary> {
        var _result: Int64 = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_ellipsis_glyphs, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return VariantCollection<GDictionary>(content: _result)
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_ellipsis_glyphs, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return VariantCollection<GDictionary>(content: _result)
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_ellipsis_glyph_count: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_ellipsis_glyph_count")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2198884583)!
            }
            
        }
        
    }()
    
    /// Returns number of glyphs in the ellipsis.
    public final func shapedTextGetEllipsisGlyphCount (shaped: RID)-> Int {
        var _result: Int = 0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_ellipsis_glyph_count, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_ellipsis_glyph_count, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_overrun_trim_to_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_overrun_trim_to_width")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2723146520)!
            }
            
        }
        
    }()
    
    /// Trims text if it exceeds the given width.
    public final func shapedTextOverrunTrimToWidth (shaped: RID, width: Double = 0, overrunTrimFlags: TextServer.TextOverrunFlag = []) {
        #if false
        
        var copy_width = width
        var copy_overrun_trim_flags = overrunTrimFlags
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_overrun_trim_to_width, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &copy_width, &copy_overrun_trim_flags)
        
        #else
        
        var copy_width = width
        var copy_overrun_trim_flags = overrunTrimFlags
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_width) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_overrun_trim_flags) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_shaped_text_overrun_trim_to_width, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_objects: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_objects")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2684255073)!
            }
            
        }
        
    }()
    
    /// Returns array of inline objects.
    public final func shapedTextGetObjects (shaped: RID)-> GArray {
        let _result: GArray = GArray ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_objects, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_objects, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_object_rect: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_object_rect")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 447978354)!
            }
            
        }
        
    }()
    
    /// Returns bounding rectangle of the inline object.
    public final func shapedTextGetObjectRect (shaped: RID, key: Variant)-> Rect2 {
        var _result: Rect2 = Rect2 ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_object_rect, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &key.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &key.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_object_rect, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_size: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_size")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2440833711)!
            }
            
        }
        
    }()
    
    /// Returns size of the text.
    public final func shapedTextGetSize (shaped: RID)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_size, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_size, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_ascent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_ascent")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns the text ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).
    /// 
    /// > Note: Overall ascent can be higher than font ascent, if some glyphs are displaced from the baseline.
    /// 
    public final func shapedTextGetAscent (shaped: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_ascent, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_ascent, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_descent: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_descent")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns the text descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).
    /// 
    /// > Note: Overall descent can be higher than font descent, if some glyphs are displaced from the baseline.
    /// 
    public final func shapedTextGetDescent (shaped: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_descent, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_descent, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_width: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_width")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns width (for horizontal layout) or height (for vertical) of the text.
    public final func shapedTextGetWidth (shaped: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_width, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_width, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_underline_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_underline_position")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns pixel offset of the underline below the baseline.
    public final func shapedTextGetUnderlinePosition (shaped: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_underline_position, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_underline_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_underline_thickness: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_underline_thickness")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 866169185)!
            }
            
        }
        
    }()
    
    /// Returns thickness of the underline.
    public final func shapedTextGetUnderlineThickness (shaped: RID)-> Double {
        var _result: Double = 0.0
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_underline_thickness, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_underline_thickness, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_carets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_carets")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1574219346)!
            }
            
        }
        
    }()
    
    /// Returns shapes of the carets corresponding to the character offset `position` in the text. Returned caret shape is 1 pixel wide rectangle.
    public final func shapedTextGetCarets (shaped: RID, position: Int)-> GDictionary {
        let _result: GDictionary = GDictionary ()
        #if false
        
        var copy_position = position
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_carets, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content, &copy_position)
        return _result
        #else
        
        var copy_position = position
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_position) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_carets, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_selection: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_selection")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3714187733)!
            }
            
        }
        
    }()
    
    /// Returns selection rectangles for the specified character range.
    public final func shapedTextGetSelection (shaped: RID, start: Int, end: Int)-> PackedVector2Array {
        let _result: PackedVector2Array = PackedVector2Array ()
        #if false
        
        var copy_start = start
        var copy_end = end
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_selection, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content, &copy_start, &copy_end)
        return _result
        #else
        
        var copy_start = start
        var copy_end = end
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_start) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_end) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_selection, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_hit_test_grapheme: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_hit_test_grapheme")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3149310417)!
            }
            
        }
        
    }()
    
    /// Returns grapheme index at the specified pixel offset at the baseline, or `-1` if none is found.
    public final func shapedTextHitTestGrapheme (shaped: RID, coords: Double)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_coords = coords
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_hit_test_grapheme, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_coords)
        return _result
        #else
        
        var copy_coords = coords
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_coords) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_hit_test_grapheme, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_hit_test_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_hit_test_position")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3149310417)!
            }
            
        }
        
    }()
    
    /// Returns caret character offset at the specified pixel offset at the baseline. This function always returns a valid position.
    public final func shapedTextHitTestPosition (shaped: RID, coords: Double)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_coords = coords
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_hit_test_position, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_coords)
        return _result
        #else
        
        var copy_coords = coords
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_coords) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_hit_test_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_grapheme_bounds: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_grapheme_bounds")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2546185844)!
            }
            
        }
        
    }()
    
    /// Returns composite character's bounds as offsets from the start of the line.
    public final func shapedTextGetGraphemeBounds (shaped: RID, pos: Int)-> Vector2 {
        var _result: Vector2 = Vector2 ()
        #if false
        
        var copy_pos = pos
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_grapheme_bounds, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_pos)
        return _result
        #else
        
        var copy_pos = pos
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_grapheme_bounds, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_next_grapheme_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_next_grapheme_pos")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns grapheme end position closest to the `pos`.
    public final func shapedTextNextGraphemePos (shaped: RID, pos: Int)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_pos = pos
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_next_grapheme_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_pos)
        return _result
        #else
        
        var copy_pos = pos
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_next_grapheme_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_prev_grapheme_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_prev_grapheme_pos")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns grapheme start position closest to the `pos`.
    public final func shapedTextPrevGraphemePos (shaped: RID, pos: Int)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_pos = pos
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_prev_grapheme_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_pos)
        return _result
        #else
        
        var copy_pos = pos
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_prev_grapheme_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_character_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_character_breaks")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 788230395)!
            }
            
        }
        
    }()
    
    /// Returns array of the composite character boundaries.
    public final func shapedTextGetCharacterBreaks (shaped: RID)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_character_breaks, UnsafeMutableRawPointer (mutating: handle), &_result.content, &shaped.content)
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_character_breaks, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_next_character_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_next_character_pos")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns composite character end position closest to the `pos`.
    public final func shapedTextNextCharacterPos (shaped: RID, pos: Int)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_pos = pos
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_next_character_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_pos)
        return _result
        #else
        
        var copy_pos = pos
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_next_character_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_prev_character_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_prev_character_pos")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns composite character start position closest to the `pos`.
    public final func shapedTextPrevCharacterPos (shaped: RID, pos: Int)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_pos = pos
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_prev_character_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_pos)
        return _result
        #else
        
        var copy_pos = pos
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_prev_character_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_closest_character_pos: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_closest_character_pos")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1120910005)!
            }
            
        }
        
    }()
    
    /// Returns composite character position closest to the `pos`.
    public final func shapedTextClosestCharacterPos (shaped: RID, pos: Int)-> Int {
        var _result: Int = 0
        #if false
        
        var copy_pos = pos
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_closest_character_pos, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_pos)
        return _result
        #else
        
        var copy_pos = pos
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_pos) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_closest_character_pos, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_draw: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_draw")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 880389142)!
            }
            
        }
        
    }()
    
    /// Draw shaped text into a canvas item at a given position, with `color`. `pos` specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
    public final func shapedTextDraw (shaped: RID, canvas: RID, pos: Vector2, clipL: Double = -1, clipR: Double = -1, color: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_pos = pos
        var copy_clip_l = clipL
        var copy_clip_r = clipR
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_draw, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &canvas.content, &copy_pos, &copy_clip_l, &copy_clip_r, &copy_color)
        
        #else
        
        var copy_pos = pos
        var copy_clip_l = clipL
        var copy_clip_r = clipR
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_pos) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_clip_l) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_clip_r) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_color) { p5 in
                                _args.append (p5)
        
                                gi.object_method_bind_ptrcall (TextServer.method_shaped_text_draw, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_draw_outline: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_draw_outline")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2559184194)!
            }
            
        }
        
    }()
    
    /// Draw the outline of the shaped text into a canvas item at a given position, with `color`. `pos` specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
    public final func shapedTextDrawOutline (shaped: RID, canvas: RID, pos: Vector2, clipL: Double = -1, clipR: Double = -1, outlineSize: Int = 1, color: Color = Color (r: 1, g: 1, b: 1, a: 1)) {
        #if false
        
        var copy_pos = pos
        var copy_clip_l = clipL
        var copy_clip_r = clipR
        var copy_outline_size = outlineSize
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_draw_outline, UnsafeMutableRawPointer (mutating: handle), nil, &shaped.content, &canvas.content, &copy_pos, &copy_clip_l, &copy_clip_r, &copy_outline_size, &copy_color)
        
        #else
        
        var copy_pos = pos
        var copy_clip_l = clipL
        var copy_clip_r = clipR
        var copy_outline_size = outlineSize
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &canvas.content) { p1 in
                _args.append (p1)
                withUnsafePointer (to: &copy_pos) { p2 in
                    _args.append (p2)
                    withUnsafePointer (to: &copy_clip_l) { p3 in
                        _args.append (p3)
                        withUnsafePointer (to: &copy_clip_r) { p4 in
                            _args.append (p4)
                            withUnsafePointer (to: &copy_outline_size) { p5 in
                                _args.append (p5)
                                withUnsafePointer (to: &copy_color) { p6 in
                                    _args.append (p6)
        
                                    gi.object_method_bind_ptrcall (TextServer.method_shaped_text_draw_outline, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_shaped_text_get_dominant_direction_in_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("shaped_text_get_dominant_direction_in_range")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3326907668)!
            }
            
        }
        
    }()
    
    /// Returns dominant direction of in the range of text.
    public final func shapedTextGetDominantDirectionInRange (shaped: RID, start: Int, end: Int)-> TextServer.Direction {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_start = start
        var copy_end = end
        
        gi.object_method_bind_ptrcall_v (TextServer.method_shaped_text_get_dominant_direction_in_range, UnsafeMutableRawPointer (mutating: handle), &_result, &shaped.content, &copy_start, &copy_end)
        return TextServer.Direction (rawValue: _result)!
        #else
        
        var copy_start = start
        var copy_end = end
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &shaped.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_start) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_end) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_shaped_text_get_dominant_direction_in_range, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return TextServer.Direction (rawValue: _result)!
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_format_number: GDExtensionMethodBindPtr = {
        let methodName = StringName ("format_number")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Converts a number from the Western Arabic (0..9) to the numeral systems used in `language`.
    /// 
    /// If `language` is omitted, the active locale will be used.
    /// 
    public final func formatNumber (_ number: String, language: String = "")-> String {
        let _result = GString ()
        #if false
        
        let gstr_number = GString (number)
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_format_number, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_number.content, &gstr_language.content)
        return _result.description
        #else
        
        let gstr_number = GString (number)
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_number.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_format_number, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_parse_number: GDExtensionMethodBindPtr = {
        let methodName = StringName ("parse_number")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Converts `number` from the numeral systems used in `language` to Western Arabic (0..9).
    public final func parseNumber (_ number: String, language: String = "")-> String {
        let _result = GString ()
        #if false
        
        let gstr_number = GString (number)
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_parse_number, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_number.content, &gstr_language.content)
        return _result.description
        #else
        
        let gstr_number = GString (number)
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_number.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_parse_number, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_percent_sign: GDExtensionMethodBindPtr = {
        let methodName = StringName ("percent_sign")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 993269549)!
            }
            
        }
        
    }()
    
    /// Returns percent sign used in the `language`.
    public final func percentSign (language: String = "")-> String {
        let _result = GString ()
        #if false
        
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_percent_sign, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_language.content)
        return _result.description
        #else
        
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_language.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_percent_sign, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_string_get_word_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName ("string_get_word_breaks")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 581857818)!
            }
            
        }
        
    }()
    
    /// Returns an array of the word break boundaries. Elements in the returned array are the offsets of the start and end of words. Therefore the length of the array is always even.
    /// 
    /// When `charsPerLine` is greater than zero, line break boundaries are returned instead.
    /// 
    public final func stringGetWordBreaks (string: String, language: String = "", charsPerLine: Int = 0)-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        let gstr_string = GString (string)
        let gstr_language = GString (language)
        var copy_chars_per_line = charsPerLine
        
        gi.object_method_bind_ptrcall_v (TextServer.method_string_get_word_breaks, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_string.content, &gstr_language.content, &copy_chars_per_line)
        return _result
        #else
        
        let gstr_string = GString (string)
        let gstr_language = GString (language)
        var copy_chars_per_line = charsPerLine
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_chars_per_line) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_string_get_word_breaks, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_string_get_character_breaks: GDExtensionMethodBindPtr = {
        let methodName = StringName ("string_get_character_breaks")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2333794773)!
            }
            
        }
        
    }()
    
    /// Returns array of the composite character boundaries.
    /// 
    public final func stringGetCharacterBreaks (string: String, language: String = "")-> PackedInt32Array {
        let _result: PackedInt32Array = PackedInt32Array ()
        #if false
        
        let gstr_string = GString (string)
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_string_get_character_breaks, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_string.content, &gstr_language.content)
        return _result
        #else
        
        let gstr_string = GString (string)
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_string_get_character_breaks, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_confusable: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_confusable")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1433197768)!
            }
            
        }
        
    }()
    
    /// Returns index of the first string in `dict` which is visually confusable with the `string`, or `-1` if none is found.
    /// 
    /// > Note: This method doesn't detect invisible characters, for spoof detection use it in combination with ``spoofCheck(string:)``.
    /// 
    /// > Note: Always returns `-1` if the server does not support the .unicodeSecurity feature.
    /// 
    public final func isConfusable (string: String, dict: PackedStringArray)-> Int {
        var _result: Int = 0
        #if false
        
        let gstr_string = GString (string)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_is_confusable, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_string.content, &dict.content)
        return _result
        #else
        
        let gstr_string = GString (string)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &dict.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_is_confusable, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_spoof_check: GDExtensionMethodBindPtr = {
        let methodName = StringName ("spoof_check")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `string` is likely to be an attempt at confusing the reader.
    /// 
    /// > Note: Always returns `false` if the server does not support the .unicodeSecurity feature.
    /// 
    public final func spoofCheck (string: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_string = GString (string)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_spoof_check, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_string.content)
        return _result
        #else
        
        let gstr_string = GString (string)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_spoof_check, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_strip_diacritics: GDExtensionMethodBindPtr = {
        let methodName = StringName ("strip_diacritics")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3135753539)!
            }
            
        }
        
    }()
    
    /// Strips diacritics from the string.
    /// 
    /// > Note: The result may be longer or shorter than the original.
    /// 
    public final func stripDiacritics (string: String)-> String {
        let _result = GString ()
        #if false
        
        let gstr_string = GString (string)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_strip_diacritics, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_string.content)
        return _result.description
        #else
        
        let gstr_string = GString (string)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_strip_diacritics, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_is_valid_identifier: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_valid_identifier")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if `string` is a valid identifier.
    /// 
    /// If the text server supports the .unicodeIdentifiers feature, a valid identifier must:
    /// 
    /// - Conform to normalization form C.
    /// 
    /// - Begin with a Unicode character of class XID_Start or `"_"`.
    /// 
    /// - May contain Unicode characters of class XID_Continue in the other positions.
    /// 
    /// - Use UAX #31 recommended scripts only (mixed scripts are allowed).
    /// 
    /// If the .unicodeIdentifiers feature is not supported, a valid identifier must:
    /// 
    /// - Begin with a Unicode character of class XID_Start or `"_"`.
    /// 
    /// - May contain Unicode characters of class XID_Continue in the other positions.
    /// 
    public final func isValidIdentifier (string: String)-> Bool {
        var _result: Bool = false
        #if false
        
        let gstr_string = GString (string)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_is_valid_identifier, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_string.content)
        return _result
        #else
        
        let gstr_string = GString (string)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (TextServer.method_is_valid_identifier, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_string_to_upper: GDExtensionMethodBindPtr = {
        let methodName = StringName ("string_to_upper")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Returns the string converted to uppercase.
    /// 
    /// > Note: Casing is locale dependent and context sensitive if server support .contextSensitiveCaseConversion feature (supported by ``TextServerAdvanced``).
    /// 
    /// > Note: The result may be longer or shorter than the original.
    /// 
    public final func stringToUpper (string: String, language: String = "")-> String {
        let _result = GString ()
        #if false
        
        let gstr_string = GString (string)
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_string_to_upper, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_string.content, &gstr_language.content)
        return _result.description
        #else
        
        let gstr_string = GString (string)
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_string_to_upper, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_string_to_lower: GDExtensionMethodBindPtr = {
        let methodName = StringName ("string_to_lower")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2664628024)!
            }
            
        }
        
    }()
    
    /// Returns the string converted to lowercase.
    /// 
    /// > Note: Casing is locale dependent and context sensitive if server support .contextSensitiveCaseConversion feature (supported by ``TextServerAdvanced``).
    /// 
    /// > Note: The result may be longer or shorter than the original.
    /// 
    public final func stringToLower (string: String, language: String = "")-> String {
        let _result = GString ()
        #if false
        
        let gstr_string = GString (string)
        let gstr_language = GString (language)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_string_to_lower, UnsafeMutableRawPointer (mutating: handle), &_result.content, &gstr_string.content, &gstr_language.content)
        return _result.description
        #else
        
        let gstr_string = GString (string)
        let gstr_language = GString (language)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &gstr_language.content) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (TextServer.method_string_to_lower, UnsafeMutableRawPointer (mutating: handle), &_args, &_result.content)
                return _result.description
            }
        }
        
        #endif
    }
    
    fileprivate static var method_parse_structured_text: GDExtensionMethodBindPtr = {
        let methodName = StringName ("parse_structured_text")
        return withUnsafePointer (to: &TextServer.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3310685015)!
            }
            
        }
        
    }()
    
    /// Default implementation of the BiDi algorithm override function. See ``TextServer/StructuredTextParser`` for more info.
    public final func parseStructuredText (parserType: TextServer.StructuredTextParser, args: GArray, text: String)-> VariantCollection<Vector3i> {
        var _result: Int64 = 0
        #if false
        
        var copy_parser_type = Int64 (parserType.rawValue)
        let gstr_text = GString (text)
        
        gi.object_method_bind_ptrcall_v (TextServer.method_parse_structured_text, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_parser_type, &args.content, &gstr_text.content)
        return VariantCollection<Vector3i>(content: _result)
        #else
        
        var copy_parser_type = Int64 (parserType.rawValue)
        let gstr_text = GString (text)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_parser_type) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &args.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &gstr_text.content) { p2 in
                    _args.append (p2)
        
                    gi.object_method_bind_ptrcall (TextServer.method_parse_structured_text, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                    return VariantCollection<Vector3i>(content: _result)
                }
            }
        }
        
        #endif
    }
    
}

