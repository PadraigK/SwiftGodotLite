// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// Our OpenXR interface.
/// 
/// The OpenXR interface allows Godot to interact with OpenXR runtimes and make it possible to create XR experiences and games.
/// 
/// Due to the needs of OpenXR this interface works slightly different than other plugin based XR interfaces. It needs to be initialized when Godot starts. You need to enable OpenXR, settings for this can be found in your games project settings under the XR heading. You do need to mark a viewport for use with XR in order for Godot to know which render result should be output to the headset.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``sessionBegun``
/// - ``sessionStopping``
/// - ``sessionFocussed``
/// - ``sessionVisible``
/// - ``poseRecentered``
open class OpenXRInterface: XRInterface {
    override open class var godotClassName: StringName { "OpenXRInterface" }
    public enum Hand: Int64 {
        /// Left hand.
        case left = 0 // HAND_LEFT
        /// Right hand.
        case right = 1 // HAND_RIGHT
        /// Maximum value for the hand enum.
        case max = 2 // HAND_MAX
    }
    
    public enum HandMotionRange: Int64 {
        /// 
        case unobstructed = 0 // HAND_MOTION_RANGE_UNOBSTRUCTED
        /// 
        case conformToController = 1 // HAND_MOTION_RANGE_CONFORM_TO_CONTROLLER
        /// 
        case max = 2 // HAND_MOTION_RANGE_MAX
    }
    
    public enum HandJoints: Int64 {
        /// Palm joint.
        case palm = 0 // HAND_JOINT_PALM
        /// Wrist joint.
        case wrist = 1 // HAND_JOINT_WRIST
        /// Thumb metacarpal joint.
        case thumbMetacarpal = 2 // HAND_JOINT_THUMB_METACARPAL
        /// Thumb proximal joint.
        case thumbProximal = 3 // HAND_JOINT_THUMB_PROXIMAL
        /// Thumb distal joint.
        case thumbDistal = 4 // HAND_JOINT_THUMB_DISTAL
        /// Thumb tip joint.
        case thumbTip = 5 // HAND_JOINT_THUMB_TIP
        /// Index metacarpal joint.
        case indexMetacarpal = 6 // HAND_JOINT_INDEX_METACARPAL
        /// Index proximal joint.
        case indexProximal = 7 // HAND_JOINT_INDEX_PROXIMAL
        /// Index intermediate joint.
        case indexIntermediate = 8 // HAND_JOINT_INDEX_INTERMEDIATE
        /// Index distal joint.
        case indexDistal = 9 // HAND_JOINT_INDEX_DISTAL
        /// Index tip joint.
        case indexTip = 10 // HAND_JOINT_INDEX_TIP
        /// Middle metacarpal joint.
        case middleMetacarpal = 11 // HAND_JOINT_MIDDLE_METACARPAL
        /// Middle proximal joint.
        case middleProximal = 12 // HAND_JOINT_MIDDLE_PROXIMAL
        /// Middle intermediate joint.
        case middleIntermediate = 13 // HAND_JOINT_MIDDLE_INTERMEDIATE
        /// Middle distal joint.
        case middleDistal = 14 // HAND_JOINT_MIDDLE_DISTAL
        /// Middle tip joint.
        case middleTip = 15 // HAND_JOINT_MIDDLE_TIP
        /// Ring metacarpal joint.
        case ringMetacarpal = 16 // HAND_JOINT_RING_METACARPAL
        /// Ring proximal joint.
        case ringProximal = 17 // HAND_JOINT_RING_PROXIMAL
        /// Ring intermediate joint.
        case ringIntermediate = 18 // HAND_JOINT_RING_INTERMEDIATE
        /// Ring distal joint.
        case ringDistal = 19 // HAND_JOINT_RING_DISTAL
        /// Ring tip joint.
        case ringTip = 20 // HAND_JOINT_RING_TIP
        /// Little metacarpal joint.
        case littleMetacarpal = 21 // HAND_JOINT_LITTLE_METACARPAL
        /// Little proximal joint.
        case littleProximal = 22 // HAND_JOINT_LITTLE_PROXIMAL
        /// Little intermediate joint.
        case littleIntermediate = 23 // HAND_JOINT_LITTLE_INTERMEDIATE
        /// Little distal joint.
        case littleDistal = 24 // HAND_JOINT_LITTLE_DISTAL
        /// Little tip joint.
        case littleTip = 25 // HAND_JOINT_LITTLE_TIP
        /// Maximum value for the hand joint enum.
        case max = 26 // HAND_JOINT_MAX
    }
    
    public struct HandJointFlags: OptionSet, CustomDebugStringConvertible {
        public let rawValue: Int
        public init (rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// If set, the orientation data is valid, otherwise, the orientation data is unreliable and should not be used.
        public static let orientationValid = HandJointFlags (rawValue: 1)
        /// If set, the orientation data comes from tracking data, otherwise, the orientation data contains predicted data.
        public static let orientationTracked = HandJointFlags (rawValue: 2)
        /// If set, the positional data is valid, otherwise, the positional data is unreliable and should not be used.
        public static let positionValid = HandJointFlags (rawValue: 4)
        /// If set, the positional data comes from tracking data, otherwise, the positional data contains predicted data.
        public static let positionTracked = HandJointFlags (rawValue: 8)
        /// If set, our linear velocity data is valid, otherwise, the linear velocity data is unreliable and should not be used.
        public static let linearVelocityValid = HandJointFlags (rawValue: 16)
        /// If set, our angular velocity data is valid, otherwise, the angular velocity data is unreliable and should not be used.
        public static let angularVelocityValid = HandJointFlags (rawValue: 32)
        /// A textual representation of this instance, suitable for debugging
        public var debugDescription: String {
            var result = ""
            if self.contains (.orientationValid) { result += "orientationValid, " }
            if self.contains (.orientationTracked) { result += "orientationTracked, " }
            if self.contains (.positionValid) { result += "positionValid, " }
            if self.contains (.positionTracked) { result += "positionTracked, " }
            if self.contains (.linearVelocityValid) { result += "linearVelocityValid, " }
            if self.contains (.angularVelocityValid) { result += "angularVelocityValid, " }
            if result.hasSuffix (", ") { result.removeLast (2) }
            return result
        }
        
    }
    
    
    /* Properties */
    
    /// The display refresh rate for the current HMD. Only functional if this feature is supported by the OpenXR runtime and after the interface has been initialized.
    final public var displayRefreshRate: Double {
        get {
            return get_display_refresh_rate ()
        }
        
        set {
            set_display_refresh_rate (newValue)
        }
        
    }
    
    /// The render size multiplier for the current HMD. Must be set before the interface has been initialized.
    final public var renderTargetSizeMultiplier: Double {
        get {
            return get_render_target_size_multiplier ()
        }
        
        set {
            set_render_target_size_multiplier (newValue)
        }
        
    }
    
    /// Set foveation level from 0 (off) to 3 (high), the interface must be initialized before this is accessible.
    final public var foveationLevel: Int32 {
        get {
            return get_foveation_level ()
        }
        
        set {
            set_foveation_level (newValue)
        }
        
    }
    
    /// Enable dynamic foveation adjustment, the interface must be initialized before this is accessible. If enabled foveation will automatically adjusted between low and ``foveationLevel``.
    final public var foveationDynamic: Bool {
        get {
            return get_foveation_dynamic ()
        }
        
        set {
            set_foveation_dynamic (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_get_display_refresh_rate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_display_refresh_rate")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_display_refresh_rate ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (OpenXRInterface.method_get_display_refresh_rate, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_display_refresh_rate: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_display_refresh_rate")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_display_refresh_rate (_ refreshRate: Double) {
        #if true
        
        var copy_refresh_rate = refreshRate
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_set_display_refresh_rate, UnsafeMutableRawPointer (mutating: handle), nil, &copy_refresh_rate)
        
        #else
        
        var copy_refresh_rate = refreshRate
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_refresh_rate) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRInterface.method_set_display_refresh_rate, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_render_target_size_multiplier: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_render_target_size_multiplier")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1740695150)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_render_target_size_multiplier ()-> Double {
        var _result: Double = 0.0
        gi.object_method_bind_ptrcall (OpenXRInterface.method_get_render_target_size_multiplier, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_render_target_size_multiplier: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_render_target_size_multiplier")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 373806689)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_render_target_size_multiplier (_ multiplier: Double) {
        #if true
        
        var copy_multiplier = multiplier
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_set_render_target_size_multiplier, UnsafeMutableRawPointer (mutating: handle), nil, &copy_multiplier)
        
        #else
        
        var copy_multiplier = multiplier
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_multiplier) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRInterface.method_set_render_target_size_multiplier, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_foveation_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_foveation_supported")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    /// Returns `true` if OpenXR's foveation extension is supported, the interface must be initialized before this returns a valid value.
    /// 
    /// > Note: This feature is only available on the compatibility renderer and currently only available on some stand alone headsets. For Vulkan set ``Viewport/vrsMode`` to `VRS_XR` on desktop.
    /// 
    public final func isFoveationSupported ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (OpenXRInterface.method_is_foveation_supported, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_get_foveation_level: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_foveation_level")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3905245786)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_foveation_level ()-> Int32 {
        var _result: Int32 = 0
        gi.object_method_bind_ptrcall (OpenXRInterface.method_get_foveation_level, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_foveation_level: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_foveation_level")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1286410249)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_foveation_level (_ foveationLevel: Int32) {
        #if true
        
        var copy_foveation_level: Int = Int (foveationLevel)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_set_foveation_level, UnsafeMutableRawPointer (mutating: handle), nil, &copy_foveation_level)
        
        #else
        
        var copy_foveation_level: Int = Int (foveationLevel)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_foveation_level) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRInterface.method_set_foveation_level, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_foveation_dynamic: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_foveation_dynamic")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_foveation_dynamic ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (OpenXRInterface.method_get_foveation_dynamic, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_foveation_dynamic: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_foveation_dynamic")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_foveation_dynamic (_ foveationDynamic: Bool) {
        #if true
        
        var copy_foveation_dynamic = foveationDynamic
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_set_foveation_dynamic, UnsafeMutableRawPointer (mutating: handle), nil, &copy_foveation_dynamic)
        
        #else
        
        var copy_foveation_dynamic = foveationDynamic
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_foveation_dynamic) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRInterface.method_set_foveation_dynamic, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_action_set_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_action_set_active")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3927539163)!
            }
            
        }
        
    }()
    
    /// Returns `true` if the given action set is active.
    public final func isActionSetActive (name: String)-> Bool {
        var _result: Bool = false
        #if true
        
        let gstr_name = GString (name)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_is_action_set_active, UnsafeMutableRawPointer (mutating: handle), &_result, &gstr_name.content)
        return _result
        #else
        
        let gstr_name = GString (name)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_name.content) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRInterface.method_is_action_set_active, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_set_action_set_active: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_action_set_active")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2678287736)!
            }
            
        }
        
    }()
    
    /// Sets the given action set as active or inactive.
    public final func setActionSetActive (name: String, active: Bool) {
        #if true
        
        let gstr_name = GString (name)
        var copy_active = active
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_set_action_set_active, UnsafeMutableRawPointer (mutating: handle), nil, &gstr_name.content, &copy_active)
        
        #else
        
        let gstr_name = GString (name)
        var copy_active = active
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_name.content) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_active) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OpenXRInterface.method_set_action_set_active, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_action_sets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_action_sets")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns a list of action sets registered with Godot (loaded from the action map at runtime).
    public final func getActionSets ()-> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall (OpenXRInterface.method_get_action_sets, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_get_available_display_refresh_rates: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_available_display_refresh_rates")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3995934104)!
            }
            
        }
        
    }()
    
    /// Returns display refresh rates supported by the current HMD. Only returned if this feature is supported by the OpenXR runtime and after the interface has been initialized.
    public final func getAvailableDisplayRefreshRates ()-> GArray {
        let _result: GArray = GArray ()
        gi.object_method_bind_ptrcall (OpenXRInterface.method_get_available_display_refresh_rates, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_motion_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_motion_range")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 855158159)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled and motion range is supported, sets the currently configured motion range for `hand` to `motionRange`.
    public final func setMotionRange (hand: OpenXRInterface.Hand, motionRange: OpenXRInterface.HandMotionRange) {
        #if true
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_motion_range = Int64 (motionRange.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_set_motion_range, UnsafeMutableRawPointer (mutating: handle), nil, &copy_hand, &copy_motion_range)
        
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_motion_range = Int64 (motionRange.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
            withUnsafePointer (to: &copy_motion_range) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OpenXRInterface.method_set_motion_range, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_motion_range: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_motion_range")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3955838114)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled and motion range is supported, gets the currently configured motion range for `hand`.
    public final func getMotionRange (hand: OpenXRInterface.Hand)-> OpenXRInterface.HandMotionRange {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if true
        
        var copy_hand = Int64 (hand.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_get_motion_range, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_hand)
        return OpenXRInterface.HandMotionRange (rawValue: _result)!
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (OpenXRInterface.method_get_motion_range, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
            return OpenXRInterface.HandMotionRange (rawValue: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_get_hand_joint_flags: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hand_joint_flags")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 720567706)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns flags that inform us of the validity of the tracking data.
    public final func getHandJointFlags (hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints)-> OpenXRInterface.HandJointFlags {
        var _result: OpenXRInterface.HandJointFlags = OpenXRInterface.HandJointFlags ()
        #if true
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_get_hand_joint_flags, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_hand, &copy_joint)
        return _result
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_joint) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OpenXRInterface.method_get_hand_joint_flags, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_hand_joint_rotation: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hand_joint_rotation")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1974618321)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the rotation of a joint (`joint`) of a hand (`hand`) as provided by OpenXR.
    public final func getHandJointRotation (hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints)-> Quaternion {
        var _result: Quaternion = Quaternion ()
        #if true
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_get_hand_joint_rotation, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_hand, &copy_joint)
        return _result
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_joint) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OpenXRInterface.method_get_hand_joint_rotation, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_hand_joint_position: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hand_joint_position")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3529194242)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the position of a joint (`joint`) of a hand (`hand`) as provided by OpenXR. This is relative to ``XROrigin3D`` without worldscale applied!
    public final func getHandJointPosition (hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints)-> Vector3 {
        var _result: Vector3 = Vector3 ()
        #if true
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_get_hand_joint_position, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_hand, &copy_joint)
        return _result
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_joint) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OpenXRInterface.method_get_hand_joint_position, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_hand_joint_radius: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hand_joint_radius")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 901522724)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the radius of a joint (`joint`) of a hand (`hand`) as provided by OpenXR. This is without worldscale applied!
    public final func getHandJointRadius (hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints)-> Double {
        var _result: Double = 0.0
        #if true
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_get_hand_joint_radius, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_hand, &copy_joint)
        return _result
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_joint) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OpenXRInterface.method_get_hand_joint_radius, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_hand_joint_linear_velocity: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hand_joint_linear_velocity")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3529194242)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the linear velocity of a joint (`joint`) of a hand (`hand`) as provided by OpenXR. This is relative to ``XROrigin3D`` without worldscale applied!
    public final func getHandJointLinearVelocity (hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints)-> Vector3 {
        var _result: Vector3 = Vector3 ()
        #if true
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_get_hand_joint_linear_velocity, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_hand, &copy_joint)
        return _result
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_joint) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OpenXRInterface.method_get_hand_joint_linear_velocity, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_get_hand_joint_angular_velocity: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_hand_joint_angular_velocity")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3529194242)!
            }
            
        }
        
    }()
    
    /// If handtracking is enabled, returns the angular velocity of a joint (`joint`) of a hand (`hand`) as provided by OpenXR. This is relative to ``XROrigin3D``!
    public final func getHandJointAngularVelocity (hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints)-> Vector3 {
        var _result: Vector3 = Vector3 ()
        #if true
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        
        gi.object_method_bind_ptrcall_v (OpenXRInterface.method_get_hand_joint_angular_velocity, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_hand, &copy_joint)
        return _result
        #else
        
        var copy_hand = Int64 (hand.rawValue)
        var copy_joint = Int64 (joint.rawValue)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_hand) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_joint) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (OpenXRInterface.method_get_hand_joint_angular_velocity, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_hand_tracking_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_hand_tracking_supported")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Returns `true` if OpenXR's hand tracking is supported and enabled.
    /// 
    /// > Note: This only returns a valid value after OpenXR has been initialized.
    /// 
    public final func isHandTrackingSupported ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (OpenXRInterface.method_is_hand_tracking_supported, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_is_eye_gaze_interaction_supported: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_eye_gaze_interaction_supported")
        return withUnsafePointer (to: &OpenXRInterface.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2240911060)!
            }
            
        }
        
    }()
    
    /// Returns the capabilities of the eye gaze interaction extension.
    /// 
    /// > Note: This only returns a valid value after OpenXR has been initialized.
    /// 
    public final func isEyeGazeInteractionSupported ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (OpenXRInterface.method_is_eye_gaze_interaction_supported, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    // Signals 
    /// Informs our OpenXR session has been started.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionBegun.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionBegun: SimpleSignal { SimpleSignal (target: self, signalName: "session_begun") }
    
    /// Informs our OpenXR session is stopping.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionStopping.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionStopping: SimpleSignal { SimpleSignal (target: self, signalName: "session_stopping") }
    
    /// Informs our OpenXR session now has focus.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionFocussed.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionFocussed: SimpleSignal { SimpleSignal (target: self, signalName: "session_focussed") }
    
    /// Informs our OpenXR session is now visible (output is being sent to the HMD).
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.sessionVisible.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var sessionVisible: SimpleSignal { SimpleSignal (target: self, signalName: "session_visible") }
    
    /// Informs the user queued a recenter of the player position.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.poseRecentered.connect {
    ///    print ("caught signal")
    /// }
    /// ```
    public var poseRecentered: SimpleSignal { SimpleSignal (target: self, signalName: "pose_recentered") }
    
}

