// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A widget that provides an interface for selecting or modifying a color.
/// 
/// A widget that provides an interface for selecting or modifying a color. It can optionally provide functionalities like a color sampler (eyedropper), color modes, and presets.
/// 
/// > Note: This control is the color picker widget itself. You can use a ``ColorPickerButton`` instead if you need a button that brings up a ``ColorPicker`` in a popup.
/// 
/// 
/// 
/// This object emits the following signals:
/// 
/// - ``colorChanged``
/// - ``presetAdded``
/// - ``presetRemoved``
open class ColorPicker: VBoxContainer {
    override open class var godotClassName: StringName { "ColorPicker" }
    public enum ColorModeType: Int64 {
        /// Allows editing the color with Red/Green/Blue sliders.
        case rgb = 0 // MODE_RGB
        /// Allows editing the color with Hue/Saturation/Value sliders.
        case hsv = 1 // MODE_HSV
        /// Allows the color R, G, B component values to go beyond 1.0, which can be used for certain special operations that require it (like tinting without darkening or rendering sprites in HDR).
        case raw = 2 // MODE_RAW
        /// Allows editing the color with Hue/Saturation/Lightness sliders.
        /// 
        /// OKHSL is a new color space similar to HSL but that better match perception by leveraging the Oklab color space which is designed to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue.
        /// 
        /// [url=https://bottosson.github.io/posts/colorpicker/]Okhsv and Okhsl color spaces[/url]
        /// 
        case okhsl = 3 // MODE_OKHSL
    }
    
    public enum PickerShapeType: Int64 {
        /// HSV Color Model rectangle color space.
        case hsvRectangle = 0 // SHAPE_HSV_RECTANGLE
        /// HSV Color Model rectangle color space with a wheel.
        case hsvWheel = 1 // SHAPE_HSV_WHEEL
        /// HSV Color Model circle color space. Use Saturation as a radius.
        case vhsCircle = 2 // SHAPE_VHS_CIRCLE
        /// HSL OK Color Model circle color space.
        case okhslCircle = 3 // SHAPE_OKHSL_CIRCLE
        /// The color space shape and the shape select button are hidden. Can't be selected from the shapes popup.
        case none = 4 // SHAPE_NONE
    }
    
    
    /* Properties */
    
    /// The currently selected color.
    final public var color: Color {
        get {
            return get_pick_color ()
        }
        
        set {
            set_pick_color (newValue)
        }
        
    }
    
    /// If `true`, shows an alpha channel slider (opacity).
    final public var editAlpha: Bool {
        get {
            return is_editing_alpha ()
        }
        
        set {
            set_edit_alpha (newValue)
        }
        
    }
    
    /// The currently selected color mode. See ``ColorPicker/ColorModeType``.
    final public var colorMode: ColorPicker.ColorModeType {
        get {
            return get_color_mode ()
        }
        
        set {
            set_color_mode (newValue)
        }
        
    }
    
    /// If `true`, the color will apply only after the user releases the mouse button, otherwise it will apply immediately even in mouse motion event (which can cause performance issues).
    final public var deferredMode: Bool {
        get {
            return is_deferred_mode ()
        }
        
        set {
            set_deferred_mode (newValue)
        }
        
    }
    
    /// The shape of the color space view. See ``ColorPicker/PickerShapeType``.
    final public var pickerShape: ColorPicker.PickerShapeType {
        get {
            return get_picker_shape ()
        }
        
        set {
            set_picker_shape (newValue)
        }
        
    }
    
    /// If `true`, it's possible to add presets under Swatches. If `false`, the button to add presets is disabled.
    final public var canAddSwatches: Bool {
        get {
            return are_swatches_enabled ()
        }
        
        set {
            set_can_add_swatches (newValue)
        }
        
    }
    
    /// If `true`, the color sampler and color preview are visible.
    final public var samplerVisible: Bool {
        get {
            return is_sampler_visible ()
        }
        
        set {
            set_sampler_visible (newValue)
        }
        
    }
    
    /// If `true`, the color mode buttons are visible.
    final public var colorModesVisible: Bool {
        get {
            return are_modes_visible ()
        }
        
        set {
            set_modes_visible (newValue)
        }
        
    }
    
    /// If `true`, the color sliders are visible.
    final public var slidersVisible: Bool {
        get {
            return are_sliders_visible ()
        }
        
        set {
            set_sliders_visible (newValue)
        }
        
    }
    
    /// If `true`, the hex color code input field is visible.
    final public var hexVisible: Bool {
        get {
            return is_hex_visible ()
        }
        
        set {
            set_hex_visible (newValue)
        }
        
    }
    
    /// If `true`, the Swatches and Recent Colors presets are visible.
    final public var presetsVisible: Bool {
        get {
            return are_presets_visible ()
        }
        
        set {
            set_presets_visible (newValue)
        }
        
    }
    
    /* Methods */
    fileprivate static var method_set_pick_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_pick_color")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_pick_color (_ color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_pick_color, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_pick_color, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_pick_color: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_pick_color")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3444240500)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_pick_color ()-> Color {
        var _result: Color = Color ()
        gi.object_method_bind_ptrcall (ColorPicker.method_get_pick_color, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_deferred_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_deferred_mode")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_deferred_mode (_ mode: Bool) {
        #if false
        
        var copy_mode = mode
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_deferred_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_mode)
        
        #else
        
        var copy_mode = mode
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_deferred_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_deferred_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_deferred_mode")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_deferred_mode ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (ColorPicker.method_is_deferred_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_color_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_color_mode")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1579114136)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_color_mode (_ colorMode: ColorPicker.ColorModeType) {
        #if false
        
        var copy_color_mode = Int64 (colorMode.rawValue)
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_color_mode, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color_mode)
        
        #else
        
        var copy_color_mode = Int64 (colorMode.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color_mode) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_color_mode, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_color_mode: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_color_mode")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 392907674)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_color_mode ()-> ColorPicker.ColorModeType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (ColorPicker.method_get_color_mode, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return ColorPicker.ColorModeType (rawValue: _result)!
    }
    
    fileprivate static var method_set_edit_alpha: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_edit_alpha")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_edit_alpha (_ show: Bool) {
        #if false
        
        var copy_show = show
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_edit_alpha, UnsafeMutableRawPointer (mutating: handle), nil, &copy_show)
        
        #else
        
        var copy_show = show
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_show) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_edit_alpha, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_editing_alpha: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_editing_alpha")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_editing_alpha ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (ColorPicker.method_is_editing_alpha, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_can_add_swatches: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_can_add_swatches")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_can_add_swatches (_ enabled: Bool) {
        #if false
        
        var copy_enabled = enabled
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_can_add_swatches, UnsafeMutableRawPointer (mutating: handle), nil, &copy_enabled)
        
        #else
        
        var copy_enabled = enabled
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_enabled) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_can_add_swatches, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_are_swatches_enabled: GDExtensionMethodBindPtr = {
        let methodName = StringName ("are_swatches_enabled")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func are_swatches_enabled ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (ColorPicker.method_are_swatches_enabled, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_presets_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_presets_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_presets_visible (_ visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_presets_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_presets_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_are_presets_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("are_presets_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func are_presets_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (ColorPicker.method_are_presets_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_modes_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_modes_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_modes_visible (_ visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_modes_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_modes_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_are_modes_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("are_modes_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func are_modes_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (ColorPicker.method_are_modes_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_sampler_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_sampler_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_sampler_visible (_ visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_sampler_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_sampler_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_sampler_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_sampler_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_sampler_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (ColorPicker.method_is_sampler_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_sliders_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_sliders_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_sliders_visible (_ visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_sliders_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_sliders_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_are_sliders_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("are_sliders_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func are_sliders_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (ColorPicker.method_are_sliders_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_set_hex_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_hex_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2586408642)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_hex_visible (_ visible: Bool) {
        #if false
        
        var copy_visible = visible
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_hex_visible, UnsafeMutableRawPointer (mutating: handle), nil, &copy_visible)
        
        #else
        
        var copy_visible = visible
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_visible) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_hex_visible, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_is_hex_visible: GDExtensionMethodBindPtr = {
        let methodName = StringName ("is_hex_visible")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 36873697)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func is_hex_visible ()-> Bool {
        var _result: Bool = false
        gi.object_method_bind_ptrcall (ColorPicker.method_is_hex_visible, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return _result
    }
    
    fileprivate static var method_add_preset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_preset")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds the given color to a list of color presets. The presets are displayed in the color picker and the user will be able to select them.
    /// 
    /// > Note: The presets list is only for _this_ color picker.
    /// 
    public final func addPreset (color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_add_preset, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_add_preset, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_erase_preset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("erase_preset")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Removes the given color from the list of color presets of this color picker.
    public final func erasePreset (color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_erase_preset, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_erase_preset, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_presets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_presets")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1392750486)!
            }
            
        }
        
    }()
    
    /// Returns the list of colors in the presets of the color picker.
    public final func getPresets ()-> PackedColorArray {
        let _result: PackedColorArray = PackedColorArray ()
        gi.object_method_bind_ptrcall (ColorPicker.method_get_presets, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_add_recent_preset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("add_recent_preset")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Adds the given color to a list of color recent presets so that it can be picked later. Recent presets are the colors that were picked recently, a new preset is automatically created and added to recent presets when you pick a new color.
    /// 
    /// > Note: The recent presets list is only for _this_ color picker.
    /// 
    public final func addRecentPreset (color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_add_recent_preset, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_add_recent_preset, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_erase_recent_preset: GDExtensionMethodBindPtr = {
        let methodName = StringName ("erase_recent_preset")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 2920490490)!
            }
            
        }
        
    }()
    
    /// Removes the given color from the list of color recent presets of this color picker.
    public final func eraseRecentPreset (color: Color) {
        #if false
        
        var copy_color = color
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_erase_recent_preset, UnsafeMutableRawPointer (mutating: handle), nil, &copy_color)
        
        #else
        
        var copy_color = color
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_color) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_erase_recent_preset, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_recent_presets: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_recent_presets")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1392750486)!
            }
            
        }
        
    }()
    
    /// Returns the list of colors in the recent presets of the color picker.
    public final func getRecentPresets ()-> PackedColorArray {
        let _result: PackedColorArray = PackedColorArray ()
        gi.object_method_bind_ptrcall (ColorPicker.method_get_recent_presets, UnsafeMutableRawPointer (mutating: handle), nil, &_result.content)
        return _result
    }
    
    fileprivate static var method_set_picker_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("set_picker_shape")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3981373861)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func set_picker_shape (_ shape: ColorPicker.PickerShapeType) {
        #if false
        
        var copy_shape = Int64 (shape.rawValue)
        
        gi.object_method_bind_ptrcall_v (ColorPicker.method_set_picker_shape, UnsafeMutableRawPointer (mutating: handle), nil, &copy_shape)
        
        #else
        
        var copy_shape = Int64 (shape.rawValue)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_shape) { p0 in
            _args.append (p0)
        
            gi.object_method_bind_ptrcall (ColorPicker.method_set_picker_shape, UnsafeMutableRawPointer (mutating: handle), &_args, nil)
        }
        
        #endif
    }
    
    fileprivate static var method_get_picker_shape: GDExtensionMethodBindPtr = {
        let methodName = StringName ("get_picker_shape")
        return withUnsafePointer (to: &ColorPicker.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 1143229889)!
            }
            
        }
        
    }()
    
    @inline(__always)
    fileprivate final func get_picker_shape ()-> ColorPicker.PickerShapeType {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (ColorPicker.method_get_picker_shape, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return ColorPicker.PickerShapeType (rawValue: _result)!
    }
    
    // Signals 
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal1/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal1/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal1/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal1 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal1 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ color: Color) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Color (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when the color is changed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.colorChanged.connect { color in
    ///    print ("caught signal")
    /// }
    /// ```
    public var colorChanged: Signal1 { Signal1 (target: self, signalName: "color_changed") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal2/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal2/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal2/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal2 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal2 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ color: Color) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Color (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a preset is added.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.presetAdded.connect { color in
    ///    print ("caught signal")
    /// }
    /// ```
    public var presetAdded: Signal2 { Signal2 (target: self, signalName: "preset_added") }
    
    /// Signal support.
    /// 
    /// 
    /// 
    /// Use the ``Signal3/connect(flags:_:)`` method to connect to the signal on the container object, and ``Signal3/disconnect(_:)`` to drop the connection.
    /// 
    /// You can also await the ``Signal3/emitted`` property for waiting for a single emission of the signal.
    /// 
    public class Signal3 {
        var target: Object
        var signalName: StringName
        init (target: Object, signalName: StringName) {
            self.target = target
            self.signalName = signalName
        }
        
        /// Connects the signal to the specified callback
        /// 
        /// 
        /// 
        /// To disconnect, call the disconnect method, with the returned token on success
        /// 
        /// - Parameters:
        /// 
        /// - callback: the method to invoke when this signal is raised
        /// 
        /// - flags: Optional, can be also added to configure the connection's behavior (see ``Object/ConnectFlags`` constants).
        /// 
        /// - Returns: an object token that can be used to disconnect the object from the target on success, or the error produced by Godot.
        /// 
        @discardableResult /* Signal3 */
        public func connect (flags: Object.ConnectFlags = [], _ callback: @escaping (_ color: Color) -> ()) -> Object {
            let signalProxy = SignalProxy()
            signalProxy.proxy =  {
                args in
                let arg_0 = Color (args [0])!
                
                callback (arg_0)
            }
            
            let callable = Callable(object: signalProxy, method: SignalProxy.proxyName)
            let r = target.connect(signal: signalName, callable: callable, flags: UInt32 (flags.rawValue))
            if r != .ok { print ("Warning, error connecting to signal, code: \(r)") }
            return signalProxy
        }
        
        /// Disconnects a signal that was previously connected, the return value from calling ``connect(flags:_:)``
        public func disconnect (_ token: Object) {
            target.disconnect(signal: signalName, callable: Callable (object: token, method: SignalProxy.proxyName))
        }
        
        /// You can await this property to wait for the signal to be emitted once
        public var emitted: Void  {
            get async {
                await withCheckedContinuation {
                    c in
                    connect (flags: .oneShot) { _ in c.resume () }
                }
                
            }
            
        }
        
    }
    
    /// Emitted when a preset is removed.
    ///
    /// To connect to this signal, reference this property and call the
    /// 
    /// `connect` method with the method you want to invoke
    /// 
    /// 
    /// 
    /// Example:
    /// ```swift
    /// obj.presetRemoved.connect { color in
    ///    print ("caught signal")
    /// }
    /// ```
    public var presetRemoved: Signal3 { Signal3 (target: self, signalName: "preset_removed") }
    
}

