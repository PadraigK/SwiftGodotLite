// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

// Generated by Swift code generator - do not edit
@_implementationOnly import GDExtension

/// A stream peer that handles GZIP and deflate compression/decompression.
/// 
/// This class allows to compress or decompress data using GZIP/deflate in a streaming fashion. This is particularly useful when compressing or decompressing files that have to be sent through the network without needing to allocate them all in memory.
/// 
/// After starting the stream via ``startCompression(useDeflate:bufferSize:)`` (or ``startDecompression(useDeflate:bufferSize:)``), calling ``StreamPeer/putPartialData(_:)`` on this stream will compress (or decompress) the data, writing it to the internal buffer. Calling ``StreamPeer/getAvailableBytes()`` will return the pending bytes in the internal buffer, and ``StreamPeer/getPartialData(bytes:)`` will retrieve the compressed (or decompressed) bytes from it. When the stream is over, you must call ``finish()`` to ensure the internal buffer is properly flushed (make sure to call ``StreamPeer/getAvailableBytes()`` on last time to check if more data needs to be read after that).
/// 
open class StreamPeerGZIP: StreamPeer {
    override open class var godotClassName: StringName { "StreamPeerGZIP" }
    /* Methods */
    fileprivate static var method_start_compression: GDExtensionMethodBindPtr = {
        let methodName = StringName ("start_compression")
        return withUnsafePointer (to: &StreamPeerGZIP.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 781582770)!
            }
            
        }
        
    }()
    
    /// Start the stream in compression mode with the given `bufferSize`, if `useDeflate` is `true` uses deflate instead of GZIP.
    public final func startCompression (useDeflate: Bool = false, bufferSize: Int32 = 65535)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_use_deflate = useDeflate
        var copy_buffer_size: Int = Int (bufferSize)
        
        gi.object_method_bind_ptrcall_v (StreamPeerGZIP.method_start_compression, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_use_deflate, &copy_buffer_size)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_use_deflate = useDeflate
        var copy_buffer_size: Int = Int (bufferSize)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_use_deflate) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_buffer_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (StreamPeerGZIP.method_start_compression, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_start_decompression: GDExtensionMethodBindPtr = {
        let methodName = StringName ("start_decompression")
        return withUnsafePointer (to: &StreamPeerGZIP.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 781582770)!
            }
            
        }
        
    }()
    
    /// Start the stream in decompression mode with the given `bufferSize`, if `useDeflate` is `true` uses deflate instead of GZIP.
    public final func startDecompression (useDeflate: Bool = false, bufferSize: Int32 = 65535)-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        #if false
        
        var copy_use_deflate = useDeflate
        var copy_buffer_size: Int = Int (bufferSize)
        
        gi.object_method_bind_ptrcall_v (StreamPeerGZIP.method_start_decompression, UnsafeMutableRawPointer (mutating: handle), &_result, &copy_use_deflate, &copy_buffer_size)
        return GodotError (rawValue: _result)!
        #else
        
        var copy_use_deflate = useDeflate
        var copy_buffer_size: Int = Int (bufferSize)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_use_deflate) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_buffer_size) { p1 in
                _args.append (p1)
        
                gi.object_method_bind_ptrcall (StreamPeerGZIP.method_start_decompression, UnsafeMutableRawPointer (mutating: handle), &_args, &_result)
                return GodotError (rawValue: _result)!
            }
        }
        
        #endif
    }
    
    fileprivate static var method_finish: GDExtensionMethodBindPtr = {
        let methodName = StringName ("finish")
        return withUnsafePointer (to: &StreamPeerGZIP.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 166280745)!
            }
            
        }
        
    }()
    
    /// Finalizes the stream, compressing or decompressing any buffered chunk left.
    public final func finish ()-> GodotError {
        var _result: Int64 = 0 // to avoid packed enums on the stack
        gi.object_method_bind_ptrcall (StreamPeerGZIP.method_finish, UnsafeMutableRawPointer (mutating: handle), nil, &_result)
        return GodotError (rawValue: _result)!
    }
    
    fileprivate static var method_clear: GDExtensionMethodBindPtr = {
        let methodName = StringName ("clear")
        return withUnsafePointer (to: &StreamPeerGZIP.godotClassName.content) { classPtr in
            withUnsafePointer (to: &methodName.content) { mnamePtr in
                gi.classdb_get_method_bind (classPtr, mnamePtr, 3218959716)!
            }
            
        }
        
    }()
    
    /// Clears this stream, resetting the internal state.
    public final func clear () {
        gi.object_method_bind_ptrcall (StreamPeerGZIP.method_clear, UnsafeMutableRawPointer (mutating: handle), nil, nil)
    }
    
}

