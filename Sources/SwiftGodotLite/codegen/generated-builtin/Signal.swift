// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A built-in type representing a signal of an ``Object``.
/// 
/// ``Signal`` is a built-in ``Variant`` type that represents a signal of an ``Object`` instance. Like all ``Variant`` types, it can be stored in variables and passed to functions. Signals allow all connected ``Callable``s (and by extension their respective objects) to listen and react to events, without directly referencing one another. This keeps the code flexible and easier to manage.
/// 
/// In GDScript, signals can be declared with the `signal` keyword. In C#, you may use the ```Signal``` attribute on a delegate.
/// 
public class Signal: Equatable {
    static var destructor: GDExtensionPtrDestructor = {
        return gi.variant_get_ptr_destructor (GDEXTENSION_VARIANT_TYPE_SIGNAL)!
    }()
    
    deinit {
        if content != Signal.zero {
            Signal.destructor (&content)
        }
        
    }
    
    // Contains a binary blob where this type information is stored
    public var content: ContentType = (0, 0)
    // Used to initialize empty types
    public static let zero: ContentType  = (0, 0)
    // Convenience type that matches the build configuration storage needs
    public typealias ContentType = (Int64, Int64)
    // Used to construct objects on virtual proxies
    public required init (content: ContentType) {
        var copy = content
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy) { ptr in
            args.append (ptr)
            Signal.constructor1 (&self.content, &args)
        }
        
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_SIGNAL, 0)!
    
    /// Constructs an empty ``Signal`` with no object nor signal name bound.
    public required init () {
        Signal.constructor0 (&content, nil)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_SIGNAL, 1)!
    
    /// Constructs a ``Signal`` as a copy of the given ``Signal``.
    public init (from: Signal) {
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &from.content) { p0 in
            args.append (p0)
        
            Signal.constructor1 (&content, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_SIGNAL, 2)!
    
    /// Creates a new ``Signal`` named `signal` in the specified `object`.
    public init (object: Object, signal: StringName) {
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &object.handle) { p0 in
            args.append (p0)
            withUnsafePointer (to: &signal.content) { p1 in
                args.append (p1)
        
                Signal.constructor2 (&content, &args)
            }
        }
    }
    
    
    /* Methods */
    
    static var method_is_null: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_null")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the signal's name does not exist in its object, or the object is not valid.
    public final func isNull ()-> Bool {
        var result: Bool = Bool()
        Signal.method_is_null (&content, nil, &result, 0)
        return result
    }
    
    static var method_get_object_id: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_object_id")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 3173160232)!
    }()
    
    /// Returns the ID of the object emitting this signal (see ``Object/getInstanceId()``).
    public final func getObjectId ()-> Int64 {
        var result: Int64 = Int64()
        Signal.method_get_object_id (&content, nil, &result, 0)
        return result
    }
    
    static var method_get_name: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_name")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 1825232092)!
    }()
    
    /// Returns the name of this signal.
    public final func getName ()-> StringName {
        let result: StringName = StringName()
        Signal.method_get_name (&content, nil, &result.content, 0)
        return result
    }
    
    static var method_connect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("connect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 979702392)!
    }()
    
    /// Connects this signal to the specified `callable`. Optional `flags` can be also added to configure the connection's behavior (see ``Object.ConnectFlags`` constants). You can provide additional arguments to the connected `callable` by using ``Callable/bind()``.
    /// 
    /// A signal can only be connected once to the same ``Callable``. If the signal is already connected, returns ``GodotError/errInvalidParameter`` and pushes an error message, unless the signal is connected with ``Object/ConnectFlags/connectReferenceCounted``. To prevent this, use ``isConnected(callable:)`` first to check for existing connections.
    /// 
    public final func connect (callable: Callable, flags: Int64 = 0)-> Int64 {
        var result: Int64 = Int64()
        var copy_flags = flags
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &callable.content) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_flags) { p1 in
                args.append (p1)
        
                Signal.method_connect (&content, &args, &result, 2)
                return result
            }
        }
    }
    
    static var method_disconnect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("disconnect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 3470848906)!
    }()
    
    /// Disconnects this signal from the specified ``Callable``. If the connection does not exist, generates an error. Use ``isConnected(callable:)`` to make sure that the connection exists.
    public final func disconnect (callable: Callable) {
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &callable.content) { p0 in
            args.append (p0)
        
            Signal.method_disconnect (&content, &args, nil, 1)
        }
    }
    
    static var method_is_connected: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_connected")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 4129521963)!
    }()
    
    /// Returns `true` if the specified ``Callable`` is connected to this signal.
    public final func isConnected (callable: Callable)-> Bool {
        var result: Bool = Bool()
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &callable.content) { p0 in
            args.append (p0)
        
            Signal.method_is_connected (&content, &args, &result, 1)
            return result
        }
    }
    
    static var method_get_connections: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_connections")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 4144163970)!
    }()
    
    /// Returns an ``GArray`` of connections for this signal. Each connection is represented as a ``GDictionary`` that contains three entries:
    /// 
    /// - `signal` is a reference to this signal;
    /// 
    /// - `callable` is a reference to the connected ``Callable``;
    /// 
    /// - `flags` is a combination of ``Object.ConnectFlags``.
    /// 
    public final func getConnections ()-> GArray {
        let result: GArray = GArray()
        Signal.method_get_connections (&content, nil, &result.content, 0)
        return result
    }
    
    static var method_emit: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("emit")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_SIGNAL, &name.content, 3286317445)!
    }()
    
    /// Emits this signal. All ``Callable``s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list.
    public final func emit () {
        Signal.method_emit (&content, nil, nil, 0)
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_SIGNAL, GDEXTENSION_VARIANT_TYPE_SIGNAL)!
    }()
    
    /// Returns `true` if both signals share the same object and name.
    public static func == (lhs: Signal, rhs: Signal) -> Bool  {
        var result: Bool = Bool()
        
        Signal.operator_3 (&lhs.content, &rhs.content, &result)
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_SIGNAL, GDEXTENSION_VARIANT_TYPE_SIGNAL)!
    }()
    
    /// Returns `true` if the signals do not share the same object and name.
    public static func != (lhs: Signal, rhs: Signal) -> Bool  {
        var result: Bool = Bool()
        
        Signal.operator_4 (&lhs.content, &rhs.content, &result)
        return result
    }
    
}

