// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A unit quaternion used for representing 3D rotations.
/// 
/// Quaternions are similar to ``Basis``, which implements the matrix representation of rotations. Unlike ``Basis``, which stores rotation, scale, and shearing, quaternions only store rotation.
/// 
/// Quaternions can be parametrized using both an axis-angle pair or Euler angles. Due to their compactness and the way they are stored in memory, certain operations (obtaining axis-angle and performing SLERP, in particular) are more efficient and robust against floating-point errors.
/// 
/// > Note: Quaternions need to be normalized before being used for rotation.
/// 
public struct Quaternion: Equatable, Hashable {
    /// X component of the quaternion (imaginary `i` axis part).
    /// 
    /// Quaternion components should usually not be manipulated directly.
    /// 
    public var x: Float
    /// Y component of the quaternion (imaginary `j` axis part).
    /// 
    /// Quaternion components should usually not be manipulated directly.
    /// 
    public var y: Float
    /// Z component of the quaternion (imaginary `k` axis part).
    /// 
    /// Quaternion components should usually not be manipulated directly.
    /// 
    public var z: Float
    /// W component of the quaternion (real part).
    /// 
    /// Quaternion components should usually not be manipulated directly.
    /// 
    public var w: Float
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_QUATERNION, 0)!
    
    /// Constructs a default-initialized quaternion with all components set to `0`.
    public init () {
        self.x = 0
        self.y = 0
        self.z = 0
        self.w = 1
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_QUATERNION, 1)!
    
    /// Constructs a ``Quaternion`` as a copy of the given ``Quaternion``.
    public init (from: Quaternion) {
        self.x = Float ()
        self.y = Float ()
        self.z = Float ()
        self.w = Float ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Quaternion.constructor1 (&self, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_QUATERNION, 2)!
    
    /// Constructs a quaternion from the given ``Basis``.
    public init (from: Basis) {
        self.x = Float ()
        self.y = Float ()
        self.z = Float ()
        self.w = Float ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Quaternion.constructor2 (&self, &args)
        }
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_QUATERNION, 3)!
    
    /// Constructs a quaternion that will rotate around the given axis by the specified angle. The axis must be a normalized vector.
    public init (axis: Vector3, angle: Float) {
        self.x = Float ()
        self.y = Float ()
        self.z = Float ()
        self.w = Float ()
        var copy_axis = axis
        var copy_angle = Double (angle)
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_axis) { p0 in
            args.append (p0)
            withUnsafePointer (to: &copy_angle) { p1 in
                args.append (p1)
        
                Quaternion.constructor3 (&self, &args)
            }
        }
    }
    
    static var constructor4: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_QUATERNION, 4)!
    
    /// Constructs a quaternion representing the shortest arc between two points on the surface of a sphere with a radius of `1.0`.
    public init (arcFrom: Vector3, arcTo: Vector3) {
        self.x = Float ()
        self.y = Float ()
        self.z = Float ()
        self.w = Float ()
        var copy_arc_from = arcFrom
        var copy_arc_to = arcTo
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arc_from) { p0 in
            args.append (p0)
            withUnsafePointer (to: &copy_arc_to) { p1 in
                args.append (p1)
        
                Quaternion.constructor4 (&self, &args)
            }
        }
    }
    
    static var constructor5: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_QUATERNION, 5)!
    
    /// Constructs a quaternion defined by the given values.
    public init (x: Float, y: Float, z: Float, w: Float) {
        self.x = x
        self.y = y
        self.z = z
        self.w = w
    }
    
    
    /* Methods */
    
    static var method_length: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("length")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 466405837)!
    }()
    
    /// Returns the length of the quaternion.
    public func length ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_length (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_length_squared: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("length_squared")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 466405837)!
    }()
    
    /// Returns the length of the quaternion, squared.
    public func lengthSquared ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_length_squared (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_normalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("normalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 4274879941)!
    }()
    
    /// Returns a copy of the quaternion, normalized to unit length.
    public func normalized ()-> Quaternion {
        var result: Quaternion = Quaternion()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_normalized (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_is_normalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_normalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 3918633141)!
    }()
    
    /// Returns whether the quaternion is normalized or not.
    public func isNormalized ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_is_normalized (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 1682156903)!
    }()
    
    /// Returns `true` if this quaternion and `to` are approximately equal, by running ``@GlobalScope.is_equal_approx`` on each component.
    public func isEqualApprox (to: Quaternion)-> Bool {
        var result: Bool = Bool()
        var copy_to = to
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Quaternion.method_is_equal_approx (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this quaternion is finite, by calling ``@GlobalScope.is_finite`` on each component.
    public func isFinite ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_is_finite (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 4274879941)!
    }()
    
    /// Returns the inverse of the quaternion.
    public func inverse ()-> Quaternion {
        var result: Quaternion = Quaternion()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_inverse (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_log: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("log")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 4274879941)!
    }()
    
    /// 
    public func log ()-> Quaternion {
        var result: Quaternion = Quaternion()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_log (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_exp: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("exp")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 4274879941)!
    }()
    
    /// 
    public func exp ()-> Quaternion {
        var result: Quaternion = Quaternion()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_exp (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_angle_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("angle_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 3244682419)!
    }()
    
    /// Returns the angle between this quaternion and `to`. This is the magnitude of the angle you would need to rotate by to get from one to the other.
    /// 
    /// > Note: The magnitude of the floating-point error for this method is abnormally high, so methods such as `is_zero_approx` will not work reliably.
    /// 
    public func angleTo (_ to: Quaternion)-> Double {
        var result: Double = Double()
        var copy_to = to
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Quaternion.method_angle_to (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_dot: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("dot")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 3244682419)!
    }()
    
    /// Returns the dot product of two quaternions.
    public func dot (with: Quaternion)-> Double {
        var result: Double = Double()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Quaternion.method_dot (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_slerp: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slerp")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 1773590316)!
    }()
    
    /// Returns the result of the spherical linear interpolation between this quaternion and `to` by amount `weight`.
    /// 
    /// > Note: Both quaternions must be normalized.
    /// 
    public func slerp (to: Quaternion, weight: Double)-> Quaternion {
        var result: Quaternion = Quaternion()
        var copy_to = to
        var copy_weight = Double (weight)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_weight) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Quaternion.method_slerp (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_slerpni: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slerpni")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 1773590316)!
    }()
    
    /// Returns the result of the spherical linear interpolation between this quaternion and `to` by amount `weight`, but without checking if the rotation path is not bigger than 90 degrees.
    public func slerpni (to: Quaternion, weight: Double)-> Quaternion {
        var result: Quaternion = Quaternion()
        var copy_to = to
        var copy_weight = Double (weight)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_weight) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Quaternion.method_slerpni (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_spherical_cubic_interpolate: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("spherical_cubic_interpolate")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 2150967576)!
    }()
    
    /// Performs a spherical cubic interpolation between quaternions `preA`, this vector, `b`, and `postB`, by the given amount `weight`.
    public func sphericalCubicInterpolate (b: Quaternion, preA: Quaternion, postB: Quaternion, weight: Double)-> Quaternion {
        var result: Quaternion = Quaternion()
        var copy_b = b
        var copy_pre_a = preA
        var copy_post_b = postB
        var copy_weight = Double (weight)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_b) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_pre_a) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_post_b) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_weight) { p3 in
                        args.append (p3)
        
                        withUnsafePointer (to: self) { ptr in 
                            Quaternion.method_spherical_cubic_interpolate (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 4)
                        }
                        return result
                    }
                }
            }
        }
    }
    
    static var method_spherical_cubic_interpolate_in_time: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("spherical_cubic_interpolate_in_time")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 1436023539)!
    }()
    
    /// Performs a spherical cubic interpolation between quaternions `preA`, this vector, `b`, and `postB`, by the given amount `weight`.
    /// 
    /// It can perform smoother interpolation than ``sphericalCubicInterpolate(b:preA:postB:weight:)`` by the time values.
    /// 
    public func sphericalCubicInterpolateInTime (b: Quaternion, preA: Quaternion, postB: Quaternion, weight: Double, bT: Double, preAT: Double, postBT: Double)-> Quaternion {
        var result: Quaternion = Quaternion()
        var copy_b = b
        var copy_pre_a = preA
        var copy_post_b = postB
        var copy_weight = Double (weight)
        var copy_b_t = Double (bT)
        var copy_pre_a_t = Double (preAT)
        var copy_post_b_t = Double (postBT)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_b) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_pre_a) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_post_b) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_weight) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_b_t) { p4 in
                            args.append (p4)
                            return withUnsafePointer (to: &copy_pre_a_t) { p5 in
                                args.append (p5)
                                return withUnsafePointer (to: &copy_post_b_t) { p6 in
                                    args.append (p6)
        
                                    withUnsafePointer (to: self) { ptr in 
                                        Quaternion.method_spherical_cubic_interpolate_in_time (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 7)
                                    }
                                    return result
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    static var method_get_euler: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_euler")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 1394941017)!
    }()
    
    /// Returns the quaternion's rotation in the form of Euler angles. The Euler order depends on the `order` parameter, for example using the YXZ convention: since this method decomposes, first Z, then X, and Y last. See the ``EulerOrder`` enum for possible values. The returned vector contains the rotation angles in the format (X angle, Y angle, Z angle).
    public func getEuler (order: Int64 = 2)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_order = order
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_order) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Quaternion.method_get_euler (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_from_euler: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("from_euler")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 4053467903)!
    }()
    
    /// Constructs a Quaternion from Euler angles in YXZ rotation order.
    public static func fromEuler (_ euler: Vector3)-> Quaternion {
        var result: Quaternion = Quaternion()
        var copy_euler = euler
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_euler) { p0 in
            args.append (p0)
        
            Quaternion.method_from_euler (nil, &args, &result, 1)
            return result
        }
    }
    
    static var method_get_axis: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_axis")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 1776574132)!
    }()
    
    /// 
    public func getAxis ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_get_axis (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_angle: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_angle")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_QUATERNION, &name.content, 466405837)!
    }()
    
    /// 
    public func getAngle ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Quaternion.method_get_angle (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_QUATERNION)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_QUATERNION)!
    }()
    
     public subscript (index: Int64) -> Double {
        mutating get {
            var result = Double ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// Multiplies each component of the ``Quaternion`` by the given value. This operation is not meaningful on its own, but it can be used as a part of a larger expression.
    public static func * (lhs: Quaternion, rhs: Int64) -> Quaternion  {
        var result: Quaternion = Quaternion()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Quaternion.operator_5 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// Divides each component of the ``Quaternion`` by the given value. This operation is not meaningful on its own, but it can be used as a part of a larger expression.
    public static func / (lhs: Quaternion, rhs: Int64) -> Quaternion  {
        var result: Quaternion = Quaternion()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Quaternion.operator_6 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// Multiplies each component of the ``Quaternion`` by the given value. This operation is not meaningful on its own, but it can be used as a part of a larger expression.
    public static func * (lhs: Quaternion, rhs: Double) -> Quaternion  {
        var result: Quaternion = Quaternion()
        var copy_lhs = lhs
        var copy_rhs = Double (rhs)
        
        Quaternion.operator_7 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_8: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// Divides each component of the ``Quaternion`` by the given value. This operation is not meaningful on its own, but it can be used as a part of a larger expression.
    public static func / (lhs: Quaternion, rhs: Double) -> Quaternion  {
        var result: Quaternion = Quaternion()
        var copy_lhs = lhs
        var copy_rhs = Double (rhs)
        
        Quaternion.operator_8 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_9: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Multiplies each component of the ``Quaternion`` by the given value. This operation is not meaningful on its own, but it can be used as a part of a larger expression.
    public static func * (lhs: Quaternion, rhs: Vector3) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Quaternion.operator_9 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_10: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_QUATERNION)!
    }()
    
    /// Returns `true` if the quaternions are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(to:)`` instead, which is more reliable.
    /// 
    public static func == (lhs: Quaternion, rhs: Quaternion) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Quaternion.operator_10 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_11: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_QUATERNION)!
    }()
    
    /// Returns `true` if the quaternions are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(to:)`` instead, which is more reliable.
    /// 
    public static func != (lhs: Quaternion, rhs: Quaternion) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Quaternion.operator_11 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_12: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_ADD, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_QUATERNION)!
    }()
    
    /// Adds each component of the left ``Quaternion`` to the right ``Quaternion``. This operation is not meaningful on its own, but it can be used as a part of a larger expression, such as approximating an intermediate rotation between two nearby rotations.
    public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion  {
        var result: Quaternion = Quaternion()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Quaternion.operator_12 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_13: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_SUBTRACT, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_QUATERNION)!
    }()
    
    /// Subtracts each component of the left ``Quaternion`` by the right ``Quaternion``. This operation is not meaningful on its own, but it can be used as a part of a larger expression.
    public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion  {
        var result: Quaternion = Quaternion()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Quaternion.operator_13 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_14: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_QUATERNION, GDEXTENSION_VARIANT_TYPE_QUATERNION)!
    }()
    
    /// Multiplies each component of the ``Quaternion`` by the given value. This operation is not meaningful on its own, but it can be used as a part of a larger expression.
    public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion  {
        var result: Quaternion = Quaternion()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Quaternion.operator_14 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    /// The identity quaternion, representing no rotation. Equivalent to an identity ``Basis`` matrix. If a vector is transformed by an identity quaternion, it will not change.
    public static let identity = Quaternion (x: 0, y: 0, z: 0, w: 1)
}

