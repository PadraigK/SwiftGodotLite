// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A 3×4 matrix representing a 3D transformation.
/// 
/// A 3×4 matrix (3 rows, 4 columns) used for 3D linear transformations. It can represent transformations such as translation, rotation, and scaling. It consists of a ``basis`` (first 3 columns) and a ``Vector3`` for the ``origin`` (last column).
/// 
/// For more information, read the "Matrices and transforms" documentation article.
/// 
public struct Transform3D: Equatable, Hashable {
    /// The basis is a matrix containing 3 ``Vector3`` as its columns: X axis, Y axis, and Z axis. These vectors can be interpreted as the basis vectors of local coordinate system traveling with the object.
    public var basis: Basis
    /// The translation offset of the transform (column 3, the fourth column). Equivalent to array index `3`.
    public var origin: Vector3
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, 0)!
    
    /// Constructs a default-initialized ``Transform3D`` set to ``IDENTITY``.
    public init () {
        self.basis = Basis ()
        self.origin = Vector3 ()
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, 1)!
    
    /// Constructs a ``Transform3D`` as a copy of the given ``Transform3D``.
    public init (from: Transform3D) {
        self.basis = Basis ()
        self.origin = Vector3 ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Transform3D.constructor1 (&self, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, 2)!
    
    /// Constructs a Transform3D from a ``Basis`` and ``Vector3``.
    public init (basis: Basis, origin: Vector3) {
        self.basis = basis
        self.origin = origin
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, 3)!
    
    /// Constructs a Transform3D from four ``Vector3`` values (matrix columns). Each axis corresponds to local basis vectors (some of which may be scaled).
    public init (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3, origin: Vector3) {
        self.basis = Basis ()
        self.origin = Vector3 ()
        var copy_x_axis = xAxis
        var copy_y_axis = yAxis
        var copy_z_axis = zAxis
        var copy_origin = origin
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_x_axis) { p0 in
            args.append (p0)
            withUnsafePointer (to: &copy_y_axis) { p1 in
                args.append (p1)
                withUnsafePointer (to: &copy_z_axis) { p2 in
                    args.append (p2)
                    withUnsafePointer (to: &copy_origin) { p3 in
                        args.append (p3)
        
                        Transform3D.constructor3 (&self, &args)
                    }
                }
            }
        }
    }
    
    static var constructor4: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, 4)!
    
    /// Constructs a Transform3D from a ``Projection`` by trimming the last row of the projection matrix (`from.x.w`, `from.y.w`, `from.z.w`, and `from.w.w` are not copied over).
    public init (from: Projection) {
        self.basis = Basis ()
        self.origin = Vector3 ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Transform3D.constructor4 (&self, &args)
        }
    }
    
    
    /* Methods */
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 3816817146)!
    }()
    
    /// Returns the inverse of the transform, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not). Use ``affineInverse()`` for non-orthonormal transforms (e.g. with scaling).
    public func inverse ()-> Transform3D {
        var result: Transform3D = Transform3D()
        withUnsafePointer (to: self) { ptr in 
            Transform3D.method_inverse (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_affine_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("affine_inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 3816817146)!
    }()
    
    /// Returns the inverse of the transform, under the assumption that the basis is invertible (must have non-zero determinant).
    public func affineInverse ()-> Transform3D {
        var result: Transform3D = Transform3D()
        withUnsafePointer (to: self) { ptr in 
            Transform3D.method_affine_inverse (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_orthonormalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("orthonormalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 3816817146)!
    }()
    
    /// Returns the transform with the basis orthogonal (90 degrees), and normalized axis vectors (scale of 1 or -1).
    public func orthonormalized ()-> Transform3D {
        var result: Transform3D = Transform3D()
        withUnsafePointer (to: self) { ptr in 
            Transform3D.method_orthonormalized (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_rotated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 1563203923)!
    }()
    
    /// Returns a copy of the transform rotated around the given `axis` by the given `angle` (in radians).
    /// 
    /// The `axis` must be a normalized vector.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding rotation transform `R` from the left, i.e., `R * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func rotated (axis: Vector3, angle: Double)-> Transform3D {
        var result: Transform3D = Transform3D()
        var copy_axis = axis
        var copy_angle = Double (angle)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_axis) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_angle) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Transform3D.method_rotated (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_rotated_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 1563203923)!
    }()
    
    /// Returns a copy of the transform rotated around the given `axis` by the given `angle` (in radians).
    /// 
    /// The `axis` must be a normalized vector.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding rotation transform `R` from the right, i.e., `X * R`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func rotatedLocal (axis: Vector3, angle: Double)-> Transform3D {
        var result: Transform3D = Transform3D()
        var copy_axis = axis
        var copy_angle = Double (angle)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_axis) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_angle) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Transform3D.method_rotated_local (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_scaled: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("scaled")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 1405596198)!
    }()
    
    /// Returns a copy of the transform scaled by the given `scale` factor.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding scaling transform `S` from the left, i.e., `S * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func scaled (scale: Vector3)-> Transform3D {
        var result: Transform3D = Transform3D()
        var copy_scale = scale
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_scale) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform3D.method_scaled (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_scaled_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("scaled_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 1405596198)!
    }()
    
    /// Returns a copy of the transform scaled by the given `scale` factor.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding scaling transform `S` from the right, i.e., `X * S`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func scaledLocal (scale: Vector3)-> Transform3D {
        var result: Transform3D = Transform3D()
        var copy_scale = scale
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_scale) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform3D.method_scaled_local (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_translated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("translated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 1405596198)!
    }()
    
    /// Returns a copy of the transform translated by the given `offset`.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding translation transform `T` from the left, i.e., `T * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func translated (offset: Vector3)-> Transform3D {
        var result: Transform3D = Transform3D()
        var copy_offset = offset
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_offset) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform3D.method_translated (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_translated_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("translated_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 1405596198)!
    }()
    
    /// Returns a copy of the transform translated by the given `offset`.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding translation transform `T` from the right, i.e., `X * T`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func translatedLocal (offset: Vector3)-> Transform3D {
        var result: Transform3D = Transform3D()
        var copy_offset = offset
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_offset) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform3D.method_translated_local (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_looking_at: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("looking_at")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 90889270)!
    }()
    
    /// Returns a copy of the transform rotated such that the forward axis (-Z) points towards the `target` position.
    /// 
    /// The up axis (+Y) points as close to the `up` vector as possible while staying perpendicular to the forward axis. The resulting transform is orthonormalized. The existing rotation, scale, and skew information from the original transform is discarded. The `target` and `up` vectors cannot be zero, cannot be parallel to each other, and are defined in global/parent space.
    /// 
    /// If `useModelFront` is `true`, the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the `target` position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).
    /// 
    public func lookingAt (target: Vector3, up: Vector3 = Vector3 (x: 0, y: 1, z: 0), useModelFront: Bool = false)-> Transform3D {
        var result: Transform3D = Transform3D()
        var copy_target = target
        var copy_up = up
        var copy_use_model_front = useModelFront
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_target) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_up) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_use_model_front) { p2 in
                    args.append (p2)
        
                    withUnsafePointer (to: self) { ptr in 
                        Transform3D.method_looking_at (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 3)
                    }
                    return result
                }
            }
        }
    }
    
    static var method_interpolate_with: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("interpolate_with")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 1786453358)!
    }()
    
    /// Returns a transform interpolated between this transform and another by a given `weight` (on the range of 0.0 to 1.0).
    public func interpolateWith (xform: Transform3D, weight: Double)-> Transform3D {
        var result: Transform3D = Transform3D()
        var copy_xform = xform
        var copy_weight = Double (weight)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_xform) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_weight) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Transform3D.method_interpolate_with (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 696001652)!
    }()
    
    /// Returns `true` if this transform and `xform` are approximately equal, by running ``@GlobalScope.is_equal_approx`` on each component.
    public func isEqualApprox (xform: Transform3D)-> Bool {
        var result: Bool = Bool()
        var copy_xform = xform
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_xform) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform3D.method_is_equal_approx (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this transform is finite, by calling ``@GlobalScope.is_finite`` on each component.
    public func isFinite ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Transform3D.method_is_finite (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// This operator multiplies all components of the ``Transform3D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform3D, rhs: Int64) -> Transform3D  {
        var result: Transform3D = Transform3D()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform3D.operator_3 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// This operator multiplies all components of the ``Transform3D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform3D, rhs: Double) -> Transform3D  {
        var result: Transform3D = Transform3D()
        var copy_lhs = lhs
        var copy_rhs = Double (rhs)
        
        Transform3D.operator_4 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// This operator multiplies all components of the ``Transform3D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform3D, rhs: Vector3) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform3D.operator_5 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_PLANE)!
    }()
    
    /// This operator multiplies all components of the ``Transform3D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform3D, rhs: Plane) -> Plane  {
        var result: Plane = Plane()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform3D.operator_6 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_AABB)!
    }()
    
    /// This operator multiplies all components of the ``Transform3D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform3D, rhs: AABB) -> AABB  {
        var result: AABB = AABB()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform3D.operator_7 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_8: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D)!
    }()
    
    /// Returns `true` if the transforms are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(xform:)`` instead, which is more reliable.
    /// 
    public static func == (lhs: Transform3D, rhs: Transform3D) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform3D.operator_8 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_9: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D)!
    }()
    
    /// Returns `true` if the transforms are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(xform:)`` instead, which is more reliable.
    /// 
    public static func != (lhs: Transform3D, rhs: Transform3D) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform3D.operator_9 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_10: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D)!
    }()
    
    /// This operator multiplies all components of the ``Transform3D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform3D, rhs: Transform3D) -> Transform3D  {
        var result: Transform3D = Transform3D()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform3D.operator_10 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_13: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR3_ARRAY)!
    }()
    
    /// This operator multiplies all components of the ``Transform3D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform3D, rhs: PackedVector3Array) -> PackedVector3Array  {
        let result: PackedVector3Array = PackedVector3Array()
        var copy_lhs = lhs
        
        Transform3D.operator_13 (&copy_lhs, &rhs.content, &result.content)
        return result
    }
    
    /// ``Transform3D`` with no translation, rotation or scaling applied. When applied to other data structures, ``IDENTITY`` performs no transformation.
    public static let identity = Transform3D (basis: Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1)), origin: Vector3(x: 0, y: 0, z: 0))
    /// ``Transform3D`` with mirroring applied perpendicular to the YZ plane.
    public static let flipX = Transform3D (basis: Basis (xAxis: Vector3 (x: -1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1)), origin: Vector3(x: 0, y: 0, z: 0))
    /// ``Transform3D`` with mirroring applied perpendicular to the XZ plane.
    public static let flipY = Transform3D (basis: Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: -1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1)), origin: Vector3(x: 0, y: 0, z: 0))
    /// ``Transform3D`` with mirroring applied perpendicular to the XY plane.
    public static let flipZ = Transform3D (basis: Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: -1)), origin: Vector3(x: 0, y: 0, z: 0))
}

