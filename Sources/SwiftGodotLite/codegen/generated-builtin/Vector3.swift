// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A 3D vector using floating point coordinates.
/// 
/// A 3-element structure that can be used to represent 3D coordinates or any other triplet of numeric values.
/// 
/// It uses floating-point coordinates. By default, these floating-point values use 32-bit precision, unlike float which is always 64-bit. If double precision is needed, compile the engine with the option `precision=double`.
/// 
/// See ``Vector3i`` for its integer counterpart.
/// 
/// > Note: In a boolean context, a Vector3 will evaluate to `false` if it's equal to `Vector3(0, 0, 0)`. Otherwise, a Vector3 will always evaluate to `true`.
/// 
public struct Vector3: Equatable, Hashable {
    /// The vector's X component. Also accessible by using the index position `[0]`.
    public var x: Float
    /// The vector's Y component. Also accessible by using the index position `[1]`.
    public var y: Float
    /// The vector's Z component. Also accessible by using the index position `[2]`.
    public var z: Float
    public enum Axis: Int64 {
        /// Enumerated value for the X axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
        case x = 0 // AXIS_X
        /// Enumerated value for the Y axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
        case y = 1 // AXIS_Y
        /// Enumerated value for the Z axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
        case z = 2 // AXIS_Z
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_VECTOR3, 0)!
    
    /// Constructs a default-initialized ``Vector3`` with all components set to `0`.
    public init () {
        self.x = Float ()
        self.y = Float ()
        self.z = Float ()
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_VECTOR3, 1)!
    
    /// Constructs a ``Vector3`` as a copy of the given ``Vector3``.
    public init (from: Vector3) {
        self.x = Float ()
        self.y = Float ()
        self.z = Float ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Vector3.constructor1 (&self, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_VECTOR3, 2)!
    
    /// Constructs a new ``Vector3`` from ``Vector3i``.
    public init (from: Vector3i) {
        self.x = Float ()
        self.y = Float ()
        self.z = Float ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Vector3.constructor2 (&self, &args)
        }
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_VECTOR3, 3)!
    
    /// Returns a ``Vector3`` with the given components.
    public init (x: Float, y: Float, z: Float) {
        self.x = x
        self.y = y
        self.z = z
    }
    
    
    /* Methods */
    
    static var method_min_axis_index: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("min_axis_index")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 3173160232)!
    }()
    
    /// Returns the axis of the vector's lowest value. See `AXIS_*` constants. If all components are equal, this method returns .z.
    public func minAxisIndex ()-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_min_axis_index (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_max_axis_index: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("max_axis_index")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 3173160232)!
    }()
    
    /// Returns the axis of the vector's highest value. See `AXIS_*` constants. If all components are equal, this method returns .x.
    public func maxAxisIndex ()-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_max_axis_index (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_angle_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("angle_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1047977935)!
    }()
    
    /// Returns the unsigned minimum angle to the given vector, in radians.
    public func angleTo (_ to: Vector3)-> Double {
        var result: Double = Double()
        var copy_to = to
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_angle_to (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_signed_angle_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("signed_angle_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2781412522)!
    }()
    
    /// Returns the signed angle to the given vector, in radians. The sign of the angle is positive in a counter-clockwise direction and negative in a clockwise direction when viewed from the side specified by the `axis`.
    public func signedAngleTo (_ to: Vector3, axis: Vector3)-> Double {
        var result: Double = Double()
        var copy_to = to
        var copy_axis = axis
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_axis) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Vector3.method_signed_angle_to (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_direction_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("direction_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2923479887)!
    }()
    
    /// Returns the normalized vector pointing from this vector to `to`. This is equivalent to using `(b - a).normalized()`.
    public func directionTo (_ to: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_to = to
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_direction_to (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_distance_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("distance_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1047977935)!
    }()
    
    /// Returns the distance between this vector and `to`.
    public func distanceTo (_ to: Vector3)-> Double {
        var result: Double = Double()
        var copy_to = to
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_distance_to (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_distance_squared_to: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("distance_squared_to")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1047977935)!
    }()
    
    /// Returns the squared distance between this vector and `to`.
    /// 
    /// This method runs faster than ``distanceTo(to:)``, so prefer it if you need to compare vectors or need the squared distance for some formula.
    /// 
    public func distanceSquaredTo (_ to: Vector3)-> Double {
        var result: Double = Double()
        var copy_to = to
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_distance_squared_to (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_length: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("length")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 466405837)!
    }()
    
    /// Returns the length (magnitude) of this vector.
    public func length ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_length (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_length_squared: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("length_squared")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 466405837)!
    }()
    
    /// Returns the squared length (squared magnitude) of this vector.
    /// 
    /// This method runs faster than ``length()``, so prefer it if you need to compare vectors or need the squared distance for some formula.
    /// 
    public func lengthSquared ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_length_squared (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_limit_length: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("limit_length")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 514930144)!
    }()
    
    /// Returns the vector with a maximum length by limiting its length to `length`.
    public func limitLength (_ length: Double = 1.0)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_length = Double (length)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_length) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_limit_length (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_normalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("normalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1776574132)!
    }()
    
    /// Returns the result of scaling the vector to unit length. Equivalent to `v / v.length()`. See also ``isNormalized()``.
    /// 
    /// > Note: This function may return incorrect values if the input vector length is near zero.
    /// 
    public func normalized ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_normalized (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_is_normalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_normalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the vector is normalized, i.e. its length is approximately equal to 1.
    public func isNormalized ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_is_normalized (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1749054343)!
    }()
    
    /// Returns `true` if this vector and `to` are approximately equal, by running ``@GlobalScope.is_equal_approx`` on each component.
    public func isEqualApprox (to: Vector3)-> Bool {
        var result: Bool = Bool()
        var copy_to = to
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_is_equal_approx (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_is_zero_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_zero_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this vector's values are approximately zero, by running ``@GlobalScope.is_zero_approx`` on each component.
    /// 
    /// This method is faster than using ``isEqualApprox(to:)`` with one value as a zero vector.
    /// 
    public func isZeroApprox ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_is_zero_approx (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this vector is finite, by calling ``@GlobalScope.is_finite`` on each component.
    public func isFinite ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_is_finite (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1776574132)!
    }()
    
    /// Returns the inverse of the vector. This is the same as `Vector3(1.0 / v.x, 1.0 / v.y, 1.0 / v.z)`.
    public func inverse ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_inverse (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_clamp: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("clamp")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 4145107892)!
    }()
    
    /// Returns a new vector with all components clamped between the components of `min` and `max`, by running ``@GlobalScope.clamp`` on each component.
    public func clamp (min: Vector3, max: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_min = min
        var copy_max = max
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_min) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_max) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Vector3.method_clamp (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_rotated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1682608829)!
    }()
    
    /// Returns the result of rotating this vector around a given axis by `angle` (in radians). The axis must be a normalized vector. See also ``@GlobalScope.deg_to_rad``.
    public func rotated (axis: Vector3, angle: Double)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_axis = axis
        var copy_angle = Double (angle)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_axis) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_angle) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Vector3.method_rotated (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_slerp: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slerp")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1682608829)!
    }()
    
    /// Returns the result of spherical linear interpolation between this vector and `to`, by amount `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.
    /// 
    /// This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like ``lerp(to:weight:)``.
    /// 
    public func slerp (to: Vector3, weight: Double)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_to = to
        var copy_weight = Double (weight)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_weight) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Vector3.method_slerp (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_cubic_interpolate: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("cubic_interpolate")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2597922253)!
    }()
    
    /// Performs a cubic interpolation between this vector and `b` using `preA` and `postB` as handles, and returns the result at position `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.
    public func cubicInterpolate (b: Vector3, preA: Vector3, postB: Vector3, weight: Double)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_b = b
        var copy_pre_a = preA
        var copy_post_b = postB
        var copy_weight = Double (weight)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_b) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_pre_a) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_post_b) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_weight) { p3 in
                        args.append (p3)
        
                        withUnsafePointer (to: self) { ptr in 
                            Vector3.method_cubic_interpolate (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 4)
                        }
                        return result
                    }
                }
            }
        }
    }
    
    static var method_cubic_interpolate_in_time: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("cubic_interpolate_in_time")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 3256682901)!
    }()
    
    /// Performs a cubic interpolation between this vector and `b` using `preA` and `postB` as handles, and returns the result at position `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.
    /// 
    /// It can perform smoother interpolation than ``cubicInterpolate(b:preA:postB:weight:)`` by the time values.
    /// 
    public func cubicInterpolateInTime (b: Vector3, preA: Vector3, postB: Vector3, weight: Double, bT: Double, preAT: Double, postBT: Double)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_b = b
        var copy_pre_a = preA
        var copy_post_b = postB
        var copy_weight = Double (weight)
        var copy_b_t = Double (bT)
        var copy_pre_a_t = Double (preAT)
        var copy_post_b_t = Double (postBT)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_b) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_pre_a) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_post_b) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_weight) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_b_t) { p4 in
                            args.append (p4)
                            return withUnsafePointer (to: &copy_pre_a_t) { p5 in
                                args.append (p5)
                                return withUnsafePointer (to: &copy_post_b_t) { p6 in
                                    args.append (p6)
        
                                    withUnsafePointer (to: self) { ptr in 
                                        Vector3.method_cubic_interpolate_in_time (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 7)
                                    }
                                    return result
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    static var method_bezier_interpolate: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("bezier_interpolate")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2597922253)!
    }()
    
    /// Returns the point at the given `t` on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given `control1`, `control2`, and `end` points.
    public func bezierInterpolate (control1: Vector3, control2: Vector3, end: Vector3, t: Double)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_control_1 = control1
        var copy_control_2 = control2
        var copy_end = end
        var copy_t = Double (t)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_control_1) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_control_2) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_end) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_t) { p3 in
                        args.append (p3)
        
                        withUnsafePointer (to: self) { ptr in 
                            Vector3.method_bezier_interpolate (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 4)
                        }
                        return result
                    }
                }
            }
        }
    }
    
    static var method_bezier_derivative: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("bezier_derivative")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2597922253)!
    }()
    
    /// Returns the derivative at the given `t` on the [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by this vector and the given `control1`, `control2`, and `end` points.
    public func bezierDerivative (control1: Vector3, control2: Vector3, end: Vector3, t: Double)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_control_1 = control1
        var copy_control_2 = control2
        var copy_end = end
        var copy_t = Double (t)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_control_1) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_control_2) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_end) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_t) { p3 in
                        args.append (p3)
        
                        withUnsafePointer (to: self) { ptr in 
                            Vector3.method_bezier_derivative (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 4)
                        }
                        return result
                    }
                }
            }
        }
    }
    
    static var method_move_toward: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("move_toward")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1682608829)!
    }()
    
    /// Returns a new vector moved toward `to` by the fixed `delta` amount. Will not go past the final value.
    public func moveToward (to: Vector3, delta: Double)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_to = to
        var copy_delta = Double (delta)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_delta) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Vector3.method_move_toward (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_dot: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("dot")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1047977935)!
    }()
    
    /// Returns the dot product of this vector and `with`. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.
    /// 
    /// The dot product will be `0` for a straight angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.
    /// 
    /// When using unit (normalized) vectors, the result will always be between `-1.0` (180 degree angle) when the vectors are facing opposite directions, and `1.0` (0 degree angle) when the vectors are aligned.
    /// 
    /// > Note: `a.dot(b)` is equivalent to `b.dot(a)`.
    /// 
    public func dot (with: Vector3)-> Double {
        var result: Double = Double()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_dot (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_cross: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("cross")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2923479887)!
    }()
    
    /// Returns the cross product of this vector and `with`.
    public func cross (with: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_cross (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_outer: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("outer")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 3934786792)!
    }()
    
    /// Returns the outer product with `with`.
    public func outer (with: Vector3)-> Basis {
        var result: Basis = Basis()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_outer (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_abs: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("abs")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1776574132)!
    }()
    
    /// Returns a new vector with all components in absolute values (i.e. positive).
    public func abs ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_abs (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_floor: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("floor")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1776574132)!
    }()
    
    /// Returns a new vector with all components rounded down (towards negative infinity).
    public func floor ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_floor (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_ceil: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("ceil")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1776574132)!
    }()
    
    /// Returns a new vector with all components rounded up (towards positive infinity).
    public func ceil ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_ceil (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_round: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("round")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1776574132)!
    }()
    
    /// Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero.
    public func round ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_round (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_posmod: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("posmod")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 514930144)!
    }()
    
    /// Returns a vector composed of the ``@GlobalScope.fposmod`` of this vector's components and `mod`.
    public func posmod (mod: Double)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_mod = Double (mod)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_mod) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_posmod (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_posmodv: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("posmodv")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2923479887)!
    }()
    
    /// Returns a vector composed of the ``@GlobalScope.fposmod`` of this vector's components and `modv`'s components.
    public func posmodv (modv: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_modv = modv
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_modv) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_posmodv (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_project: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("project")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2923479887)!
    }()
    
    /// Returns the result of projecting the vector onto the given vector `b`.
    public func project (b: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_b = b
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_b) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_project (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_slide: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slide")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2923479887)!
    }()
    
    /// Returns a new vector slid along a plane defined by the given normal.
    public func slide (n: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_n = n
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_n) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_slide (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_bounce: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("bounce")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2923479887)!
    }()
    
    /// Returns the vector "bounced off" from a plane defined by the given normal.
    public func bounce (n: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_n = n
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_n) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_bounce (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_reflect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("reflect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2923479887)!
    }()
    
    /// Returns the result of reflecting the vector from a plane defined by the given normal `n`.
    public func reflect (n: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_n = n
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_n) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Vector3.method_reflect (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_sign: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("sign")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 1776574132)!
    }()
    
    /// Returns a new vector with each component set to `1.0` if it's positive, `-1.0` if it's negative, and `0.0` if it's zero. The result is identical to calling ``@GlobalScope.sign`` on each component.
    public func sign ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_sign (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_octahedron_encode: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("octahedron_encode")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 2428350749)!
    }()
    
    /// Returns the octahedral-encoded (oct32) form of this ``Vector3`` as a ``Vector2``. Since a ``Vector2`` occupies 1/3 less memory compared to ``Vector3``, this form of compression can be used to pass greater amounts of ``normalized()`` ``Vector3``s without increasing storage or memory requirements. See also ``octahedronDecode(uv:)``.
    /// 
    /// > Note: ``octahedronEncode()`` can only be used for ``normalized()`` vectors. ``octahedronEncode()`` does _not_ check whether this ``Vector3`` is normalized, and will return a value that does not decompress to the original value if the ``Vector3`` is not normalized.
    /// 
    /// > Note: Octahedral compression is _lossy_, although visual differences are rarely perceptible in real world scenarios.
    /// 
    public func octahedronEncode ()-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer (to: self) { ptr in 
            Vector3.method_octahedron_encode (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_octahedron_decode: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("octahedron_decode")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_VECTOR3, &name.content, 3991820552)!
    }()
    
    /// Returns the ``Vector3`` from an octahedral-compressed form created using ``octahedronEncode()`` (stored as a ``Vector2``).
    public static func octahedronDecode (uv: Vector2)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_uv = uv
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_uv) { p0 in
            args.append (p0)
        
            Vector3.method_octahedron_decode (nil, &args, &result, 1)
            return result
        }
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
     public subscript (index: Int64) -> Double {
        mutating get {
            var result = Double ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// Multiplies each component of the ``Vector3`` by the given integer.
    public static func * (lhs: Vector3, rhs: Int64) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_5 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// Divides each component of the ``Vector3`` by the given integer.
    public static func / (lhs: Vector3, rhs: Int64) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_6 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// Multiplies each component of the ``Vector3`` by the given integer.
    public static func * (lhs: Vector3, rhs: Double) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = Double (rhs)
        
        Vector3.operator_7 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_8: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// Divides each component of the ``Vector3`` by the given integer.
    public static func / (lhs: Vector3, rhs: Double) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = Double (rhs)
        
        Vector3.operator_8 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_9: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Returns `true` if the vectors are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(to:)`` instead, which is more reliable.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func == (lhs: Vector3, rhs: Vector3) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_9 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_10: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Returns `true` if the vectors are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(to:)`` instead, which is more reliable.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func != (lhs: Vector3, rhs: Vector3) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_10 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_11: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_LESS_EQUAL, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Compares two ``Vector3`` vectors by first checking if the X value of the left vector is less than the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func < (lhs: Vector3, rhs: Vector3) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_11 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_12: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_LESS, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Compares two ``Vector3`` vectors by first checking if the X value of the left vector is less than or equal to the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func <= (lhs: Vector3, rhs: Vector3) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_12 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_13: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_GREATER, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Compares two ``Vector3`` vectors by first checking if the X value of the left vector is greater than the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func > (lhs: Vector3, rhs: Vector3) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_13 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_14: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_GREATER_EQUAL, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Compares two ``Vector3`` vectors by first checking if the X value of the left vector is greater than or equal to the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.
    /// 
    /// > Note: Vectors with ``@GDScript.NAN`` elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.
    /// 
    public static func >= (lhs: Vector3, rhs: Vector3) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_14 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_15: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_ADD, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Adds each component of the ``Vector3`` by the components of the given ``Vector3``.
    /// 
    public static func + (lhs: Vector3, rhs: Vector3) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_15 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_16: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_SUBTRACT, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Subtracts each component of the ``Vector3`` by the components of the given ``Vector3``.
    /// 
    public static func - (lhs: Vector3, rhs: Vector3) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_16 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_17: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Multiplies each component of the ``Vector3`` by the given integer.
    public static func * (lhs: Vector3, rhs: Vector3) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_17 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_18: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_DIVIDE, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// Divides each component of the ``Vector3`` by the given integer.
    public static func / (lhs: Vector3, rhs: Vector3) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_18 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_19: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_QUATERNION)!
    }()
    
    /// Multiplies each component of the ``Vector3`` by the given integer.
    public static func * (lhs: Vector3, rhs: Quaternion) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_19 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_20: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    /// Multiplies each component of the ``Vector3`` by the given integer.
    public static func * (lhs: Vector3, rhs: Basis) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_20 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_21: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_VECTOR3, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D)!
    }()
    
    /// Multiplies each component of the ``Vector3`` by the given integer.
    public static func * (lhs: Vector3, rhs: Transform3D) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Vector3.operator_21 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    /// Enumerated value for the X axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
    public static let axisX = 0
    /// Enumerated value for the Y axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
    public static let axisY = 1
    /// Enumerated value for the Z axis. Returned by ``maxAxisIndex()`` and ``minAxisIndex()``.
    public static let axisZ = 2
    /// Zero vector, a vector with all components set to `0`.
    public static let zero = Vector3 (x: 0, y: 0, z: 0)
    /// One vector, a vector with all components set to `1`.
    public static let one = Vector3 (x: 1, y: 1, z: 1)
    /// Infinity vector, a vector with all components set to ``@GDScript.INF``.
    public static let inf = Vector3 (x: Float.infinity, y: Float.infinity, z: Float.infinity)
    /// Left unit vector. Represents the local direction of left, and the global direction of west.
    public static let left = Vector3 (x: -1, y: 0, z: 0)
    /// Right unit vector. Represents the local direction of right, and the global direction of east.
    public static let right = Vector3 (x: 1, y: 0, z: 0)
    /// Up unit vector.
    public static let up = Vector3 (x: 0, y: 1, z: 0)
    /// Down unit vector.
    public static let down = Vector3 (x: 0, y: -1, z: 0)
    /// Forward unit vector. Represents the local direction of forward, and the global direction of north. Keep in mind that the forward direction for lights, cameras, etc is different from 3D assets like characters, which face towards the camera by convention. Use ``Vector3.MODEL_FRONT`` and similar constants when working in 3D asset space.
    public static let forward = Vector3 (x: 0, y: 0, z: -1)
    /// Back unit vector. Represents the local direction of back, and the global direction of south.
    public static let back = Vector3 (x: 0, y: 0, z: 1)
    /// Unit vector pointing towards the left side of imported 3D assets.
    public static let modelLeft = Vector3 (x: 1, y: 0, z: 0)
    /// Unit vector pointing towards the right side of imported 3D assets.
    public static let modelRight = Vector3 (x: -1, y: 0, z: 0)
    /// Unit vector pointing towards the top side (up) of imported 3D assets.
    public static let modelTop = Vector3 (x: 0, y: 1, z: 0)
    /// Unit vector pointing towards the bottom side (down) of imported 3D assets.
    public static let modelBottom = Vector3 (x: 0, y: -1, z: 0)
    /// Unit vector pointing towards the front side (facing forward) of imported 3D assets.
    public static let modelFront = Vector3 (x: 0, y: 0, z: 1)
    /// Unit vector pointing towards the rear side (back) of imported 3D assets.
    public static let modelRear = Vector3 (x: 0, y: 0, z: -1)
}

