// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A built-in data structure that holds key-value pairs.
/// 
/// Dictionaries are associative containers that contain values referenced by unique keys. Dictionaries will preserve the insertion order when adding new entries. In other programming languages, this data structure is often referred to as a hash map or an associative array.
/// 
/// You can define a dictionary by placing a comma-separated list of `key: value` pairs inside curly braces `{}`.
/// 
/// Creating a dictionary:
/// 
/// You can access a dictionary's value by referencing its corresponding key. In the above example, `points_dict["White"]` will return `50`. You can also write `points_dict.White`, which is equivalent. However, you'll have to use the bracket syntax if the key you're accessing the dictionary with isn't a fixed string (such as a number or variable).
/// 
/// In the above code, `points` will be assigned the value that is paired with the appropriate color selected in `my_color`.
/// 
/// Dictionaries can contain more complex data:
/// 
/// To add a key to an existing dictionary, access it like an existing key and assign to it:
/// 
/// Finally, dictionaries can contain different types of keys and values in the same dictionary:
/// 
/// The keys of a dictionary can be iterated with the `for` keyword:
/// 
/// > Note: Dictionaries are always passed by reference. To get a copy of a dictionary which can be modified independently of the original dictionary, use ``duplicate(deep:)``.
/// 
/// > Note: Erasing elements while iterating over dictionaries is **not** supported and will result in unpredictable behavior.
/// 
public class GDictionary: Equatable {
    static var destructor: GDExtensionPtrDestructor = {
        return gi.variant_get_ptr_destructor (GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    deinit {
        if content != GDictionary.zero {
            GDictionary.destructor (&content)
        }
        
    }
    
    // Contains a binary blob where this type information is stored
    public var content: ContentType = 0
    // Used to initialize empty types
    public static let zero: ContentType  = 0
    // Convenience type that matches the build configuration storage needs
    public typealias ContentType = Int64
    // Used to construct objects on virtual proxies
    public required init (content: ContentType) {
        var copy = content
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy) { ptr in
            args.append (ptr)
            GDictionary.constructor1 (&self.content, &args)
        }
        
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_DICTIONARY, 0)!
    
    /// Constructs an empty ``GDictionary``.
    public required init () {
        GDictionary.constructor0 (&content, nil)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_DICTIONARY, 1)!
    
    /// Returns the same dictionary as `from`. If you need a copy of the dictionary, use ``duplicate(deep:)``.
    public init (from: GDictionary) {
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &from.content) { p0 in
            args.append (p0)
        
            GDictionary.constructor1 (&content, &args)
        }
    }
    
    
    /* Methods */
    
    static var method_size: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("size")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3173160232)!
    }()
    
    /// Returns the number of entries in the dictionary. Empty dictionaries (`{ }`) always return `0`. See also ``isEmpty()``.
    public final func size ()-> Int64 {
        var result: Int64 = Int64()
        GDictionary.method_size (&content, nil, &result, 0)
        return result
    }
    
    static var method_is_empty: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_empty")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the dictionary is empty (its size is `0`). See also ``size()``.
    public final func isEmpty ()-> Bool {
        var result: Bool = Bool()
        GDictionary.method_is_empty (&content, nil, &result, 0)
        return result
    }
    
    static var method_clear: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("clear")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3218959716)!
    }()
    
    /// Clears the dictionary, removing all entries from it.
    public final func clear () {
        GDictionary.method_clear (&content, nil, nil, 0)
    }
    
    static var method_merge: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("merge")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 2079548978)!
    }()
    
    /// Adds entries from `dictionary` to this dictionary. By default, duplicate keys are not copied over, unless `overwrite` is `true`.
    /// 
    /// > Note: ``merge(dictionary:overwrite:)`` is _not_ recursive. Nested dictionaries are considered as keys that can be overwritten or not depending on the value of `overwrite`, but they will never be merged together.
    /// 
    public final func merge (dictionary: GDictionary, overwrite: Bool = false) {
        var copy_overwrite = overwrite
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &dictionary.content) { p0 in
            args.append (p0)
            withUnsafePointer (to: &copy_overwrite) { p1 in
                args.append (p1)
        
                GDictionary.method_merge (&content, &args, nil, 2)
            }
        }
    }
    
    static var method_has: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("has")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3680194679)!
    }()
    
    /// Returns `true` if the dictionary contains an entry with the given `key`.
    /// 
    /// In GDScript, this is equivalent to the `in` operator:
    /// 
    /// > Note: This method returns `true` as long as the `key` exists, even if its corresponding value is `null`.
    /// 
    public final func has (key: Variant)-> Bool {
        var result: Bool = Bool()
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &key.content) { p0 in
            args.append (p0)
        
            GDictionary.method_has (&content, &args, &result, 1)
            return result
        }
    }
    
    static var method_has_all: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("has_all")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 2988181878)!
    }()
    
    /// Returns `true` if the dictionary contains all keys in the given `keys` array.
    /// 
    public final func hasAll (keys: GArray)-> Bool {
        var result: Bool = Bool()
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &keys.content) { p0 in
            args.append (p0)
        
            GDictionary.method_has_all (&content, &args, &result, 1)
            return result
        }
    }
    
    static var method_find_key: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("find_key")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 1988825835)!
    }()
    
    /// Finds and returns the first key whose associated value is equal to `value`, or `null` if it is not found.
    /// 
    /// > Note: `null` is also a valid key. If inside the dictionary, ``findKey(value:)`` may give misleading results.
    /// 
    public final func findKey (value: Variant)-> Variant {
        let result: Variant = Variant()
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &value.content) { p0 in
            args.append (p0)
        
            GDictionary.method_find_key (&content, &args, &result.content, 1)
            return result
        }
    }
    
    static var method_erase: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("erase")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 1776646889)!
    }()
    
    /// Removes the dictionary entry by key, if it exists. Returns `true` if the given `key` existed in the dictionary, otherwise `false`.
    /// 
    /// > Note: Do not erase entries while iterating over the dictionary. You can iterate over the ``keys()`` array instead.
    /// 
    public final func erase (key: Variant)-> Bool {
        var result: Bool = Bool()
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &key.content) { p0 in
            args.append (p0)
        
            GDictionary.method_erase (&content, &args, &result, 1)
            return result
        }
    }
    
    static var method_hash: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("hash")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3173160232)!
    }()
    
    /// Returns a hashed 32-bit integer value representing the dictionary contents.
    /// 
    /// > Note: Dictionaries with the same entries but in a different order will not have the same hash.
    /// 
    /// > Note: Dictionaries with equal hash values are _not_ guaranteed to be the same, because of hash collisions. On the contrary, dictionaries with different hash values are guaranteed to be different.
    /// 
    public final func hash ()-> Int64 {
        var result: Int64 = Int64()
        GDictionary.method_hash (&content, nil, &result, 0)
        return result
    }
    
    static var method_keys: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("keys")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 4144163970)!
    }()
    
    /// Returns the list of keys in the dictionary.
    public final func keys ()-> GArray {
        let result: GArray = GArray()
        GDictionary.method_keys (&content, nil, &result.content, 0)
        return result
    }
    
    static var method_values: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("values")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 4144163970)!
    }()
    
    /// Returns the list of values in this dictionary.
    public final func values ()-> GArray {
        let result: GArray = GArray()
        GDictionary.method_values (&content, nil, &result.content, 0)
        return result
    }
    
    static var method_duplicate: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("duplicate")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 830099069)!
    }()
    
    /// Creates and returns a new copy of the dictionary. If `deep` is `true`, inner ``GDictionary`` and ``GArray`` keys and values are also copied, recursively.
    public final func duplicate (deep: Bool = false)-> GDictionary {
        let result: GDictionary = GDictionary()
        var copy_deep = deep
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_deep) { p0 in
            args.append (p0)
        
            GDictionary.method_duplicate (&content, &args, &result.content, 1)
            return result
        }
    }
    
    static var method_get: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 2205440559)!
    }()
    
    /// Returns the corresponding value for the given `key` in the dictionary. If the `key` does not exist, returns `default`, or `null` if the parameter is omitted.
    public final func get (key: Variant, `default`: Variant)-> Variant {
        let result: Variant = Variant()
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &key.content) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &`default`.content) { p1 in
                args.append (p1)
        
                GDictionary.method_get (&content, &args, &result.content, 2)
                return result
            }
        }
    }
    
    static var method_make_read_only: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("make_read_only")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3218959716)!
    }()
    
    /// Makes the dictionary read-only, i.e. disables modification of the dictionary's contents. Does not apply to nested content, e.g. content of nested dictionaries.
    public final func makeReadOnly () {
        GDictionary.method_make_read_only (&content, nil, nil, 0)
    }
    
    static var method_is_read_only: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_read_only")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_DICTIONARY, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the dictionary is read-only. See ``makeReadOnly()``. Dictionaries are automatically read-only if declared with `const` keyword.
    public final func isReadOnly ()-> Bool {
        var result: Bool = Bool()
        GDictionary.method_is_read_only (&content, nil, &result, 0)
        return result
    }
    
    private static var keyed_getter: GDExtensionPtrKeyedGetter = {
        return gi.variant_get_ptr_keyed_getter (GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    private static var keyed_setter: GDExtensionPtrKeyedSetter = {
        return gi.variant_get_ptr_keyed_setter (GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    private static var keyed_checker: GDExtensionPtrKeyedChecker = {
        return gi.variant_get_ptr_keyed_checker (GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    public subscript (key: Variant) -> Variant? {
        get {
            let keyCopy = key
            var result = Variant.zero
            if Self.keyed_checker (&content, &keyCopy.content) != 0 {
                Self.keyed_getter (&content, &keyCopy.content, &result)
                return Variant (fromContentPtr: &result)
            }
            
            else {
                return nil
            }
            
        }
        
        set {
            let keyCopy = key
            if let newCopy = newValue {
                Self.keyed_setter (&content, &keyCopy.content, &newCopy.content)
            }
            
            else {
                Self.keyed_setter (&content, &keyCopy.content, nil)
            }
            
        }
        
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_DICTIONARY, GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    /// Returns `true` if the two dictionaries contain the same keys and values. The order of the entries does not matter.
    /// 
    /// > Note: In C#, by convention, this operator compares by **reference**. If you need to compare by value, iterate over both dictionaries.
    /// 
    public static func == (lhs: GDictionary, rhs: GDictionary) -> Bool  {
        var result: Bool = Bool()
        
        GDictionary.operator_3 (&lhs.content, &rhs.content, &result)
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_DICTIONARY, GDEXTENSION_VARIANT_TYPE_DICTIONARY)!
    }()
    
    /// Returns `true` if the two dictionaries do not contain the same keys and values.
    public static func != (lhs: GDictionary, rhs: GDictionary) -> Bool  {
        var result: Bool = Bool()
        
        GDictionary.operator_4 (&lhs.content, &rhs.content, &result)
        return result
    }
    
}

