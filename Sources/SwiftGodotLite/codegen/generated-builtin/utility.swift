// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

public class GD {
    fileprivate static var method_sinh: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("sinh")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2140049587)!
        }
        
    }()
    
    /// Returns the hyperbolic sine of `x`.
    /// 
    public static func sinh (x: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_x = x
        
        withArgPointers(&copy_x) { _args in
            method_sinh (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
        
            method_sinh (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_abs: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("abs")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 4776452)!
        }
        
    }()
    
    /// Returns the absolute value of a ``Variant`` parameter `x` (i.e. non-negative value). Supported types: integer, float, ``Vector2``, ``Vector2i``, ``Vector3``, ``Vector3i``, ``Vector4``, ``Vector4i``.
    /// 
    /// > Note: For better type safety, use ``absf()``, ``absi()``, ``Vector2/abs()``, ``Vector2i/abs()``, ``Vector3/abs()``, ``Vector3i/abs()``, ``Vector4/abs()``, or ``Vector4i/abs()``.
    /// 
    public static func abs (x: Variant)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        withArgPointers(&x.content) { _args in
            method_abs (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &x.content) { p0 in
            _args.append (p0)
        
            method_abs (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_sign: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("sign")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 4776452)!
        }
        
    }()
    
    /// Returns the same type of ``Variant`` as `x`, with `-1` for negative values, `1` for positive values, and `0` for zeros. For `nan` values it returns 0.
    /// 
    /// Supported types: integer, float, ``Vector2``, ``Vector2i``, ``Vector3``, ``Vector3i``, ``Vector4``, ``Vector4i``.
    /// 
    /// > Note: For better type safety, use ``signf()``, ``signi()``, ``Vector2/sign()``, ``Vector2i/sign()``, ``Vector3/sign()``, ``Vector3i/sign()``, ``Vector4/sign()``, or ``Vector4i/sign()``.
    /// 
    public static func sign (x: Variant)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        withArgPointers(&x.content) { _args in
            method_sign (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &x.content) { p0 in
            _args.append (p0)
        
            method_sign (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_signf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("signf")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2140049587)!
        }
        
    }()
    
    /// Returns `-1.0` if `x` is negative, `1.0` if `x` is positive, and `0.0` if `x` is zero. For `nan` values of `x` it returns 0.0.
    /// 
    public static func signf (x: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_x = x
        
        withArgPointers(&copy_x) { _args in
            method_signf (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
        
            method_signf (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_signi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("signi")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2157319888)!
        }
        
    }()
    
    /// Returns `-1` if `x` is negative, `1` if `x` is positive, and `0` if if `x` is zero.
    /// 
    public static func signi (x: Int64)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_x = x
        
        withArgPointers(&copy_x) { _args in
            method_signi (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
        
            method_signi (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_snappedi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("snappedi")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3570758393)!
        }
        
    }()
    
    /// Returns the multiple of `step` that is the closest to `x`.
    /// 
    /// A type-safe version of ``snapped()``, returning an integer.
    /// 
    public static func snappedi (x: Double, step: Int64)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_x = x
        var copy_step = step
        
        withArgPointers(&copy_x, &copy_step) { _args in
            method_snappedi (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_x = x
        var copy_step = step
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_step) { p1 in
                _args.append (p1)
        
                method_snappedi (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_nan: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("is_nan")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3569215213)!
        }
        
    }()
    
    /// Returns `true` if `x` is a NaN ("Not a Number" or invalid) value.
    public static func isNan (x: Double)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_x = x
        
        withArgPointers(&copy_x) { _args in
            method_is_nan (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
        
            method_is_nan (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_inf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("is_inf")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3569215213)!
        }
        
    }()
    
    /// Returns `true` if `x` is either positive infinity or negative infinity.
    public static func isInf (x: Double)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_x = x
        
        withArgPointers(&copy_x) { _args in
            method_is_inf (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
        
            method_is_inf (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_equal_approx: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("is_equal_approx")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1400789633)!
        }
        
    }()
    
    /// Returns `true` if `a` and `b` are approximately equal to each other.
    /// 
    /// Here, "approximately equal" means that `a` and `b` are within a small internal epsilon of each other, which scales with the magnitude of the numbers.
    /// 
    /// Infinity values of the same sign are considered equal.
    /// 
    public static func isEqualApprox (a: Double, b: Double)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_a = a
        var copy_b = b
        
        withArgPointers(&copy_a, &copy_b) { _args in
            method_is_equal_approx (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_a = a
        var copy_b = b
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_a) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_b) { p1 in
                _args.append (p1)
        
                method_is_equal_approx (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_is_zero_approx: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("is_zero_approx")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3569215213)!
        }
        
    }()
    
    /// Returns `true` if `x` is zero or almost zero. The comparison is done using a tolerance calculation with a small internal epsilon.
    /// 
    /// This function is faster than using ``isEqualApprox()`` with one value as zero.
    /// 
    public static func isZeroApprox (x: Double)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_x = x
        
        withArgPointers(&copy_x) { _args in
            method_is_zero_approx (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
        
            method_is_zero_approx (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_finite: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("is_finite")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3569215213)!
        }
        
    }()
    
    /// Returns whether `x` is a finite value, i.e. it is not ``@GDScript.NAN``, positive infinity, or negative infinity.
    public static func isFinite (x: Double)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_x = x
        
        withArgPointers(&copy_x) { _args in
            method_is_finite (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
        
            method_is_finite (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_ease: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("ease")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 92296394)!
        }
        
    }()
    
    /// Returns an "eased" value of `x` based on an easing function defined with `curve`. This easing function is based on an exponent. The `curve` can be any floating-point number, with specific values leading to the following behaviors:
    /// 
    /// [url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/ease_cheatsheet.png]ease() curve values cheatsheet[/url]
    /// 
    /// See also ``smoothstep()``. If you need to perform more advanced transitions, use ``Tween/interpolateValue(initialValue:deltaValue:elapsedTime:duration:transType:easeType:)``.
    /// 
    public static func ease (x: Double, curve: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_x = x
        var copy_curve = curve
        
        withArgPointers(&copy_x, &copy_curve) { _args in
            method_ease (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_x = x
        var copy_curve = curve
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_curve) { p1 in
                _args.append (p1)
        
                method_ease (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_step_decimals: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("step_decimals")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2780425386)!
        }
        
    }()
    
    /// Returns the position of the first non-zero digit, after the decimal point. Note that the maximum return value is 10, which is a design decision in the implementation.
    /// 
    public static func stepDecimals (x: Double)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_x = x
        
        withArgPointers(&copy_x) { _args in
            method_step_decimals (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_x) { p0 in
            _args.append (p0)
        
            method_step_decimals (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_cubic_interpolate: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("cubic_interpolate")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1090965791)!
        }
        
    }()
    
    /// Cubic interpolates between two values by the factor defined in `weight` with `pre` and `post` values.
    public static func cubicInterpolate (from: Double, to: Double, pre: Double, post: Double, weight: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_pre = pre
        var copy_post = post
        var copy_weight = weight
        
        withArgPointers(&copy_from, &copy_to, &copy_pre, &copy_post, &copy_weight) { _args in
            method_cubic_interpolate (&_result, _args, Int32 (5))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_pre = pre
        var copy_post = post
        var copy_weight = weight
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_pre) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_post) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_weight) { p4 in
                            _args.append (p4)
        
                            method_cubic_interpolate (&_result, &_args, Int32 (5))
                            return _result
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_cubic_interpolate_angle: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("cubic_interpolate_angle")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1090965791)!
        }
        
    }()
    
    /// Cubic interpolates between two rotation values with shortest path by the factor defined in `weight` with `pre` and `post` values. See also ``lerpAngle()``.
    public static func cubicInterpolateAngle (from: Double, to: Double, pre: Double, post: Double, weight: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_pre = pre
        var copy_post = post
        var copy_weight = weight
        
        withArgPointers(&copy_from, &copy_to, &copy_pre, &copy_post, &copy_weight) { _args in
            method_cubic_interpolate_angle (&_result, _args, Int32 (5))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_pre = pre
        var copy_post = post
        var copy_weight = weight
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_pre) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_post) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_weight) { p4 in
                            _args.append (p4)
        
                            method_cubic_interpolate_angle (&_result, &_args, Int32 (5))
                            return _result
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_cubic_interpolate_in_time: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("cubic_interpolate_in_time")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 388121036)!
        }
        
    }()
    
    /// Cubic interpolates between two values by the factor defined in `weight` with `pre` and `post` values.
    /// 
    /// It can perform smoother interpolation than ``cubicInterpolate()`` by the time values.
    /// 
    public static func cubicInterpolateInTime (from: Double, to: Double, pre: Double, post: Double, weight: Double, toT: Double, preT: Double, postT: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_pre = pre
        var copy_post = post
        var copy_weight = weight
        var copy_to_t = toT
        var copy_pre_t = preT
        var copy_post_t = postT
        
        withArgPointers(&copy_from, &copy_to, &copy_pre, &copy_post, &copy_weight, &copy_to_t, &copy_pre_t, &copy_post_t) { _args in
            method_cubic_interpolate_in_time (&_result, _args, Int32 (8))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_pre = pre
        var copy_post = post
        var copy_weight = weight
        var copy_to_t = toT
        var copy_pre_t = preT
        var copy_post_t = postT
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_pre) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_post) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_weight) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &copy_to_t) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &copy_pre_t) { p6 in
                                    _args.append (p6)
                                    return withUnsafePointer (to: &copy_post_t) { p7 in
                                        _args.append (p7)
        
                                        method_cubic_interpolate_in_time (&_result, &_args, Int32 (8))
                                        return _result
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_cubic_interpolate_angle_in_time: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("cubic_interpolate_angle_in_time")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 388121036)!
        }
        
    }()
    
    /// Cubic interpolates between two rotation values with shortest path by the factor defined in `weight` with `pre` and `post` values. See also ``lerpAngle()``.
    /// 
    /// It can perform smoother interpolation than ``cubicInterpolate()`` by the time values.
    /// 
    public static func cubicInterpolateAngleInTime (from: Double, to: Double, pre: Double, post: Double, weight: Double, toT: Double, preT: Double, postT: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_pre = pre
        var copy_post = post
        var copy_weight = weight
        var copy_to_t = toT
        var copy_pre_t = preT
        var copy_post_t = postT
        
        withArgPointers(&copy_from, &copy_to, &copy_pre, &copy_post, &copy_weight, &copy_to_t, &copy_pre_t, &copy_post_t) { _args in
            method_cubic_interpolate_angle_in_time (&_result, _args, Int32 (8))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_pre = pre
        var copy_post = post
        var copy_weight = weight
        var copy_to_t = toT
        var copy_pre_t = preT
        var copy_post_t = postT
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_pre) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_post) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_weight) { p4 in
                            _args.append (p4)
                            return withUnsafePointer (to: &copy_to_t) { p5 in
                                _args.append (p5)
                                return withUnsafePointer (to: &copy_pre_t) { p6 in
                                    _args.append (p6)
                                    return withUnsafePointer (to: &copy_post_t) { p7 in
                                        _args.append (p7)
        
                                        method_cubic_interpolate_angle_in_time (&_result, &_args, Int32 (8))
                                        return _result
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_bezier_interpolate: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("bezier_interpolate")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1090965791)!
        }
        
    }()
    
    /// Returns the point at the given `t` on a one-dimensional [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by the given `control1`, `control2`, and `end` points.
    public static func bezierInterpolate (start: Double, control1: Double, control2: Double, end: Double, t: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_start = start
        var copy_control_1 = control1
        var copy_control_2 = control2
        var copy_end = end
        var copy_t = t
        
        withArgPointers(&copy_start, &copy_control_1, &copy_control_2, &copy_end, &copy_t) { _args in
            method_bezier_interpolate (&_result, _args, Int32 (5))
        }
        return _result
        #else
        
        var copy_start = start
        var copy_control_1 = control1
        var copy_control_2 = control2
        var copy_end = end
        var copy_t = t
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_start) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_control_1) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_control_2) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_end) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_t) { p4 in
                            _args.append (p4)
        
                            method_bezier_interpolate (&_result, &_args, Int32 (5))
                            return _result
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_bezier_derivative: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("bezier_derivative")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1090965791)!
        }
        
    }()
    
    /// Returns the derivative at the given `t` on a one-dimensional [url=https://en.wikipedia.org/wiki/B%C3%A9zier_curve]Bézier curve[/url] defined by the given `control1`, `control2`, and `end` points.
    public static func bezierDerivative (start: Double, control1: Double, control2: Double, end: Double, t: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_start = start
        var copy_control_1 = control1
        var copy_control_2 = control2
        var copy_end = end
        var copy_t = t
        
        withArgPointers(&copy_start, &copy_control_1, &copy_control_2, &copy_end, &copy_t) { _args in
            method_bezier_derivative (&_result, _args, Int32 (5))
        }
        return _result
        #else
        
        var copy_start = start
        var copy_control_1 = control1
        var copy_control_2 = control2
        var copy_end = end
        var copy_t = t
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_start) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_control_1) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_control_2) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_end) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_t) { p4 in
                            _args.append (p4)
        
                            method_bezier_derivative (&_result, &_args, Int32 (5))
                            return _result
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_angle_difference: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("angle_difference")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 92296394)!
        }
        
    }()
    
    /// Returns the difference between the two angles, in the range of `[-PI, +PI]`. When `from` and `to` are opposite, returns `-PI` if `from` is smaller than `to`, or `PI` otherwise.
    public static func angleDifference (from: Double, to: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        
        withArgPointers(&copy_from, &copy_to) { _args in
            method_angle_difference (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
        
                method_angle_difference (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_lerp_angle: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("lerp_angle")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 998901048)!
        }
        
    }()
    
    /// Linearly interpolates between two angles (in radians) by a `weight` value between 0.0 and 1.0.
    /// 
    /// Similar to ``lerp()``, but interpolates correctly when the angles wrap around ``@GDScript.TAU``. To perform eased interpolation with ``lerpAngle()``, combine it with ``ease()`` or ``smoothstep()``.
    /// 
    /// > Note: This function lerps through the shortest path between `from` and `to`. However, when these two angles are approximately `PI + k * TAU` apart for any integer `k`, it's not obvious which way they lerp due to floating-point precision errors. For example, `lerp_angle(0, PI, weight)` lerps counter-clockwise, while `lerp_angle(0, PI + 5 * TAU, weight)` lerps clockwise.
    /// 
    public static func lerpAngle (from: Double, to: Double, weight: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_weight = weight
        
        withArgPointers(&copy_from, &copy_to, &copy_weight) { _args in
            method_lerp_angle (&_result, _args, Int32 (3))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_weight = weight
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_weight) { p2 in
                    _args.append (p2)
        
                    method_lerp_angle (&_result, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_remap: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("remap")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1090965791)!
        }
        
    }()
    
    /// Maps a `value` from range `[istart, istop]` to `[ostart, ostop]`. See also ``lerp()`` and ``inverseLerp()``. If `value` is outside `[istart, istop]`, then the resulting value will also be outside `[ostart, ostop]`. If this is not desired, use ``clamp()`` on the result of this function.
    /// 
    /// For complex use cases where multiple ranges are needed, consider using ``Curve`` or ``Gradient`` instead.
    /// 
    public static func remap (value: Double, istart: Double, istop: Double, ostart: Double, ostop: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_value = value
        var copy_istart = istart
        var copy_istop = istop
        var copy_ostart = ostart
        var copy_ostop = ostop
        
        withArgPointers(&copy_value, &copy_istart, &copy_istop, &copy_ostart, &copy_ostop) { _args in
            method_remap (&_result, _args, Int32 (5))
        }
        return _result
        #else
        
        var copy_value = value
        var copy_istart = istart
        var copy_istop = istop
        var copy_ostart = ostart
        var copy_ostop = ostop
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_istart) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_istop) { p2 in
                    _args.append (p2)
                    return withUnsafePointer (to: &copy_ostart) { p3 in
                        _args.append (p3)
                        return withUnsafePointer (to: &copy_ostop) { p4 in
                            _args.append (p4)
        
                            method_remap (&_result, &_args, Int32 (5))
                            return _result
                        }
                    }
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_smoothstep: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("smoothstep")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 998901048)!
        }
        
    }()
    
    /// Returns the result of smoothly interpolating the value of `x` between `0` and `1`, based on the where `x` lies with respect to the edges `from` and `to`.
    /// 
    /// The return value is `0` if `x <= from`, and `1` if `x >= to`. If `x` lies between `from` and `to`, the returned value follows an S-shaped curve that maps `x` between `0` and `1`.
    /// 
    /// This S-shaped curve is the cubic Hermite interpolator, given by `f(y) = 3*y^2 - 2*y^3` where `y = (x-from) / (to-from)`.
    /// 
    /// Compared to ``ease()`` with a curve value of `-1.6521`, ``smoothstep()`` returns the smoothest possible curve with no sudden changes in the derivative. If you need to perform more advanced transitions, use ``Tween`` or ``AnimationPlayer``.
    /// 
    /// [url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/smoothstep_ease_comparison.png]Comparison between smoothstep() and ease(x, -1.6521) return values[/url]
    /// 
    public static func smoothstep (from: Double, to: Double, x: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_x = x
        
        withArgPointers(&copy_from, &copy_to, &copy_x) { _args in
            method_smoothstep (&_result, _args, Int32 (3))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_x = x
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_x) { p2 in
                    _args.append (p2)
        
                    method_smoothstep (&_result, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_move_toward: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("move_toward")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 998901048)!
        }
        
    }()
    
    /// Moves `from` toward `to` by the `delta` amount. Will not go past `to`.
    /// 
    /// Use a negative `delta` value to move away.
    /// 
    public static func moveToward (from: Double, to: Double, delta: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_delta = delta
        
        withArgPointers(&copy_from, &copy_to, &copy_delta) { _args in
            method_move_toward (&_result, _args, Int32 (3))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_delta = delta
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_delta) { p2 in
                    _args.append (p2)
        
                    method_move_toward (&_result, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_rotate_toward: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("rotate_toward")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 998901048)!
        }
        
    }()
    
    /// Rotates `from` toward `to` by the `delta` amount. Will not go past `to`.
    /// 
    /// Similar to ``moveToward()``, but interpolates correctly when the angles wrap around ``@GDScript.TAU``.
    /// 
    /// If `delta` is negative, this function will rotate away from `to`, toward the opposite angle, and will not go past the opposite angle.
    /// 
    public static func rotateToward (from: Double, to: Double, delta: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        var copy_delta = delta
        
        withArgPointers(&copy_from, &copy_to, &copy_delta) { _args in
            method_rotate_toward (&_result, _args, Int32 (3))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var copy_delta = delta
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_delta) { p2 in
                    _args.append (p2)
        
                    method_rotate_toward (&_result, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_linear_to_db: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("linear_to_db")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2140049587)!
        }
        
    }()
    
    /// Converts from linear energy to decibels (audio). This can be used to implement volume sliders that behave as expected (since volume isn't linear).
    /// 
    /// **Example:**
    /// 
    public static func linearToDb (lin: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_lin = lin
        
        withArgPointers(&copy_lin) { _args in
            method_linear_to_db (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_lin = lin
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_lin) { p0 in
            _args.append (p0)
        
            method_linear_to_db (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_db_to_linear: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("db_to_linear")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2140049587)!
        }
        
    }()
    
    /// Converts from decibels to linear energy (audio).
    public static func dbToLinear (db: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_db = db
        
        withArgPointers(&copy_db) { _args in
            method_db_to_linear (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_db = db
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_db) { p0 in
            _args.append (p0)
        
            method_db_to_linear (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_wrap: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("wrap")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3389874542)!
        }
        
    }()
    
    /// Wraps the ``Variant`` `value` between `min` and `max`. Can be used for creating loop-alike behavior or infinite surfaces.
    /// 
    /// Variant types integer and float are supported. If any of the arguments is float this function returns a float, otherwise it returns an integer.
    /// 
    public static func wrap (value: Variant, min: Variant, max: Variant)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        withArgPointers(&value.content, &min.content, &max.content) { _args in
            method_wrap (&_result.content, _args, Int32 (3))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &value.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &min.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &max.content) { p2 in
                    _args.append (p2)
        
                    method_wrap (&_result.content, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_wrapi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("wrapi")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 650295447)!
        }
        
    }()
    
    /// Wraps the integer `value` between `min` and `max`. Can be used for creating loop-alike behavior or infinite surfaces.
    /// 
    public static func wrapi (value: Int64, min: Int64, max: Int64)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_value = value
        var copy_min = min
        var copy_max = max
        
        withArgPointers(&copy_value, &copy_min, &copy_max) { _args in
            method_wrapi (&_result, _args, Int32 (3))
        }
        return _result
        #else
        
        var copy_value = value
        var copy_min = min
        var copy_max = max
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_min) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_max) { p2 in
                    _args.append (p2)
        
                    method_wrapi (&_result, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_wrapf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("wrapf")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 998901048)!
        }
        
    }()
    
    /// Wraps the float `value` between `min` and `max`. Can be used for creating loop-alike behavior or infinite surfaces.
    /// 
    /// > Note: If `min` is `0`, this is equivalent to ``fposmod()``, so prefer using that instead.
    /// 
    /// ``wrapf()`` is more flexible than using the ``fposmod()`` approach by giving the user control over the minimum value.
    /// 
    public static func wrapf (value: Double, min: Double, max: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_value = value
        var copy_min = min
        var copy_max = max
        
        withArgPointers(&copy_value, &copy_min, &copy_max) { _args in
            method_wrapf (&_result, _args, Int32 (3))
        }
        return _result
        #else
        
        var copy_value = value
        var copy_min = min
        var copy_max = max
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_min) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_max) { p2 in
                    _args.append (p2)
        
                    method_wrapf (&_result, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_max: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("max")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3896050336)!
        }
        
    }()
    
    /// Returns the maximum of the given numeric values. This function can take any number of arguments.
    /// 
    public static func max (arg1: Variant, arg2: Variant, _ arguments: Variant...)-> Variant {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        let copy_arg2 = Variant (arg2)
        
        withArgPointers(&copy_arg1.content, &copy_arg2.content) { _args in
            method_max (&_result, _args, Int32 (_args.count))
        }
        return Variant (fromContentPtr: &_result)
        #else
        
        let copy_arg1 = Variant (arg1)
        let copy_arg2 = Variant (arg2)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_arg2.content) { p1 in
                _args.append (p1)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
                method_max (&_result, &_args, Int32 (_args.count))
                return Variant (fromContentPtr: &_result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_maxi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("maxi")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3133453818)!
        }
        
    }()
    
    /// Returns the maximum of two integer values.
    /// 
    public static func maxi (a: Int64, b: Int64)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_a = a
        var copy_b = b
        
        withArgPointers(&copy_a, &copy_b) { _args in
            method_maxi (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_a = a
        var copy_b = b
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_a) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_b) { p1 in
                _args.append (p1)
        
                method_maxi (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_maxf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("maxf")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 92296394)!
        }
        
    }()
    
    /// Returns the maximum of two float values.
    /// 
    public static func maxf (a: Double, b: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_a = a
        var copy_b = b
        
        withArgPointers(&copy_a, &copy_b) { _args in
            method_maxf (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_a = a
        var copy_b = b
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_a) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_b) { p1 in
                _args.append (p1)
        
                method_maxf (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_min: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("min")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3896050336)!
        }
        
    }()
    
    /// Returns the minimum of the given numeric values. This function can take any number of arguments.
    /// 
    public static func min (arg1: Variant, arg2: Variant, _ arguments: Variant...)-> Variant {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        let copy_arg2 = Variant (arg2)
        
        withArgPointers(&copy_arg1.content, &copy_arg2.content) { _args in
            method_min (&_result, _args, Int32 (_args.count))
        }
        return Variant (fromContentPtr: &_result)
        #else
        
        let copy_arg1 = Variant (arg1)
        let copy_arg2 = Variant (arg2)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_arg2.content) { p1 in
                _args.append (p1)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
                method_min (&_result, &_args, Int32 (_args.count))
                return Variant (fromContentPtr: &_result)
            }
        }
        
        #endif
    }
    
    fileprivate static var method_mini: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("mini")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3133453818)!
        }
        
    }()
    
    /// Returns the minimum of two integer values.
    /// 
    public static func mini (a: Int64, b: Int64)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_a = a
        var copy_b = b
        
        withArgPointers(&copy_a, &copy_b) { _args in
            method_mini (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_a = a
        var copy_b = b
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_a) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_b) { p1 in
                _args.append (p1)
        
                method_mini (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_minf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("minf")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 92296394)!
        }
        
    }()
    
    /// Returns the minimum of two float values.
    /// 
    public static func minf (a: Double, b: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_a = a
        var copy_b = b
        
        withArgPointers(&copy_a, &copy_b) { _args in
            method_minf (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_a = a
        var copy_b = b
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_a) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_b) { p1 in
                _args.append (p1)
        
                method_minf (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_clamp: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("clamp")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3389874542)!
        }
        
    }()
    
    /// Clamps the `value`, returning a ``Variant`` not less than `min` and not more than `max`. Any values that can be compared with the less than and greater than operators will work.
    /// 
    /// > Note: For better type safety, use ``clampf()``, ``clampi()``, ``Vector2/clamp(min:max:)``, ``Vector2i/clamp(min:max:)``, ``Vector3/clamp(min:max:)``, ``Vector3i/clamp(min:max:)``, ``Vector4/clamp(min:max:)``, ``Vector4i/clamp(min:max:)``, or ``Color/clamp(min:max:)``.
    /// 
    public static func clamp (value: Variant, min: Variant, max: Variant)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        withArgPointers(&value.content, &min.content, &max.content) { _args in
            method_clamp (&_result.content, _args, Int32 (3))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &value.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &min.content) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &max.content) { p2 in
                    _args.append (p2)
        
                    method_clamp (&_result.content, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_clampi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("clampi")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 650295447)!
        }
        
    }()
    
    /// Clamps the `value`, returning an integer not less than `min` and not more than `max`.
    /// 
    public static func clampi (value: Int64, min: Int64, max: Int64)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_value = value
        var copy_min = min
        var copy_max = max
        
        withArgPointers(&copy_value, &copy_min, &copy_max) { _args in
            method_clampi (&_result, _args, Int32 (3))
        }
        return _result
        #else
        
        var copy_value = value
        var copy_min = min
        var copy_max = max
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_min) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_max) { p2 in
                    _args.append (p2)
        
                    method_clampi (&_result, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_clampf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("clampf")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 998901048)!
        }
        
    }()
    
    /// Clamps the `value`, returning a float not less than `min` and not more than `max`.
    /// 
    public static func clampf (value: Double, min: Double, max: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_value = value
        var copy_min = min
        var copy_max = max
        
        withArgPointers(&copy_value, &copy_min, &copy_max) { _args in
            method_clampf (&_result, _args, Int32 (3))
        }
        return _result
        #else
        
        var copy_value = value
        var copy_min = min
        var copy_max = max
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_min) { p1 in
                _args.append (p1)
                return withUnsafePointer (to: &copy_max) { p2 in
                    _args.append (p2)
        
                    method_clampf (&_result, &_args, Int32 (3))
                    return _result
                }
            }
        }
        
        #endif
    }
    
    fileprivate static var method_nearest_po2: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("nearest_po2")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2157319888)!
        }
        
    }()
    
    /// Returns the smallest integer power of 2 that is greater than or equal to `value`.
    /// 
    /// > Warning: Due to its implementation, this method returns `0` rather than `1` for values less than or equal to `0`, with an exception for `value` being the smallest negative 64-bit integer (`-9223372036854775808`) in which case the `value` is returned unchanged.
    /// 
    public static func nearestPo2 (value: Int64)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_value = value
        
        withArgPointers(&copy_value) { _args in
            method_nearest_po2 (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_value = value
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
        
            method_nearest_po2 (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_pingpong: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("pingpong")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 92296394)!
        }
        
    }()
    
    /// Wraps `value` between `0` and the `length`. If the limit is reached, the next value the function returns is decreased to the `0` side or increased to the `length` side (like a triangle wave). If `length` is less than zero, it becomes positive.
    /// 
    public static func pingpong (value: Double, length: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_value = value
        var copy_length = length
        
        withArgPointers(&copy_value, &copy_length) { _args in
            method_pingpong (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_value = value
        var copy_length = length
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_value) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_length) { p1 in
                _args.append (p1)
        
                method_pingpong (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_randomize: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("randomize")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1691721052)!
        }
        
    }()
    
    /// Randomizes the seed (or the internal state) of the random number generator. The current implementation uses a number based on the device's time.
    /// 
    /// > Note: This function is called automatically when the project is run. If you need to fix the seed to have consistent, reproducible results, use ``seed()`` to initialize the random number generator.
    /// 
    public static func randomize () {
        method_randomize (nil, nil, Int32 (0))
    }
    
    fileprivate static var method_randi: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("randi")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 701202648)!
        }
        
    }()
    
    /// Returns a random unsigned 32-bit integer. Use remainder to obtain a random value in the interval `[0, N - 1]` (where N is smaller than 2^32).
    /// 
    public static func randi ()-> Int64 {
        var _result: Int64 = 0
        method_randi (&_result, nil, Int32 (0))
        return _result
    }
    
    fileprivate static var method_randf: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("randf")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2086227845)!
        }
        
    }()
    
    /// Returns a random floating point value between `0.0` and `1.0` (inclusive).
    /// 
    public static func randf ()-> Double {
        var _result: Double = 0.0
        method_randf (&_result, nil, Int32 (0))
        return _result
    }
    
    fileprivate static var method_randi_range: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("randi_range")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3133453818)!
        }
        
    }()
    
    /// Returns a random signed 32-bit integer between `from` and `to` (inclusive). If `to` is lesser than `from`, they are swapped.
    /// 
    public static func randiRange (from: Int64, to: Int64)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        var copy_from = from
        var copy_to = to
        
        withArgPointers(&copy_from, &copy_to) { _args in
            method_randi_range (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
        
                method_randi_range (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_randf_range: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("randf_range")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 92296394)!
        }
        
    }()
    
    /// Returns a random floating point value between `from` and `to` (inclusive).
    /// 
    public static func randfRange (from: Double, to: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_from = from
        var copy_to = to
        
        withArgPointers(&copy_from, &copy_to) { _args in
            method_randf_range (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_from = from
        var copy_to = to
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                _args.append (p1)
        
                method_randf_range (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_randfn: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("randfn")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 92296394)!
        }
        
    }()
    
    /// Returns a normally-distributed pseudo-random floating point value using Box-Muller transform with the specified `mean` and a standard `deviation`. This is also called Gaussian distribution.
    public static func randfn (mean: Double, deviation: Double)-> Double {
        var _result: Double = 0.0
        #if false
        
        var copy_mean = mean
        var copy_deviation = deviation
        
        withArgPointers(&copy_mean, &copy_deviation) { _args in
            method_randfn (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_mean = mean
        var copy_deviation = deviation
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_mean) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_deviation) { p1 in
                _args.append (p1)
        
                method_randfn (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_seed: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("seed")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 382931173)!
        }
        
    }()
    
    /// Sets the seed for the random number generator to `base`. Setting the seed manually can ensure consistent, repeatable results for most random functions.
    /// 
    public static func seed (base: Int64) {
        #if false
        
        var copy_base = base
        
        withArgPointers(&copy_base) { _args in
            method_seed (nil, _args, Int32 (1))
        }
        
        #else
        
        var copy_base = base
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_base) { p0 in
            _args.append (p0)
        
            method_seed (nil, &_args, Int32 (1))
        }
        
        #endif
    }
    
    fileprivate static var method_rand_from_seed: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("rand_from_seed")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1391063685)!
        }
        
    }()
    
    /// Given a `seed`, returns a ``PackedInt64Array`` of size `2`, where its first element is the randomized integer value, and the second element is the same as `seed`. Passing the same `seed` consistently returns the same array.
    /// 
    /// > Note: "Seed" here refers to the internal state of the pseudo random number generator, currently implemented as a 64 bit integer.
    /// 
    public static func randFromSeed (_ seed: Int64)-> PackedInt64Array {
        let _result: PackedInt64Array = PackedInt64Array ()
        #if false
        
        var copy_seed = seed
        
        withArgPointers(&copy_seed) { _args in
            method_rand_from_seed (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_seed = seed
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_seed) { p0 in
            _args.append (p0)
        
            method_rand_from_seed (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_weakref: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("weakref")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 4776452)!
        }
        
    }()
    
    /// Returns a ``WeakRef`` instance holding a weak reference to `obj`. Returns an empty ``WeakRef`` instance if `obj` is `null`. Prints an error and returns `null` if `obj` is neither ``Object``-derived nor `null`.
    /// 
    /// A weak reference to an object is not enough to keep the object alive: when the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else. However, until the object is actually destroyed the weak reference may return the object even if there are no strong references to it.
    /// 
    public static func weakref (obj: Variant)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        withArgPointers(&obj.content) { _args in
            method_weakref (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &obj.content) { p0 in
            _args.append (p0)
        
            method_weakref (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_typeof: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("typeof")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 326422594)!
        }
        
    }()
    
    /// Returns the internal type of the given `variable`, using the ``Variant.GType`` values.
    /// 
    /// See also ``typeString()``.
    /// 
    public static func typeof (variable: Variant)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        
        withArgPointers(&variable.content) { _args in
            method_typeof (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &variable.content) { p0 in
            _args.append (p0)
        
            method_typeof (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_type_convert: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("type_convert")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2453062746)!
        }
        
    }()
    
    /// Converts the given `variant` to the given `type`, using the ``Variant.GType`` values. This method is generous with how it handles types, it can automatically convert between array types, convert numeric ``String``s to integer, and converting most things to ``String``.
    /// 
    /// If the type conversion cannot be done, this method will return the default value for that type, for example converting ``Rect2`` to ``Vector2`` will always return ``Vector2.ZERO``. This method will never show error messages as long as `type` is a valid Variant type.
    /// 
    /// The returned value is a ``Variant``, but the data inside and the ``Variant.GType`` will be the same as the requested type.
    /// 
    public static func typeConvert (variant: Variant, type: Int64)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        var copy_type = type
        
        withArgPointers(&variant.content, &copy_type) { _args in
            method_type_convert (&_result.content, _args, Int32 (2))
        }
        return _result
        #else
        
        var copy_type = type
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &variant.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &copy_type) { p1 in
                _args.append (p1)
        
                method_type_convert (&_result.content, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
    fileprivate static var method_str: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("str")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 32569176)!
        }
        
    }()
    
    /// Converts one or more arguments of any ``Variant`` type to a ``String`` in the best way possible.
    /// 
    public static func str (arg1: Variant, _ arguments: Variant...)-> String {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_str (&_result, _args, Int32 (_args.count))
        }
        return GString (Variant (fromContentPtr: &_result))?.description ?? ""
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_str (&_result, &_args, Int32 (_args.count))
            return GString (Variant (fromContentPtr: &_result))?.description ?? ""
        }
        
        #endif
    }
    
    fileprivate static var method_error_string: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("error_string")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 942708242)!
        }
        
    }()
    
    /// Returns a human-readable name for the given ``GodotError`` code.
    /// 
    public static func errorString (error: Int64)-> String {
        let _result = GString ()
        #if false
        
        var copy_error = error
        
        withArgPointers(&copy_error) { _args in
            method_error_string (&_result.content, _args, Int32 (1))
        }
        return _result.description
        #else
        
        var copy_error = error
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_error) { p0 in
            _args.append (p0)
        
            method_error_string (&_result.content, &_args, Int32 (1))
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_type_string: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("type_string")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 942708242)!
        }
        
    }()
    
    /// Returns a human-readable name of the given `type`, using the ``Variant.GType`` values.
    /// 
    /// See also ``typeof()``.
    /// 
    public static func typeString (type: Int64)-> String {
        let _result = GString ()
        #if false
        
        var copy_type = type
        
        withArgPointers(&copy_type) { _args in
            method_type_string (&_result.content, _args, Int32 (1))
        }
        return _result.description
        #else
        
        var copy_type = type
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_type) { p0 in
            _args.append (p0)
        
            method_type_string (&_result.content, &_args, Int32 (1))
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_print: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("print")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// Converts one or more arguments of any type to string in the best way possible and prints them to the console.
    /// 
    /// > Note: Consider using ``pushError()`` and ``pushWarning()`` to print error and warning messages instead of ``print()`` or ``printRich()``. This distinguishes them from print messages used for debugging purposes, while also displaying a stack trace when an error or warning is printed.
    /// 
    public static func print (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_print (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_print (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_print_rich: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("print_rich")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// Converts one or more arguments of any type to string in the best way possible and prints them to the console.
    /// 
    /// The following BBCode tags are supported: `b`, `i`, `u`, `s`, `indent`, `code`, `url`, `center`, `right`, `color`, `bgcolor`, `fgcolor`.
    /// 
    /// Color tags only support the following named colors: `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `pink`, `purple`, `cyan`, `white`, `orange`, `gray`. Hexadecimal color codes are not supported.
    /// 
    /// URL tags only support URLs wrapped by a URL tag, not URLs with a different title.
    /// 
    /// When printing to standard output, the supported subset of BBCode is converted to ANSI escape codes for the terminal emulator to display. Support for ANSI escape codes varies across terminal emulators, especially for italic and strikethrough. In standard output, `code` is represented with faint text but without any font change. Unsupported tags are left as-is in standard output.
    /// 
    /// > Note: Consider using ``pushError()`` and ``pushWarning()`` to print error and warning messages instead of ``print()`` or ``printRich()``. This distinguishes them from print messages used for debugging purposes, while also displaying a stack trace when an error or warning is printed.
    /// 
    /// > Note: On Windows, only Windows 10 and later correctly displays ANSI escape codes in standard output.
    /// 
    public static func printRich (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_print_rich (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_print_rich (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_printerr: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("printerr")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// Prints one or more arguments to strings in the best way possible to standard error line.
    /// 
    public static func printerr (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_printerr (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_printerr (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_printt: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("printt")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// Prints one or more arguments to the console with a tab between each argument.
    /// 
    public static func printt (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_printt (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_printt (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_prints: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("prints")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// Prints one or more arguments to the console with a space between each argument.
    /// 
    public static func prints (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_prints (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_prints (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_printraw: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("printraw")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// Prints one or more arguments to strings in the best way possible to the OS terminal. Unlike ``print()``, no newline is automatically added at the end.
    /// 
    public static func printraw (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_printraw (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_printraw (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_print_verbose: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("print_verbose")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// If verbose mode is enabled (``OS/isStdoutVerbose()`` returning `true`), converts one or more arguments of any type to string in the best way possible and prints them to the console.
    public static func printVerbose (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_print_verbose (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_print_verbose (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_push_error: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("push_error")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// Pushes an error message to Godot's built-in debugger and to the OS terminal.
    /// 
    /// > Note: This function does not pause project execution. To print an error message and pause project execution in debug builds, use `assert(false, "test error")` instead.
    /// 
    public static func pushError (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_push_error (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_push_error (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_push_warning: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("push_warning")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2648703342)!
        }
        
    }()
    
    /// Pushes a warning message to Godot's built-in debugger and to the OS terminal.
    /// 
    public static func pushWarning (arg1: Variant, _ arguments: Variant...) {
        var _result: Variant.ContentType = Variant.zero
        #if false
        
        let copy_arg1 = Variant (arg1)
        
        withArgPointers(&copy_arg1.content) { _args in
            method_push_warning (&_result, _args, Int32 (_args.count))
        }
        
        #else
        
        let copy_arg1 = Variant (arg1)
        var _args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_arg1.content) { p0 in
            _args.append (p0)
        
        let content = UnsafeMutableBufferPointer<Variant.ContentType>.allocate(capacity: arguments.count)
        defer { content.deallocate () }
        for idx in 0..<arguments.count {
            content [idx] = arguments [idx].content
            _args.append (content.baseAddress! + idx)
        }
        
            method_push_warning (&_result, &_args, Int32 (_args.count))
        }
        
        #endif
    }
    
    fileprivate static var method_var_to_str: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("var_to_str")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 866625479)!
        }
        
    }()
    
    /// Converts a ``Variant`` `variable` to a formatted ``String`` that can then be parsed using ``strToVar()``.
    /// 
    /// Prints:
    /// 
    /// > Note: Converting ``Signal`` or ``Callable`` is not supported and will result in an empty value for these types, regardless of their data.
    /// 
    public static func varToStr (variable: Variant)-> String {
        let _result = GString ()
        #if false
        
        
        withArgPointers(&variable.content) { _args in
            method_var_to_str (&_result.content, _args, Int32 (1))
        }
        return _result.description
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &variable.content) { p0 in
            _args.append (p0)
        
            method_var_to_str (&_result.content, &_args, Int32 (1))
            return _result.description
        }
        
        #endif
    }
    
    fileprivate static var method_str_to_var: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("str_to_var")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1891498491)!
        }
        
    }()
    
    /// Converts a formatted `string` that was returned by ``varToStr()`` to the original ``Variant``.
    /// 
    public static func strToVar (string: String)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        let gstr_string = GString (string)
        
        withArgPointers(&gstr_string.content) { _args in
            method_str_to_var (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        let gstr_string = GString (string)
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &gstr_string.content) { p0 in
            _args.append (p0)
        
            method_str_to_var (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_var_to_bytes: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("var_to_bytes")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2947269930)!
        }
        
    }()
    
    /// Encodes a ``Variant`` value to a byte array, without encoding objects. Deserialization can be done with ``bytesToVar()``.
    /// 
    /// > Note: If you need object serialization, see ``varToBytesWithObjects()``.
    /// 
    public static func varToBytes (variable: Variant)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        
        withArgPointers(&variable.content) { _args in
            method_var_to_bytes (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &variable.content) { p0 in
            _args.append (p0)
        
            method_var_to_bytes (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_bytes_to_var: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("bytes_to_var")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 4249819452)!
        }
        
    }()
    
    /// Decodes a byte array back to a ``Variant`` value, without decoding objects.
    /// 
    /// > Note: If you need object deserialization, see ``bytesToVarWithObjects()``.
    /// 
    public static func bytesToVar (bytes: PackedByteArray)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        withArgPointers(&bytes.content) { _args in
            method_bytes_to_var (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &bytes.content) { p0 in
            _args.append (p0)
        
            method_bytes_to_var (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_var_to_bytes_with_objects: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("var_to_bytes_with_objects")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2947269930)!
        }
        
    }()
    
    /// Encodes a ``Variant`` value to a byte array. Encoding objects is allowed (and can potentially include executable code). Deserialization can be done with ``bytesToVarWithObjects()``.
    public static func varToBytesWithObjects (variable: Variant)-> PackedByteArray {
        let _result: PackedByteArray = PackedByteArray ()
        #if false
        
        
        withArgPointers(&variable.content) { _args in
            method_var_to_bytes_with_objects (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &variable.content) { p0 in
            _args.append (p0)
        
            method_var_to_bytes_with_objects (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_bytes_to_var_with_objects: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("bytes_to_var_with_objects")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 4249819452)!
        }
        
    }()
    
    /// Decodes a byte array back to a ``Variant`` value. Decoding objects is allowed.
    /// 
    /// > Warning: Deserialized object can contain code which gets executed. Do not use this option if the serialized object comes from untrusted sources to avoid potential security threats (remote code execution).
    /// 
    public static func bytesToVarWithObjects (bytes: PackedByteArray)-> Variant {
        let _result: Variant = Variant ()
        #if false
        
        
        withArgPointers(&bytes.content) { _args in
            method_bytes_to_var_with_objects (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &bytes.content) { p0 in
            _args.append (p0)
        
            method_bytes_to_var_with_objects (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_hash: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("hash")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 326422594)!
        }
        
    }()
    
    /// Returns the integer hash of the passed `variable`.
    /// 
    public static func hash (variable: Variant)-> Int64 {
        var _result: Int64 = 0
        #if false
        
        
        withArgPointers(&variable.content) { _args in
            method_hash (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &variable.content) { p0 in
            _args.append (p0)
        
            method_hash (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_instance_from_id: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("instance_from_id")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1156694636)!
        }
        
    }()
    
    /// Returns the ``Object`` that corresponds to `instanceId`. All Objects have a unique instance ID. See also ``Object/getInstanceId()``.
    /// 
    public static func instanceFromId (instanceId: Int64)-> Object? {
        var _result = UnsafeRawPointer (bitPattern: 0)
        #if false
        
        var copy_instance_id = instanceId
        
        withArgPointers(&copy_instance_id) { _args in
            method_instance_from_id (&_result, _args, Int32 (1))
        }
        guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        #else
        
        var copy_instance_id = instanceId
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_instance_id) { p0 in
            _args.append (p0)
        
            method_instance_from_id (&_result, &_args, Int32 (1))
            guard let _result else { return nil } ; return lookupObject (nativeHandle: _result)!
        }
        
        #endif
    }
    
    fileprivate static var method_is_instance_id_valid: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("is_instance_id_valid")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 2232439758)!
        }
        
    }()
    
    /// Returns `true` if the Object that corresponds to `id` is a valid object (e.g. has not been deleted from memory). All Objects have a unique instance ID.
    public static func isInstanceIdValid (id: Int64)-> Bool {
        var _result: Bool = false
        #if false
        
        var copy_id = id
        
        withArgPointers(&copy_id) { _args in
            method_is_instance_id_valid (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_id = id
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_id) { p0 in
            _args.append (p0)
        
            method_is_instance_id_valid (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_instance_valid: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("is_instance_valid")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 996128841)!
        }
        
    }()
    
    /// Returns `true` if `instance` is a valid Object (e.g. has not been deleted from memory).
    public static func isInstanceValid (instance: Variant)-> Bool {
        var _result: Bool = false
        #if false
        
        
        withArgPointers(&instance.content) { _args in
            method_is_instance_valid (&_result, _args, Int32 (1))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &instance.content) { p0 in
            _args.append (p0)
        
            method_is_instance_valid (&_result, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_rid_allocate_id: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("rid_allocate_id")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 701202648)!
        }
        
    }()
    
    /// Allocates a unique ID which can be used by the implementation to construct a RID. This is used mainly from native extensions to implement servers.
    public static func ridAllocateId ()-> Int64 {
        var _result: Int64 = 0
        method_rid_allocate_id (&_result, nil, Int32 (0))
        return _result
    }
    
    fileprivate static var method_rid_from_int64: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("rid_from_int64")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 3426892196)!
        }
        
    }()
    
    /// Creates a RID from a `base`. This is used mainly from native extensions to build servers.
    public static func ridFromInt64 (base: Int64)-> RID {
        let _result: RID = RID ()
        #if false
        
        var copy_base = base
        
        withArgPointers(&copy_base) { _args in
            method_rid_from_int64 (&_result.content, _args, Int32 (1))
        }
        return _result
        #else
        
        var copy_base = base
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_base) { p0 in
            _args.append (p0)
        
            method_rid_from_int64 (&_result.content, &_args, Int32 (1))
            return _result
        }
        
        #endif
    }
    
    fileprivate static var method_is_same: GDExtensionPtrUtilityFunction = {
        let methodName = StringName ("is_same")
        return withUnsafePointer (to: &methodName.content) { ptr in
            return gi.variant_get_ptr_utility_function (ptr, 1409423524)!
        }
        
    }()
    
    /// Returns `true`, for value types, if `a` and `b` share the same value. Returns `true`, for reference types, if the references of `a` and `b` are the same.
    /// 
    /// These are ``Variant`` value types: `null`, [bool], integer, float, ``String``, ``StringName``, ``Vector2``, ``Vector2i``, ``Vector3``, ``Vector3i``, ``Vector4``, ``Vector4i``, ``Rect2``, ``Rect2i``, ``Transform2D``, ``Transform3D``, ``Plane``, ``Quaternion``, ``AABB``, ``Basis``, ``Projection``, ``Color``, ``NodePath``, ``RID``, ``Callable`` and ``Signal``.
    /// 
    /// These are ``Variant`` reference types: ``Object``, ``GDictionary``, ``GArray``, ``PackedByteArray``, ``PackedInt32Array``, ``PackedInt64Array``, ``PackedFloat32Array``, ``PackedFloat64Array``, ``PackedStringArray``, ``PackedVector2Array``, ``PackedVector3Array`` and ``PackedColorArray``.
    /// 
    public static func isSame (a: Variant, b: Variant)-> Bool {
        var _result: Bool = false
        #if false
        
        
        withArgPointers(&a.content, &b.content) { _args in
            method_is_same (&_result, _args, Int32 (2))
        }
        return _result
        #else
        
        var _args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &a.content) { p0 in
            _args.append (p0)
            return withUnsafePointer (to: &b.content) { p1 in
                _args.append (p1)
        
                method_is_same (&_result, &_args, Int32 (2))
                return _result
            }
        }
        
        #endif
    }
    
}

