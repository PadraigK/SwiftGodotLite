// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A pre-parsed scene tree path.
/// 
/// A pre-parsed relative or absolute path in a scene tree, for use with ``Node/getNode(path:)`` and similar functions. It can reference a node, a resource within a node, or a property of a node or resource. For example, `"Path2D/PathFollow2D/Sprite2D:texture:size"` would refer to the `size` property of the `texture` resource on the node named `"Sprite2D"`, which is a child of the other named nodes in the path.
/// 
/// You will usually just pass a string to ``Node/getNode(path:)`` and it will be automatically converted, but you may occasionally want to parse a path ahead of time with ``NodePath`` or the literal syntax `^"path"`. Exporting a ``NodePath`` variable will give you a node selection widget in the properties panel of the editor, which can often be useful.
/// 
/// A ``NodePath`` is composed of a list of slash-separated node names (like a filesystem path) and an optional colon-separated list of "subnames" which can be resources or properties.
/// 
/// Some examples of NodePaths include the following:
/// 
/// See also ``StringName``, which is a similar concept for general-purpose string interning.
/// 
/// > Note: In the editor, ``NodePath`` properties are automatically updated when moving, renaming or deleting a node in the scene tree, but they are never updated at runtime.
/// 
/// > Note: In a boolean context, a ``NodePath`` will evaluate to `false` if it is empty (`NodePath("")`). Otherwise, a ``NodePath`` will always evaluate to `true`.
/// 
public class NodePath: Equatable, ExpressibleByStringLiteral, ExpressibleByStringInterpolation, LosslessStringConvertible {
    // ExpressibleByStringLiteral conformace
    public required init (stringLiteral value: String) {
        let from = GString (value)
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &from.content) { ptr in
            args.append (ptr)
            NodePath.constructor2 (&content, &args)
        }
        
    }
    
    // LosslessStringConvertible conformance)
    public required init (_ value: String) {
        let from = GString (value)
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &from.content) { ptr in
            args.append (ptr)
            NodePath.constructor2 (&content, &args)
        }
        
    }
    
    /// Produces a string representation of this NodePath
    public var description: String {
        let sub = getSubnameCount () > 0 ? getConcatenatedSubnames ().description : ""
        return (isAbsolute() ? "/" : "") + (getNameCount () > 0 ? getConcatenatedNames ().description : "") + (sub == "" ? sub : ":\(sub)")
    }
    
    static var destructor: GDExtensionPtrDestructor = {
        return gi.variant_get_ptr_destructor (GDEXTENSION_VARIANT_TYPE_NODE_PATH)!
    }()
    
    deinit {
        if content != NodePath.zero {
            NodePath.destructor (&content)
        }
        
    }
    
    // Contains a binary blob where this type information is stored
    public var content: ContentType = 0
    // Used to initialize empty types
    public static let zero: ContentType  = 0
    // Convenience type that matches the build configuration storage needs
    public typealias ContentType = Int64
    // Used to construct objects on virtual proxies
    public required init (content: ContentType) {
        var copy = content
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy) { ptr in
            args.append (ptr)
            NodePath.constructor1 (&self.content, &args)
        }
        
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_NODE_PATH, 0)!
    
    /// Constructs an empty ``NodePath``.
    public required init () {
        NodePath.constructor0 (&content, nil)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_NODE_PATH, 1)!
    
    /// Constructs a ``NodePath`` as a copy of the given ``NodePath``. `NodePath("example")` is equivalent to `^"example"`.
    public init (from: NodePath) {
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &from.content) { p0 in
            args.append (p0)
        
            NodePath.constructor1 (&content, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_NODE_PATH, 2)!
    
    /// Creates a NodePath from a string, e.g. `"Path2D/PathFollow2D/Sprite2D:texture:size"`. A path is absolute if it starts with a slash. Absolute paths are only valid in the global scene tree, not within individual scenes. In a relative path, `"."` and `".."` indicate the current node and its parent.
    /// 
    /// The "subnames" optionally included after the path to the target node can point to resources or properties, and can also be nested.
    /// 
    /// Examples of valid NodePaths (assuming that those nodes exist and have the referenced resources or properties):
    /// 
    public init (from: String) {
        let gstr_from = GString (from)
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &gstr_from.content) { p0 in
            args.append (p0)
        
            NodePath.constructor2 (&content, &args)
        }
    }
    
    
    /* Methods */
    
    static var method_is_absolute: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_absolute")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the node path is absolute (as opposed to relative), which means that it starts with a slash character (`/`). Absolute node paths can be used to access the root node (`"/root"`) or autoloads (e.g. `"/global"` if a "global" autoload was registered).
    public final func isAbsolute ()-> Bool {
        var result: Bool = Bool()
        NodePath.method_is_absolute (&content, nil, &result, 0)
        return result
    }
    
    static var method_get_name_count: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_name_count")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 3173160232)!
    }()
    
    /// Gets the number of node names which make up the path. Subnames (see ``getSubnameCount()``) are not included.
    /// 
    /// For example, `"Path2D/PathFollow2D/Sprite2D"` has 3 names.
    /// 
    public final func getNameCount ()-> Int64 {
        var result: Int64 = Int64()
        NodePath.method_get_name_count (&content, nil, &result, 0)
        return result
    }
    
    static var method_get_name: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_name")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 2948586938)!
    }()
    
    /// Gets the node name indicated by `idx` (0 to ``getNameCount()`` - 1).
    /// 
    public final func getName (idx: Int64)-> StringName {
        let result: StringName = StringName()
        var copy_idx = idx
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            args.append (p0)
        
            NodePath.method_get_name (&content, &args, &result.content, 1)
            return result
        }
    }
    
    static var method_get_subname_count: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_subname_count")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 3173160232)!
    }()
    
    /// Gets the number of resource or property names ("subnames") in the path. Each subname is listed after a colon character (`:`) in the node path.
    /// 
    /// For example, `"Path2D/PathFollow2D/Sprite2D:texture:load_path"` has 2 subnames.
    /// 
    public final func getSubnameCount ()-> Int64 {
        var result: Int64 = Int64()
        NodePath.method_get_subname_count (&content, nil, &result, 0)
        return result
    }
    
    static var method_hash: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("hash")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 3173160232)!
    }()
    
    /// Returns the 32-bit hash value representing the ``NodePath``'s contents.
    public final func hash ()-> Int64 {
        var result: Int64 = Int64()
        NodePath.method_hash (&content, nil, &result, 0)
        return result
    }
    
    static var method_get_subname: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_subname")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 2948586938)!
    }()
    
    /// Gets the resource or property name indicated by `idx` (0 to ``getSubnameCount()`` - 1).
    /// 
    public final func getSubname (idx: Int64)-> StringName {
        let result: StringName = StringName()
        var copy_idx = idx
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            args.append (p0)
        
            NodePath.method_get_subname (&content, &args, &result.content, 1)
            return result
        }
    }
    
    static var method_get_concatenated_names: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_concatenated_names")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 1825232092)!
    }()
    
    /// Returns all paths concatenated with a slash character (`/`) as separator without subnames.
    public final func getConcatenatedNames ()-> StringName {
        let result: StringName = StringName()
        NodePath.method_get_concatenated_names (&content, nil, &result.content, 0)
        return result
    }
    
    static var method_get_concatenated_subnames: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_concatenated_subnames")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 1825232092)!
    }()
    
    /// Returns all subnames concatenated with a colon character (`:`) as separator, i.e. the right side of the first colon in a node path.
    /// 
    public final func getConcatenatedSubnames ()-> StringName {
        let result: StringName = StringName()
        NodePath.method_get_concatenated_subnames (&content, nil, &result.content, 0)
        return result
    }
    
    static var method_get_as_property_path: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_as_property_path")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 1598598043)!
    }()
    
    /// Returns a node path with a colon character (`:`) prepended, transforming it to a pure property path with no node name (defaults to resolving from the current node).
    /// 
    public final func getAsPropertyPath ()-> NodePath {
        let result: NodePath = NodePath()
        NodePath.method_get_as_property_path (&content, nil, &result.content, 0)
        return result
    }
    
    static var method_is_empty: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_empty")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_NODE_PATH, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the node path is empty.
    public final func isEmpty ()-> Bool {
        var result: Bool = Bool()
        NodePath.method_is_empty (&content, nil, &result, 0)
        return result
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_NODE_PATH, GDEXTENSION_VARIANT_TYPE_NODE_PATH)!
    }()
    
    /// Returns `true` if two node paths are equal, i.e. all node names in the path are the same and in the same order.
    public static func == (lhs: NodePath, rhs: NodePath) -> Bool  {
        var result: Bool = Bool()
        
        NodePath.operator_3 (&lhs.content, &rhs.content, &result)
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_NODE_PATH, GDEXTENSION_VARIANT_TYPE_NODE_PATH)!
    }()
    
    /// Returns `true` if two node paths are not equal.
    public static func != (lhs: NodePath, rhs: NodePath) -> Bool  {
        var result: Bool = Bool()
        
        NodePath.operator_4 (&lhs.content, &rhs.content, &result)
        return result
    }
    
}

