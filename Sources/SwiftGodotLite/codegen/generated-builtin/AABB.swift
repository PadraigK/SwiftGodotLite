// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A 3D axis-aligned bounding box.
/// 
/// ``AABB`` consists of a position, a size, and several utility functions. It is typically used for fast overlap tests.
/// 
/// It uses floating-point coordinates. The 2D counterpart to ``AABB`` is ``Rect2``.
/// 
/// Negative values for ``size`` are not supported and will not work for most methods. Use ``abs()`` to get an AABB with a positive size.
/// 
/// > Note: Unlike ``Rect2``, ``AABB`` does not have a variant that uses integer coordinates.
/// 
public struct AABB: Equatable, Hashable {
    /// Beginning corner. Typically has values lower than ``end``.
    public var position: Vector3
    /// Size from ``position`` to ``end``. Typically, all components are positive.
    /// 
    /// If the size is negative, you can use ``abs()`` to fix it.
    /// 
    public var size: Vector3
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_AABB, 0)!
    
    /// Constructs a default-initialized ``AABB`` with default (zero) values of ``position`` and ``size``.
    public init () {
        self.position = Vector3 ()
        self.size = Vector3 ()
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_AABB, 1)!
    
    /// Constructs an ``AABB`` as a copy of the given ``AABB``.
    public init (from: AABB) {
        self.position = Vector3 ()
        self.size = Vector3 ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            AABB.constructor1 (&self, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_AABB, 2)!
    
    /// Constructs an ``AABB`` from a position and size.
    public init (position: Vector3, size: Vector3) {
        self.position = position
        self.size = size
    }
    
    
    /* Methods */
    
    static var method_abs: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("abs")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1576868580)!
    }()
    
    /// Returns an AABB with equivalent position and size, modified so that the most-negative corner is the origin and the size is positive.
    public func abs ()-> AABB {
        var result: AABB = AABB()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_abs (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_center: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_center")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1776574132)!
    }()
    
    /// Returns the center of the ``AABB``, which is equal to ``position`` + (``size`` / 2).
    public func getCenter ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_get_center (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_volume: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_volume")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 466405837)!
    }()
    
    /// Returns the volume of the ``AABB``.
    public func getVolume ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_get_volume (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_has_volume: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("has_volume")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the ``AABB`` has a volume, and `false` if the ``AABB`` is flat, empty, or has a negative ``size``.
    public func hasVolume ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_has_volume (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_has_surface: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("has_surface")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the ``AABB`` has a surface or a length, and `false` if the ``AABB`` is empty (all components of ``size`` are zero or negative).
    public func hasSurface ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_has_surface (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_has_point: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("has_point")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1749054343)!
    }()
    
    /// Returns `true` if the ``AABB`` contains a point. Points on the faces of the AABB are considered included, though float-point precision errors may impact the accuracy of such checks.
    /// 
    /// > Note: This method is not reliable for ``AABB`` with a _negative size_. Use ``abs()`` to get a positive sized equivalent ``AABB`` to check for contained points.
    /// 
    public func hasPoint (_ point: Vector3)-> Bool {
        var result: Bool = Bool()
        var copy_point = point
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_point) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_has_point (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 299946684)!
    }()
    
    /// Returns `true` if this ``AABB`` and `aabb` are approximately equal, by calling ``@GlobalScope.is_equal_approx`` on each component.
    public func isEqualApprox (aabb: AABB)-> Bool {
        var result: Bool = Bool()
        var copy_aabb = aabb
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_aabb) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_is_equal_approx (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this ``AABB`` is finite, by calling ``@GlobalScope.is_finite`` on each component.
    public func isFinite ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_is_finite (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_intersects: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("intersects")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 299946684)!
    }()
    
    /// Returns `true` if the ``AABB`` overlaps with another.
    public func intersects (with: AABB)-> Bool {
        var result: Bool = Bool()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_intersects (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_encloses: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("encloses")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 299946684)!
    }()
    
    /// Returns `true` if this ``AABB`` completely encloses another one.
    public func encloses (with: AABB)-> Bool {
        var result: Bool = Bool()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_encloses (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_intersects_plane: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("intersects_plane")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1150170233)!
    }()
    
    /// Returns `true` if the ``AABB`` is on both sides of a plane.
    public func intersectsPlane (_ plane: Plane)-> Bool {
        var result: Bool = Bool()
        var copy_plane = plane
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_plane) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_intersects_plane (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_intersection: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("intersection")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1271470306)!
    }()
    
    /// Returns the intersection between two ``AABB``. An empty AABB (size `(0, 0, 0)`) is returned on failure.
    public func intersection (with: AABB)-> AABB {
        var result: AABB = AABB()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_intersection (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_merge: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("merge")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1271470306)!
    }()
    
    /// Returns a larger ``AABB`` that contains both this ``AABB`` and `with`.
    public func merge (with: AABB)-> AABB {
        var result: AABB = AABB()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_merge (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_expand: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("expand")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 2851643018)!
    }()
    
    /// Returns a copy of this ``AABB`` expanded to include a given point.
    /// 
    /// **Example:**
    /// 
    public func expand (toPoint: Vector3)-> AABB {
        var result: AABB = AABB()
        var copy_to_point = toPoint
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to_point) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_expand (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_grow: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("grow")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 239217291)!
    }()
    
    /// Returns a copy of the ``AABB`` grown a given number of units towards all the sides.
    public func grow (by: Double)-> AABB {
        var result: AABB = AABB()
        var copy_by = Double (by)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_by) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_grow (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_get_support: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_support")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 2923479887)!
    }()
    
    /// Returns the vertex of the AABB that's the farthest in a given direction. This point is commonly known as the support point in collision detection algorithms.
    public func getSupport (dir: Vector3)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_dir = dir
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_dir) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_get_support (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_get_longest_axis: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_longest_axis")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1776574132)!
    }()
    
    /// Returns the normalized longest axis of the ``AABB``.
    public func getLongestAxis ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_get_longest_axis (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_longest_axis_index: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_longest_axis_index")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 3173160232)!
    }()
    
    /// Returns the index of the longest axis of the ``AABB`` (according to ``Vector3``'s `AXIS_*` constants).
    public func getLongestAxisIndex ()-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_get_longest_axis_index (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_longest_axis_size: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_longest_axis_size")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 466405837)!
    }()
    
    /// Returns the scalar length of the longest axis of the ``AABB``.
    public func getLongestAxisSize ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_get_longest_axis_size (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_shortest_axis: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_shortest_axis")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1776574132)!
    }()
    
    /// Returns the normalized shortest axis of the ``AABB``.
    public func getShortestAxis ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_get_shortest_axis (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_shortest_axis_index: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_shortest_axis_index")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 3173160232)!
    }()
    
    /// Returns the index of the shortest axis of the ``AABB`` (according to ``Vector3``::AXIS* enum).
    public func getShortestAxisIndex ()-> Int64 {
        var result: Int64 = Int64()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_get_shortest_axis_index (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_shortest_axis_size: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_shortest_axis_size")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 466405837)!
    }()
    
    /// Returns the scalar length of the shortest axis of the ``AABB``.
    public func getShortestAxisSize ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            AABB.method_get_shortest_axis_size (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_endpoint: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_endpoint")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 1394941017)!
    }()
    
    /// Gets the position of the 8 endpoints of the ``AABB`` in space.
    public func getEndpoint (idx: Int64)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_idx = idx
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_idx) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                AABB.method_get_endpoint (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_intersects_segment: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("intersects_segment")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 2048133369)!
    }()
    
    /// Returns the point of intersection between `from` and `to` with this ``AABB`` or `null` if there is no intersection.
    public func intersectsSegment (from: Vector3, to: Vector3)-> Variant {
        let result: Variant = Variant()
        var copy_from = from
        var copy_to = to
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_to) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    AABB.method_intersects_segment (UnsafeMutableRawPointer (mutating: ptr), &args, &result.content, 2)
                }
                return result
            }
        }
    }
    
    static var method_intersects_ray: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("intersects_ray")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_AABB, &name.content, 2048133369)!
    }()
    
    /// Returns the point of intersection of the given ray with this ``AABB`` or `null` if there is no intersection. Ray length is infinite.
    public func intersectsRay (from: Vector3, dir: Vector3)-> Variant {
        let result: Variant = Variant()
        var copy_from = from
        var copy_dir = dir
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_dir) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    AABB.method_intersects_ray (UnsafeMutableRawPointer (mutating: ptr), &args, &result.content, 2)
                }
                return result
            }
        }
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_AABB, GDEXTENSION_VARIANT_TYPE_AABB)!
    }()
    
    /// Returns `true` if the AABBs are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(aabb:)`` instead, which is more reliable.
    /// 
    public static func == (lhs: AABB, rhs: AABB) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        AABB.operator_3 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_AABB, GDEXTENSION_VARIANT_TYPE_AABB)!
    }()
    
    /// Returns `true` if the AABBs are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(aabb:)`` instead, which is more reliable.
    /// 
    public static func != (lhs: AABB, rhs: AABB) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        AABB.operator_4 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_AABB, GDEXTENSION_VARIANT_TYPE_TRANSFORM3D)!
    }()
    
    /// Inversely transforms (multiplies) the ``AABB`` by the given ``Transform3D`` transformation matrix, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).
    /// 
    /// `aabb * transform` is equivalent to `transform.inverse() * aabb`. See ``Transform3D/inverse()``.
    /// 
    /// For transforming by inverse of an affine transformation (e.g. with scaling) `transform.affine_inverse() * aabb` can be used instead. See ``Transform3D/affineInverse()``.
    /// 
    public static func * (lhs: AABB, rhs: Transform3D) -> AABB  {
        var result: AABB = AABB()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        AABB.operator_5 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    /// Ending corner. This is calculated as `position + size`. Setting this value will change the size.
    public var end: Vector3 {
        set {
            size = newValue - position
        }
        
        get {
            position + size
        }
        
    }
    
}

