// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A 4Ã—4 matrix for 3D projective transformations.
/// 
/// A 4x4 matrix used for 3D projective transformations. It can represent transformations such as translation, rotation, scaling, shearing, and perspective division. It consists of four ``Vector4`` columns.
/// 
/// For purely linear transformations (translation, rotation, and scale), it is recommended to use ``Transform3D``, as it is more performant and requires less memory.
/// 
/// Used internally as ``Camera3D``'s projection matrix.
/// 
public struct Projection: Equatable, Hashable {
    /// The projection matrix's X vector (column 0). Equivalent to array index `0`.
    public var x: Vector4
    /// The projection matrix's Y vector (column 1). Equivalent to array index `1`.
    public var y: Vector4
    /// The projection matrix's Z vector (column 2). Equivalent to array index `2`.
    public var z: Vector4
    /// The projection matrix's W vector (column 3). Equivalent to array index `3`.
    public var w: Vector4
    public enum Planes: Int64 {
        /// The index value of the projection's near clipping plane.
        case near = 0 // PLANE_NEAR
        /// The index value of the projection's far clipping plane.
        case far = 1 // PLANE_FAR
        /// The index value of the projection's left clipping plane.
        case left = 2 // PLANE_LEFT
        /// The index value of the projection's top clipping plane.
        case top = 3 // PLANE_TOP
        /// The index value of the projection's right clipping plane.
        case right = 4 // PLANE_RIGHT
        /// The index value of the projection bottom clipping plane.
        case bottom = 5 // PLANE_BOTTOM
    }
    
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PROJECTION, 0)!
    
    /// Constructs a default-initialized ``Projection`` set to ``IDENTITY``.
    public init () {
        self.x = Vector4 (x: 1, y: 0, z: 0, w: 0)
        self.y = Vector4 (x: 0, y: 1, z: 0, w: 0)
        self.z = Vector4 (x: 0, y: 0, z: 1, w: 0)
        self.w = Vector4 (x: 0, y: 0, z: 0, w: 1)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PROJECTION, 1)!
    
    /// Constructs a ``Projection`` as a copy of the given ``Projection``.
    public init (from: Projection) {
        self.x = Vector4 ()
        self.y = Vector4 ()
        self.z = Vector4 ()
        self.w = Vector4 ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Projection.constructor1 (&self, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PROJECTION, 2)!
    
    /// Constructs a Projection as a copy of the given ``Transform3D``.
    public init (from: Transform3D) {
        self.x = Vector4 ()
        self.y = Vector4 ()
        self.z = Vector4 ()
        self.w = Vector4 ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Projection.constructor2 (&self, &args)
        }
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_PROJECTION, 3)!
    
    /// Constructs a Projection from four ``Vector4`` values (matrix columns).
    public init (xAxis: Vector4, yAxis: Vector4, zAxis: Vector4, wAxis: Vector4) {
        self.x = xAxis
        self.y = yAxis
        self.z = zAxis
        self.w = wAxis
    }
    
    
    /* Methods */
    
    static var method_create_depth_correction: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_depth_correction")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 1228516048)!
    }()
    
    /// Creates a new ``Projection`` that projects positions from a depth range of `-1` to `1` to one that ranges from `0` to `1`, and flips the projected positions vertically, according to `flipY`.
    public static func createDepthCorrection (flipY: Bool)-> Projection {
        var result: Projection = Projection()
        var copy_flip_y = flipY
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_flip_y) { p0 in
            args.append (p0)
        
            Projection.method_create_depth_correction (nil, &args, &result, 1)
            return result
        }
    }
    
    static var method_create_light_atlas_rect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_light_atlas_rect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2654950662)!
    }()
    
    /// Creates a new ``Projection`` that projects positions into the given ``Rect2``.
    public static func createLightAtlasRect (_ rect: Rect2)-> Projection {
        var result: Projection = Projection()
        var copy_rect = rect
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_rect) { p0 in
            args.append (p0)
        
            Projection.method_create_light_atlas_rect (nil, &args, &result, 1)
            return result
        }
    }
    
    static var method_create_perspective: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_perspective")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 390915442)!
    }()
    
    /// Creates a new ``Projection`` that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping planes.
    /// 
    /// `flipFov` determines whether the projection's field of view is flipped over its diagonal.
    /// 
    public static func createPerspective (fovy: Double, aspect: Double, zNear: Double, zFar: Double, flipFov: Bool = false)-> Projection {
        var result: Projection = Projection()
        var copy_fovy = Double (fovy)
        var copy_aspect = Double (aspect)
        var copy_z_near = Double (zNear)
        var copy_z_far = Double (zFar)
        var copy_flip_fov = flipFov
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_fovy) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_aspect) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_z_near) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_z_far) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_flip_fov) { p4 in
                            args.append (p4)
        
                            Projection.method_create_perspective (nil, &args, &result, 5)
                            return result
                        }
                    }
                }
            }
        }
    }
    
    static var method_create_perspective_hmd: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_perspective_hmd")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2857674800)!
    }()
    
    /// Creates a new ``Projection`` that projects positions using a perspective projection with the given Y-axis field of view (in degrees), X:Y aspect ratio, and clipping distances. The projection is adjusted for a head-mounted display with the given distance between eyes and distance to a point that can be focused on.
    /// 
    /// `eye` creates the projection for the left eye when set to 1, or the right eye when set to 2.
    /// 
    /// `flipFov` determines whether the projection's field of view is flipped over its diagonal.
    /// 
    public static func createPerspectiveHmd (fovy: Double, aspect: Double, zNear: Double, zFar: Double, flipFov: Bool, eye: Int64, intraocularDist: Double, convergenceDist: Double)-> Projection {
        var result: Projection = Projection()
        var copy_fovy = Double (fovy)
        var copy_aspect = Double (aspect)
        var copy_z_near = Double (zNear)
        var copy_z_far = Double (zFar)
        var copy_flip_fov = flipFov
        var copy_eye = eye
        var copy_intraocular_dist = Double (intraocularDist)
        var copy_convergence_dist = Double (convergenceDist)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_fovy) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_aspect) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_z_near) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_z_far) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_flip_fov) { p4 in
                            args.append (p4)
                            return withUnsafePointer (to: &copy_eye) { p5 in
                                args.append (p5)
                                return withUnsafePointer (to: &copy_intraocular_dist) { p6 in
                                    args.append (p6)
                                    return withUnsafePointer (to: &copy_convergence_dist) { p7 in
                                        args.append (p7)
        
                                        Projection.method_create_perspective_hmd (nil, &args, &result, 8)
                                        return result
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    static var method_create_for_hmd: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_for_hmd")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 4184144994)!
    }()
    
    /// Creates a new ``Projection`` for projecting positions onto a head-mounted display with the given X:Y aspect ratio, distance between eyes, display width, distance to lens, oversampling factor, and depth clipping planes.
    /// 
    /// `eye` creates the projection for the left eye when set to 1, or the right eye when set to 2.
    /// 
    public static func createForHmd (eye: Int64, aspect: Double, intraocularDist: Double, displayWidth: Double, displayToLens: Double, oversample: Double, zNear: Double, zFar: Double)-> Projection {
        var result: Projection = Projection()
        var copy_eye = eye
        var copy_aspect = Double (aspect)
        var copy_intraocular_dist = Double (intraocularDist)
        var copy_display_width = Double (displayWidth)
        var copy_display_to_lens = Double (displayToLens)
        var copy_oversample = Double (oversample)
        var copy_z_near = Double (zNear)
        var copy_z_far = Double (zFar)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_eye) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_aspect) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_intraocular_dist) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_display_width) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_display_to_lens) { p4 in
                            args.append (p4)
                            return withUnsafePointer (to: &copy_oversample) { p5 in
                                args.append (p5)
                                return withUnsafePointer (to: &copy_z_near) { p6 in
                                    args.append (p6)
                                    return withUnsafePointer (to: &copy_z_far) { p7 in
                                        args.append (p7)
        
                                        Projection.method_create_for_hmd (nil, &args, &result, 8)
                                        return result
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    static var method_create_orthogonal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_orthogonal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3707929169)!
    }()
    
    /// Creates a new ``Projection`` that projects positions using an orthogonal projection with the given clipping planes.
    public static func createOrthogonal (left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double)-> Projection {
        var result: Projection = Projection()
        var copy_left = Double (left)
        var copy_right = Double (right)
        var copy_bottom = Double (bottom)
        var copy_top = Double (top)
        var copy_z_near = Double (zNear)
        var copy_z_far = Double (zFar)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_left) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_right) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_bottom) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_top) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_z_near) { p4 in
                            args.append (p4)
                            return withUnsafePointer (to: &copy_z_far) { p5 in
                                args.append (p5)
        
                                Projection.method_create_orthogonal (nil, &args, &result, 6)
                                return result
                            }
                        }
                    }
                }
            }
        }
    }
    
    static var method_create_orthogonal_aspect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_orthogonal_aspect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 390915442)!
    }()
    
    /// Creates a new ``Projection`` that projects positions using an orthogonal projection with the given size, X:Y aspect ratio, and clipping planes.
    /// 
    /// `flipFov` determines whether the projection's field of view is flipped over its diagonal.
    /// 
    public static func createOrthogonalAspect (size: Double, aspect: Double, zNear: Double, zFar: Double, flipFov: Bool = false)-> Projection {
        var result: Projection = Projection()
        var copy_size = Double (size)
        var copy_aspect = Double (aspect)
        var copy_z_near = Double (zNear)
        var copy_z_far = Double (zFar)
        var copy_flip_fov = flipFov
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_size) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_aspect) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_z_near) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_z_far) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_flip_fov) { p4 in
                            args.append (p4)
        
                            Projection.method_create_orthogonal_aspect (nil, &args, &result, 5)
                            return result
                        }
                    }
                }
            }
        }
    }
    
    static var method_create_frustum: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_frustum")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3707929169)!
    }()
    
    /// Creates a new ``Projection`` that projects positions in a frustum with the given clipping planes.
    public static func createFrustum (left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double)-> Projection {
        var result: Projection = Projection()
        var copy_left = Double (left)
        var copy_right = Double (right)
        var copy_bottom = Double (bottom)
        var copy_top = Double (top)
        var copy_z_near = Double (zNear)
        var copy_z_far = Double (zFar)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_left) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_right) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_bottom) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_top) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_z_near) { p4 in
                            args.append (p4)
                            return withUnsafePointer (to: &copy_z_far) { p5 in
                                args.append (p5)
        
                                Projection.method_create_frustum (nil, &args, &result, 6)
                                return result
                            }
                        }
                    }
                }
            }
        }
    }
    
    static var method_create_frustum_aspect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_frustum_aspect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 1535076251)!
    }()
    
    /// Creates a new ``Projection`` that projects positions in a frustum with the given size, X:Y aspect ratio, offset, and clipping planes.
    /// 
    /// `flipFov` determines whether the projection's field of view is flipped over its diagonal.
    /// 
    public static func createFrustumAspect (size: Double, aspect: Double, offset: Vector2, zNear: Double, zFar: Double, flipFov: Bool = false)-> Projection {
        var result: Projection = Projection()
        var copy_size = Double (size)
        var copy_aspect = Double (aspect)
        var copy_offset = offset
        var copy_z_near = Double (zNear)
        var copy_z_far = Double (zFar)
        var copy_flip_fov = flipFov
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_size) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_aspect) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_offset) { p2 in
                    args.append (p2)
                    return withUnsafePointer (to: &copy_z_near) { p3 in
                        args.append (p3)
                        return withUnsafePointer (to: &copy_z_far) { p4 in
                            args.append (p4)
                            return withUnsafePointer (to: &copy_flip_fov) { p5 in
                                args.append (p5)
        
                                Projection.method_create_frustum_aspect (nil, &args, &result, 6)
                                return result
                            }
                        }
                    }
                }
            }
        }
    }
    
    static var method_create_fit_aabb: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("create_fit_aabb")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2264694907)!
    }()
    
    /// Creates a new ``Projection`` that scales a given projection to fit around a given ``AABB`` in projection space.
    public static func createFitAabb (_ aabb: AABB)-> Projection {
        var result: Projection = Projection()
        var copy_aabb = aabb
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_aabb) { p0 in
            args.append (p0)
        
            Projection.method_create_fit_aabb (nil, &args, &result, 1)
            return result
        }
    }
    
    static var method_determinant: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("determinant")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns a scalar value that is the signed factor by which areas are scaled by this matrix. If the sign is negative, the matrix flips the orientation of the area.
    /// 
    /// The determinant can be used to calculate the invertibility of a matrix or solve linear systems of equations involving the matrix, among other applications.
    /// 
    public func determinant ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_determinant (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_perspective_znear_adjusted: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("perspective_znear_adjusted")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3584785443)!
    }()
    
    /// Returns a ``Projection`` with the near clipping distance adjusted to be `newZnear`.
    /// 
    /// > Note: The original ``Projection`` must be a perspective projection.
    /// 
    public func perspectiveZnearAdjusted (newZnear: Double)-> Projection {
        var result: Projection = Projection()
        var copy_new_znear = Double (newZnear)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_new_znear) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Projection.method_perspective_znear_adjusted (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_get_projection_plane: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_projection_plane")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 1551184160)!
    }()
    
    /// Returns the clipping plane of this ``Projection`` whose index is given by `plane`.
    /// 
    /// `plane` should be equal to one of .planeNear, .planeFar, .planeLeft, .planeTop, .planeRight, or .planeBottom.
    /// 
    public func getProjectionPlane (_ plane: Int64)-> Plane {
        var result: Plane = Plane()
        var copy_plane = plane
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_plane) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Projection.method_get_projection_plane (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_flipped_y: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("flipped_y")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 4212530932)!
    }()
    
    /// Returns a copy of this ``Projection`` with the signs of the values of the Y column flipped.
    public func flippedY ()-> Projection {
        var result: Projection = Projection()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_flipped_y (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_jitter_offseted: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("jitter_offseted")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2448438599)!
    }()
    
    /// Returns a ``Projection`` with the X and Y values from the given ``Vector2`` added to the first and second values of the final column respectively.
    public func jitterOffseted (offset: Vector2)-> Projection {
        var result: Projection = Projection()
        var copy_offset = offset
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_offset) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Projection.method_jitter_offseted (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_get_fovy: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_fovy")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3514207532)!
    }()
    
    /// Returns the vertical field of view of the projection (in degrees) associated with the given horizontal field of view (in degrees) and aspect ratio.
    public static func getFovy (fovx: Double, aspect: Double)-> Double {
        var result: Double = Double()
        var copy_fovx = Double (fovx)
        var copy_aspect = Double (aspect)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_fovx) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_aspect) { p1 in
                args.append (p1)
        
                Projection.method_get_fovy (nil, &args, &result, 2)
                return result
            }
        }
    }
    
    static var method_get_z_far: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_z_far")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the distance for this ``Projection`` beyond which positions are clipped.
    public func getZFar ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_get_z_far (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_z_near: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_z_near")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the distance for this ``Projection`` before which positions are clipped.
    public func getZNear ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_get_z_near (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_aspect: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_aspect")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the X:Y aspect ratio of this ``Projection``'s viewport.
    public func getAspect ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_get_aspect (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_fov: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_fov")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the horizontal field of view of the projection (in degrees).
    public func getFov ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_get_fov (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_is_orthogonal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_orthogonal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this ``Projection`` performs an orthogonal projection.
    public func isOrthogonal ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_is_orthogonal (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_viewport_half_extents: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_viewport_half_extents")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2428350749)!
    }()
    
    /// Returns the dimensions of the viewport plane that this ``Projection`` projects positions onto, divided by two.
    public func getViewportHalfExtents ()-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_get_viewport_half_extents (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_far_plane_half_extents: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_far_plane_half_extents")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 2428350749)!
    }()
    
    /// Returns the dimensions of the far clipping plane of the projection, divided by two.
    public func getFarPlaneHalfExtents ()-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_get_far_plane_half_extents (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 4212530932)!
    }()
    
    /// Returns a ``Projection`` that performs the inverse of this ``Projection``'s projective transformation.
    public func inverse ()-> Projection {
        var result: Projection = Projection()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_inverse (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_pixels_per_meter: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_pixels_per_meter")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 4103005248)!
    }()
    
    /// Returns the number of pixels with the given pixel width displayed per meter, after this ``Projection`` is applied.
    public func getPixelsPerMeter (forPixelWidth: Int64)-> Int64 {
        var result: Int64 = Int64()
        var copy_for_pixel_width = forPixelWidth
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_for_pixel_width) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Projection.method_get_pixels_per_meter (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_get_lod_multiplier: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_lod_multiplier")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_PROJECTION, &name.content, 466405837)!
    }()
    
    /// Returns the factor by which the visible level of detail is scaled by this ``Projection``.
    public func getLodMultiplier ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Projection.method_get_lod_multiplier (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
     public subscript (index: Int64) -> Vector4 {
        mutating get {
            var result = Vector4 ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_PROJECTION, GDEXTENSION_VARIANT_TYPE_VECTOR4)!
    }()
    
    /// Projects (multiplies) the given ``Vector4`` by this ``Projection`` matrix.
    public static func * (lhs: Projection, rhs: Vector4) -> Vector4  {
        var result: Vector4 = Vector4()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Projection.operator_3 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_PROJECTION, GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
    /// Returns `true` if the projections are equal.
    /// 
    /// > Note: Due to floating-point precision errors, this may return `false`, even if the projections are virtually equal. An `is_equal_approx` method may be added in a future version of Godot.
    /// 
    public static func == (lhs: Projection, rhs: Projection) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Projection.operator_4 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_PROJECTION, GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
    /// Returns `true` if the projections are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, this may return `true`, even if the projections are virtually equal. An `is_equal_approx` method may be added in a future version of Godot.
    /// 
    public static func != (lhs: Projection, rhs: Projection) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Projection.operator_5 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_PROJECTION, GDEXTENSION_VARIANT_TYPE_PROJECTION)!
    }()
    
    /// Projects (multiplies) the given ``Vector4`` by this ``Projection`` matrix.
    public static func * (lhs: Projection, rhs: Projection) -> Projection  {
        var result: Projection = Projection()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Projection.operator_6 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    /// The index value of the projection's near clipping plane.
    public static let planeNear = 0
    /// The index value of the projection's far clipping plane.
    public static let planeFar = 1
    /// The index value of the projection's left clipping plane.
    public static let planeLeft = 2
    /// The index value of the projection's top clipping plane.
    public static let planeTop = 3
    /// The index value of the projection's right clipping plane.
    public static let planeRight = 4
    /// The index value of the projection bottom clipping plane.
    public static let planeBottom = 5
    /// A ``Projection`` with no transformation defined. When applied to other data structures, no transformation is performed.
    public static let identity = Projection (xAxis: Vector4 (x: 1, y: 0, z: 0, w: 0), yAxis: Vector4 (x: 0, y: 1, z: 0, w: 0), zAxis: Vector4 (x: 0, y: 0, z: 1, w: 0), wAxis: Vector4 (x: 0, y: 0, z: 0, w: 1))
    /// A ``Projection`` with all values initialized to 0. When applied to other data structures, they will be zeroed.
    public static let zero = Projection (xAxis: Vector4 (x: 0, y: 0, z: 0, w: 0), yAxis: Vector4 (x: 0, y: 0, z: 0, w: 0), zAxis: Vector4 (x: 0, y: 0, z: 0, w: 0), wAxis: Vector4 (x: 0, y: 0, z: 0, w: 0))
}

