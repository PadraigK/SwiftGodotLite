// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A 3×3 matrix for representing 3D rotation and scale.
/// 
/// A 3×3 matrix used for representing 3D rotation and scale. Usually used as an orthogonal basis for a ``Transform3D``.
/// 
/// Contains 3 vector fields X, Y and Z as its columns, which are typically interpreted as the local basis vectors of a transformation. For such use, it is composed of a scaling and a rotation matrix, in that order (M = R.S).
/// 
/// Basis can also be accessed as an array of 3D vectors. These vectors are usually orthogonal to each other, but are not necessarily normalized (due to scaling).
/// 
/// For more information, read the "Matrices and transforms" documentation article.
/// 
public struct Basis: Equatable, Hashable {
    /// The basis matrix's X vector (column 0). Equivalent to array index `0`.
    public var x: Vector3
    /// The basis matrix's Y vector (column 1). Equivalent to array index `1`.
    public var y: Vector3
    /// The basis matrix's Z vector (column 2). Equivalent to array index `2`.
    public var z: Vector3
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 0)!
    
    /// Constructs a default-initialized ``Basis`` set to ``IDENTITY``.
    public init () {
        self.x = Vector3 (x: 1, y: 0, z: 0)
        self.y = Vector3 (x: 0, y: 1, z: 0)
        self.z = Vector3 (x: 0, y: 0, z: 1)
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 1)!
    
    /// Constructs a ``Basis`` as a copy of the given ``Basis``.
    public init (from: Basis) {
        self.x = Vector3 ()
        self.y = Vector3 ()
        self.z = Vector3 ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Basis.constructor1 (&self, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 2)!
    
    /// Constructs a pure rotation basis matrix from the given quaternion.
    public init (from: Quaternion) {
        self.x = Vector3 ()
        self.y = Vector3 ()
        self.z = Vector3 ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Basis.constructor2 (&self, &args)
        }
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 3)!
    
    /// Constructs a pure rotation basis matrix, rotated around the given `axis` by `angle` (in radians). The axis must be a normalized vector.
    public init (axis: Vector3, angle: Float) {
        self.x = Vector3 ()
        self.y = Vector3 ()
        self.z = Vector3 ()
        var copy_axis = axis
        var copy_angle = Double (angle)
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_axis) { p0 in
            args.append (p0)
            withUnsafePointer (to: &copy_angle) { p1 in
                args.append (p1)
        
                Basis.constructor3 (&self, &args)
            }
        }
    }
    
    static var constructor4: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_BASIS, 4)!
    
    /// Constructs a basis matrix from 3 axis vectors (matrix columns).
    public init (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) {
        self.x = xAxis
        self.y = yAxis
        self.z = zAxis
    }
    
    
    /* Methods */
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 594669093)!
    }()
    
    /// Returns the inverse of the matrix.
    public func inverse ()-> Basis {
        var result: Basis = Basis()
        withUnsafePointer (to: self) { ptr in 
            Basis.method_inverse (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_transposed: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("transposed")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 594669093)!
    }()
    
    /// Returns the transposed version of the matrix.
    public func transposed ()-> Basis {
        var result: Basis = Basis()
        withUnsafePointer (to: self) { ptr in 
            Basis.method_transposed (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_orthonormalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("orthonormalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 594669093)!
    }()
    
    /// Returns the orthonormalized version of the matrix (useful to call from time to time to avoid rounding error for orthogonal matrices). This performs a Gram-Schmidt orthonormalization on the basis of the matrix.
    public func orthonormalized ()-> Basis {
        var result: Basis = Basis()
        withUnsafePointer (to: self) { ptr in 
            Basis.method_orthonormalized (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_determinant: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("determinant")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 466405837)!
    }()
    
    /// Returns the determinant of the basis matrix. If the basis is uniformly scaled, its determinant is the square of the scale.
    /// 
    /// A negative determinant means the basis has a negative scale. A zero determinant means the basis isn't invertible, and is usually considered invalid.
    /// 
    public func determinant ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Basis.method_determinant (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_rotated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1998708965)!
    }()
    
    /// Introduce an additional rotation around the given axis by `angle` (in radians). The axis must be a normalized vector.
    public func rotated (axis: Vector3, angle: Double)-> Basis {
        var result: Basis = Basis()
        var copy_axis = axis
        var copy_angle = Double (angle)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_axis) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_angle) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Basis.method_rotated (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_scaled: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("scaled")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3934786792)!
    }()
    
    /// Introduce an additional scaling specified by the given 3D scaling factor.
    public func scaled (scale: Vector3)-> Basis {
        var result: Basis = Basis()
        var copy_scale = scale
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_scale) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Basis.method_scaled (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_get_scale: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_scale")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1776574132)!
    }()
    
    /// Assuming that the matrix is the combination of a rotation and scaling, return the absolute value of scaling factors along each axis.
    public func getScale ()-> Vector3 {
        var result: Vector3 = Vector3()
        withUnsafePointer (to: self) { ptr in 
            Basis.method_get_scale (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_euler: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_euler")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1394941017)!
    }()
    
    /// Returns the basis's rotation in the form of Euler angles. The Euler order depends on the `order` parameter, by default it uses the YXZ convention: when decomposing, first Z, then X, and Y last. The returned vector contains the rotation angles in the format (X angle, Y angle, Z angle).
    /// 
    /// Consider using the ``getRotationQuaternion()`` method instead, which returns a ``Quaternion`` quaternion instead of Euler angles.
    /// 
    public func getEuler (order: Int64 = 2)-> Vector3 {
        var result: Vector3 = Vector3()
        var copy_order = order
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_order) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Basis.method_get_euler (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_tdotx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("tdotx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1047977935)!
    }()
    
    /// Transposed dot product with the X axis of the matrix.
    public func tdotx (with: Vector3)-> Double {
        var result: Double = Double()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Basis.method_tdotx (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_tdoty: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("tdoty")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1047977935)!
    }()
    
    /// Transposed dot product with the Y axis of the matrix.
    public func tdoty (with: Vector3)-> Double {
        var result: Double = Double()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Basis.method_tdoty (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_tdotz: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("tdotz")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 1047977935)!
    }()
    
    /// Transposed dot product with the Z axis of the matrix.
    public func tdotz (with: Vector3)-> Double {
        var result: Double = Double()
        var copy_with = with
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_with) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Basis.method_tdotz (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_slerp: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("slerp")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3118673011)!
    }()
    
    /// Assuming that the matrix is a proper rotation matrix, slerp performs a spherical-linear interpolation with another rotation matrix.
    public func slerp (to: Basis, weight: Double)-> Basis {
        var result: Basis = Basis()
        var copy_to = to
        var copy_weight = Double (weight)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_to) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_weight) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Basis.method_slerp (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_is_conformal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_conformal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the basis is conformal, meaning it preserves angles and distance ratios, and may only be composed of rotation and uniform scale. Returns `false` if the basis has non-uniform scale or shear/skew. This can be used to validate if the basis is non-distorted, which is important for physics and other use cases.
    public func isConformal ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Basis.method_is_conformal (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3165333982)!
    }()
    
    /// Returns `true` if this basis and `b` are approximately equal, by calling ``@GlobalScope.is_equal_approx`` on all vector components.
    public func isEqualApprox (b: Basis)-> Bool {
        var result: Bool = Bool()
        var copy_b = b
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_b) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Basis.method_is_equal_approx (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this basis is finite, by calling ``@GlobalScope.is_finite`` on all vector components.
    public func isFinite ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Basis.method_is_finite (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_rotation_quaternion: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_rotation_quaternion")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 4274879941)!
    }()
    
    /// Returns the basis's rotation in the form of a quaternion. See ``getEuler(order:)`` if you need Euler angles, but keep in mind quaternions should generally be preferred to Euler angles.
    public func getRotationQuaternion ()-> Quaternion {
        var result: Quaternion = Quaternion()
        withUnsafePointer (to: self) { ptr in 
            Basis.method_get_rotation_quaternion (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_looking_at: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("looking_at")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3728732505)!
    }()
    
    /// Creates a Basis with a rotation such that the forward axis (-Z) points towards the `target` position.
    /// 
    /// The up axis (+Y) points as close to the `up` vector as possible while staying perpendicular to the forward axis. The resulting Basis is orthonormalized. The `target` and `up` vectors cannot be zero, and cannot be parallel to each other.
    /// 
    /// If `useModelFront` is `true`, the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the `target` position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).
    /// 
    public static func lookingAt (target: Vector3, up: Vector3 = Vector3 (x: 0, y: 1, z: 0), useModelFront: Bool = false)-> Basis {
        var result: Basis = Basis()
        var copy_target = target
        var copy_up = up
        var copy_use_model_front = useModelFront
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_target) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_up) { p1 in
                args.append (p1)
                return withUnsafePointer (to: &copy_use_model_front) { p2 in
                    args.append (p2)
        
                    Basis.method_looking_at (nil, &args, &result, 3)
                    return result
                }
            }
        }
    }
    
    static var method_from_scale: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("from_scale")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 3703240166)!
    }()
    
    /// Constructs a pure scale basis matrix with no rotation or shearing. The scale values are set as the diagonal of the matrix, and the other parts of the matrix are zero.
    public static func fromScale (_ scale: Vector3)-> Basis {
        var result: Basis = Basis()
        var copy_scale = scale
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_scale) { p0 in
            args.append (p0)
        
            Basis.method_from_scale (nil, &args, &result, 1)
            return result
        }
    }
    
    static var method_from_euler: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("from_euler")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_BASIS, &name.content, 2802321791)!
    }()
    
    /// Constructs a pure rotation Basis matrix from Euler angles in the specified Euler rotation order. By default, use YXZ order (most common). See the ``EulerOrder`` enum for possible values.
    public static func fromEuler (_ euler: Vector3, order: Int64 = 2)-> Basis {
        var result: Basis = Basis()
        var copy_euler = euler
        var copy_order = order
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_euler) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_order) { p1 in
                args.append (p1)
        
                Basis.method_from_euler (nil, &args, &result, 2)
                return result
            }
        }
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
     public subscript (index: Int64) -> Vector3 {
        mutating get {
            var result = Vector3 ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// This operator multiplies all components of the ``Basis``, which scales it uniformly.
    public static func * (lhs: Basis, rhs: Int64) -> Basis  {
        var result: Basis = Basis()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Basis.operator_3 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// This operator multiplies all components of the ``Basis``, which scales it uniformly.
    public static func * (lhs: Basis, rhs: Double) -> Basis  {
        var result: Basis = Basis()
        var copy_lhs = lhs
        var copy_rhs = Double (rhs)
        
        Basis.operator_4 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_VECTOR3)!
    }()
    
    /// This operator multiplies all components of the ``Basis``, which scales it uniformly.
    public static func * (lhs: Basis, rhs: Vector3) -> Vector3  {
        var result: Vector3 = Vector3()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Basis.operator_5 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    /// Returns `true` if the ``Basis`` matrices are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(b:)`` instead, which is more reliable.
    /// 
    public static func == (lhs: Basis, rhs: Basis) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Basis.operator_6 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    /// Returns `true` if the ``Basis`` matrices are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(b:)`` instead, which is more reliable.
    /// 
    public static func != (lhs: Basis, rhs: Basis) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Basis.operator_7 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_8: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_BASIS, GDEXTENSION_VARIANT_TYPE_BASIS)!
    }()
    
    /// This operator multiplies all components of the ``Basis``, which scales it uniformly.
    public static func * (lhs: Basis, rhs: Basis) -> Basis  {
        var result: Basis = Basis()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Basis.operator_8 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    /// The identity basis, with no rotation or scaling applied.
    /// 
    /// This is identical to creating [constructor Basis] without any parameters. This constant can be used to make your code clearer, and for consistency with C#.
    /// 
    public static let identity = Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1))
    /// The basis that will flip something along the X axis when used in a transformation.
    public static let flipX = Basis (xAxis: Vector3 (x: -1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1))
    /// The basis that will flip something along the Y axis when used in a transformation.
    public static let flipY = Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: -1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: 1))
    /// The basis that will flip something along the Z axis when used in a transformation.
    public static let flipZ = Basis (xAxis: Vector3 (x: 1, y: 0, z: 0), yAxis: Vector3 (x: 0, y: 1, z: 0), zAxis: Vector3 (x: 0, y: 0, z: -1))
}

