// This file is autogenerated, do not edit

@_implementationOnly import GDExtension

/// A 2×3 matrix representing a 2D transformation.
/// 
/// A 2×3 matrix (2 rows, 3 columns) used for 2D linear transformations. It can represent transformations such as translation, rotation, and scaling. It consists of three ``Vector2`` values: ``x``, ``y``, and the ``origin``.
/// 
/// For more information, read the "Matrices and transforms" documentation article.
/// 
public struct Transform2D: Equatable, Hashable {
    /// The basis matrix's X vector (column 0). Equivalent to array index `0`.
    public var x: Vector2
    /// The basis matrix's Y vector (column 1). Equivalent to array index `1`.
    public var y: Vector2
    /// The origin vector (column 2, the third column). Equivalent to array index `2`. The origin vector represents translation.
    public var origin: Vector2
    static var constructor0: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 0)!
    
    /// Constructs a default-initialized ``Transform2D`` set to ``IDENTITY``.
    public init () {
        self.x = Vector2 (x: 1, y: 0)
        self.y = Vector2 (x: 0, y: 1)
        self.origin = Vector2 ()
    }
    
    static var constructor1: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 1)!
    
    /// Constructs a ``Transform2D`` as a copy of the given ``Transform2D``.
    public init (from: Transform2D) {
        self.x = Vector2 ()
        self.y = Vector2 ()
        self.origin = Vector2 ()
        var copy_from = from
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_from) { p0 in
            args.append (p0)
        
            Transform2D.constructor1 (&self, &args)
        }
    }
    
    static var constructor2: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 2)!
    
    /// Constructs the transform from a given angle (in radians) and position.
    public init (rotation: Float, position: Vector2) {
        self.x = Vector2 ()
        self.y = Vector2 ()
        self.origin = Vector2 ()
        var copy_rotation = Double (rotation)
        var copy_position = position
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_rotation) { p0 in
            args.append (p0)
            withUnsafePointer (to: &copy_position) { p1 in
                args.append (p1)
        
                Transform2D.constructor2 (&self, &args)
            }
        }
    }
    
    static var constructor3: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 3)!
    
    /// Constructs the transform from a given angle (in radians), scale, skew (in radians) and position.
    public init (rotation: Float, scale: Vector2, skew: Float, position: Vector2) {
        self.x = Vector2 ()
        self.y = Vector2 ()
        self.origin = Vector2 ()
        var copy_rotation = Double (rotation)
        var copy_scale = scale
        var copy_skew = Double (skew)
        var copy_position = position
        var args: [UnsafeRawPointer?] = []
        withUnsafePointer (to: &copy_rotation) { p0 in
            args.append (p0)
            withUnsafePointer (to: &copy_scale) { p1 in
                args.append (p1)
                withUnsafePointer (to: &copy_skew) { p2 in
                    args.append (p2)
                    withUnsafePointer (to: &copy_position) { p3 in
                        args.append (p3)
        
                        Transform2D.constructor3 (&self, &args)
                    }
                }
            }
        }
    }
    
    static var constructor4: GDExtensionPtrConstructor = gi.variant_get_ptr_constructor (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 4)!
    
    /// Constructs the transform from 3 ``Vector2`` values representing ``x``, ``y``, and the ``origin`` (the three column vectors).
    public init (xAxis: Vector2, yAxis: Vector2, origin: Vector2) {
        self.x = xAxis
        self.y = yAxis
        self.origin = origin
    }
    
    
    /* Methods */
    
    static var method_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1420440541)!
    }()
    
    /// Returns the inverse of the transform, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not). Use ``affineInverse()`` for non-orthonormal transforms (e.g. with scaling).
    public func inverse ()-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_inverse (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_affine_inverse: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("affine_inverse")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1420440541)!
    }()
    
    /// Returns the inverse of the transform, under the assumption that the basis is invertible (must have non-zero determinant).
    public func affineInverse ()-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_affine_inverse (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_rotation: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_rotation")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 466405837)!
    }()
    
    /// Returns the transform's rotation (in radians).
    public func getRotation ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_get_rotation (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_origin: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_origin")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 2428350749)!
    }()
    
    /// Returns the transform's origin (translation).
    public func getOrigin ()-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_get_origin (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_scale: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_scale")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 2428350749)!
    }()
    
    /// Returns the scale.
    public func getScale ()-> Vector2 {
        var result: Vector2 = Vector2()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_get_scale (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_get_skew: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("get_skew")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 466405837)!
    }()
    
    /// Returns the transform's skew (in radians).
    public func getSkew ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_get_skew (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_orthonormalized: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("orthonormalized")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1420440541)!
    }()
    
    /// Returns the transform with the basis orthogonal (90 degrees), and normalized axis vectors (scale of 1 or -1).
    public func orthonormalized ()-> Transform2D {
        var result: Transform2D = Transform2D()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_orthonormalized (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_rotated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 729597514)!
    }()
    
    /// Returns a copy of the transform rotated by the given `angle` (in radians).
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding rotation transform `R` from the left, i.e., `R * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func rotated (angle: Double)-> Transform2D {
        var result: Transform2D = Transform2D()
        var copy_angle = Double (angle)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_angle) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_rotated (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_rotated_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("rotated_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 729597514)!
    }()
    
    /// Returns a copy of the transform rotated by the given `angle` (in radians).
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding rotation transform `R` from the right, i.e., `X * R`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func rotatedLocal (angle: Double)-> Transform2D {
        var result: Transform2D = Transform2D()
        var copy_angle = Double (angle)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_angle) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_rotated_local (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_scaled: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("scaled")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform scaled by the given `scale` factor.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding scaling transform `S` from the left, i.e., `S * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func scaled (scale: Vector2)-> Transform2D {
        var result: Transform2D = Transform2D()
        var copy_scale = scale
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_scale) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_scaled (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_scaled_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("scaled_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform scaled by the given `scale` factor.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding scaling transform `S` from the right, i.e., `X * S`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func scaledLocal (scale: Vector2)-> Transform2D {
        var result: Transform2D = Transform2D()
        var copy_scale = scale
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_scale) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_scaled_local (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_translated: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("translated")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform translated by the given `offset`.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding translation transform `T` from the left, i.e., `T * X`.
    /// 
    /// This can be seen as transforming with respect to the global/parent frame.
    /// 
    public func translated (offset: Vector2)-> Transform2D {
        var result: Transform2D = Transform2D()
        var copy_offset = offset
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_offset) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_translated (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_translated_local: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("translated_local")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform translated by the given `offset`.
    /// 
    /// This method is an optimized version of multiplying the given transform `X` with a corresponding translation transform `T` from the right, i.e., `X * T`.
    /// 
    /// This can be seen as transforming with respect to the local frame.
    /// 
    public func translatedLocal (offset: Vector2)-> Transform2D {
        var result: Transform2D = Transform2D()
        var copy_offset = offset
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_offset) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_translated_local (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_determinant: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("determinant")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 466405837)!
    }()
    
    /// Returns the determinant of the basis matrix. If the basis is uniformly scaled, then its determinant equals the square of the scale factor.
    /// 
    /// A negative determinant means the basis was flipped, so one part of the scale is negative. A zero determinant means the basis isn't invertible, and is usually considered invalid.
    /// 
    public func determinant ()-> Double {
        var result: Double = Double()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_determinant (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_basis_xform: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("basis_xform")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 2026743667)!
    }()
    
    /// Returns a vector transformed (multiplied) by the basis matrix.
    /// 
    /// This method does not account for translation (the ``origin`` vector).
    /// 
    public func basisXform (v: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        var copy_v = v
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_v) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_basis_xform (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_basis_xform_inv: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("basis_xform_inv")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 2026743667)!
    }()
    
    /// Returns a vector transformed (multiplied) by the inverse basis matrix, under the assumption that the basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).
    /// 
    /// This method does not account for translation (the ``origin`` vector).
    /// 
    /// `transform.basis_xform_inv(vector)` is equivalent to `transform.inverse().basis_xform(vector)`. See ``inverse()``.
    /// 
    /// For non-orthonormal transforms (e.g. with scaling) `transform.affine_inverse().basis_xform(vector)` can be used instead. See ``affineInverse()``.
    /// 
    public func basisXformInv (v: Vector2)-> Vector2 {
        var result: Vector2 = Vector2()
        var copy_v = v
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_v) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_basis_xform_inv (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_interpolate_with: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("interpolate_with")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 359399686)!
    }()
    
    /// Returns a transform interpolated between this transform and another by a given `weight` (on the range of 0.0 to 1.0).
    public func interpolateWith (xform: Transform2D, weight: Double)-> Transform2D {
        var result: Transform2D = Transform2D()
        var copy_xform = xform
        var copy_weight = Double (weight)
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_xform) { p0 in
            args.append (p0)
            return withUnsafePointer (to: &copy_weight) { p1 in
                args.append (p1)
        
                withUnsafePointer (to: self) { ptr in 
                    Transform2D.method_interpolate_with (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 2)
                }
                return result
            }
        }
    }
    
    static var method_is_conformal: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_conformal")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if the transform's basis is conformal, meaning it preserves angles and distance ratios, and may only be composed of rotation and uniform scale. Returns `false` if the transform's basis has non-uniform scale or shear/skew. This can be used to validate if the transform is non-distorted, which is important for physics and other use cases.
    public func isConformal ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_is_conformal (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_is_equal_approx: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_equal_approx")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 3837431929)!
    }()
    
    /// Returns `true` if this transform and `xform` are approximately equal, by running ``@GlobalScope.is_equal_approx`` on each component.
    public func isEqualApprox (xform: Transform2D)-> Bool {
        var result: Bool = Bool()
        var copy_xform = xform
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_xform) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_is_equal_approx (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    static var method_is_finite: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("is_finite")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 3918633141)!
    }()
    
    /// Returns `true` if this transform is finite, by calling ``@GlobalScope.is_finite`` on each component.
    public func isFinite ()-> Bool {
        var result: Bool = Bool()
        withUnsafePointer (to: self) { ptr in 
            Transform2D.method_is_finite (UnsafeMutableRawPointer (mutating: ptr), nil, &result, 0)
        }
        return result
    }
    
    static var method_looking_at: GDExtensionPtrBuiltInMethod = {
        let name = StringName ("looking_at")
        return gi.variant_get_ptr_builtin_method (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, &name.content, 1446323263)!
    }()
    
    /// Returns a copy of the transform rotated such that the rotated X-axis points towards the `target` position.
    /// 
    /// Operations take place in global space.
    /// 
    public func lookingAt (target: Vector2 = Vector2 (x: 0, y: 0))-> Transform2D {
        var result: Transform2D = Transform2D()
        var copy_target = target
        var args: [UnsafeRawPointer?] = []
        return withUnsafePointer (to: &copy_target) { p0 in
            args.append (p0)
        
            withUnsafePointer (to: self) { ptr in 
                Transform2D.method_looking_at (UnsafeMutableRawPointer (mutating: ptr), &args, &result, 1)
            }
            return result
        }
    }
    
    private static var indexed_getter: GDExtensionPtrIndexedGetter = {
        return gi.variant_get_ptr_indexed_getter (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    private static var indexed_setter: GDExtensionPtrIndexedSetter = {
        return gi.variant_get_ptr_indexed_setter (GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
     public subscript (index: Int64) -> Vector2 {
        mutating get {
            var result = Vector2 ()
            Self.indexed_getter (&self, index, &result)
            return result
        }
        
        set {
            var value = newValue
            Self.indexed_setter (&self, index, &value)
        }
        
    }
    
    static var operator_3: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_INT)!
    }()
    
    /// This operator multiplies all components of the ``Transform2D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform2D, rhs: Int64) -> Transform2D  {
        var result: Transform2D = Transform2D()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform2D.operator_3 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_4: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_FLOAT)!
    }()
    
    /// This operator multiplies all components of the ``Transform2D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform2D, rhs: Double) -> Transform2D  {
        var result: Transform2D = Transform2D()
        var copy_lhs = lhs
        var copy_rhs = Double (rhs)
        
        Transform2D.operator_4 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_5: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_VECTOR2)!
    }()
    
    /// This operator multiplies all components of the ``Transform2D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform2D, rhs: Vector2) -> Vector2  {
        var result: Vector2 = Vector2()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform2D.operator_5 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_6: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_RECT2)!
    }()
    
    /// This operator multiplies all components of the ``Transform2D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform2D, rhs: Rect2) -> Rect2  {
        var result: Rect2 = Rect2()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform2D.operator_6 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_7: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    /// Returns `true` if the transforms are exactly equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(xform:)`` instead, which is more reliable.
    /// 
    public static func == (lhs: Transform2D, rhs: Transform2D) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform2D.operator_7 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_8: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_NOT_EQUAL, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    /// Returns `true` if the transforms are not equal.
    /// 
    /// > Note: Due to floating-point precision errors, consider using ``isEqualApprox(xform:)`` instead, which is more reliable.
    /// 
    public static func != (lhs: Transform2D, rhs: Transform2D) -> Bool  {
        var result: Bool = Bool()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform2D.operator_8 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_9: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)!
    }()
    
    /// This operator multiplies all components of the ``Transform2D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform2D, rhs: Transform2D) -> Transform2D  {
        var result: Transform2D = Transform2D()
        var copy_lhs = lhs
        var copy_rhs = rhs
        
        Transform2D.operator_9 (&copy_lhs, &copy_rhs, &result)
        return result
    }
    
    static var operator_12: GDExtensionPtrOperatorEvaluator = {
        return gi.variant_get_ptr_operator_evaluator (GDEXTENSION_VARIANT_OP_MULTIPLY, GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, GDEXTENSION_VARIANT_TYPE_PACKED_VECTOR2_ARRAY)!
    }()
    
    /// This operator multiplies all components of the ``Transform2D``, including the ``origin`` vector, which scales it uniformly.
    public static func * (lhs: Transform2D, rhs: PackedVector2Array) -> PackedVector2Array  {
        let result: PackedVector2Array = PackedVector2Array()
        var copy_lhs = lhs
        
        Transform2D.operator_12 (&copy_lhs, &rhs.content, &result.content)
        return result
    }
    
    /// The identity ``Transform2D`` with no translation, rotation or scaling applied. When applied to other data structures, ``IDENTITY`` performs no transformation.
    public static let identity = Transform2D (xAxis: Vector2 (x: 1, y: 0), yAxis: Vector2 (x: 0, y: 1), origin: Vector2 (x: 0, y: 0))
    /// The ``Transform2D`` that will flip something along the X axis.
    public static let flipX = Transform2D (xAxis: Vector2 (x: -1, y: 0), yAxis: Vector2 (x: 0, y: 1), origin: Vector2 (x: 0, y: 0))
    /// The ``Transform2D`` that will flip something along the Y axis.
    public static let flipY = Transform2D (xAxis: Vector2 (x: 1, y: 0), yAxis: Vector2 (x: 0, y: -1), origin: Vector2 (x: 0, y: 0))
}

